
author: er433
description: "\\nNew attribute `@entry` allows to define entries for a module/namespace, or from the top-level of a file.\\n\\nFor example, the file `contract.jsligo`\\n\\n```\\ntype storage = int;\\n\\n// @entry\\nconst increment = (action: int, store: storage) : [list <operation>, storage] => [list([]), store + action];\\n\\n// @entry\\nconst decrement = (action: int, store: storage) : [list <operation>, storage] => [list([]), store - action];\\n\\n// @entry\\nconst reset = (_u: unit, _store: storage) : [list<operation>, storage] => [list([]), 0];\\n\\n```\\ncan be compiled directly:\\n\\n```\\n$ ligo compile contract contract.jsligo \\n{ parameter (or (or (int %decrement) (int %increment)) (unit %reset)) ;\\n  storage int ;\\n  code { UNPAIR ;\\n         IF_LEFT { IF_LEFT { SWAP ; SUB } { ADD } } { DROP 2 ; PUSH int 0 } ;\\n         NIL operation ;\\n         PAIR } }\\n\\n```\\n\\nMoreover, when using the testing framework, a `contract_of` keyword can be used to originate a module as a contract with the help of the new function `Test.originate_module`:\\n\\n```\\n$ cat src/test/contracts/interpreter_tests/test_originate_module.jsligo \\nnamespace C {\\n  type storage = int;\\n\\n  // @entry\\n  const increment = (action: int, store: storage) : [list <operation>, storage] => [list([]), store + action];\\n\\n  // @entry\\n  const decrement = (action: int, store: storage) : [list <operation>, storage] => [list([]), store - action];\\n};\\n\\nconst test_increment = (() => {\\n  let initial_storage = 42;\\n  let [taddr, _, _] = Test.originate_module(contract_of(C), initial_storage, 0 as tez);\\n  let contr = Test.to_contract(taddr);\\n  let _ = Test.transfer_to_contract_exn(contr, (Increment (1)), 1 as mutez);\\n  return assert(Test.get_storage(taddr) == initial_storage + 1);\\n}) ();\\n\\n$ ligo run test src/test/contracts/interpreter_tests/test_originate_module.jsligo \\nEverything at the top-level was executed.   \\n- test_increment exited with value ().\\n\\n```\\n\\n#### Breaking changes\\n\\nNotice that this feature is breaking as `contract_of` becomes a keyword, rending invalid contracts that use this name as a variable. In this case, the fix is simple, and just amounts to change the name of the variable, or use `@contract_of`:\\n\\n```\\n$ cat contract.jsligo \\n// @entry\\nconst increment = (action: int, store: int) : [list <operation>, int] => [list([]), store + action];\\n\\nconst contract_of = 42;\\n$ ligo compile contract contract.jsligo \\nFile \"contract.jsligo\", line 4, characters 6-17:\\n  3 | \\n  4 | const contract_of = 42;\\nIll-formed value declaration.\\nAt this point, a pattern is expected, e.g. a variable.\\n\\n```\\n\\nAfter modifying `contract.jsligo` with `@contract_of`:\\n\\n```\\n$ cat contract.jsligo \\n// @entry\\nconst increment = (action: int, store: int) : [list <operation>, int] => [list([]), store + action];\\n\\nconst @contract_of = 42;\\n$ ligo compile contract contract.jsligo \\n{ parameter int ;        \\n  storage int ;\\n  code { UNPAIR ; ADD ; NIL operation ; PAIR } }\\n\\n```\\n\\nThis MR also modifies the parameters for the sub-command `evaluate-call` (`-e` is not used anymore to signal the function to compile).\\n\\n"
merge_request: '2379'
title: "Attribute for entries"
type: breaking
            