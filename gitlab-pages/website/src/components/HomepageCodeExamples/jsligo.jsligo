type storage = int;

type parameter = 
  { kind: "Increment", value: int}
| { kind: "Decrement", value: int}
| { kind: "Reset"};

type return_ = [list<operation>, storage];

/* Two entrypoints */
const add = (store: storage, delta: int) : storage => store + delta;
const sub = (store: storage, delta: int) : storage => store - delta;

/* Main access point that dispatches to the entrypoints according to
   the smart contract parameter. */
const main = (action : parameter, store: storage) : return_ => {
  const noop = list([]);
  switch(action.kind){
    case "Increment": 
      return [noop, add(store, action.value)];
    case "Decrement": 
      return [noop, sub(store, action.value)];
    case "Reset": 
      return [noop, 0];
  }
};

/* Tests for main access point */

const test_initial_storage = (() => {
  let initial_storage = 42;
  let [taddr, _, _] = Test.originate(main, initial_storage, 0 as tez);
  return assert(Test.get_storage(taddr) == initial_storage)
}) ();

const test_increment = (() => {
  let initial_storage = 42;
  let [taddr, _, _] = Test.originate(main, initial_storage, 0 as tez);
  let contr = Test.to_contract(taddr);
  let _ = Test.transfer_to_contract_exn(contr, {kind : "Increment", value : 1}, 1 as mutez);
  return assert(Test.get_storage(taddr) == initial_storage + 1);
}) ();