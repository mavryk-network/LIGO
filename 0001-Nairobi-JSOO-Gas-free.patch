From 59663a77ca0b7aa92ddda5c27fbfbacd954530d2 Mon Sep 17 00:00:00 2001
From: prometheansacrifice
 <2601505-prometheansacrifice@users.noreply.gitlab.com>
Date: Fri, 2 Jun 2023 11:26:05 +0530
Subject: [PATCH 1/2] Nairobi: JSOO Gas free


diff --git a/src/proto_017_PtNairob/lib_protocol/alpha_context.ml b/src/proto_017_PtNairob/lib_protocol/alpha_context.ml
index 3e7e28721f..d95a21073b 100644
--- a/src/proto_017_PtNairob/lib_protocol/alpha_context.ml
+++ b/src/proto_017_PtNairob/lib_protocol/alpha_context.ml
@@ -278,7 +278,8 @@ module Gas = struct
   let consume_from available_gas cost =
     match raw_consume available_gas cost with
     | Some remaining_gas -> ok remaining_gas
-    | None -> error Operation_quota_exceeded
+    | None ->
+       error Operation_quota_exceeded
 
   let remaining_operation_gas = Raw_context.remaining_operation_gas
 
diff --git a/src/proto_017_PtNairob/lib_protocol/alpha_context.mli b/src/proto_017_PtNairob/lib_protocol/alpha_context.mli
index cc41a3cdeb..68071e744a 100644
--- a/src/proto_017_PtNairob/lib_protocol/alpha_context.mli
+++ b/src/proto_017_PtNairob/lib_protocol/alpha_context.mli
@@ -376,9 +376,11 @@ module Gas : sig
 
   *)
 
-  module Arith :
-    Fixed_point_repr.Safe
-      with type 'a t = private Saturation_repr.may_saturate Saturation_repr.t
+module Arith : sig
+  include Fixed_point_repr.Full
+    with type 'a t = private Saturation_repr.may_saturate Saturation_repr.t
+  val to_int: 'a t -> int
+end
 
   (** For maintenance operations or for testing, gas can be
      [Unaccounted]. Otherwise, the computation is [Limited] by the
diff --git a/src/proto_017_PtNairob/lib_protocol/gas_limit_repr.ml b/src/proto_017_PtNairob/lib_protocol/gas_limit_repr.ml
index a6a8f42849..9e95e94682 100644
--- a/src/proto_017_PtNairob/lib_protocol/gas_limit_repr.ml
+++ b/src/proto_017_PtNairob/lib_protocol/gas_limit_repr.ml
@@ -72,6 +72,7 @@ module Arith = struct
   let equal = S.equal
 
   let of_int_opt = S.of_int_opt
+  let to_int = S.wont_saturate
 
   let fatally_saturated_int i =
     failwith (string_of_int i ^ " should not be saturated.")
diff --git a/src/proto_017_PtNairob/lib_protocol/gas_limit_repr.mli b/src/proto_017_PtNairob/lib_protocol/gas_limit_repr.mli
index 891fd46f1c..6e07c43b51 100644
--- a/src/proto_017_PtNairob/lib_protocol/gas_limit_repr.mli
+++ b/src/proto_017_PtNairob/lib_protocol/gas_limit_repr.mli
@@ -39,9 +39,11 @@
     All computations on gas are performed in saturation arithmetic (see
     [Saturation_repr]) bounded between [0] and [2 ^ 62 - 1]*)
 
-module Arith :
-  Fixed_point_repr.Full
+module Arith : sig
+  include Fixed_point_repr.Full
     with type 'a t = private Saturation_repr.may_saturate Saturation_repr.t
+  val to_int: 'a t -> int
+end
 
 type t = Unaccounted | Limited of {remaining : Arith.fp}
 
diff --git a/src/proto_017_PtNairob/lib_protocol/gas_monad.ml b/src/proto_017_PtNairob/lib_protocol/gas_monad.ml
index 3597f4bfa4..3586ce8eca 100644
--- a/src/proto_017_PtNairob/lib_protocol/gas_monad.ml
+++ b/src/proto_017_PtNairob/lib_protocol/gas_monad.ml
@@ -66,7 +66,7 @@ let run ctxt m =
   let open Local_gas_counter in
   match Gas.level ctxt with
   | Gas.Unaccounted -> (
-      match m (Local_gas_counter (Saturation_repr.saturated :> int)) with
+      match m (Local_gas_counter Saturation_repr.saturated_int) with
       | Some (res, _new_gas_counter) -> ok (res, ctxt)
       | None -> error Gas.Operation_quota_exceeded)
   | Limited {remaining = _} -> (
diff --git a/src/proto_017_PtNairob/lib_protocol/local_gas_counter.ml b/src/proto_017_PtNairob/lib_protocol/local_gas_counter.ml
index 868ee3abd6..6a4a5a873f 100644
--- a/src/proto_017_PtNairob/lib_protocol/local_gas_counter.ml
+++ b/src/proto_017_PtNairob/lib_protocol/local_gas_counter.ml
@@ -70,7 +70,7 @@ let update_context (Local_gas_counter gas_counter) (Outdated_context ctxt) =
   [@@ocaml.inline always]
 
 let local_gas_counter ctxt =
-  Local_gas_counter (Gas.remaining_operation_gas ctxt :> int)
+  Local_gas_counter (Gas.Arith.to_int (Gas.remaining_operation_gas ctxt))
   [@@ocaml.inline always]
 
 let local_gas_counter_and_outdated_context ctxt =
@@ -83,7 +83,7 @@ let use_gas_counter_in_context ctxt gas_counter f =
   [@@ocaml.inline always]
 
 let consume_opt (Local_gas_counter gas_counter) (cost : Gas.cost) =
-  let gas_counter = gas_counter - (cost :> int) in
+  let gas_counter = gas_counter - (Saturation_repr.wont_saturate cost) in
   if Compare.Int.(gas_counter < 0) then None
   else Some (Local_gas_counter gas_counter)
   [@@ocaml.inline always]
diff --git a/src/proto_017_PtNairob/lib_protocol/saturation_repr.ml b/src/proto_017_PtNairob/lib_protocol/saturation_repr.ml
index 47739c809b..5854903162 100644
--- a/src/proto_017_PtNairob/lib_protocol/saturation_repr.ml
+++ b/src/proto_017_PtNairob/lib_protocol/saturation_repr.ml
@@ -25,7 +25,7 @@
 
 (* let () = assert (Sys.int_size = 63) *)
 
-type _ t = int
+type _ t = Z.t
 
 type mul_safe
 
@@ -33,38 +33,43 @@ type may_saturate
 
 let may_saturate : _ t -> may_saturate t = fun x -> x
 
-let to_int x = x
+let to_int = Z.to_int
+let wont_saturate : may_saturate t -> int = fun x -> Z.to_int x
 
-let ( < ) : _ t -> _ t -> bool = Compare.Int.( < )
+let ( < ) : _ t -> _ t -> bool = Z.lt
 
-let ( <= ) : _ t -> _ t -> bool = Compare.Int.( <= )
+let ( <= ) : _ t -> _ t -> bool = Z.leq
 
-let ( > ) : _ t -> _ t -> bool = Compare.Int.( > )
+let ( > ) : _ t -> _ t -> bool = Z.gt
 
-let ( >= ) : _ t -> _ t -> bool = Compare.Int.( >= )
+let ( >= ) : _ t -> _ t -> bool = Z.geq
 
-let ( = ) : _ t -> _ t -> bool = Compare.Int.( = )
+let ( = ) : _ t -> _ t -> bool = Z.equal
 
 let equal = ( = )
 
-let ( <> ) : _ t -> _ t -> bool = Compare.Int.( <> )
+let ( <> ) (x: _ t) (y: _ t) : bool = not @@ equal x y
 
 let max : _ t -> _ t -> _ t = fun x y -> if x >= y then x else y
 
 let min : _ t -> _ t -> _ t = fun x y -> if x >= y then y else x
 
-let compare : _ t -> _ t -> _ t = Compare.Int.compare
+let compare (x: _ t) (y:_ t) : int = Z.compare x y
 
-let saturated = max_int
+let saturated = Z.of_int max_int
+let saturated_int = max_int
 
-let ( >! ) : _ t -> int -> bool = Compare.Int.( > )
 
-let of_int_opt t = if t >= 0 && t < saturated then Some t else None
+let ( >! ) (x : _ t) (y : int) : bool = Z.(x > (Z.of_int y))
 
-let of_z_opt z =
-  match Z.to_int z with int -> of_int_opt int | exception Z.Overflow -> None
+let of_int_opt (t: int): _ t option =
+  let open Z in
+  let z = Z.of_int t in
+  if z >= zero && Z.(z < saturated) then Some z else None
 
-let to_z x = Z.of_int x
+let of_z_opt z = Some z
+
+let to_z x = x
 
 let saturate_if_undef = function None -> saturated | Some x -> x
 
@@ -72,45 +77,22 @@ let safe_z z = saturate_if_undef @@ of_z_opt z
 
 let safe_int x = of_int_opt x |> saturate_if_undef
 
-let numbits x =
-  let x = ref x and n = ref 0 in
-  (let y = !x lsr 32 in
-   if y <> 0 then (
-     n := !n + 32 ;
-     x := y)) ;
-  (let y = !x lsr 16 in
-   if y <> 0 then (
-     n := !n + 16 ;
-     x := y)) ;
-  (let y = !x lsr 8 in
-   if y <> 0 then (
-     n := !n + 8 ;
-     x := y)) ;
-  (let y = !x lsr 4 in
-   if y <> 0 then (
-     n := !n + 4 ;
-     x := y)) ;
-  (let y = !x lsr 2 in
-   if y <> 0 then (
-     n := !n + 2 ;
-     x := y)) ;
-  if !x lsr 1 <> 0 then !n + 2 else !n + !x
-
-let zero = 0
-
-let one = 1
+let numbits = Z.numbits
+
+let zero = Z.zero
+
+let one = Z.one
 
 let small_enough z =
-  (* The following literal triggers an error if compiled under 32-bit
-     architectures, please do not modify it. This is a static way to
-     ensure that this file is compiled under a 64-bit architecture. *)
-  z land 0x7fffffff80000000 = 0
+  let open Z in
+  equal (logand z (of_int 0x7fffffff80000000)) zero
 
 let mul_safe x = if small_enough x then Some x else None
 
 let mul_safe_exn x =
   if small_enough x then x
-  else failwith (Format.sprintf "mul_safe_exn: %d must be below 2147483648" x)
+  else failwith (Format.sprintf "mul_safe_exn: %d must be below 2147483648" (Z.to_int x))
+
 
 let mul_safe_of_int_exn x =
   Option.bind (of_int_opt x) mul_safe |> function
@@ -121,50 +103,50 @@ let mul_safe_of_int_exn x =
 
 (* If [x] is positive, shifting to the right will produce a number
    which is positive and is less than [x]. *)
-let shift_right x y = (x :> int) lsr y
+let shift_right = Z.shift_right
 
 let shift_left x y =
-  if shift_right saturated y < x then saturated else (x :> int) lsl y
+  let open Z in
+  if shift_right saturated y < x then saturated else Z.shift_left x y
 
 let mul x y =
+  let open Z in
   (* assert (x >= 0 && y >= 0); *)
   match x with
-  | 0 -> 0
+  | x when x = Z.zero -> zero
   | x ->
-      if small_enough x && small_enough y then x * y
-      else if Compare.Int.(y > saturated / x) then saturated
-      else x * y
+     if small_enough x && small_enough y then Z.mul x y
+      else if Z.gt y (Z.div saturated x) then saturated
+      else Z.mul x y
 
-let mul_fast x y = x * y
+let mul_fast x y = Z.mul x y
 
 let scale_fast x y =
-  if x = 0 then 0
-  else if small_enough y then x * y
-  else if Compare.Int.(y > saturated / x) then saturated
-  else x * y
+  let open Z in
+  if x = zero then zero
+  else if small_enough y then Z.mul x y
+  else if Z.gt y (Z.div saturated  x) then saturated
+  else Z.mul x y
 
 let add x y =
-  let z = x + y in
-  if Compare.Int.(z >= 0) then z else saturated
+  let z = Z.add x y in
+  if (Z.geq z zero) then z else saturated
 
 let succ x = add one x
 
-let sub x y = Compare.Int.max (x - y) 0
+let sub x y = Z.max (Z.sub x y) zero
 
 let sub_opt x y =
-  let s = x - y in
-  if Compare.Int.(s >= 0) then Some s else None
+  let s = Z.sub x y in
+  if (Z.geq s zero) then Some s else None
 
 (* Notice that Z.erem does not behave as mod on negative numbers.
    Fortunately, the inhabitant of [t] are non-negative. *)
-let erem x y = x mod y
+let erem x y = Z.rem x y
 
-let ediv x y = x / y
+let ediv x y = Z.ediv x  y
 
-let sqrt x =
-  of_int_opt x
-  |> Option.map (fun x -> Z.of_int x |> Z.sqrt |> Z.to_int)
-  |> saturate_if_undef
+let sqrt = Z.sqrt
 
 let t_to_z_exn z =
   match of_z_opt z with
@@ -176,7 +158,7 @@ let z_encoding = Data_encoding.(check_size 9 (conv to_z t_to_z_exn z))
 
 let n_encoding = Data_encoding.(check_size 9 (conv to_z t_to_z_exn n))
 
-let pp fmt x = Format.pp_print_int fmt x
+let pp = Z.pp_print 
 
 module Syntax = struct
   (* This is a good enough approximation. S.log2 0 = 1 *)
diff --git a/src/proto_017_PtNairob/lib_protocol/saturation_repr.mli b/src/proto_017_PtNairob/lib_protocol/saturation_repr.mli
index e1fcf58cb2..e1341390cf 100644
--- a/src/proto_017_PtNairob/lib_protocol/saturation_repr.mli
+++ b/src/proto_017_PtNairob/lib_protocol/saturation_repr.mli
@@ -58,13 +58,14 @@
     multiplication.
 
 *)
-type 'a t = private int
+type 'a t = private Z.t
 
 type mul_safe
 
 type may_saturate
 
 val may_saturate : _ t -> may_saturate t
+val wont_saturate : may_saturate t -> int
 
 (** [to_int x] returns the underlying integer representing [x]. *)
 val to_int : 'a t -> int
@@ -77,6 +78,7 @@ val one : _ t
 
 (** 2^62 - 1 *)
 val saturated : may_saturate t
+val saturated_int : int
 
 (** We inherit the order over native integers. *)
 val ( >= ) : _ t -> _ t -> bool
diff --git a/src/proto_017_PtNairob/lib_protocol/script_interpreter_defs.ml b/src/proto_017_PtNairob/lib_protocol/script_interpreter_defs.ml
index 94c1c0ce6f..a537ef3493 100644
--- a/src/proto_017_PtNairob/lib_protocol/script_interpreter_defs.ml
+++ b/src/proto_017_PtNairob/lib_protocol/script_interpreter_defs.ml
@@ -436,12 +436,12 @@ let cost_of_control : type a s r f. (a, s, r, f) continuation -> Gas.cost =
 *)
 
 let consume_instr local_gas_counter k accu stack =
-  let cost = cost_of_instr k accu stack in
+  let cost = Gas.free in (* cost_of_instr k accu stack in *)
   consume_opt local_gas_counter cost
   [@@ocaml.inline always]
 
 let consume_control local_gas_counter ks =
-  let cost = cost_of_control ks in
+  let cost = Gas.free in (* cost_of_control ks in *)
   consume_opt local_gas_counter cost
   [@@ocaml.inline always]
 
-- 
2.34.1

