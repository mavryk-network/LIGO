//#define USE_SET

#if USE_SET
#import "set_monad.mligo" "M"
#else
#import "list_monad.mligo" "M"
#endif

type t = M.monad;

let interval = ([x,y] : [int, int]) : t<int> => {
  let aux = ([x, c, acc] : [int, int, t<int>]) : t<int> => {
    if (c < x) {
      return acc;
    } else {
      return aux([x, c - 1, M.mplus(M.ret(c),acc)]);
    }
  };
  return aux([x, y, (M.mzero as t<int>)]);
};

let triples = (n : int) : t<[int, int, int]> =>
  M.bind(interval([1, n]), (x =>
  M.bind(interval([1, n]), (y => {
    if (x <= y) {
      return M.bind(interval([1, n]), (z => M.ret([x, y, z])))
    } else {
      return (M.mzero as t<[int, int, int]>)
    }
   }))))

let solve = (n : int) : t<[int, int, int]> =>
  M.bind(triples(n),(p => {
  let [x, y, z] = p;
  if (x * x + y * y == z * z) {
    return M.ret([x, y, z]);
  } else {
    return (M.mzero as t<[int, int, int]>);
  }}));
