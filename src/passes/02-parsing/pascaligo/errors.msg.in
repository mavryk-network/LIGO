interactive_expr: Begin Case Verbatim Of LBRACKET WILD ARROW Skip With
##
## Ends in an error in state: 583.
##
## case(test_clause(instruction)) -> Case expr Of LBRACKET cases(test_clause(instruction)) . RBRACKET [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## Case expr Of LBRACKET cases(test_clause(instruction))
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 580, spurious reduction of production nsepseq(case_clause(test_clause(instruction)),VBAR) -> case_clause(test_clause(instruction))
## In state 577, spurious reduction of production cases(test_clause(instruction)) -> nsepseq(case_clause(test_clause(instruction)),VBAR)
##
interactive_expr: Begin Case UIdent Of LBRACKET VBAR UIdent ARROW Skip While
##
## Ends in an error in state: 578.
##
## case(test_clause(instruction)) -> Case expr Of LBRACKET VBAR cases(test_clause(instruction)) . RBRACKET [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## Case expr Of LBRACKET VBAR cases(test_clause(instruction))
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 580, spurious reduction of production nsepseq(case_clause(test_clause(instruction)),VBAR) -> case_clause(test_clause(instruction))
## In state 577, spurious reduction of production cases(test_clause(instruction)) -> nsepseq(case_clause(test_clause(instruction)),VBAR)
##

Ill-formed case instruction.
At this point, if the clause is complete, one of the following is
expected:
  * another clause;
  * a closing bracket ']' if the case is complete.
Note: A clause, here, is made of a pattern and an instruction or
a block of statements, separated by an arrow '->'.

interactive_expr: Case UIdent Of LBRACKET VBAR UIdent ARROW UIdent While
##
## Ends in an error in state: 691.
##
## case(expr) -> Case expr Of LBRACKET VBAR cases(expr) . RBRACKET [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End Else EOF Directive Const COMMA Block Begin Attr ARROW ]
##
## The known suffix of the stack is as follows:
## Case expr Of LBRACKET VBAR cases(expr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 227, spurious reduction of production ctor_app_expr -> UIdent
## In state 295, spurious reduction of production core_expr -> ctor_app_expr
## In state 315, spurious reduction of production update_expr_level -> core_expr
## In state 280, spurious reduction of production unary_expr_level -> update_expr_level
## In state 309, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 311, spurious reduction of production add_expr_level -> mult_expr_level
## In state 332, spurious reduction of production cons_expr_level -> add_expr_level
## In state 322, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 352, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 339, spurious reduction of production set_mem_level -> comp_expr_level
## In state 360, spurious reduction of production conj_expr_level -> set_mem_level
## In state 385, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 379, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 387, spurious reduction of production expr -> base_expr(expr)
## In state 689, spurious reduction of production case_clause(expr) -> pattern ARROW expr
## In state 693, spurious reduction of production nsepseq(case_clause(expr),VBAR) -> case_clause(expr)
## In state 690, spurious reduction of production cases(expr) -> nsepseq(case_clause(expr),VBAR)
##
interactive_expr: Case UIdent Of LBRACKET UIdent ARROW UIdent While
##
## Ends in an error in state: 696.
##
## case(expr) -> Case expr Of LBRACKET cases(expr) . RBRACKET [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End Else EOF Directive Const COMMA Block Begin Attr ARROW ]
##
## The known suffix of the stack is as follows:
## Case expr Of LBRACKET cases(expr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 227, spurious reduction of production ctor_app_expr -> UIdent
## In state 295, spurious reduction of production core_expr -> ctor_app_expr
## In state 315, spurious reduction of production update_expr_level -> core_expr
## In state 280, spurious reduction of production unary_expr_level -> update_expr_level
## In state 309, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 311, spurious reduction of production add_expr_level -> mult_expr_level
## In state 332, spurious reduction of production cons_expr_level -> add_expr_level
## In state 322, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 352, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 339, spurious reduction of production set_mem_level -> comp_expr_level
## In state 360, spurious reduction of production conj_expr_level -> set_mem_level
## In state 385, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 379, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 387, spurious reduction of production expr -> base_expr(expr)
## In state 689, spurious reduction of production case_clause(expr) -> pattern ARROW expr
## In state 693, spurious reduction of production nsepseq(case_clause(expr),VBAR) -> case_clause(expr)
## In state 690, spurious reduction of production cases(expr) -> nsepseq(case_clause(expr),VBAR)
##

Ill-formed case expression.
At this point, if the clause is complete, one of the following is
expected:
  * another clause;
  * a closing bracket ']' if the case is complete.
Note: A clause, here, is made of a pattern and an instruction or
a block of statements, separated by an arrow '->'.

interactive_expr: Begin Case Verbatim Of LBRACKET With
##
## Ends in an error in state: 554.
##
## case(test_clause(instruction)) -> Case expr Of LBRACKET . cases(test_clause(instruction)) RBRACKET [ VBAR SEMI RBRACKET RBRACE End Else ]
## case(test_clause(instruction)) -> Case expr Of LBRACKET . VBAR cases(test_clause(instruction)) RBRACKET [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## Case expr Of LBRACKET
##

Ill-formed case instruction.
At this point, one of the following is expected:
  * a clause, starting with a pattern;
  * a vertical bar '|' followed by a clause.
Note: A clause, here, is made of a pattern and an instruction or
a block of statements, separated by an arrow '->'.

interactive_expr: Begin Case Verbatim Of With
##
## Ends in an error in state: 553.
##
## case(test_clause(instruction)) -> Case expr Of . LBRACKET cases(test_clause(instruction)) RBRACKET [ VBAR SEMI RBRACKET RBRACE End Else ]
## case(test_clause(instruction)) -> Case expr Of . LBRACKET VBAR cases(test_clause(instruction)) RBRACKET [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## Case expr Of
##

Ill-formed case instruction.
At this point, an opening bracket '[' is expected.

interactive_expr: Begin Case With
##
## Ends in an error in state: 551.
##
## case(test_clause(instruction)) -> Case . expr Of LBRACKET cases(test_clause(instruction)) RBRACKET [ VBAR SEMI RBRACKET RBRACE End Else ]
## case(test_clause(instruction)) -> Case . expr Of LBRACKET VBAR cases(test_clause(instruction)) RBRACKET [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## Case
##

Ill-formed case instruction.
At this point, the analysed expression is expected, followed by the
keyword 'of'.

interactive_expr: Begin UIdent With
##
## Ends in an error in state: 401.
##
## module_path(selected) -> UIdent . DOT module_path(selected) [ VBAR SEMI RBRACKET RBRACE LPAR LBRACKET End Else ASS ]
## module_path(selected) -> UIdent . DOT selected [ VBAR SEMI RBRACKET RBRACE LPAR LBRACKET End Else ASS ]
##
## The known suffix of the stack is as follows:
## UIdent
##

Ill-formed selection of a value from a module.
At this point, the selection symbol '.' is expected, followed by either
  * the qualified name of a value, like 'A.B.c.2.d';
  * a value or function name.

interactive_expr: Begin For Ident ASS Verbatim To Verbatim Step Verbatim Attr
##
## Ends in an error in state: 542.
##
## for_int -> For Ident ASS expr To expr step_clause . block [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## For Ident ASS expr To expr step_clause
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 315, spurious reduction of production update_expr_level -> core_expr
## In state 280, spurious reduction of production unary_expr_level -> update_expr_level
## In state 309, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 311, spurious reduction of production add_expr_level -> mult_expr_level
## In state 332, spurious reduction of production cons_expr_level -> add_expr_level
## In state 322, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 352, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 339, spurious reduction of production set_mem_level -> comp_expr_level
## In state 360, spurious reduction of production conj_expr_level -> set_mem_level
## In state 385, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 379, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 387, spurious reduction of production expr -> base_expr(expr)
## In state 541, spurious reduction of production step_clause -> Step expr
##

Ill-formed iteration over a numerical interval.
At this point, if the step clause is complete, the loop body is
expected as a block of statements.

interactive_expr: Begin For Ident ASS Verbatim To Verbatim Step With
##
## Ends in an error in state: 540.
##
## step_clause -> Step . expr [ LBRACE Block Begin ]
##
## The known suffix of the stack is as follows:
## Step
##

Ill-formed iteration over a numerical interval.
At this point, the index increment (step) is expected as an
expression.

interactive_expr: Begin For Ident ASS Verbatim To With
##
## Ends in an error in state: 538.
##
## for_int -> For Ident ASS expr To . expr block [ VBAR SEMI RBRACKET RBRACE End Else ]
## for_int -> For Ident ASS expr To . expr step_clause block [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## For Ident ASS expr To
##

Ill-formed iteration over a numerical interval.
At this point, the final value of the index is expected as an
expression.

interactive_expr: Begin For Ident ASS With
##
## Ends in an error in state: 536.
##
## for_int -> For Ident ASS . expr To expr block [ VBAR SEMI RBRACKET RBRACE End Else ]
## for_int -> For Ident ASS . expr To expr step_clause block [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## For Ident ASS
##

Ill-formed iteration over a numerical interval.
At this point, the expression for the initial value of the index is
expected.

interactive_expr: Begin For Ident ARROW Ident In Map UIdent While
##
## Ends in an error in state: 549.
##
## for_in -> For Ident ARROW Ident In Map expr . block [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## For Ident ARROW Ident In Map expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 227, spurious reduction of production ctor_app_expr -> UIdent
## In state 295, spurious reduction of production core_expr -> ctor_app_expr
## In state 315, spurious reduction of production update_expr_level -> core_expr
## In state 280, spurious reduction of production unary_expr_level -> update_expr_level
## In state 309, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 311, spurious reduction of production add_expr_level -> mult_expr_level
## In state 332, spurious reduction of production cons_expr_level -> add_expr_level
## In state 322, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 352, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 339, spurious reduction of production set_mem_level -> comp_expr_level
## In state 360, spurious reduction of production conj_expr_level -> set_mem_level
## In state 385, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 379, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 387, spurious reduction of production expr -> base_expr(expr)
##

Ill-formed iteration over a map.
At this point, if the expression is complete, the body of the loop is
expected as a block of statements (declarations and instructions).

interactive_expr: Begin For Ident In List With
##
## Ends in an error in state: 533.
##
## for_in -> For Ident In List . expr block [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## For Ident In List
##

Ill-formed iteration over a list.
At this point, the iterated list is expected as an expression.

interactive_expr: Begin For Ident In Set With
##
## Ends in an error in state: 530.
##
## for_in -> For Ident In Set . expr block [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## For Ident In Set
##

Ill-formed iteration over a set.
At this point, the iterated set is expected as an expression.

interactive_expr: Begin For Ident In With
##
## Ends in an error in state: 529.
##
## for_in -> For Ident In . Set expr block [ VBAR SEMI RBRACKET RBRACE End Else ]
## for_in -> For Ident In . List expr block [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## For Ident In
##

Ill-formed iteration over a set or a list.
At this point, one of the following is expected:
  * the keyword 'set' if iterating over a set;
  * the keyword 'list' if iterating over a list.

interactive_expr: Begin For Ident With
##
## Ends in an error in state: 528.
##
## for_in -> For Ident . ARROW Ident In Map expr block [ VBAR SEMI RBRACKET RBRACE End Else ]
## for_in -> For Ident . In Set expr block [ VBAR SEMI RBRACKET RBRACE End Else ]
## for_in -> For Ident . In List expr block [ VBAR SEMI RBRACKET RBRACE End Else ]
## for_int -> For Ident . ASS expr To expr block [ VBAR SEMI RBRACKET RBRACE End Else ]
## for_int -> For Ident . ASS expr To expr step_clause block [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## For Ident
##

Ill-formed iteration.
At this point, one of the following is expected:
  * the assignment symbol ':=' if iterating over a numerical interval;
  * the keyword 'in' if iterating over a list or a set;
  * a binding arrow '->' if iterating over a map.

interactive_expr: Begin For With
##
## Ends in an error in state: 527.
##
## for_in -> For . Ident ARROW Ident In Map expr block [ VBAR SEMI RBRACKET RBRACE End Else ]
## for_in -> For . Ident In Set expr block [ VBAR SEMI RBRACKET RBRACE End Else ]
## for_in -> For . Ident In List expr block [ VBAR SEMI RBRACKET RBRACE End Else ]
## for_int -> For . Ident ASS expr To expr block [ VBAR SEMI RBRACKET RBRACE End Else ]
## for_int -> For . Ident ASS expr To expr step_clause block [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## For
##

Ill-formed iteration.
At this point, one of the following is expected:
  * a variable denoting the index, if iterating over a numerical
    interval;
  * a variable denoting an element, if iterating over a list or a set;
  * a variable denoting the key of a map, if iterating over a map.

interactive_expr: Begin Ident ASS With
##
## Ends in an error in state: 563.
##
## assignment(expr) -> left_expr ASS . expr [ VBAR SEMI RBRACKET RBRACE End ]
##
## The known suffix of the stack is as follows:
## left_expr ASS
##
interactive_expr: Begin If UIdent Then Ident ASS With
##
## Ends in an error in state: 594.
##
## assignment(closed_expr) -> left_expr ASS . closed_expr [ Else ]
## assignment(expr) -> left_expr ASS . expr [ VBAR SEMI RBRACKET RBRACE End ]
##
## The known suffix of the stack is as follows:
## left_expr ASS
##

Ill-formed assignment.
At this point, the right-hand side is expected as an expression.

interactive_expr: Begin Ident With
##
## Ends in an error in state: 562.
##
## assignment(expr) -> left_expr . ASS expr [ VBAR SEMI RBRACKET RBRACE End ]
##
## The known suffix of the stack is as follows:
## left_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 252, spurious reduction of production field_path -> Ident
## In state 294, spurious reduction of production local_path -> field_path
## In state 291, spurious reduction of production path_expr -> local_path
## In state 276, spurious reduction of production left_expr -> path_expr
##
interactive_expr: Begin If UIdent Then Ident With
##
## Ends in an error in state: 593.
##
## assignment(closed_expr) -> left_expr . ASS closed_expr [ Else ]
## assignment(expr) -> left_expr . ASS expr [ VBAR SEMI RBRACKET RBRACE End ]
##
## The known suffix of the stack is as follows:
## left_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 252, spurious reduction of production field_path -> Ident
## In state 294, spurious reduction of production local_path -> field_path
## In state 291, spurious reduction of production path_expr -> local_path
## In state 276, spurious reduction of production left_expr -> path_expr
##

Ill-formed assignment instruction.
At this point, if the expression is complete, the assignment symbol
':=' is expected.

interactive_expr: Begin If Verbatim Then Skip Else With
##
## Ends in an error in state: 646.
##
## if_then_else_instr(instruction) -> If expr Then test_clause(closed_instr) Else . test_clause(instruction) [ VBAR SEMI RBRACKET RBRACE End ]
##
## The known suffix of the stack is as follows:
## If expr Then test_clause(closed_instr) Else
##
interactive_expr: Begin If UIdent Then If UIdent Then Skip Else With
##
## Ends in an error in state: 588.
##
## if_then_else_instr(closed_instr) -> If expr Then test_clause(closed_instr) Else . test_clause(closed_instr) [ Else ]
## if_then_else_instr(instruction) -> If expr Then test_clause(closed_instr) Else . test_clause(instruction) [ VBAR SEMI RBRACKET RBRACE End ]
##
## The known suffix of the stack is as follows:
## If expr Then test_clause(closed_instr) Else
##

Ill-formed conditional instruction.
At this point, the 'else' branch is expected as either
  * a single instruction;
  * a block of statements (instructions and declarations).

interactive_expr: Begin If Verbatim Then Skip With
##
## Ends in an error in state: 645.
##
## if_then_else_instr(instruction) -> If expr Then test_clause(closed_instr) . Else test_clause(instruction) [ VBAR SEMI RBRACKET RBRACE End ]
##
## The known suffix of the stack is as follows:
## If expr Then test_clause(closed_instr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 512, spurious reduction of production base_instr(closed_instr,closed_expr) -> Skip
## In state 643, spurious reduction of production closed_instr -> base_instr(closed_instr,closed_expr)
## In state 639, spurious reduction of production test_clause(closed_instr) -> closed_instr
##
interactive_expr: Begin If UIdent Then If UIdent Then Skip With
##
## Ends in an error in state: 587.
##
## if_then_else_instr(closed_instr) -> If expr Then test_clause(closed_instr) . Else test_clause(closed_instr) [ Else ]
## if_then_else_instr(instruction) -> If expr Then test_clause(closed_instr) . Else test_clause(instruction) [ VBAR SEMI RBRACKET RBRACE End ]
##
## The known suffix of the stack is as follows:
## If expr Then test_clause(closed_instr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 512, spurious reduction of production base_instr(closed_instr,closed_expr) -> Skip
## In state 643, spurious reduction of production closed_instr -> base_instr(closed_instr,closed_expr)
## In state 639, spurious reduction of production test_clause(closed_instr) -> closed_instr
##

Ill-formed conditional instruction.
At this point, if the 'then' branch is complete, the keyword 'else' is
expected, followed by either
  * a single instruction;
  * a block of statements (instructions and declarations).

interactive_expr: Begin If Verbatim Then With
##
## Ends in an error in state: 511.
##
## if_then_else_instr(instruction) -> If expr Then . test_clause(closed_instr) Else test_clause(instruction) [ VBAR SEMI RBRACKET RBRACE End ]
## if_then_instr -> If expr Then . test_clause(instruction) [ VBAR SEMI RBRACKET RBRACE End ]
##
## The known suffix of the stack is as follows:
## If expr Then
##
interactive_expr: Begin If UIdent Then If UIdent Then With
##
## Ends in an error in state: 526.
##
## if_then_else_instr(closed_instr) -> If expr Then . test_clause(closed_instr) Else test_clause(closed_instr) [ Else ]
## if_then_else_instr(instruction) -> If expr Then . test_clause(closed_instr) Else test_clause(instruction) [ VBAR SEMI RBRACKET RBRACE End ]
## if_then_instr -> If expr Then . test_clause(instruction) [ VBAR SEMI RBRACKET RBRACE End ]
##
## The known suffix of the stack is as follows:
## If expr Then
##

Ill-formed conditional instruction.
At this point, the 'then' branch is expected as one of the following:
  * a single instruction;
  * a block of statements (instructions and declarations).

interactive_expr: Begin If With
##
## Ends in an error in state: 509.
##
## if_then_else_instr(instruction) -> If . expr Then test_clause(closed_instr) Else test_clause(instruction) [ VBAR SEMI RBRACKET RBRACE End ]
## if_then_instr -> If . expr Then test_clause(instruction) [ VBAR SEMI RBRACKET RBRACE End ]
##
## The known suffix of the stack is as follows:
## If
##
interactive_expr: Begin If UIdent Then If With
##
## Ends in an error in state: 524.
##
## if_then_else_instr(closed_instr) -> If . expr Then test_clause(closed_instr) Else test_clause(closed_instr) [ Else ]
## if_then_else_instr(instruction) -> If . expr Then test_clause(closed_instr) Else test_clause(instruction) [ VBAR SEMI RBRACKET RBRACE End ]
## if_then_instr -> If . expr Then test_clause(instruction) [ VBAR SEMI RBRACKET RBRACE End ]
##
## The known suffix of the stack is as follows:
## If
##

Ill-formed conditional instruction.
At this point, the condition is expected as a Boolean expression.

interactive_expr: If With
##
## Ends in an error in state: 251.
##
## if_then_else_expr(expr) -> If . expr Then closed_expr Else expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
## if_then_expr -> If . expr Then expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
##
## The known suffix of the stack is as follows:
## If
##
interactive_expr: If UIdent Then If With
##
## Ends in an error in state: 595.
##
## if_then_else_expr(closed_expr) -> If . expr Then closed_expr Else closed_expr [ Else ]
## if_then_else_expr(expr) -> If . expr Then closed_expr Else expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
## if_then_expr -> If . expr Then expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
##
## The known suffix of the stack is as follows:
## If
##

Ill-formed conditional expression.
At this point, the condition is expected as a Boolean expression.

interactive_expr: Ident DOT Int DOT With
##
## Ends in an error in state: 257.
##
## nsepseq(selection,DOT) -> selection DOT . nsepseq(selection,DOT) [ With VBAR_EQ VBAR Type To Then TIMES_EQ TIMES Step SLASH_EQ SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS_EQ PLUS Or Of NE Module Mod MINUS_EQ MINUS LT LPAR LE LBRACKET LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ASS ARROW ]
##
## The known suffix of the stack is as follows:
## selection DOT
##
interactive_expr: Ident DOT With
##
## Ends in an error in state: 253.
##
## field_path -> Ident DOT . nsepseq(selection,DOT) [ With VBAR_EQ VBAR Type To Then TIMES_EQ TIMES Step SLASH_EQ SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS_EQ PLUS Or Of NE Module Mod MINUS_EQ MINUS LT LPAR LE LBRACKET LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ASS ARROW ]
##
## The known suffix of the stack is as follows:
## Ident DOT
##
interactive_expr: LPAR UIdent RPAR DOT With
##
## Ends in an error in state: 285.
##
## local_path -> par(expr) DOT . nsepseq(selection,DOT) [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LPAR LE LBRACKET LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ASS ARROW ]
##
## The known suffix of the stack is as follows:
## par(expr) DOT
##

Ill-formed selection from a record or a tuple.
At this point, one of the following is expected:
  * a record field name, if selecting from a record;
  * the index of a tuple component, '0' or '@0' denoting the first
    component.

interactive_expr: Begin Patch With
##
## Ends in an error in state: 427.
##
## patch_instr(expr) -> Patch . core_expr With patch_expr [ VBAR SEMI RBRACKET RBRACE End ]
##
## The known suffix of the stack is as follows:
## Patch
##
interactive_expr: Begin If UIdent Then Patch With
##
## Ends in an error in state: 520.
##
## patch_instr(closed_expr) -> Patch . core_expr With patch_expr [ Else ]
## patch_instr(expr) -> Patch . core_expr With patch_expr [ VBAR SEMI RBRACKET RBRACE End ]
##
## The known suffix of the stack is as follows:
## Patch
##

Ill-formed patch instruction.
At this point, the patched data structure is expected as an
expression.

interactive_expr: Begin Patch UIdent While
##
## Ends in an error in state: 428.
##
## patch_instr(expr) -> Patch core_expr . With patch_expr [ VBAR SEMI RBRACKET RBRACE End ]
##
## The known suffix of the stack is as follows:
## Patch core_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 227, spurious reduction of production ctor_app_expr -> UIdent
## In state 295, spurious reduction of production core_expr -> ctor_app_expr
##
interactive_expr: Begin If UIdent Then Patch UIdent While
##
## Ends in an error in state: 521.
##
## patch_instr(closed_expr) -> Patch core_expr . With patch_expr [ Else ]
## patch_instr(expr) -> Patch core_expr . With patch_expr [ VBAR SEMI RBRACKET RBRACE End ]
##
## The known suffix of the stack is as follows:
## Patch core_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 227, spurious reduction of production ctor_app_expr -> UIdent
## In state 295, spurious reduction of production core_expr -> ctor_app_expr
##

Ill-formed patch instruction.
At this point, if the expression is complete, the keyword 'with' is
expected.

interactive_expr: Begin Patch UIdent With With
##
## Ends in an error in state: 429.
##
## patch_instr(expr) -> Patch core_expr With . patch_expr [ VBAR SEMI RBRACKET RBRACE End ]
##
## The known suffix of the stack is as follows:
## Patch core_expr With
##
interactive_expr: Begin If UIdent Then Patch UIdent With With
##
## Ends in an error in state: 522.
##
## patch_instr(closed_expr) -> Patch core_expr With . patch_expr [ Else ]
## patch_instr(expr) -> Patch core_expr With . patch_expr [ VBAR SEMI RBRACKET RBRACE End ]
##
## The known suffix of the stack is as follows:
## Patch core_expr With
##

Ill-formed patch instruction.
At this point, one of the following is expected:
  * a record literal, starting with the keyword 'record';
  * a map literal, starting with the keyword 'map';
  * a set literal, starting with the keyword 'set';
  * the keyword 'record', 'set' or 'map', followed by either a
    function call or a parenthesised expression denoting a record, a
    set or a map, respectively.

interactive_expr: Record With
##
## Ends in an error in state: 232.
##
## compound(Record,field_path_assignment) -> Record . LBRACKET RBRACKET [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
## compound(Record,field_path_assignment) -> Record . LBRACKET sep_or_term_list(field_path_assignment,SEMI) RBRACKET [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## Record
##

Ill-formed record expression or record patch.
At this point, an opening bracket '[' is expected.

interactive_expr: Record LBRACKET Ident SEMI While
##
## Ends in an error in state: 745.
##
## compound(Record,field_path_assignment) -> Record LBRACKET sep_or_term_list(field_path_assignment,SEMI) . RBRACKET [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## Record LBRACKET sep_or_term_list(field_path_assignment,SEMI)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 768, spurious reduction of production nseq(__anonymous_0(field_path_assignment,SEMI)) -> field_path_assignment SEMI
## In state 747, spurious reduction of production sep_or_term_list(field_path_assignment,SEMI) -> nseq(__anonymous_0(field_path_assignment,SEMI))
##

Ill-formed record expression or record patch.
At this point, if the field assignment is complete, one of the
following is expected:
  * another assignment;
  * a closing bracket ']' if the record or patch is complete.

interactive_expr: Record LBRACKET Ident Type
##
## Ends in an error in state: 764.
##
## field_path_assignment -> field_path_lhs . field_lens expr [ SEMI RBRACKET ]
##
## The known suffix of the stack is as follows:
## field_path_lhs
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 744, spurious reduction of production field_path -> Ident
## In state 761, spurious reduction of production field_path_lhs -> field_path
##
interactive_expr: Record LBRACKET Attr UIdent DOT Ident With
##
## Ends in an error in state: 752.
##
## field_path_assignment -> nseq(Attr) field_path_lhs . field_lens expr [ SEMI RBRACKET ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) field_path_lhs
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 739, spurious reduction of production field_path -> Ident
## In state 742, spurious reduction of production module_path(field_path) -> UIdent DOT field_path
## In state 749, spurious reduction of production field_path_lhs -> module_path(field_path)
##

Ill-formed record expression or record patch.
At this point, if the left-hand side of the field is complete, a lens
is expected amongst: '=', '+=', '-=', '*=', '/='. or '|='.

interactive_expr: Begin Remove UIdent From Set With
##
## Ends in an error in state: 416.
##
## remove_instr(expr) -> Remove expr From Set . left_expr [ VBAR SEMI RBRACKET RBRACE End ]
##
## The known suffix of the stack is as follows:
## Remove expr From Set
##
interactive_expr: Begin If UIdent Then Remove UIdent From Set With
##
## Ends in an error in state: 516.
##
## remove_instr(closed_expr) -> Remove expr From Set . left_expr [ Else ]
## remove_instr(expr) -> Remove expr From Set . left_expr [ VBAR SEMI RBRACKET RBRACE End ]
##
## The known suffix of the stack is as follows:
## Remove expr From Set
##

Ill-formed removal from a set.
At this point, the set is expected as an expression.

interactive_expr: Begin Remove UIdent From Map With
##
## Ends in an error in state: 425.
##
## remove_instr(expr) -> Remove expr From Map . left_expr [ VBAR SEMI RBRACKET RBRACE End ]
##
## The known suffix of the stack is as follows:
## Remove expr From Map
##
interactive_expr: Begin If UIdent Then Remove UIdent From Map With
##
## Ends in an error in state: 518.
##
## remove_instr(closed_expr) -> Remove expr From Map . left_expr [ Else ]
## remove_instr(expr) -> Remove expr From Map . left_expr [ VBAR SEMI RBRACKET RBRACE End ]
##
## The known suffix of the stack is as follows:
## Remove expr From Map
##

Ill-formed removal from a map.
At this point, the map is expected as an expression.

interactive_expr: Begin If UIdent Then Remove UIdent While
##
## Ends in an error in state: 514.
##
## remove_instr(closed_expr) -> Remove expr . From Set left_expr [ Else ]
## remove_instr(closed_expr) -> Remove expr . From Map left_expr [ Else ]
## remove_instr(expr) -> Remove expr . From Set left_expr [ VBAR SEMI RBRACKET RBRACE End ]
## remove_instr(expr) -> Remove expr . From Map left_expr [ VBAR SEMI RBRACKET RBRACE End ]
##
## The known suffix of the stack is as follows:
## Remove expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 227, spurious reduction of production ctor_app_expr -> UIdent
## In state 295, spurious reduction of production core_expr -> ctor_app_expr
## In state 315, spurious reduction of production update_expr_level -> core_expr
## In state 280, spurious reduction of production unary_expr_level -> update_expr_level
## In state 309, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 311, spurious reduction of production add_expr_level -> mult_expr_level
## In state 332, spurious reduction of production cons_expr_level -> add_expr_level
## In state 322, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 352, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 339, spurious reduction of production set_mem_level -> comp_expr_level
## In state 360, spurious reduction of production conj_expr_level -> set_mem_level
## In state 385, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 379, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 387, spurious reduction of production expr -> base_expr(expr)
##
interactive_expr: Begin Remove UIdent While
##
## Ends in an error in state: 414.
##
## remove_instr(expr) -> Remove expr . From Set left_expr [ VBAR SEMI RBRACKET RBRACE End ]
## remove_instr(expr) -> Remove expr . From Map left_expr [ VBAR SEMI RBRACKET RBRACE End ]
##
## The known suffix of the stack is as follows:
## Remove expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 227, spurious reduction of production ctor_app_expr -> UIdent
## In state 295, spurious reduction of production core_expr -> ctor_app_expr
## In state 315, spurious reduction of production update_expr_level -> core_expr
## In state 280, spurious reduction of production unary_expr_level -> update_expr_level
## In state 309, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 311, spurious reduction of production add_expr_level -> mult_expr_level
## In state 332, spurious reduction of production cons_expr_level -> add_expr_level
## In state 322, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 352, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 339, spurious reduction of production set_mem_level -> comp_expr_level
## In state 360, spurious reduction of production conj_expr_level -> set_mem_level
## In state 385, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 379, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 387, spurious reduction of production expr -> base_expr(expr)
##

Ill-formed removal from a map or a set.
At this point, if the map key or the set element to remove is
complete, the keyword 'from' is expected.

interactive_expr: Begin If UIdent Then Remove With
##
## Ends in an error in state: 513.
##
## remove_instr(closed_expr) -> Remove . expr From Set left_expr [ Else ]
## remove_instr(closed_expr) -> Remove . expr From Map left_expr [ Else ]
## remove_instr(expr) -> Remove . expr From Set left_expr [ VBAR SEMI RBRACKET RBRACE End ]
## remove_instr(expr) -> Remove . expr From Map left_expr [ VBAR SEMI RBRACKET RBRACE End ]
##
## The known suffix of the stack is as follows:
## Remove
##
interactive_expr: Begin Remove With
##
## Ends in an error in state: 413.
##
## remove_instr(expr) -> Remove . expr From Set left_expr [ VBAR SEMI RBRACKET RBRACE End ]
## remove_instr(expr) -> Remove . expr From Map left_expr [ VBAR SEMI RBRACKET RBRACE End ]
##
## The known suffix of the stack is as follows:
## Remove
##

Ill-formed removal from a set or a map.
At this point, the set element or key map to remove is expected as an
expression.

interactive_expr: Begin Remove UIdent From With
##
## Ends in an error in state: 415.
##
## remove_instr(expr) -> Remove expr From . Set left_expr [ VBAR SEMI RBRACKET RBRACE End ]
## remove_instr(expr) -> Remove expr From . Map left_expr [ VBAR SEMI RBRACKET RBRACE End ]
##
## The known suffix of the stack is as follows:
## Remove expr From
##
interactive_expr: Begin If UIdent Then Remove UIdent From With
##
## Ends in an error in state: 515.
##
## remove_instr(closed_expr) -> Remove expr From . Set left_expr [ Else ]
## remove_instr(closed_expr) -> Remove expr From . Map left_expr [ Else ]
## remove_instr(expr) -> Remove expr From . Set left_expr [ VBAR SEMI RBRACKET RBRACE End ]
## remove_instr(expr) -> Remove expr From . Map left_expr [ VBAR SEMI RBRACKET RBRACE End ]
##
## The known suffix of the stack is as follows:
## Remove expr From
##

Ill-formed removal from a set or a map.
At this point, one of the following is expected:
  * the keyword 'set' followed by set elements as expressions;
  * the keyword 'map' followed by bindings or a function call or a
    parenthesised expression.

interactive_expr: Begin Skip End While
##
## Ends in an error in state: 375.
##
## block_with(expr) -> block . With expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
##
## The known suffix of the stack is as follows:
## block
##

Ill-formed block expression.
At this point, the keyword 'with' is expected, followed by an
expression whose value is that of the whole block.

interactive_expr: Begin Skip End With With
##
## Ends in an error in state: 376.
##
## block_with(expr) -> block With . expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
##
## The known suffix of the stack is as follows:
## block With
##
interactive_expr: If UIdent Then LBRACE Skip RBRACE With With
##
## Ends in an error in state: 608.
##
## block_with(closed_expr) -> block With . closed_expr [ Else ]
## block_with(expr) -> block With . expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
##
## The known suffix of the stack is as follows:
## block With
##

Ill-formed block expression.
At this point, an expression is expected, whose value is that of the
block.

interactive_expr: Begin Skip With
##
## Ends in an error in state: 670.
##
## verb_block -> Begin sep_or_term_list(statement,SEMI) . End [ With VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## Begin sep_or_term_list(statement,SEMI)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 649, spurious reduction of production nsepseq(statement,SEMI) -> statement
## In state 661, spurious reduction of production sep_or_term_list(statement,SEMI) -> nsepseq(statement,SEMI)
##

Ill-formed block of statements.
At this point, if the statement is complete, one of the following is
expected:
  * another statement (instruction or declaration);
  * the keyword 'end' if the block is complete.

interactive_expr: Begin Var UIdent LT Ident GT With
##
## Ends in an error in state: 393.
##
## unqualified_decl(ASS) -> core_pattern type_params . ASS expr [ SEMI RBRACE End ]
## unqualified_decl(ASS) -> core_pattern type_params . COLON type_expr ASS expr [ SEMI RBRACE End ]
##
## The known suffix of the stack is as follows:
## core_pattern type_params
##

Ill-formed variable declaration.
At this point, one of the following is expected:
  * the assignment symbol ':=';
  * a type annotation starting with a colon ':'.

interactive_expr: Begin Var UIdent LT Ident GT COLON With
##
## Ends in an error in state: 394.
##
## unqualified_decl(ASS) -> core_pattern type_params COLON . type_expr ASS expr [ SEMI RBRACE End ]
##
## The known suffix of the stack is as follows:
## core_pattern type_params COLON
##

Ill-formed variable declaration.
At this point, the type of the variable is expected.

interactive_expr: Begin Var UIdent LT Ident GT COLON Ident With
##
## Ends in an error in state: 395.
##
## unqualified_decl(ASS) -> core_pattern type_params COLON type_expr . ASS expr [ SEMI RBRACE End ]
##
## The known suffix of the stack is as follows:
## core_pattern type_params COLON type_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 34, spurious reduction of production core_type -> Ident
## In state 69, spurious reduction of production cartesian_level -> core_type
## In state 76, spurious reduction of production fun_type_level -> cartesian_level
## In state 68, spurious reduction of production type_expr -> fun_type_level
##

Ill-formed variable declaration.
At this point, if the type is complete, the assignment symbol ':=' is
expected.

interactive_expr: Begin Var UIdent LT Ident GT COLON Ident ASS With
##
## Ends in an error in state: 396.
##
## unqualified_decl(ASS) -> core_pattern type_params COLON type_expr ASS . expr [ SEMI RBRACE End ]
##
## The known suffix of the stack is as follows:
## core_pattern type_params COLON type_expr ASS
##
interactive_expr: Begin Var UIdent LT Ident GT ASS With
##
## Ends in an error in state: 398.
##
## unqualified_decl(ASS) -> core_pattern type_params ASS . expr [ SEMI RBRACE End ]
##
## The known suffix of the stack is as follows:
## core_pattern type_params ASS
##
interactive_expr: Begin Var Ident ASS With
##
## Ends in an error in state: 391.
##
## unqualified_decl(ASS) -> core_pattern ASS . expr [ SEMI RBRACE End ]
##
## The known suffix of the stack is as follows:
## core_pattern ASS
##
interactive_expr: Begin Var Ident COLON WILD ASS With
##
## Ends in an error in state: 368.
##
## unqualified_decl(ASS) -> core_pattern COLON type_expr ASS . expr [ SEMI RBRACE End ]
##
## The known suffix of the stack is as follows:
## core_pattern COLON type_expr ASS
##

Ill-formed variable declaration.
At this point, an expression is expected, whose value is the first
assigned.

interactive_expr: Begin Var Ident With
##
## Ends in an error in state: 365.
##
## unqualified_decl(ASS) -> core_pattern . ASS expr [ SEMI RBRACE End ]
## unqualified_decl(ASS) -> core_pattern . COLON type_expr ASS expr [ SEMI RBRACE End ]
## unqualified_decl(ASS) -> core_pattern . type_params ASS expr [ SEMI RBRACE End ]
## unqualified_decl(ASS) -> core_pattern . type_params COLON type_expr ASS expr [ SEMI RBRACE End ]
##
## The known suffix of the stack is as follows:
## core_pattern
##

Ill-formed variable declaration.
At this point, one of the following is expected:
  * a colon ':' followed by the type of the variable;
  * the assignment symbol ':=' followed by an expression whose
    value is the first assigned.

interactive_expr: Begin Var With
##
## Ends in an error in state: 363.
##
## var_decl -> Var . unqualified_decl(ASS) [ SEMI RBRACE End ]
##
## The known suffix of the stack is as follows:
## Var
##

Ill-formed variable declaration.
At this point, a pattern is expected, e.g. a variable.

interactive_expr: Begin While With
##
## Ends in an error in state: 271.
##
## while_loop -> While . expr block [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## While
##

Ill-formed general loop.
At this point, the condition is expected as a Boolean expression.

interactive_expr: BigMap LBRACKET With
##
## Ends in an error in state: 268.
##
## compound(BigMap,binding) -> BigMap LBRACKET . RBRACKET [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
## compound(BigMap,binding) -> BigMap LBRACKET . sep_or_term_list(binding,SEMI) RBRACKET [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## BigMap LBRACKET
##

Ill-formed big map expression.
At this point, one of the following is expected:
  * key-value bindings separated by semicolons ';';
  * a closing bracket ']' if the big map is empty.
Note: A binding is made of two expressions (a key and a value)
separated by an arrow '->'.

interactive_expr: BigMap With
##
## Ends in an error in state: 267.
##
## compound(BigMap,binding) -> BigMap . LBRACKET RBRACKET [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
## compound(BigMap,binding) -> BigMap . LBRACKET sep_or_term_list(binding,SEMI) RBRACKET [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## BigMap
##

Ill-formed big map expression.
At this point, an opening bracket '[' is expected.

interactive_expr: Block LBRACE Skip With
##
## Ends in an error in state: 658.
##
## terse_block -> option(Block) LBRACE sep_or_term_list(statement,SEMI) . RBRACE [ With VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## option(Block) LBRACE sep_or_term_list(statement,SEMI)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 649, spurious reduction of production nsepseq(statement,SEMI) -> statement
## In state 661, spurious reduction of production sep_or_term_list(statement,SEMI) -> nsepseq(statement,SEMI)
##

Ill-formed block of statements.
At this point, if the statement is complete, one of the following is
expected:
  * another statement (instruction or declaration);
  * a closing brace '}' if there are no more statements.

interactive_expr: Block With
##
## Ends in an error in state: 361.
##
## terse_block -> option(Block) . LBRACE sep_or_term_list(statement,SEMI) RBRACE [ With VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## option(Block)
##

Ill-formed block of statements.
At this point, an opening brace '{' is expected.

interactive_expr: Case Verbatim Of LBRACKET With
##
## Ends in an error in state: 685.
##
## case(expr) -> Case expr Of LBRACKET . cases(expr) RBRACKET [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End Else EOF Directive Const COMMA Block Begin Attr ARROW ]
## case(expr) -> Case expr Of LBRACKET . VBAR cases(expr) RBRACKET [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End Else EOF Directive Const COMMA Block Begin Attr ARROW ]
##
## The known suffix of the stack is as follows:
## Case expr Of LBRACKET
##

Ill-formed case expression.
At this point, one of the following is expected:
  * a clause made of a pattern and an expression separated by an arrow
    '->';
  * a vertical bar '|' followed by a clause.

interactive_expr: Case Verbatim Of With
##
## Ends in an error in state: 684.
##
## case(expr) -> Case expr Of . LBRACKET cases(expr) RBRACKET [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End Else EOF Directive Const COMMA Block Begin Attr ARROW ]
## case(expr) -> Case expr Of . LBRACKET VBAR cases(expr) RBRACKET [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End Else EOF Directive Const COMMA Block Begin Attr ARROW ]
##
## The known suffix of the stack is as follows:
## Case expr Of
##

Ill-formed case expression.
At this point, an opening bracket '[' is expected.

interactive_expr: Case With
##
## Ends in an error in state: 264.
##
## case(expr) -> Case . expr Of LBRACKET cases(expr) RBRACKET [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End Else EOF Directive Const COMMA Block Begin Attr ARROW ]
## case(expr) -> Case . expr Of LBRACKET VBAR cases(expr) RBRACKET [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End Else EOF Directive Const COMMA Block Begin Attr ARROW ]
##
## The known suffix of the stack is as follows:
## Case
##

Ill-formed case expression.
At this point, the analysed expression is expected.

interactive_expr: Function LT Ident GT LPAR Const UIdent RPAR Is With
##
## Ends in an error in state: 263.
##
## fun_expr(expr) -> Function type_params parameters Is . expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
##
## The known suffix of the stack is as follows:
## Function type_params parameters Is
##
interactive_expr: If UIdent Then Function LT Ident GT LPAR Const UIdent RPAR COLON Ident Is With
##
## Ends in an error in state: 618.
##
## fun_expr(closed_expr) -> Function type_params parameters COLON type_expr Is . closed_expr [ Else ]
## fun_expr(expr) -> Function type_params parameters COLON type_expr Is . expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
##
## The known suffix of the stack is as follows:
## Function type_params parameters COLON type_expr Is
##
interactive_expr: Function LT Ident GT LPAR Const UIdent RPAR COLON Ident Is With
##
## Ends in an error in state: 700.
##
## fun_expr(expr) -> Function type_params parameters COLON type_expr Is . expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
##
## The known suffix of the stack is as follows:
## Function type_params parameters COLON type_expr Is
##
interactive_expr: If UIdent Then Function LT Ident GT LPAR Const UIdent RPAR Is With
##
## Ends in an error in state: 601.
##
## fun_expr(closed_expr) -> Function type_params parameters Is . closed_expr [ Else ]
## fun_expr(expr) -> Function type_params parameters Is . expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
##
## The known suffix of the stack is as follows:
## Function type_params parameters Is
##
interactive_expr: Function LPAR Const Ident RPAR Is With
##
## Ends in an error in state: 702.
##
## fun_expr(expr) -> Function parameters Is . expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
##
## The known suffix of the stack is as follows:
## Function parameters Is
##
interactive_expr: If UIdent Then Function LPAR Const Ident RPAR Is With
##
## Ends in an error in state: 622.
##
## fun_expr(closed_expr) -> Function parameters Is . closed_expr [ Else ]
## fun_expr(expr) -> Function parameters Is . expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
##
## The known suffix of the stack is as follows:
## Function parameters Is
##
interactive_expr: If UIdent Then Function LPAR Const Ident RPAR COLON Ident Is With
##
## Ends in an error in state: 627.
##
## fun_expr(closed_expr) -> Function parameters COLON type_expr Is . closed_expr [ Else ]
## fun_expr(expr) -> Function parameters COLON type_expr Is . expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
##
## The known suffix of the stack is as follows:
## Function parameters COLON type_expr Is
##
interactive_expr: Function LPAR Const Ident RPAR COLON WILD Is With
##
## Ends in an error in state: 705.
##
## fun_expr(expr) -> Function parameters COLON type_expr Is . expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
##
## The known suffix of the stack is as follows:
## Function parameters COLON type_expr Is
##

Ill-formed function expression.
At this point, the body is expected as an expression.

interactive_expr: Function LT Ident GT LPAR Const UIdent RPAR With
##
## Ends in an error in state: 262.
##
## fun_expr(expr) -> Function type_params parameters . Is expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
## fun_expr(expr) -> Function type_params parameters . COLON type_expr Is expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
##
## The known suffix of the stack is as follows:
## Function type_params parameters
##
interactive_expr: If UIdent Then Function LT Ident GT LPAR Const UIdent RPAR With
##
## Ends in an error in state: 600.
##
## fun_expr(closed_expr) -> Function type_params parameters . Is closed_expr [ Else ]
## fun_expr(closed_expr) -> Function type_params parameters . COLON type_expr Is closed_expr [ Else ]
## fun_expr(expr) -> Function type_params parameters . Is expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
## fun_expr(expr) -> Function type_params parameters . COLON type_expr Is expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
##
## The known suffix of the stack is as follows:
## Function type_params parameters
##
interactive_expr: If UIdent Then Function LPAR Const Ident RPAR With
##
## Ends in an error in state: 621.
##
## fun_expr(closed_expr) -> Function parameters . Is closed_expr [ Else ]
## fun_expr(closed_expr) -> Function parameters . COLON type_expr Is closed_expr [ Else ]
## fun_expr(expr) -> Function parameters . Is expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
## fun_expr(expr) -> Function parameters . COLON type_expr Is expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
##
## The known suffix of the stack is as follows:
## Function parameters
##
interactive_expr: Function LPAR Const Ident RPAR With
##
## Ends in an error in state: 701.
##
## fun_expr(expr) -> Function parameters . Is expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
## fun_expr(expr) -> Function parameters . COLON type_expr Is expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
##
## The known suffix of the stack is as follows:
## Function parameters
##

Ill-formed function expression.
At this point, one of the following is expected:
  * a colon ':' followed by the return type;
  * the keyword 'is' followed by the function body as an expression.

contract: Recursive Function Ident LPAR Const Ident RPAR With
##
## Ends in an error in state: 793.
##
## fun_decl -> Recursive Function Ident parameters . Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
## fun_decl -> Recursive Function Ident parameters . COLON type_expr Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## Recursive Function Ident parameters
##
contract: Function Ident LT Ident GT LPAR Const UIdent RPAR With
##
## Ends in an error in state: 456.
##
## fun_decl -> Function Ident type_params parameters . Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
## fun_decl -> Function Ident type_params parameters . COLON type_expr Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## Function Ident type_params parameters
##
contract: Attr Function Ident LPAR Const Ident RPAR With
##
## Ends in an error in state: 464.
##
## fun_decl -> Function Ident parameters . Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
## fun_decl -> Function Ident parameters . COLON type_expr Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## Function Ident parameters
##
contract: Recursive Function Ident LT Ident GT LPAR Const UIdent RPAR With
##
## Ends in an error in state: 224.
##
## fun_decl -> Recursive Function Ident type_params parameters . Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
## fun_decl -> Recursive Function Ident type_params parameters . COLON type_expr Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## Recursive Function Ident type_params parameters
##

Ill-formed function declaration.
At this point, one of the following is expected:
  * a colon ':' followed by the return type;
  * the keyword 'is' followed by the function body as an expression.

interactive_expr: Function LPAR Const Ident With
##
## Ends in an error in state: 214.
##
## param_decl -> param_kind parameter . [ SEMI RPAR ]
## param_decl -> param_kind parameter . COLON type_expr [ SEMI RPAR ]
##
## The known suffix of the stack is as follows:
## param_kind parameter
##

Ill-formed function parameter declaration.
At this point, if the parameter is complete, one of the following is
expected:
  * a colon ':' followed by the type of the parameter;
  * a semicolon ';' followed by another parameter declaration;
  * a closing parenthesis ')' if there are no more parameters.

interactive_expr: Function LPAR Var Ident COLON String With
##
## Ends in an error in state: 221.
##
## par(ioption(nsepseq(param_decl,SEMI))) -> LPAR nsepseq(param_decl,SEMI) . RPAR [ Is COLON ]
##
## The known suffix of the stack is as follows:
## LPAR nsepseq(param_decl,SEMI)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 69, spurious reduction of production cartesian_level -> core_type
## In state 76, spurious reduction of production fun_type_level -> cartesian_level
## In state 68, spurious reduction of production type_expr -> fun_type_level
## In state 216, spurious reduction of production param_decl -> param_kind parameter COLON type_expr
## In state 218, spurious reduction of production nsepseq(param_decl,SEMI) -> param_decl
##

Ill-formed function parameter declaration.
At this point, if the parameter declaration is complete, one of the
following is expected:
  * a semicolon ';' followed by another parameter declaration;
  * a closing parenthesis ')' if there are no more parameters.

interactive_expr: Function LPAR Var Ident COLON With
##
## Ends in an error in state: 215.
##
## param_decl -> param_kind parameter COLON . type_expr [ SEMI RPAR ]
##
## The known suffix of the stack is as follows:
## param_kind parameter COLON
##

Ill-formed function parameter declaration.
At this point, the type of the parameter is expected.

interactive_expr: Function LPAR Var Ident SEMI With
##
## Ends in an error in state: 219.
##
## nsepseq(param_decl,SEMI) -> param_decl SEMI . nsepseq(param_decl,SEMI) [ RPAR ]
##
## The known suffix of the stack is as follows:
## param_decl SEMI
##
interactive_expr: Function LPAR With
##
## Ends in an error in state: 120.
##
## par(ioption(nsepseq(param_decl,SEMI))) -> LPAR . RPAR [ Is COLON ]
## par(ioption(nsepseq(param_decl,SEMI))) -> LPAR . nsepseq(param_decl,SEMI) RPAR [ Is COLON ]
##
## The known suffix of the stack is as follows:
## LPAR
##

Ill-formed function parameter declaration.
At this point, one of the following is expected:
  * the keyword 'const' if the parameter is constant in the body;
  * the keyword 'var' if the parameter is variable in the body;
  * a closing parenthesis ')' is there are no parameters.
Note: Each parameter is initialised with a copy of the corresponding
argument (on the caller side).

interactive_expr: Function LPAR Var With
##
## Ends in an error in state: 124.
##
## param_decl -> param_kind . parameter [ SEMI RPAR ]
## param_decl -> param_kind . parameter COLON type_expr [ SEMI RPAR ]
##
## The known suffix of the stack is as follows:
## param_kind
##

Ill-formed function parameter declaration.
At this point, a pattern is expected, e.g. a variable.

contract: Function With
##
## Ends in an error in state: 453.
##
## fun_decl -> Function . Ident parameters Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
## fun_decl -> Function . Ident parameters COLON type_expr Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
## fun_decl -> Function . Ident type_params parameters Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
## fun_decl -> Function . Ident type_params parameters COLON type_expr Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## Function
##
contract: Recursive Function With
##
## Ends in an error in state: 112.
##
## fun_decl -> Recursive Function . Ident parameters Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
## fun_decl -> Recursive Function . Ident parameters COLON type_expr Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
## fun_decl -> Recursive Function . Ident type_params parameters Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
## fun_decl -> Recursive Function . Ident type_params parameters COLON type_expr Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## Recursive Function
##

Ill-formed function declaration.
At this point, the name of the function is expected.

interactive_expr: Ident LBRACKET With
##
## Ends in an error in state: 418.
##
## brackets(expr) -> LBRACKET . expr RBRACKET [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACKET LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ASS ARROW ]
##
## The known suffix of the stack is as follows:
## LBRACKET
##

Ill-formed map lookup.
At this point, a key is expected as an expression.

interactive_expr: Ident LPAR Verbatim COMMA With
##
## Ends in an error in state: 665.
##
## nsepseq(fun_arg,COMMA) -> fun_arg COMMA . nsepseq(fun_arg,COMMA) [ RPAR ]
##
## The known suffix of the stack is as follows:
## fun_arg COMMA
##
interactive_expr: Ident LPAR With
##
## Ends in an error in state: 277.
##
## par(ioption(nsepseq(fun_arg,COMMA))) -> LPAR . RPAR [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
## par(ioption(nsepseq(fun_arg,COMMA))) -> LPAR . nsepseq(fun_arg,COMMA) RPAR [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR
##

Ill-formed function call.
At this point, one of the following is expected:
  * an argument as an expression;
  * a closing parenthesis ')' if there are no arguments.

interactive_expr: Begin Patch UIdent With Record Ident With
##
## Ends in an error in state: 431.
##
## call_expr -> path_expr . par(ioption(nsepseq(fun_arg,COMMA))) [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## path_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 252, spurious reduction of production field_path -> Ident
## In state 294, spurious reduction of production local_path -> field_path
## In state 291, spurious reduction of production path_expr -> local_path
##

Ill-formed function call.
At this point, an opening parenthesis is expected.

interactive_expr: Ident While
##
## Ends in an error in state: 810.
##
## interactive_expr -> expr . EOF [ # ]
##
## The known suffix of the stack is as follows:
## expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 252, spurious reduction of production field_path -> Ident
## In state 294, spurious reduction of production local_path -> field_path
## In state 291, spurious reduction of production path_expr -> local_path
## In state 276, spurious reduction of production left_expr -> path_expr
## In state 293, spurious reduction of production core_expr -> left_expr
## In state 315, spurious reduction of production update_expr_level -> core_expr
## In state 280, spurious reduction of production unary_expr_level -> update_expr_level
## In state 309, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 311, spurious reduction of production add_expr_level -> mult_expr_level
## In state 332, spurious reduction of production cons_expr_level -> add_expr_level
## In state 322, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 352, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 339, spurious reduction of production set_mem_level -> comp_expr_level
## In state 360, spurious reduction of production conj_expr_level -> set_mem_level
## In state 385, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 379, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 387, spurious reduction of production expr -> base_expr(expr)
##

Ill-formed expression.
At this point, if the expression is complete, the end of the file is
expected.

interactive_expr: Ident With With
##
## Ends in an error in state: 316.
##
## update_expr -> core_expr With . core_expr [ VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## core_expr With
##

Ill-formed functional update of a record.
At this point, a record is expected a an expression.

interactive_expr: If Verbatim Then Verbatim Else With
##
## Ends in an error in state: 709.
##
## if_then_else_expr(expr) -> If expr Then closed_expr Else . expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
##
## The known suffix of the stack is as follows:
## If expr Then closed_expr Else
##
interactive_expr: If UIdent Then If UIdent Then UIdent Else With
##
## Ends in an error in state: 632.
##
## if_then_else_expr(closed_expr) -> If expr Then closed_expr Else . closed_expr [ Else ]
## if_then_else_expr(expr) -> If expr Then closed_expr Else . expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
##
## The known suffix of the stack is as follows:
## If expr Then closed_expr Else
##

Ill-formed conditional expression.
At this point, the contents of the 'else' branch is expected as an
expression.

interactive_expr: If Verbatim Then With
##
## Ends in an error in state: 707.
##
## if_then_else_expr(expr) -> If expr Then . closed_expr Else expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
## if_then_expr -> If expr Then . expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
##
## The known suffix of the stack is as follows:
## If expr Then
##
interactive_expr: If UIdent Then If UIdent Then With
##
## Ends in an error in state: 597.
##
## if_then_else_expr(closed_expr) -> If expr Then . closed_expr Else closed_expr [ Else ]
## if_then_else_expr(expr) -> If expr Then . closed_expr Else expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
## if_then_expr -> If expr Then . expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
##
## The known suffix of the stack is as follows:
## If expr Then
##

Ill-formed conditional expression.
At this point, the contents of the 'then' branch is expected as an
expression.

interactive_expr: LPAR Verbatim COLON Ident With
##
## Ends in an error in state: 710.
##
## par(typed_expr) -> LPAR typed_expr . RPAR [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR typed_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 34, spurious reduction of production core_type -> Ident
## In state 69, spurious reduction of production cartesian_level -> core_type
## In state 76, spurious reduction of production fun_type_level -> cartesian_level
## In state 68, spurious reduction of production type_expr -> fun_type_level
## In state 722, spurious reduction of production typed_expr -> disj_expr_level COLON type_expr
##

Ill-formed typed expression.
At this point, if the type is complete, a closing parenthesis ')' is
expected.

interactive_expr: LPAR Verbatim COMMA With
##
## Ends in an error in state: 714.
##
## par(__anonymous_6(expr)) -> LPAR expr COMMA . nsepseq(expr,COMMA) RPAR [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR expr COMMA
##
interactive_expr: LPAR UIdent COMMA UIdent COMMA With
##
## Ends in an error in state: 718.
##
## nsepseq(expr,COMMA) -> expr COMMA . nsepseq(expr,COMMA) [ RPAR ]
##
## The known suffix of the stack is as follows:
## expr COMMA
##

Ill-formed tuple expression.
At this point, a tuple component is expected as an expression.

interactive_expr: LPAR With
##
## Ends in an error in state: 249.
##
## par(__anonymous_6(expr)) -> LPAR . expr COMMA nsepseq(expr,COMMA) RPAR [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
## par(expr) -> LPAR . expr RPAR [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LPAR LE LBRACKET LBRACE GT GE Function From End Else EQ EOF Directive DOT Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
## par(typed_expr) -> LPAR . typed_expr RPAR [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR
##

Ill-formed parenthesised/tuple/typed expression.
At this point, an expression is expected.

interactive_expr: Lang With
##
## Ends in an error in state: 248.
##
## code_inj -> Lang . expr RBRACKET [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## Lang
##

Ill-formed code injection.
At this point, an expression is expected, whose value is a verbatim
string containing the code to inject.

interactive_expr: List LBRACKET With
##
## Ends in an error in state: 246.
##
## compound(List,list_element) -> List LBRACKET . RBRACKET [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
## compound(List,list_element) -> List LBRACKET . sep_or_term_list(list_element,SEMI) RBRACKET [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## List LBRACKET
##

Ill-formed list expression.
At this point, one of the following is expected:
  * elements as expressions separated by semicolons ';';
  * a closing bracket ']' if the list is empty.

contract: Const Record LBRACKET Ident EQ Bytes End
##
## Ends in an error in state: 187.
##
## compound(Record,field_pattern) -> Record LBRACKET sep_or_term_list(field_pattern,SEMI) . RBRACKET [ SHARP SEMI RPAR RBRACKET LT EQ COMMA COLON ASS ARROW ]
##
## The known suffix of the stack is as follows:
## Record LBRACKET sep_or_term_list(field_pattern,SEMI)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 163, spurious reduction of production pattern -> core_pattern
## In state 191, spurious reduction of production field_pattern -> pattern EQ pattern
## In state 194, spurious reduction of production nsepseq(field_pattern,SEMI) -> field_pattern
## In state 193, spurious reduction of production sep_or_term_list(field_pattern,SEMI) -> nsepseq(field_pattern,SEMI)
##

Ill-formed record pattern.
At this point, if the field pattern is complete, one of the following
is expected:
  * another field pattern;
  * a closing bracket ']' if the record is complete.

contract: Const Record LBRACKET With
##
## Ends in an error in state: 131.
##
## compound(Record,field_pattern) -> Record LBRACKET . RBRACKET [ SHARP SEMI RPAR RBRACKET LT EQ COMMA COLON ASS ARROW ]
## compound(Record,field_pattern) -> Record LBRACKET . sep_or_term_list(field_pattern,SEMI) RBRACKET [ SHARP SEMI RPAR RBRACKET LT EQ COMMA COLON ASS ARROW ]
##
## The known suffix of the stack is as follows:
## Record LBRACKET
##

Ill-formed record pattern.
At this point, one of the following is expected:
  * field patterns separated by semicolons ';';
  * a closing bracket ']' if the record is empty.

contract: Const Record With
##
## Ends in an error in state: 130.
##
## compound(Record,field_pattern) -> Record . LBRACKET RBRACKET [ SHARP SEMI RPAR RBRACKET LT EQ COMMA COLON ASS ARROW ]
## compound(Record,field_pattern) -> Record . LBRACKET sep_or_term_list(field_pattern,SEMI) RBRACKET [ SHARP SEMI RPAR RBRACKET LT EQ COMMA COLON ASS ARROW ]
##
## The known suffix of the stack is as follows:
## Record
##

Ill-formed record pattern.
At this point, an opening bracket '[' is expected.

interactive_expr: MINUS With
##
## Ends in an error in state: 244.
##
## unary_op(MINUS,update_expr_level) -> MINUS . update_expr_level [ VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Const COMMA COLON CARET Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## MINUS
##

Ill-formed unary expression.
At this point, an arithmetic expression is expected.
Hint: You may want to check the priority and associativity of
operators, or use parentheses.

interactive_expr: Map LBRACKET With
##
## Ends in an error in state: 242.
##
## compound(Map,binding) -> Map LBRACKET . RBRACKET [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
## compound(Map,binding) -> Map LBRACKET . sep_or_term_list(binding,SEMI) RBRACKET [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## Map LBRACKET
##

Ill-formed map expression.
At this point, one of the following is expected:
  * key-value bindings separated by semicolons ';';
  * a closing bracket ']' if the map is empty.
Note: A binding is made of two expressions (a key and a value)
separated by an arrow '->'.

interactive_expr: Begin Patch UIdent With Map With
##
## Ends in an error in state: 438.
##
## compound(Map,binding) -> Map . LBRACKET RBRACKET [ VBAR SEMI RBRACKET RBRACE End Else ]
## compound(Map,binding) -> Map . LBRACKET sep_or_term_list(binding,SEMI) RBRACKET [ VBAR SEMI RBRACKET RBRACE End Else ]
## patch_expr -> Map . call_expr [ VBAR SEMI RBRACKET RBRACE End Else ]
## patch_expr -> Map . par(expr) [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## Map
##
interactive_expr: Map With
##
## Ends in an error in state: 241.
##
## compound(Map,binding) -> Map . LBRACKET RBRACKET [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
## compound(Map,binding) -> Map . LBRACKET sep_or_term_list(binding,SEMI) RBRACKET [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## Map
##

Ill-formed map expression.
At this point, an opening bracket '[' is expected.

interactive_expr: Not With
##
## Ends in an error in state: 237.
##
## unary_op(Not,update_expr_level) -> Not . update_expr_level [ VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Const COMMA COLON CARET Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## Not
##

Ill-formed unary expression.
At this point, a Boolean expression is expected.
Hint: You may want to check the priority and associativity of
operators, or use parentheses.

interactive_expr: Record LBRACKET With
##
## Ends in an error in state: 233.
##
## compound(Record,field_path_assignment) -> Record LBRACKET . RBRACKET [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
## compound(Record,field_path_assignment) -> Record LBRACKET . sep_or_term_list(field_path_assignment,SEMI) RBRACKET [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## Record LBRACKET
##

Ill-formed record expression or patch.
At this point, one of the following is expected:
  * a field name, if defining a record;
  * a selection of a record field in a module, like 'A.B.x';
  * a selection from modules, records or/and tuples, like 'x.y.1.0',
    if defining a patch;
  * a closing bracket ']' if defining an empty record.

interactive_expr: Attr Set LBRACKET With
##
## Ends in an error in state: 231.
##
## compound(Set,set_element) -> Set LBRACKET . RBRACKET [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
## compound(Set,set_element) -> Set LBRACKET . sep_or_term_list(set_element,SEMI) RBRACKET [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## Set LBRACKET
##

Ill-formed set expression.
At this point, one of the following is expected:
  * elements as expressions separated by semicolons ';';
  * a closing bracket ']' if the set is empty.

interactive_expr: Verbatim CARET With
##
## Ends in an error in state: 323.
##
## bin_op(cons_expr_level,CARET,cat_expr_level) -> cons_expr_level CARET . cat_expr_level [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Or Of NE Module LT LE LBRACE GT GE Function From End Else EQ EOF Directive Const COMMA COLON Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## cons_expr_level CARET
##

Ill-formed string expression.
At this point, a string expression is expected.
Hint: You may want to check the priority and associativity of
operators, or use parentheses.

interactive_expr: Verbatim SHARP With
##
## Ends in an error in state: 333.
##
## bin_op(add_expr_level,SHARP,cons_expr_level) -> add_expr_level SHARP . cons_expr_level [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Or Of NE Module LT LE LBRACE GT GE Function From End Else EQ EOF Directive Const COMMA COLON CARET Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## add_expr_level SHARP
##

Ill-formed list expression.
At this point, a list is expected as an expression.
Hint: You may want to check the priority and associativity of
operators, or use parentheses.

interactive_expr: Verbatim Contains With
##
## Ends in an error in state: 281.
##
## set_mem_level -> update_expr_level Contains . set_mem_level [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Or Of Module LBRACE Function From End Else EOF Directive Const COMMA COLON Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## update_expr_level Contains
##

Ill-formed membership test in a set.
At this point, a potential set element is expected as an expression.
Hint: You may want to check the priority and associativity of
operators, or use parentheses.

interactive_expr: Verbatim And With
##
## Ends in an error in state: 382.
##
## bin_op(conj_expr_level,And,set_mem_level) -> conj_expr_level And . set_mem_level [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Or Of Module LBRACE Function From End Else EOF Directive Const COMMA COLON Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## conj_expr_level And
##
interactive_expr: Verbatim Or With
##
## Ends in an error in state: 380.
##
## bin_op(disj_expr_level,Or,conj_expr_level) -> disj_expr_level Or . conj_expr_level [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Or Of Module LBRACE Function From End Else EOF Directive Const COMMA COLON Block Begin Attr ARROW ]
##
## The known suffix of the stack is as follows:
## disj_expr_level Or
##

Ill-formed Boolean expression.
At this point, a Boolean expression is expected.
Hint: You may want to check the priority and associativity of
operators, or use parentheses.

interactive_expr: Verbatim EQ With
##
## Ends in an error in state: 350.
##
## bin_op(comp_expr_level,EQ,cat_expr_level) -> comp_expr_level EQ . cat_expr_level [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Or Of NE Module LT LE LBRACE GT GE Function From End Else EQ EOF Directive Const COMMA COLON Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## comp_expr_level EQ
##
interactive_expr: Verbatim NE With
##
## Ends in an error in state: 340.
##
## bin_op(comp_expr_level,NE,cat_expr_level) -> comp_expr_level NE . cat_expr_level [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Or Of NE Module LT LE LBRACE GT GE Function From End Else EQ EOF Directive Const COMMA COLON Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## comp_expr_level NE
##
interactive_expr: Verbatim GE With
##
## Ends in an error in state: 348.
##
## bin_op(comp_expr_level,GE,cat_expr_level) -> comp_expr_level GE . cat_expr_level [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Or Of NE Module LT LE LBRACE GT GE Function From End Else EQ EOF Directive Const COMMA COLON Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## comp_expr_level GE
##
interactive_expr: Verbatim GT With
##
## Ends in an error in state: 346.
##
## bin_op(comp_expr_level,GT,cat_expr_level) -> comp_expr_level GT . cat_expr_level [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Or Of NE Module LT LE LBRACE GT GE Function From End Else EQ EOF Directive Const COMMA COLON Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## comp_expr_level GT
##
interactive_expr: Verbatim LE With
##
## Ends in an error in state: 344.
##
## bin_op(comp_expr_level,LE,cat_expr_level) -> comp_expr_level LE . cat_expr_level [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Or Of NE Module LT LE LBRACE GT GE Function From End Else EQ EOF Directive Const COMMA COLON Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## comp_expr_level LE
##
interactive_expr: Verbatim LT With
##
## Ends in an error in state: 342.
##
## bin_op(comp_expr_level,LT,cat_expr_level) -> comp_expr_level LT . cat_expr_level [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Or Of NE Module LT LE LBRACE GT GE Function From End Else EQ EOF Directive Const COMMA COLON Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## comp_expr_level LT
##

Ill-formed comparison expression.
At this point, a comparable expression is expected.
Hint: You may want to check the priority and associativity of
operators, or use parentheses.

interactive_expr: Verbatim MINUS With
##
## Ends in an error in state: 337.
##
## bin_op(add_expr_level,MINUS,mult_expr_level) -> add_expr_level MINUS . mult_expr_level [ VBAR Type To Then Step SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Const COMMA COLON CARET Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## add_expr_level MINUS
##
interactive_expr: Verbatim Mod With
##
## Ends in an error in state: 320.
##
## bin_op(mult_expr_level,Mod,unary_expr_level) -> mult_expr_level Mod . unary_expr_level [ VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Const COMMA COLON CARET Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## mult_expr_level Mod
##
interactive_expr: Verbatim PLUS With
##
## Ends in an error in state: 335.
##
## bin_op(add_expr_level,PLUS,mult_expr_level) -> add_expr_level PLUS . mult_expr_level [ VBAR Type To Then Step SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Const COMMA COLON CARET Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## add_expr_level PLUS
##
interactive_expr: Verbatim SLASH With
##
## Ends in an error in state: 318.
##
## bin_op(mult_expr_level,SLASH,unary_expr_level) -> mult_expr_level SLASH . unary_expr_level [ VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Const COMMA COLON CARET Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## mult_expr_level SLASH
##
interactive_expr: Verbatim TIMES With
##
## Ends in an error in state: 312.
##
## bin_op(mult_expr_level,TIMES,unary_expr_level) -> mult_expr_level TIMES . unary_expr_level [ VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Const COMMA COLON CARET Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## mult_expr_level TIMES
##

Ill-formed arithmetic expression.
At this point, an expression is expected.
Hint: You may want to check the priority and associativity of
operators, or use parentheses.

interactive_expr: With
##
## Ends in an error in state: 808.
##
## interactive_expr' -> . interactive_expr [ # ]
##
## The known suffix of the stack is as follows:
##
##

Ill-formed expression.
At this point, an expression is expected.

contract: Const UIdent LT Ident GT With
##
## Ends in an error in state: 480.
##
## unqualified_decl(EQ) -> core_pattern type_params . EQ expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
## unqualified_decl(EQ) -> core_pattern type_params . COLON type_expr EQ expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## core_pattern type_params
##

Ill-formed constant declaration.
At this point, one of the following is expected:
  * the assignment symbol '=';
  * a type annotation starting with a colon ':'.

contract: Const UIdent LT Ident GT COLON With
##
## Ends in an error in state: 483.
##
## unqualified_decl(EQ) -> core_pattern type_params COLON . type_expr EQ expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## core_pattern type_params COLON
##

Ill-formed constant declaration.
At this point, the type of the constant is expected.

contract: Const UIdent LT Ident GT COLON Ident With
##
## Ends in an error in state: 484.
##
## unqualified_decl(EQ) -> core_pattern type_params COLON type_expr . EQ expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## core_pattern type_params COLON type_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 34, spurious reduction of production core_type -> Ident
## In state 69, spurious reduction of production cartesian_level -> core_type
## In state 76, spurious reduction of production fun_type_level -> cartesian_level
## In state 68, spurious reduction of production type_expr -> fun_type_level
##
contract: Const Ident COLON UIdent With
##
## Ends in an error in state: 477.
##
## unqualified_decl(EQ) -> core_pattern COLON type_expr . EQ expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## core_pattern COLON type_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 19, spurious reduction of production short_variant -> UIdent
## In state 59, spurious reduction of production sum_type -> short_variant
## In state 58, spurious reduction of production type_expr -> sum_type
##

Ill-formed constant declaration.
At this point, if the type is complete, the assignment symbol '=' is
expected, followed by an expression whose value is that of the
constant.

contract: Const UIdent LT Ident GT EQ With
##
## Ends in an error in state: 481.
##
## unqualified_decl(EQ) -> core_pattern type_params EQ . expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## core_pattern type_params EQ
##
contract: Const UIdent LT Ident GT COLON Ident EQ With
##
## Ends in an error in state: 485.
##
## unqualified_decl(EQ) -> core_pattern type_params COLON type_expr EQ . expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## core_pattern type_params COLON type_expr EQ
##
contract: Const UIdent EQ With
##
## Ends in an error in state: 474.
##
## unqualified_decl(EQ) -> core_pattern EQ . expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## core_pattern EQ
##
contract: Const Ident COLON UIdent EQ With
##
## Ends in an error in state: 478.
##
## unqualified_decl(EQ) -> core_pattern COLON type_expr EQ . expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## core_pattern COLON type_expr EQ
##

Ill-formed constant declaration.
At this point, an expression is expected, whose value is that of the
constant.

contract: Const Ident With
##
## Ends in an error in state: 473.
##
## unqualified_decl(EQ) -> core_pattern . EQ expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
## unqualified_decl(EQ) -> core_pattern . COLON type_expr EQ expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
## unqualified_decl(EQ) -> core_pattern . type_params EQ expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
## unqualified_decl(EQ) -> core_pattern . type_params COLON type_expr EQ expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## core_pattern
##

Ill-formed constant declaration.
At this point, one of the following is expected:
  * a colon ':' followed by the type of the constant;
  * the assignment symbol '=', followed by an expression
    whose value is that of the constant.

contract: Const With
##
## Ends in an error in state: 471.
##
## const_decl -> Const . unqualified_decl(EQ) [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## Const
##

Ill-formed constant declaration.
At this point, a pattern is expected, e.g. a variable.

contract: Function Ident LT Ident GT LPAR Const UIdent RPAR Is With
##
## Ends in an error in state: 457.
##
## fun_decl -> Function Ident type_params parameters Is . expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## Function Ident type_params parameters Is
##
contract: Function Ident LT Ident GT LPAR Const UIdent RPAR COLON Ident Is With
##
## Ends in an error in state: 461.
##
## fun_decl -> Function Ident type_params parameters COLON type_expr Is . expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## Function Ident type_params parameters COLON type_expr Is
##
contract: Function Ident LPAR Const Ident RPAR COLON UIdent Is With
##
## Ends in an error in state: 469.
##
## fun_decl -> Function Ident parameters COLON type_expr Is . expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## Function Ident parameters COLON type_expr Is
##
contract: Function Ident LPAR Const Ident RPAR Is With
##
## Ends in an error in state: 465.
##
## fun_decl -> Function Ident parameters Is . expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## Function Ident parameters Is
##
contract: Recursive Function Ident LPAR Const Ident RPAR Is With
##
## Ends in an error in state: 794.
##
## fun_decl -> Recursive Function Ident parameters Is . expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## Recursive Function Ident parameters Is
##
contract: Recursive Function Ident LPAR Const Ident RPAR COLON WILD Is With
##
## Ends in an error in state: 798.
##
## fun_decl -> Recursive Function Ident parameters COLON type_expr Is . expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## Recursive Function Ident parameters COLON type_expr Is
##
contract: Recursive Function Ident LT Ident GT LPAR Const UIdent RPAR Is With
##
## Ends in an error in state: 225.
##
## fun_decl -> Recursive Function Ident type_params parameters Is . expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## Recursive Function Ident type_params parameters Is
##
contract: Recursive Function Ident LT Ident GT LPAR Const UIdent RPAR COLON Ident Is With
##
## Ends in an error in state: 791.
##
## fun_decl -> Recursive Function Ident type_params parameters COLON type_expr Is . expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## Recursive Function Ident type_params parameters COLON type_expr Is
##

Ill-formed function declaration.
At this point, the function body is expected as an expression.

contract: Function Ident LT Ident GT LPAR Const UIdent RPAR COLON Ident With
##
## Ends in an error in state: 460.
##
## fun_decl -> Function Ident type_params parameters COLON type_expr . Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## Function Ident type_params parameters COLON type_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 34, spurious reduction of production core_type -> Ident
## In state 69, spurious reduction of production cartesian_level -> core_type
## In state 76, spurious reduction of production fun_type_level -> cartesian_level
## In state 68, spurious reduction of production type_expr -> fun_type_level
##
contract: Recursive Function Ident LT Ident GT LPAR Const UIdent RPAR COLON Ident With
##
## Ends in an error in state: 790.
##
## fun_decl -> Recursive Function Ident type_params parameters COLON type_expr . Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## Recursive Function Ident type_params parameters COLON type_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 34, spurious reduction of production core_type -> Ident
## In state 69, spurious reduction of production cartesian_level -> core_type
## In state 76, spurious reduction of production fun_type_level -> cartesian_level
## In state 68, spurious reduction of production type_expr -> fun_type_level
##
contract: Recursive Function Ident LPAR Const Ident RPAR COLON String With
##
## Ends in an error in state: 797.
##
## fun_decl -> Recursive Function Ident parameters COLON type_expr . Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## Recursive Function Ident parameters COLON type_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 69, spurious reduction of production cartesian_level -> core_type
## In state 76, spurious reduction of production fun_type_level -> cartesian_level
## In state 68, spurious reduction of production type_expr -> fun_type_level
##
contract: Attr Function Ident LPAR Const Ident RPAR COLON UIdent With
##
## Ends in an error in state: 468.
##
## fun_decl -> Function Ident parameters COLON type_expr . Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## Function Ident parameters COLON type_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 19, spurious reduction of production short_variant -> UIdent
## In state 59, spurious reduction of production sum_type -> short_variant
## In state 58, spurious reduction of production type_expr -> sum_type
##

Ill-formed function declaration.
At this point, if the return type is complete, the keyword 'is' is
expected, followed by the function body as an expression.

contract: Function Ident With
##
## Ends in an error in state: 454.
##
## fun_decl -> Function Ident . parameters Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
## fun_decl -> Function Ident . parameters COLON type_expr Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
## fun_decl -> Function Ident . type_params parameters Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
## fun_decl -> Function Ident . type_params parameters COLON type_expr Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## Function Ident
##
contract: Recursive Function Ident With
##
## Ends in an error in state: 113.
##
## fun_decl -> Recursive Function Ident . parameters Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
## fun_decl -> Recursive Function Ident . parameters COLON type_expr Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
## fun_decl -> Recursive Function Ident . type_params parameters Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
## fun_decl -> Recursive Function Ident . type_params parameters COLON type_expr Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## Recursive Function Ident
##

Ill-formed function declaration.
At this point, one of the following is expected:
  * type parameters between chevrons ('<' and '>').
  * value parameters between parentheses.

contract: Recursive Function Ident LT Ident GT With
##
## Ends in an error in state: 223.
##
## fun_decl -> Recursive Function Ident type_params . parameters Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
## fun_decl -> Recursive Function Ident type_params . parameters COLON type_expr Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## Recursive Function Ident type_params
##
contract: Function Ident LT Ident GT With
##
## Ends in an error in state: 455.
##
## fun_decl -> Function Ident type_params . parameters Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
## fun_decl -> Function Ident type_params . parameters COLON type_expr Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## Function Ident type_params
##

Ill-formed function declaration.
At this point, one of the following is expected:
  * value parameters are expected between parentheses;
  * a pair of opening and closing parentheses ('(' and ')') if there
    are no parameters.

contract: Recursive With
##
## Ends in an error in state: 111.
##
## fun_decl -> Recursive . Function Ident parameters Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
## fun_decl -> Recursive . Function Ident parameters COLON type_expr Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
## fun_decl -> Recursive . Function Ident type_params parameters Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
## fun_decl -> Recursive . Function Ident type_params parameters COLON type_expr Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## Recursive
##

Ill-formed recursive function declaration.
At this point, the keyword 'function' is expected, followed by the name
of the function.

contract: Type Ident Is BigMap With
##
## Ends in an error in state: 37.
##
## type_ctor_app -> BigMap . type_tuple [ VBAR Type TIMES SEMI Recursive RPAR RBRACKET RBRACE Module Is Function End EQ EOF Directive Const COMMA Attr ASS ARROW ]
##
## The known suffix of the stack is as follows:
## BigMap
##

Ill-formed big map type.
At this point, a pair of types is expected: the type of the keys and
the type of the values, respectively.

contract: Type Ident Is UIdent DOT With
##
## Ends in an error in state: 17.
##
## module_path(__anonymous_2) -> UIdent DOT . module_path(__anonymous_2) [ VBAR Type TIMES SEMI Recursive RPAR RBRACKET RBRACE Module Is Function End EQ EOF Directive Const COMMA Attr ASS ARROW ]
## module_path(__anonymous_2) -> UIdent DOT . Ident [ VBAR Type TIMES SEMI Recursive RPAR RBRACKET RBRACE Module Is Function End EQ EOF Directive Const COMMA Attr ASS ARROW ]
## module_path(__anonymous_3) -> UIdent DOT . module_path(__anonymous_3) [ VBAR Type TIMES SEMI Recursive RPAR RBRACKET RBRACE Module Is Function End EQ EOF Directive Const COMMA Attr ASS ARROW ]
## module_path(__anonymous_3) -> UIdent DOT . par(type_expr) [ VBAR Type TIMES SEMI Recursive RPAR RBRACKET RBRACE Module Is Function End EQ EOF Directive Const COMMA Attr ASS ARROW ]
## module_path(type_ctor) -> UIdent DOT . module_path(type_ctor) [ LPAR ]
## module_path(type_ctor) -> UIdent DOT . Ident [ LPAR ]
##
## The known suffix of the stack is as follows:
## UIdent DOT
##

Ill-formed selection of a type from a module.
At this point, one of the following is expected:
  * a submodule name if the name is not fully qualified;
  * a type name;
  * a parenthesised type expression.

contract: Type Ident Is UIdent Of With
##
## Ends in an error in state: 15.
##
## of_type -> Of . fun_type_level [ VBAR Type SEMI Recursive RPAR RBRACKET RBRACE Module Is Function End EQ EOF Directive Const COMMA Attr ASS ]
##
## The known suffix of the stack is as follows:
## Of
##

Ill-formed variant of a sum type.
At this point, the parameter of the constructor is expected as a type
expression.
Note: If it is a sum type, use parentheses.

contract: Type Ident Is VBAR With
##
## Ends in an error in state: 13.
##
## long_variant -> VBAR . short_variant [ VBAR Type SEMI Recursive RPAR RBRACKET RBRACE Module Is Function End EQ EOF Directive Const COMMA Attr ASS ]
##
## The known suffix of the stack is as follows:
## VBAR
##

Ill-formed sum type.
At this point, one of the following is expected:
  * attributes for a variant;
  * the data constructor of a variant, starting with an uppercase
    letter.

contract: Type Ident Is With
##
## Ends in an error in state: 11.
##
## type_decl -> Type Ident Is . type_expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## Type Ident Is
##
contract: Type Ident LPAR Ident RPAR Is With
##
## Ends in an error in state: 108.
##
## type_decl -> Type Ident type_vars Is . type_expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## Type Ident type_vars Is
##

Ill-formed type declaration.
At this point, a type expression is expected.

contract: Type Ident Is LPAR With
##
## Ends in an error in state: 18.
##
## par(type_expr) -> LPAR . type_expr RPAR [ VBAR Type TIMES SEMI Recursive RPAR RBRACKET RBRACE Module Is Function End EQ EOF Directive Const COMMA Attr ASS ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR
##

Ill-formed parenthesised type expression.
At this point, a type expression is expected.

contract: Type Ident Is LPAR String With
##
## Ends in an error in state: 96.
##
## par(type_expr) -> LPAR type_expr . RPAR [ VBAR Type TIMES SEMI Recursive RPAR RBRACKET RBRACE Module Is Function End EQ EOF Directive Const COMMA Attr ASS ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR type_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 69, spurious reduction of production cartesian_level -> core_type
## In state 76, spurious reduction of production fun_type_level -> cartesian_level
## In state 68, spurious reduction of production type_expr -> fun_type_level
##

Ill-formed parenthesised type expression.
At this point, if the type expression is complete, a closing
parenthesis ')' is expected.

contract: Type Ident Is List With
##
## Ends in an error in state: 31.
##
## type_ctor_app -> List . par(type_expr) [ VBAR Type TIMES SEMI Recursive RPAR RBRACKET RBRACE Module Is Function End EQ EOF Directive Const COMMA Attr ASS ARROW ]
##
## The known suffix of the stack is as follows:
## List
##

Ill-formed list type.
At this point, the type of the elements is expected between
parentheses.

contract: Type Ident Is Map LPAR String With
##
## Ends in an error in state: 56.
##
## nsepseq(type_expr,COMMA) -> type_expr . [ RPAR ]
## nsepseq(type_expr,COMMA) -> type_expr . COMMA nsepseq(type_expr,COMMA) [ RPAR ]
##
## The known suffix of the stack is as follows:
## type_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 69, spurious reduction of production cartesian_level -> core_type
## In state 76, spurious reduction of production fun_type_level -> cartesian_level
## In state 68, spurious reduction of production type_expr -> fun_type_level
##

Ill-formed type tuple.
At this point, if the type expression is complete, one of the
following is expected:
  * a comma ',' followed by another component as a type expression;
  * a closing parenthesis ')' if there are no more components.

contract: Type Ident Is Map LPAR With
##
## Ends in an error in state: 30.
##
## par(nsepseq(type_expr,COMMA)) -> LPAR . nsepseq(type_expr,COMMA) RPAR [ VBAR Type TIMES SEMI Recursive RPAR RBRACKET RBRACE Module Is Function End EQ EOF Directive Const COMMA Attr ASS ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR
##
contract: Type Ident Is Map LPAR WILD COMMA With
##
## Ends in an error in state: 57.
##
## nsepseq(type_expr,COMMA) -> type_expr COMMA . nsepseq(type_expr,COMMA) [ RPAR ]
##
## The known suffix of the stack is as follows:
## type_expr COMMA
##

Ill-formed type tuple.
At this point, a component is expected as a type expression.

contract: Const UIdent COLON Attr Record LBRACKET Ident ARROW
##
## Ends in an error in state: 84.
##
## compound(Record,field_decl) -> Record LBRACKET sep_or_term_list(field_decl,SEMI) . RBRACKET [ VBAR Type TIMES SEMI Recursive RPAR RBRACKET RBRACE Module Is Function End EQ EOF Directive Const COMMA Attr ASS ARROW ]
##
## The known suffix of the stack is as follows:
## Record LBRACKET sep_or_term_list(field_decl,SEMI)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 27, spurious reduction of production field_decl -> Ident
## In state 92, spurious reduction of production nsepseq(field_decl,SEMI) -> field_decl
## In state 91, spurious reduction of production sep_or_term_list(field_decl,SEMI) -> nsepseq(field_decl,SEMI)
##

Ill-formed record type.
At this point, if the field is complete, one of the following is
expected:
  * another field declaration;
  * a closing bracket ']' if the record is complete.

contract: Type Ident Is Set With
##
## Ends in an error in state: 22.
##
## type_ctor_app -> Set . par(type_expr) [ VBAR Type TIMES SEMI Recursive RPAR RBRACKET RBRACE Module Is Function End EQ EOF Directive Const COMMA Attr ASS ARROW ]
##
## The known suffix of the stack is as follows:
## Set
##

Ill-formed set type.
At this point, the type of the elements is expected between
parentheses.

contract: Type Ident Is String ARROW With
##
## Ends in an error in state: 77.
##
## fun_type_level -> cartesian_level ARROW . fun_type_level [ VBAR Type SEMI Recursive RPAR RBRACKET RBRACE Module Is Function End EQ EOF Directive Const COMMA Attr ASS ]
##
## The known suffix of the stack is as follows:
## cartesian_level ARROW
##

Ill-formed function type.
At this point, the return type is expected.

contract: Type Ident Is String TIMES With
##
## Ends in an error in state: 70.
##
## cartesian_level -> core_type TIMES . nsepseq(core_type,TIMES) [ VBAR Type SEMI Recursive RPAR RBRACKET RBRACE Module Is Function End EQ EOF Directive Const COMMA Attr ASS ARROW ]
##
## The known suffix of the stack is as follows:
## core_type TIMES
##
contract: Const UIdent COLON Ident TIMES Ident TIMES With
##
## Ends in an error in state: 74.
##
## nsepseq(core_type,TIMES) -> core_type TIMES . nsepseq(core_type,TIMES) [ VBAR Type SEMI Recursive RPAR RBRACKET RBRACE Module Is Function End EQ EOF Directive Const COMMA Attr ASS ARROW ]
##
## The known suffix of the stack is as follows:
## core_type TIMES
##

Ill-formed product type.
At this point, a type expression is expected.
Hint: You may want to check the priority and associativity of
type operators, or use parentheses.

contract: Type Ident With
##
## Ends in an error in state: 2.
##
## type_decl -> Type Ident . Is type_expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
## type_decl -> Type Ident . type_vars Is type_expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## Type Ident
##

Ill-formed type declaration.
At this point, one of the following is expected:
  * an opening parenthesis '(' followed by a type variable, if the type
    is parametric;
  * the keyword 'is' followed by a type expression.

contract: Type Ident LPAR Ident RPAR With
##
## Ends in an error in state: 107.
##
## type_decl -> Type Ident type_vars . Is type_expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## Type Ident type_vars
##

Ill-formed parametric type declaration.
At this point, the keyword 'is' is expected, followed by a type
expression.

contract: Type With
##
## Ends in an error in state: 1.
##
## type_decl -> Type . Ident Is type_expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
## type_decl -> Type . Ident type_vars Is type_expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## Type
##

Ill-formed type declaration.
At this point, the name of the type is expected.

contract: Type Ident Is VBAR Attr With
##
## Ends in an error in state: 104.
##
## short_variant -> Attr . short_variant [ VBAR Type SEMI Recursive RPAR RBRACKET RBRACE Module Is Function End EQ EOF Directive Const COMMA Attr ASS ]
##
## The known suffix of the stack is as follows:
## Attr
##

Ill-formed sum type.
At this point, if the attribute is complete, one of the following is
expected:
  * another attribute for the variant;
  * the data constructor of the variant, starting with an uppercase
    letter.

contract: With
##
## Ends in an error in state: 0.
##
## contract' -> . contract [ # ]
##
## The known suffix of the stack is as follows:
##
##

Ill-formed contract.
At this point, a top-level declaration is expected, starting with the
keyword 'type', 'const', 'function', 'recursive' or 'module'.
Note: 'var' declarations are valid only in blocks.

contract: Type Ident Is Record With
##
## Ends in an error in state: 24.
##
## compound(Record,field_decl) -> Record . LBRACKET RBRACKET [ VBAR Type TIMES SEMI Recursive RPAR RBRACKET RBRACE Module Is Function End EQ EOF Directive Const COMMA Attr ASS ARROW ]
## compound(Record,field_decl) -> Record . LBRACKET sep_or_term_list(field_decl,SEMI) RBRACKET [ VBAR Type TIMES SEMI Recursive RPAR RBRACKET RBRACE Module Is Function End EQ EOF Directive Const COMMA Attr ASS ARROW ]
##
## The known suffix of the stack is as follows:
## Record
##

Ill-formed record type.
At this point, an opening bracket '[' is expected.

contract: Type Ident Is Attr Recursive
##
## Ends in an error in state: 64.
##
## sum_type -> nseq(Attr) . long_variants [ Type SEMI Recursive RPAR RBRACKET RBRACE Module Is Function End EQ EOF Directive Const COMMA Attr ASS ]
##
## The known suffix of the stack is as follows:
## nseq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 39, spurious reduction of production nseq(Attr) -> Attr
##

Ill-formed sum type.
At this point, if the attribute of the type is complete, one of the
following is expected:
  * another attribute;
  * a vertical bar '|' introducing a variant.

contract: Const UIdent COLON Record LBRACKET With
##
## Ends in an error in state: 25.
##
## compound(Record,field_decl) -> Record LBRACKET . RBRACKET [ VBAR Type TIMES SEMI Recursive RPAR RBRACKET RBRACE Module Is Function End EQ EOF Directive Const COMMA Attr ASS ARROW ]
## compound(Record,field_decl) -> Record LBRACKET . sep_or_term_list(field_decl,SEMI) RBRACKET [ VBAR Type TIMES SEMI Recursive RPAR RBRACKET RBRACE Module Is Function End EQ EOF Directive Const COMMA Attr ASS ARROW ]
##
## The known suffix of the stack is as follows:
## Record LBRACKET
##

Ill-formed record type.
At this point, one of the following is expected:
  * field declarations separated by semicolons ';';
  * a closing bracket ']' if the record is empty.

interactive_expr: Block LBRACE With
##
## Ends in an error in state: 362.
##
## terse_block -> option(Block) LBRACE . sep_or_term_list(statement,SEMI) RBRACE [ With VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## option(Block) LBRACE
##
interactive_expr: Begin With
##
## Ends in an error in state: 270.
##
## verb_block -> Begin . sep_or_term_list(statement,SEMI) End [ With VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## Begin
##

Ill-formed block of statements.
At this point, statements are expected, separated by semicolons ';'.
Note: A statement is either an instruction or a declaration.

contract: Attr VBAR
##
## Ends in an error in state: 487.
##
## attr_decl -> Attr . declaration [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## Attr
##

Ill-formed declaration.
At this point, one of the following is expected:
  * an attribute;
  * the keyword 'type' if defining a type;
  * the keyword 'const' if defining a constant;
  * the keyword 'function' if defining a function;
  * the keywords 'recursive function' if defining a recursive
    function;
  * the keyword 'module' if defining a module.

contract: Type Ident Is UIdent With
##
## Ends in an error in state: 805.
##
## contract -> nseq(top_declaration) . EOF [ # ]
##
## The known suffix of the stack is as follows:
## nseq(top_declaration)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 19, spurious reduction of production short_variant -> UIdent
## In state 59, spurious reduction of production sum_type -> short_variant
## In state 58, spurious reduction of production type_expr -> sum_type
## In state 106, spurious reduction of production type_decl -> Type Ident Is type_expr
## In state 488, spurious reduction of production declaration -> type_decl
## In state 803, spurious reduction of production option(SEMI) ->
## In state 804, spurious reduction of production top_declaration -> declaration option(SEMI)
## In state 801, spurious reduction of production nseq(top_declaration) -> top_declaration
##

Ill-formed contract.
At this point, if the top-level declaration is complete, one of the
following is expected:
  * another declaration starting with the keyword 'type', 'const',
    'function', 'recursive' or 'module';
  * the end of the file.
Note: 'var' declarations are valid only in blocks.

contract: Module UIdent Is Begin Type Ident Is UIdent RBRACE
##
## Ends in an error in state: 495.
##
## verb_module_expr -> Begin declarations . End [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## Begin declarations
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 19, spurious reduction of production short_variant -> UIdent
## In state 59, spurious reduction of production sum_type -> short_variant
## In state 58, spurious reduction of production type_expr -> sum_type
## In state 106, spurious reduction of production type_decl -> Type Ident Is type_expr
## In state 488, spurious reduction of production declaration -> type_decl
## In state 497, spurious reduction of production option(SEMI) ->
## In state 499, spurious reduction of production nseq(__anonymous_4) -> declaration option(SEMI)
## In state 494, spurious reduction of production declarations -> nseq(__anonymous_4)
##

Ill-formed module declaration.
At this point, if the declaration is complete, one of the
following is expected:
  * another declaration;
  * the keyword 'end' if there are no more declarations.
Note: 'var' declarations are valid only in blocks.

contract: Module UIdent Is Begin With
##
## Ends in an error in state: 452.
##
## verb_module_expr -> Begin . declarations End [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## Begin
##
contract: Module UIdent Is LBRACE With
##
## Ends in an error in state: 504.
##
## terse_module_expr -> option(Block) LBRACE . declarations RBRACE [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## option(Block) LBRACE
##

Ill-formed module declaration.
At this point, a declaration is expected.
Note: 'var' declarations are not valid at top-level in modules.

contract: Module UIdent Is LBRACE Type Ident Is UIdent End
##
## Ends in an error in state: 505.
##
## terse_module_expr -> option(Block) LBRACE declarations . RBRACE [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## option(Block) LBRACE declarations
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 19, spurious reduction of production short_variant -> UIdent
## In state 59, spurious reduction of production sum_type -> short_variant
## In state 58, spurious reduction of production type_expr -> sum_type
## In state 106, spurious reduction of production type_decl -> Type Ident Is type_expr
## In state 488, spurious reduction of production declaration -> type_decl
## In state 497, spurious reduction of production option(SEMI) ->
## In state 499, spurious reduction of production nseq(__anonymous_4) -> declaration option(SEMI)
## In state 494, spurious reduction of production declarations -> nseq(__anonymous_4)
##

Ill-formed module declaration.
At this point, if the declaration is complete, one of the
following is expected:
  * another declaration;
  * a closing brace '}' if there are no more declarations.
Note: 'var' declarations are not valid at top-level in modules.

contract: Module UIdent Is With
##
## Ends in an error in state: 447.
##
## module_decl -> Module UIdent Is . module_expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## Module UIdent Is
##

Ill-formed module declaration.
At this point, one of the following is expected:
  * the module name being aliased, e.g., 'A';
  * the qualified name of the module being aliased, e.g. 'A.B.C';
  * a module body starting with an opening brace '{'.

contract: Module UIdent With
##
## Ends in an error in state: 446.
##
## module_decl -> Module UIdent . Is module_expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## Module UIdent
##

Ill-formed module declaration.
At this point, the keyword 'is' is expected.

contract: Module With
##
## Ends in an error in state: 445.
##
## module_decl -> Module . UIdent Is module_expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## Module
##

Ill-formed module declaration.
At this point, the name of the module is expected, starting with an
uppercase letter.

contract: Module UIdent Is UIdent DOT With
##
## Ends in an error in state: 449.
##
## module_path(module_name) -> UIdent DOT . module_path(module_name) [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
## module_path(module_name) -> UIdent DOT . UIdent [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## UIdent DOT
##

Ill-formed module aliasing.
At this point, one of the following is expected:
  * a module name;
  * a qualified module name, e.g. 'A.B.C'.

contract: Type Ident LPAR Ident With
##
## Ends in an error in state: 6.
##
## nsepseq(type_var,COMMA) -> type_var . [ RPAR ]
## nsepseq(type_var,COMMA) -> type_var . COMMA nsepseq(type_var,COMMA) [ RPAR ]
##
## The known suffix of the stack is as follows:
## type_var
##

Ill-formed parametric type declaration.
At this point, one of the following is expected:
  * a comma ',' followed by another type parameter;
  * a closing parenthesis ')' if there are no more parameters.

contract: Type Ident LPAR With
##
## Ends in an error in state: 3.
##
## par(nsepseq(type_var,COMMA)) -> LPAR . nsepseq(type_var,COMMA) RPAR [ Is ]
##
## The known suffix of the stack is as follows:
## LPAR
##
contract: Type Ident LPAR Ident COMMA With
##
## Ends in an error in state: 7.
##
## nsepseq(type_var,COMMA) -> type_var COMMA . nsepseq(type_var,COMMA) [ RPAR ]
##
## The known suffix of the stack is as follows:
## type_var COMMA
##

Ill-formed parametric type declaration.
At this point, a type parameter is expected as a variable.

contract: Const Attr With
##
## Ends in an error in state: 143.
##
## attr_pattern -> Attr . core_pattern [ SHARP SEMI RPAR RBRACKET LT EQ COMMA COLON ASS ARROW ]
##
## The known suffix of the stack is as follows:
## Attr
##

Ill-formed pattern.
At this point, if the attribute is complete, one of the following is
expected:
  * another attribute;
  * a pattern other than a cons pattern.
Note: Use parentheses for a cons pattern, like '(x::y)'.

contract: Const LPAR UIdent COMMA UIdent With
##
## Ends in an error in state: 153.
##
## nsepseq(pattern,COMMA) -> pattern . [ RPAR ]
## nsepseq(pattern,COMMA) -> pattern . COMMA nsepseq(pattern,COMMA) [ RPAR ]
##
## The known suffix of the stack is as follows:
## pattern
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 127, spurious reduction of production ctor_app_pattern -> UIdent
## In state 162, spurious reduction of production core_pattern -> ctor_app_pattern
## In state 163, spurious reduction of production pattern -> core_pattern
##

Ill-formed tuple pattern.
At this point, if the component is complete, one of the following is
expected:
  * a comma ',' followed by another component as a pattern;
  * a closing parenthesis ')' if there are no more components.

contract: Const LPAR UIdent COMMA UIdent COMMA With
##
## Ends in an error in state: 154.
##
## nsepseq(pattern,COMMA) -> pattern COMMA . nsepseq(pattern,COMMA) [ RPAR ]
##
## The known suffix of the stack is as follows:
## pattern COMMA
##

Ill-formed tuple pattern.
At this point, a component is expected as a pattern.

contract: Const UIdent LPAR UIdent With
##
## Ends in an error in state: 201.
##
## nsepseq(ctor_param,COMMA) -> ctor_param . [ RPAR ]
## nsepseq(ctor_param,COMMA) -> ctor_param . COMMA nsepseq(ctor_param,COMMA) [ RPAR ]
##
## The known suffix of the stack is as follows:
## ctor_param
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 127, spurious reduction of production ctor_app_pattern -> UIdent
## In state 162, spurious reduction of production core_pattern -> ctor_app_pattern
## In state 163, spurious reduction of production pattern -> core_pattern
## In state 198, spurious reduction of production ctor_param -> pattern
##

Ill-formed constructor pattern.
At this point, if the parameter is complete, one of the following is
expected:
  * a comma ',' followed by another parameter as a pattern;
  * a closing parenthesis ')' if there are no more parameters.

contract: Const UIdent LPAR UIdent COMMA With
##
## Ends in an error in state: 202.
##
## nsepseq(ctor_param,COMMA) -> ctor_param COMMA . nsepseq(ctor_param,COMMA) [ RPAR ]
##
## The known suffix of the stack is as follows:
## ctor_param COMMA
##

Ill-formed constructor pattern.
At this point, another parameter is expected as a pattern.

interactive_expr: UIdent DOT UIdent DOT With
##
## Ends in an error in state: 402.
##
## module_path(selected) -> UIdent DOT . module_path(selected) [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LPAR LE LBRACKET LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ASS ARROW ]
## module_path(selected) -> UIdent DOT . selected [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LPAR LE LBRACKET LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ASS ARROW ]
##
## The known suffix of the stack is as follows:
## UIdent DOT
##

Ill-formed selection of a value from a module.
At this point, one of the following is expected:
  * a submodule if the value is not fully qualified;
  * a value or function name;
  * a parenthesised expression.

contract: Module UIdent Is Block With
##
## Ends in an error in state: 503.
##
## terse_module_expr -> option(Block) . LBRACE declarations RBRACE [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## option(Block)
##

Ill-formed module declaration.
At this point, an opening brace '{' is expected, followed by
declarations.

interactive_expr: Begin LPAR With
##
## Ends in an error in state: 236.
##
## par(expr) -> LPAR . expr RPAR [ With VBAR_EQ VBAR Type To Then TIMES_EQ TIMES Step SLASH_EQ SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS_EQ PLUS Or Of NE Module Mod MINUS_EQ MINUS LT LPAR LE LBRACKET LBRACE GT GE Function From End Else EQ EOF Directive DOT Contains Const COMMA COLON CARET Block Begin Attr And ASS ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR
##

Ill-formed parenthesised expression.
At this point, an expression is expected, followed by a closing
parenthesis ')'.

interactive_expr: Begin LPAR UIdent While
##
## Ends in an error in state: 738.
##
## par(expr) -> LPAR expr . RPAR [ With VBAR_EQ VBAR Type To Then TIMES_EQ TIMES Step SLASH_EQ SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS_EQ PLUS Or Of NE Module Mod MINUS_EQ MINUS LT LPAR LE LBRACKET LBRACE GT GE Function From End Else EQ EOF Directive DOT Contains Const COMMA COLON CARET Block Begin Attr And ASS ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 227, spurious reduction of production ctor_app_expr -> UIdent
## In state 295, spurious reduction of production core_expr -> ctor_app_expr
## In state 315, spurious reduction of production update_expr_level -> core_expr
## In state 280, spurious reduction of production unary_expr_level -> update_expr_level
## In state 309, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 311, spurious reduction of production add_expr_level -> mult_expr_level
## In state 332, spurious reduction of production cons_expr_level -> add_expr_level
## In state 322, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 352, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 339, spurious reduction of production set_mem_level -> comp_expr_level
## In state 360, spurious reduction of production conj_expr_level -> set_mem_level
## In state 385, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 379, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 387, spurious reduction of production expr -> base_expr(expr)
##

Ill-formed parenthesised expression.
At this point, if the expression is complete, a closing parenthesis
')' is expected.

interactive_expr: Begin If UIdent While
##
## Ends in an error in state: 510.
##
## if_then_else_instr(instruction) -> If expr . Then test_clause(closed_instr) Else test_clause(instruction) [ VBAR SEMI RBRACKET RBRACE End ]
## if_then_instr -> If expr . Then test_clause(instruction) [ VBAR SEMI RBRACKET RBRACE End ]
##
## The known suffix of the stack is as follows:
## If expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 227, spurious reduction of production ctor_app_expr -> UIdent
## In state 295, spurious reduction of production core_expr -> ctor_app_expr
## In state 315, spurious reduction of production update_expr_level -> core_expr
## In state 280, spurious reduction of production unary_expr_level -> update_expr_level
## In state 309, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 311, spurious reduction of production add_expr_level -> mult_expr_level
## In state 332, spurious reduction of production cons_expr_level -> add_expr_level
## In state 322, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 352, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 339, spurious reduction of production set_mem_level -> comp_expr_level
## In state 360, spurious reduction of production conj_expr_level -> set_mem_level
## In state 385, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 379, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 387, spurious reduction of production expr -> base_expr(expr)
##
interactive_expr: Begin If UIdent Then If UIdent While
##
## Ends in an error in state: 525.
##
## if_then_else_instr(closed_instr) -> If expr . Then test_clause(closed_instr) Else test_clause(closed_instr) [ Else ]
## if_then_else_instr(instruction) -> If expr . Then test_clause(closed_instr) Else test_clause(instruction) [ VBAR SEMI RBRACKET RBRACE End ]
## if_then_instr -> If expr . Then test_clause(instruction) [ VBAR SEMI RBRACKET RBRACE End ]
##
## The known suffix of the stack is as follows:
## If expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 227, spurious reduction of production ctor_app_expr -> UIdent
## In state 295, spurious reduction of production core_expr -> ctor_app_expr
## In state 315, spurious reduction of production update_expr_level -> core_expr
## In state 280, spurious reduction of production unary_expr_level -> update_expr_level
## In state 309, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 311, spurious reduction of production add_expr_level -> mult_expr_level
## In state 332, spurious reduction of production cons_expr_level -> add_expr_level
## In state 322, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 352, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 339, spurious reduction of production set_mem_level -> comp_expr_level
## In state 360, spurious reduction of production conj_expr_level -> set_mem_level
## In state 385, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 379, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 387, spurious reduction of production expr -> base_expr(expr)
##

Ill-formed conditional instruction.
At this point, if the condition is complete, the keyword 'then' is
expected, followed by an instruction or a block of statements
(instructions and declarations).

interactive_expr: If UIdent Then If UIdent While
##
## Ends in an error in state: 596.
##
## if_then_else_expr(closed_expr) -> If expr . Then closed_expr Else closed_expr [ Else ]
## if_then_else_expr(expr) -> If expr . Then closed_expr Else expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
## if_then_expr -> If expr . Then expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
##
## The known suffix of the stack is as follows:
## If expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 227, spurious reduction of production ctor_app_expr -> UIdent
## In state 295, spurious reduction of production core_expr -> ctor_app_expr
## In state 315, spurious reduction of production update_expr_level -> core_expr
## In state 280, spurious reduction of production unary_expr_level -> update_expr_level
## In state 309, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 311, spurious reduction of production add_expr_level -> mult_expr_level
## In state 332, spurious reduction of production cons_expr_level -> add_expr_level
## In state 322, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 352, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 339, spurious reduction of production set_mem_level -> comp_expr_level
## In state 360, spurious reduction of production conj_expr_level -> set_mem_level
## In state 385, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 379, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 387, spurious reduction of production expr -> base_expr(expr)
##
interactive_expr: If UIdent While
##
## Ends in an error in state: 706.
##
## if_then_else_expr(expr) -> If expr . Then closed_expr Else expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
## if_then_expr -> If expr . Then expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
##
## The known suffix of the stack is as follows:
## If expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 227, spurious reduction of production ctor_app_expr -> UIdent
## In state 295, spurious reduction of production core_expr -> ctor_app_expr
## In state 315, spurious reduction of production update_expr_level -> core_expr
## In state 280, spurious reduction of production unary_expr_level -> update_expr_level
## In state 309, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 311, spurious reduction of production add_expr_level -> mult_expr_level
## In state 332, spurious reduction of production cons_expr_level -> add_expr_level
## In state 322, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 352, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 339, spurious reduction of production set_mem_level -> comp_expr_level
## In state 360, spurious reduction of production conj_expr_level -> set_mem_level
## In state 385, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 379, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 387, spurious reduction of production expr -> base_expr(expr)
##

Ill-formed conditional expression.
At this point, if the condition is complete, the keyword 'then' is
expected, followed by an expression.

interactive_expr: If UIdent Then Function LT Ident GT With
##
## Ends in an error in state: 599.
##
## fun_expr(closed_expr) -> Function type_params . parameters Is closed_expr [ Else ]
## fun_expr(closed_expr) -> Function type_params . parameters COLON type_expr Is closed_expr [ Else ]
## fun_expr(expr) -> Function type_params . parameters Is expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
## fun_expr(expr) -> Function type_params . parameters COLON type_expr Is expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
##
## The known suffix of the stack is as follows:
## Function type_params
##
interactive_expr: Function LT Ident GT With
##
## Ends in an error in state: 261.
##
## fun_expr(expr) -> Function type_params . parameters Is expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
## fun_expr(expr) -> Function type_params . parameters COLON type_expr Is expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
##
## The known suffix of the stack is as follows:
## Function type_params
##

Ill-formed function expression.
At this point, one of the following is expected:
  * parameter declarations between parentheses;
  * an opening and closing parentheses ('(' and ')') if there are no
    parameters.

interactive_expr: If UIdent Then Function With
##
## Ends in an error in state: 598.
##
## fun_expr(closed_expr) -> Function . parameters Is closed_expr [ Else ]
## fun_expr(closed_expr) -> Function . parameters COLON type_expr Is closed_expr [ Else ]
## fun_expr(closed_expr) -> Function . type_params parameters Is closed_expr [ Else ]
## fun_expr(closed_expr) -> Function . type_params parameters COLON type_expr Is closed_expr [ Else ]
## fun_expr(expr) -> Function . parameters Is expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
## fun_expr(expr) -> Function . parameters COLON type_expr Is expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
## fun_expr(expr) -> Function . type_params parameters Is expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
## fun_expr(expr) -> Function . type_params parameters COLON type_expr Is expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
##
## The known suffix of the stack is as follows:
## Function
##
interactive_expr: Function With
##
## Ends in an error in state: 260.
##
## fun_expr(expr) -> Function . parameters Is expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
## fun_expr(expr) -> Function . parameters COLON type_expr Is expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
## fun_expr(expr) -> Function . type_params parameters Is expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
## fun_expr(expr) -> Function . type_params parameters COLON type_expr Is expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
##
## The known suffix of the stack is as follows:
## Function
##

Ill-formed function expression.
At this point, one of the following is expected:
  * type parameters between chevrons ('<' and '>');
  * value parameters between parentheses;
  * a opening and closing parentheses ('(' and ')') if there are no
    value parameters.

interactive_expr: If UIdent Then LBRACE Skip RBRACE While
##
## Ends in an error in state: 607.
##
## block_with(closed_expr) -> block . With closed_expr [ Else ]
## block_with(expr) -> block . With expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
##
## The known suffix of the stack is as follows:
## block
##

Ill-formed block expression.
At this point, the keyword 'with' is expected, followed by an
expression whose value is that of the block.

interactive_expr: Begin For Ident ASS UIdent While
##
## Ends in an error in state: 537.
##
## for_int -> For Ident ASS expr . To expr block [ VBAR SEMI RBRACKET RBRACE End Else ]
## for_int -> For Ident ASS expr . To expr step_clause block [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## For Ident ASS expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 227, spurious reduction of production ctor_app_expr -> UIdent
## In state 295, spurious reduction of production core_expr -> ctor_app_expr
## In state 315, spurious reduction of production update_expr_level -> core_expr
## In state 280, spurious reduction of production unary_expr_level -> update_expr_level
## In state 309, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 311, spurious reduction of production add_expr_level -> mult_expr_level
## In state 332, spurious reduction of production cons_expr_level -> add_expr_level
## In state 322, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 352, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 339, spurious reduction of production set_mem_level -> comp_expr_level
## In state 360, spurious reduction of production conj_expr_level -> set_mem_level
## In state 385, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 379, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 387, spurious reduction of production expr -> base_expr(expr)
##

Ill-formed iteration over a numerical interval.
At this point, if the initial value of the index is complete, the
keyword 'to' is expected.

interactive_expr: Begin For Ident ASS UIdent To UIdent While
##
## Ends in an error in state: 539.
##
## for_int -> For Ident ASS expr To expr . block [ VBAR SEMI RBRACKET RBRACE End Else ]
## for_int -> For Ident ASS expr To expr . step_clause block [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## For Ident ASS expr To expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 227, spurious reduction of production ctor_app_expr -> UIdent
## In state 295, spurious reduction of production core_expr -> ctor_app_expr
## In state 315, spurious reduction of production update_expr_level -> core_expr
## In state 280, spurious reduction of production unary_expr_level -> update_expr_level
## In state 309, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 311, spurious reduction of production add_expr_level -> mult_expr_level
## In state 332, spurious reduction of production cons_expr_level -> add_expr_level
## In state 322, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 352, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 339, spurious reduction of production set_mem_level -> comp_expr_level
## In state 360, spurious reduction of production conj_expr_level -> set_mem_level
## In state 385, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 379, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 387, spurious reduction of production expr -> base_expr(expr)
##

Ill-formed iteration over a numerical interval.
At this point, if the final value of the index is complete, one of the
following is expected:
  * a step clause introduced by the keyword 'step', followed by
    the index increment as an expression;
  * a loop body as a block of statements (instructions and
    declarations).

interactive_expr: Begin Case UIdent While
##
## Ends in an error in state: 552.
##
## case(test_clause(instruction)) -> Case expr . Of LBRACKET cases(test_clause(instruction)) RBRACKET [ VBAR SEMI RBRACKET RBRACE End Else ]
## case(test_clause(instruction)) -> Case expr . Of LBRACKET VBAR cases(test_clause(instruction)) RBRACKET [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## Case expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 227, spurious reduction of production ctor_app_expr -> UIdent
## In state 295, spurious reduction of production core_expr -> ctor_app_expr
## In state 315, spurious reduction of production update_expr_level -> core_expr
## In state 280, spurious reduction of production unary_expr_level -> update_expr_level
## In state 309, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 311, spurious reduction of production add_expr_level -> mult_expr_level
## In state 332, spurious reduction of production cons_expr_level -> add_expr_level
## In state 322, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 352, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 339, spurious reduction of production set_mem_level -> comp_expr_level
## In state 360, spurious reduction of production conj_expr_level -> set_mem_level
## In state 385, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 379, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 387, spurious reduction of production expr -> base_expr(expr)
##

Ill-formed case instruction.
At this point, if the analysed expression is complete, the keyword
'of' is expected, followed by an opening bracket '['.

interactive_expr: Ident LBRACKET UIdent While
##
## Ends in an error in state: 419.
##
## brackets(expr) -> LBRACKET expr . RBRACKET [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACKET LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ASS ARROW ]
##
## The known suffix of the stack is as follows:
## LBRACKET expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 227, spurious reduction of production ctor_app_expr -> UIdent
## In state 295, spurious reduction of production core_expr -> ctor_app_expr
## In state 315, spurious reduction of production update_expr_level -> core_expr
## In state 280, spurious reduction of production unary_expr_level -> update_expr_level
## In state 309, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 311, spurious reduction of production add_expr_level -> mult_expr_level
## In state 332, spurious reduction of production cons_expr_level -> add_expr_level
## In state 322, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 352, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 339, spurious reduction of production set_mem_level -> comp_expr_level
## In state 360, spurious reduction of production conj_expr_level -> set_mem_level
## In state 385, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 379, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 387, spurious reduction of production expr -> base_expr(expr)
##

Ill-formed map lookup.
At this point, if the key is complete, a closing bracket ']' is
expected.

interactive_expr: Begin While UIdent While
##
## Ends in an error in state: 668.
##
## while_loop -> While expr . block [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## While expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 227, spurious reduction of production ctor_app_expr -> UIdent
## In state 295, spurious reduction of production core_expr -> ctor_app_expr
## In state 315, spurious reduction of production update_expr_level -> core_expr
## In state 280, spurious reduction of production unary_expr_level -> update_expr_level
## In state 309, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 311, spurious reduction of production add_expr_level -> mult_expr_level
## In state 332, spurious reduction of production cons_expr_level -> add_expr_level
## In state 322, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 352, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 339, spurious reduction of production set_mem_level -> comp_expr_level
## In state 360, spurious reduction of production conj_expr_level -> set_mem_level
## In state 385, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 379, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 387, spurious reduction of production expr -> base_expr(expr)
##

Ill-formed general loop.
At this point, if the condition is complete, the body of the loop is
expected as a block of statements (instructions and declarations).

interactive_expr: BigMap LBRACKET UIdent ARROW UIdent While
##
## Ends in an error in state: 672.
##
## compound(BigMap,binding) -> BigMap LBRACKET sep_or_term_list(binding,SEMI) . RBRACKET [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## BigMap LBRACKET sep_or_term_list(binding,SEMI)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 227, spurious reduction of production ctor_app_expr -> UIdent
## In state 295, spurious reduction of production core_expr -> ctor_app_expr
## In state 315, spurious reduction of production update_expr_level -> core_expr
## In state 280, spurious reduction of production unary_expr_level -> update_expr_level
## In state 309, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 311, spurious reduction of production add_expr_level -> mult_expr_level
## In state 332, spurious reduction of production cons_expr_level -> add_expr_level
## In state 322, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 352, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 339, spurious reduction of production set_mem_level -> comp_expr_level
## In state 360, spurious reduction of production conj_expr_level -> set_mem_level
## In state 385, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 379, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 387, spurious reduction of production expr -> base_expr(expr)
## In state 678, spurious reduction of production binding -> expr ARROW expr
## In state 679, spurious reduction of production nsepseq(binding,SEMI) -> binding
## In state 675, spurious reduction of production sep_or_term_list(binding,SEMI) -> nsepseq(binding,SEMI)
##

Ill-formed big map expression.
At this point, if the key-value binding is complete, one of the
following is expected:
  * another binding;
  * a closing bracket ']' if the big map is complete.
Note: A binding is made of two expressions (a key and a value)
separated by an arrow '->'.

interactive_expr: Case UIdent While
##
## Ends in an error in state: 683.
##
## case(expr) -> Case expr . Of LBRACKET cases(expr) RBRACKET [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End Else EOF Directive Const COMMA Block Begin Attr ARROW ]
## case(expr) -> Case expr . Of LBRACKET VBAR cases(expr) RBRACKET [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End Else EOF Directive Const COMMA Block Begin Attr ARROW ]
##
## The known suffix of the stack is as follows:
## Case expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 227, spurious reduction of production ctor_app_expr -> UIdent
## In state 295, spurious reduction of production core_expr -> ctor_app_expr
## In state 315, spurious reduction of production update_expr_level -> core_expr
## In state 280, spurious reduction of production unary_expr_level -> update_expr_level
## In state 309, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 311, spurious reduction of production add_expr_level -> mult_expr_level
## In state 332, spurious reduction of production cons_expr_level -> add_expr_level
## In state 322, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 352, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 339, spurious reduction of production set_mem_level -> comp_expr_level
## In state 360, spurious reduction of production conj_expr_level -> set_mem_level
## In state 385, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 379, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 387, spurious reduction of production expr -> base_expr(expr)
##

Ill-formed case expression.
At this point, if the analysed expression is complete, the keyword
'of' is expected, followed by an opening bracket '['.


interactive_expr: LPAR UIdent COMMA UIdent While
##
## Ends in an error in state: 717.
##
## nsepseq(expr,COMMA) -> expr . [ RPAR ]
## nsepseq(expr,COMMA) -> expr . COMMA nsepseq(expr,COMMA) [ RPAR ]
##
## The known suffix of the stack is as follows:
## expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 227, spurious reduction of production ctor_app_expr -> UIdent
## In state 295, spurious reduction of production core_expr -> ctor_app_expr
## In state 315, spurious reduction of production update_expr_level -> core_expr
## In state 280, spurious reduction of production unary_expr_level -> update_expr_level
## In state 309, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 311, spurious reduction of production add_expr_level -> mult_expr_level
## In state 332, spurious reduction of production cons_expr_level -> add_expr_level
## In state 322, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 352, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 339, spurious reduction of production set_mem_level -> comp_expr_level
## In state 360, spurious reduction of production conj_expr_level -> set_mem_level
## In state 385, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 379, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 387, spurious reduction of production expr -> base_expr(expr)
##

Ill-formed tuple expression.
At this point, if the component is complete, one of the following is
expected:
  * a comma ',' followed by another component as an expression;
  * a closing parenthesis ')' if there are no more components.

interactive_expr: LPAR UIdent While
##
## Ends in an error in state: 712.
##
## par(__anonymous_6(expr)) -> LPAR expr . COMMA nsepseq(expr,COMMA) RPAR [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
## par(expr) -> LPAR expr . RPAR [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LPAR LE LBRACKET LBRACE GT GE Function From End Else EQ EOF Directive DOT Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 227, spurious reduction of production ctor_app_expr -> UIdent
## In state 295, spurious reduction of production core_expr -> ctor_app_expr
## In state 315, spurious reduction of production update_expr_level -> core_expr
## In state 280, spurious reduction of production unary_expr_level -> update_expr_level
## In state 309, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 311, spurious reduction of production add_expr_level -> mult_expr_level
## In state 332, spurious reduction of production cons_expr_level -> add_expr_level
## In state 322, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 352, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 339, spurious reduction of production set_mem_level -> comp_expr_level
## In state 360, spurious reduction of production conj_expr_level -> set_mem_level
## In state 385, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 720, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 387, spurious reduction of production expr -> base_expr(expr)
##

Ill-formed parenthesised or tuple expression.
At this point, if the expression is complete, one of the following is
expected:
  * a comma ',' followed by an expression, if defining a tuple;
  * a closing parenthesis ')' if defining a parenthesised expression.

interactive_expr: Lang UIdent While
##
## Ends in an error in state: 723.
##
## code_inj -> Lang expr . RBRACKET [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## Lang expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 227, spurious reduction of production ctor_app_expr -> UIdent
## In state 295, spurious reduction of production core_expr -> ctor_app_expr
## In state 315, spurious reduction of production update_expr_level -> core_expr
## In state 280, spurious reduction of production unary_expr_level -> update_expr_level
## In state 309, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 311, spurious reduction of production add_expr_level -> mult_expr_level
## In state 332, spurious reduction of production cons_expr_level -> add_expr_level
## In state 322, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 352, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 339, spurious reduction of production set_mem_level -> comp_expr_level
## In state 360, spurious reduction of production conj_expr_level -> set_mem_level
## In state 385, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 379, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 387, spurious reduction of production expr -> base_expr(expr)
##

Ill-formed code injection.
At this point, if the expression denoting the code to inject is
complete, then a closing bracket ']' is expected.

interactive_expr: Map LBRACKET UIdent ARROW UIdent While
##
## Ends in an error in state: 735.
##
## compound(Map,binding) -> Map LBRACKET sep_or_term_list(binding,SEMI) . RBRACKET [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## Map LBRACKET sep_or_term_list(binding,SEMI)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 227, spurious reduction of production ctor_app_expr -> UIdent
## In state 295, spurious reduction of production core_expr -> ctor_app_expr
## In state 315, spurious reduction of production update_expr_level -> core_expr
## In state 280, spurious reduction of production unary_expr_level -> update_expr_level
## In state 309, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 311, spurious reduction of production add_expr_level -> mult_expr_level
## In state 332, spurious reduction of production cons_expr_level -> add_expr_level
## In state 322, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 352, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 339, spurious reduction of production set_mem_level -> comp_expr_level
## In state 360, spurious reduction of production conj_expr_level -> set_mem_level
## In state 385, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 379, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 387, spurious reduction of production expr -> base_expr(expr)
## In state 678, spurious reduction of production binding -> expr ARROW expr
## In state 679, spurious reduction of production nsepseq(binding,SEMI) -> binding
## In state 675, spurious reduction of production sep_or_term_list(binding,SEMI) -> nsepseq(binding,SEMI)
##

Ill-formed map expression.
At this point, if the key-value binding is complete, one of the
following is expected:
  * another binding;
  * a closing bracket ']' if the map is complete.
Note: A binding is made of two expressions (a key and a value)
separated by an arrow '->'.

contract: Const LPAR UIdent COLON With
##
## Ends in an error in state: 175.
##
## typed_pattern -> pattern COLON . type_expr [ RPAR ]
##
## The known suffix of the stack is as follows:
## pattern COLON
##

Ill-formed typed pattern.
At this point, the type of the values matching the pattern is
expected.

interactive_expr: Begin Var UIdent COLON With
##
## Ends in an error in state: 366.
##
## unqualified_decl(ASS) -> core_pattern COLON . type_expr ASS expr [ SEMI RBRACE End ]
##
## The known suffix of the stack is as follows:
## core_pattern COLON
##

Ill-formed variable declaration.
At this point, the type of the variable is expected.

contract: Const UIdent COLON With
##
## Ends in an error in state: 476.
##
## unqualified_decl(EQ) -> core_pattern COLON . type_expr EQ expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## core_pattern COLON
##

Ill-formed constant declaration.
At this point, the type of the constant is expected.

contract: Function Ident LT Ident GT LPAR Const UIdent RPAR COLON With
##
## Ends in an error in state: 459.
##
## fun_decl -> Function Ident type_params parameters COLON . type_expr Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## Function Ident type_params parameters COLON
##
contract: Function Ident LPAR Const Ident RPAR COLON With
##
## Ends in an error in state: 467.
##
## fun_decl -> Function Ident parameters COLON . type_expr Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## Function Ident parameters COLON
##
contract: Recursive Function Ident LPAR Const Ident RPAR COLON With
##
## Ends in an error in state: 796.
##
## fun_decl -> Recursive Function Ident parameters COLON . type_expr Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## Recursive Function Ident parameters COLON
##
contract: Recursive Function Ident LT Ident GT LPAR Const UIdent RPAR COLON With
##
## Ends in an error in state: 789.
##
## fun_decl -> Recursive Function Ident type_params parameters COLON . type_expr Is expr [ Type SEMI Recursive RBRACE Module Function End EOF Directive Const Attr ]
##
## The known suffix of the stack is as follows:
## Recursive Function Ident type_params parameters COLON
##

Ill-formed function declaration.
At this point, the return type is expected.

interactive_expr: If UIdent Then Function LT Ident GT LPAR Const UIdent RPAR COLON With
##
## Ends in an error in state: 616.
##
## fun_expr(closed_expr) -> Function type_params parameters COLON . type_expr Is closed_expr [ Else ]
## fun_expr(expr) -> Function type_params parameters COLON . type_expr Is expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
##
## The known suffix of the stack is as follows:
## Function type_params parameters COLON
##
interactive_expr: Function LT Ident GT LPAR Const UIdent RPAR COLON With
##
## Ends in an error in state: 698.
##
## fun_expr(expr) -> Function type_params parameters COLON . type_expr Is expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
##
## The known suffix of the stack is as follows:
## Function type_params parameters COLON
##
interactive_expr: If UIdent Then Function LPAR Const Ident RPAR COLON With
##
## Ends in an error in state: 625.
##
## fun_expr(closed_expr) -> Function parameters COLON . type_expr Is closed_expr [ Else ]
## fun_expr(expr) -> Function parameters COLON . type_expr Is expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
##
## The known suffix of the stack is as follows:
## Function parameters COLON
##
interactive_expr: Function LPAR Const Ident RPAR COLON With
##
## Ends in an error in state: 703.
##
## fun_expr(expr) -> Function parameters COLON . type_expr Is expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
##
## The known suffix of the stack is as follows:
## Function parameters COLON
##

Ill-formed function expression.
At this point, the return type is expected.

interactive_expr: LPAR UIdent COLON With
##
## Ends in an error in state: 721.
##
## typed_expr -> disj_expr_level COLON . type_expr [ RPAR ]
##
## The known suffix of the stack is as follows:
## disj_expr_level COLON
##

Ill-formed typed expression.
At this point, a type expression is expected.

interactive_expr: Attr With
##
## Ends in an error in state: 369.
##
## base_expr(expr) -> nseq(Attr) . attr_base_expr(expr) [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
## expr -> nseq(Attr) . if_then_expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
##
## The known suffix of the stack is as follows:
## nseq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 272, spurious reduction of production nseq(Attr) -> Attr
##
interactive_expr: MINUS Attr With
##
## Ends in an error in state: 282.
##
## attr_expr -> Attr . core_expr [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## Attr
##
interactive_expr: If UIdent Then Attr With
##
## Ends in an error in state: 602.
##
## base_expr(closed_expr) -> nseq(Attr) . attr_base_expr(closed_expr) [ Else ]
## base_expr(expr) -> nseq(Attr) . attr_base_expr(expr) [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
## expr -> nseq(Attr) . if_then_expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
##
## The known suffix of the stack is as follows:
## nseq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 272, spurious reduction of production nseq(Attr) -> Attr
##

Ill-formed expression.
At this point, if the attribute is complete, one of the following is
expected:
  * another attribute;
  * an expression.
Note: Some expressions need to be parenthesised.

interactive_expr: Begin For Ident ARROW With
##
## Ends in an error in state: 545.
##
## for_in -> For Ident ARROW . Ident In Map expr block [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## For Ident ARROW
##

Ill-formed iteration over a map.
At this point, the value (as opposed to the key) of the binding is
expected as a variable.

interactive_expr: Begin For Ident ARROW Ident With
##
## Ends in an error in state: 546.
##
## for_in -> For Ident ARROW Ident . In Map expr block [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## For Ident ARROW Ident
##

Ill-formed iteration over a map.
At this point, the keywords 'in map' are expected.

interactive_expr: Begin For Ident ARROW Ident In With
##
## Ends in an error in state: 547.
##
## for_in -> For Ident ARROW Ident In . Map expr block [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## For Ident ARROW Ident In
##

Ill-formed iteration over a map.
At this point, the keyword 'map' is expected.

interactive_expr: Begin For Ident ARROW Ident In Map With
##
## Ends in an error in state: 548.
##
## for_in -> For Ident ARROW Ident In Map . expr block [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## For Ident ARROW Ident In Map
##

Ill-formed iteration over a map.
At this point, a map is expected as an expression.

contract: Const UIdent DOT With
##
## Ends in an error in state: 204.
##
## module_path(__anonymous_7) -> UIdent DOT . module_path(__anonymous_7) [ LPAR ]
## module_path(__anonymous_7) -> UIdent DOT . UIdent [ LPAR ]
## module_path(__anonymous_8) -> UIdent DOT . module_path(__anonymous_8) [ SHARP SEMI RPAR RBRACKET LT EQ COMMA COLON ASS ARROW ]
## module_path(__anonymous_8) -> UIdent DOT . Ident [ SHARP SEMI RPAR RBRACKET LT EQ COMMA COLON ASS ARROW ]
## module_path(__anonymous_9) -> UIdent DOT . module_path(__anonymous_9) [ SHARP SEMI RPAR RBRACKET LT EQ COMMA COLON ASS ARROW ]
## module_path(__anonymous_9) -> UIdent DOT . par(in_pattern) [ SHARP SEMI RPAR RBRACKET LT EQ COMMA COLON ASS ARROW ]
##
## The known suffix of the stack is as follows:
## UIdent DOT
##

Ill-formed qualified pattern.
At this point, one of the following is expected:
  * a submodule name if the qualification is not complete;
  * a data constructor name;
  * a variable;
  * a parenthesised pattern.

contract: Const UIdent DOT UIdent With
##
## Ends in an error in state: 205.
##
## module_path(__anonymous_7) -> UIdent . DOT module_path(__anonymous_7) [ LPAR ]
## module_path(__anonymous_7) -> UIdent . DOT UIdent [ LPAR ]
## module_path(__anonymous_7) -> UIdent DOT UIdent . [ LPAR ]
## module_path(__anonymous_8) -> UIdent . DOT module_path(__anonymous_8) [ SHARP SEMI RPAR RBRACKET LT EQ COMMA COLON ASS ARROW ]
## module_path(__anonymous_8) -> UIdent . DOT Ident [ SHARP SEMI RPAR RBRACKET LT EQ COMMA COLON ASS ARROW ]
## module_path(__anonymous_9) -> UIdent . DOT module_path(__anonymous_9) [ SHARP SEMI RPAR RBRACKET LT EQ COMMA COLON ASS ARROW ]
## module_path(__anonymous_9) -> UIdent . DOT par(in_pattern) [ SHARP SEMI RPAR RBRACKET LT EQ COMMA COLON ASS ARROW ]
##
## The known suffix of the stack is as follows:
## UIdent DOT UIdent
##

Ill-formed qualified pattern.
At this point, one of the following is expected:
  * the selection operator '.' if the qualification is not complete;
  * an opening parenthesis '(' followed by constructor parameters as
    patterns.

contract: Const UIdent DOT LPAR With
##
## Ends in an error in state: 206.
##
## par(in_pattern) -> LPAR . in_pattern RPAR [ SHARP SEMI RPAR RBRACKET LT EQ COMMA COLON ASS ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR
##

Ill-formed parenthesised pattern.
At this point, a pattern is expected.

contract: Const UIdent DOT LPAR WILD With
##
## Ends in an error in state: 207.
##
## in_pattern -> pattern . [ RPAR ]
## typed_pattern -> pattern . COLON type_expr [ RPAR ]
##
## The known suffix of the stack is as follows:
## pattern
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 163, spurious reduction of production pattern -> core_pattern
##

Ill-formed parenthesised pattern.
At this point, if the pattern is complete, one of the following is
expected:
  * a type annotation starting with a colon ':';
  * a closing parenthesis ')'.

contract: Const UIdent DOT UIdent LPAR With
##
## Ends in an error in state: 150.
##
## par(__anonymous_6(pattern)) -> LPAR . pattern COMMA nsepseq(pattern,COMMA) RPAR [ SHARP SEMI RPAR RBRACKET LT EQ COMMA COLON ASS ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR
##

Ill-formed tuple pattern.
At this point, a component is expected as a pattern.

contract: Const UIdent DOT UIdent LPAR UIdent With
##
## Ends in an error in state: 151.
##
## par(__anonymous_6(pattern)) -> LPAR pattern . COMMA nsepseq(pattern,COMMA) RPAR [ SHARP SEMI RPAR RBRACKET LT EQ COMMA COLON ASS ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR pattern
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 127, spurious reduction of production ctor_app_pattern -> UIdent
## In state 162, spurious reduction of production core_pattern -> ctor_app_pattern
## In state 163, spurious reduction of production pattern -> core_pattern
##

Ill-formed tuple pattern.
At this point, if the component is complete, a comma ',' is expected.

interactive_expr: UIdent LPAR With
##
## Ends in an error in state: 228.
##
## par(nsepseq(ctor_arg,COMMA)) -> LPAR . nsepseq(ctor_arg,COMMA) RPAR [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR
##
interactive_expr: UIdent LPAR UIdent COMMA With
##
## Ends in an error in state: 785.
##
## nsepseq(ctor_arg,COMMA) -> ctor_arg COMMA . nsepseq(ctor_arg,COMMA) [ RPAR ]
##
## The known suffix of the stack is as follows:
## ctor_arg COMMA
##

Ill-formed constructor expression.
At this point, an argument to the constructor is expected as an
expression.

interactive_expr: Ident LPAR UIdent While
##
## Ends in an error in state: 664.
##
## nsepseq(fun_arg,COMMA) -> fun_arg . [ RPAR ]
## nsepseq(fun_arg,COMMA) -> fun_arg . COMMA nsepseq(fun_arg,COMMA) [ RPAR ]
##
## The known suffix of the stack is as follows:
## fun_arg
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 227, spurious reduction of production ctor_app_expr -> UIdent
## In state 295, spurious reduction of production core_expr -> ctor_app_expr
## In state 315, spurious reduction of production update_expr_level -> core_expr
## In state 280, spurious reduction of production unary_expr_level -> update_expr_level
## In state 309, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 311, spurious reduction of production add_expr_level -> mult_expr_level
## In state 332, spurious reduction of production cons_expr_level -> add_expr_level
## In state 322, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 352, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 339, spurious reduction of production set_mem_level -> comp_expr_level
## In state 360, spurious reduction of production conj_expr_level -> set_mem_level
## In state 385, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 379, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 387, spurious reduction of production expr -> base_expr(expr)
## In state 667, spurious reduction of production fun_arg -> expr
##

Ill-formed function call.
At this point, if the argument is complete, one of the following is
expected:
  * a comma ',' followed by another argument as an expression;
  * a closing parenthesis ')' if there are no more arguments.

interactive_expr: UIdent LPAR UIdent While
##
## Ends in an error in state: 784.
##
## nsepseq(ctor_arg,COMMA) -> ctor_arg . [ RPAR ]
## nsepseq(ctor_arg,COMMA) -> ctor_arg . COMMA nsepseq(ctor_arg,COMMA) [ RPAR ]
##
## The known suffix of the stack is as follows:
## ctor_arg
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 227, spurious reduction of production ctor_app_expr -> UIdent
## In state 295, spurious reduction of production core_expr -> ctor_app_expr
## In state 315, spurious reduction of production update_expr_level -> core_expr
## In state 280, spurious reduction of production unary_expr_level -> update_expr_level
## In state 309, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 311, spurious reduction of production add_expr_level -> mult_expr_level
## In state 332, spurious reduction of production cons_expr_level -> add_expr_level
## In state 322, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 352, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 339, spurious reduction of production set_mem_level -> comp_expr_level
## In state 360, spurious reduction of production conj_expr_level -> set_mem_level
## In state 385, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 379, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 387, spurious reduction of production expr -> base_expr(expr)
## In state 783, spurious reduction of production ctor_arg -> expr
##

Ill-formed constructor expression.
At this point, if the argument is complete, one of the following is
expected:
  * a comma ',' followed by another argument as an expression;
  * a closing parenthesis ')' if there are no more arguments.

interactive_expr: List LBRACKET UIdent End
##
## Ends in an error in state: 725.
##
## compound(List,list_element) -> List LBRACKET sep_or_term_list(list_element,SEMI) . RBRACKET [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## List LBRACKET sep_or_term_list(list_element,SEMI)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 227, spurious reduction of production ctor_app_expr -> UIdent
## In state 295, spurious reduction of production core_expr -> ctor_app_expr
## In state 315, spurious reduction of production update_expr_level -> core_expr
## In state 280, spurious reduction of production unary_expr_level -> update_expr_level
## In state 309, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 311, spurious reduction of production add_expr_level -> mult_expr_level
## In state 332, spurious reduction of production cons_expr_level -> add_expr_level
## In state 322, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 352, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 339, spurious reduction of production set_mem_level -> comp_expr_level
## In state 360, spurious reduction of production conj_expr_level -> set_mem_level
## In state 385, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 379, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 387, spurious reduction of production expr -> base_expr(expr)
## In state 733, spurious reduction of production list_element -> expr
## In state 729, spurious reduction of production nsepseq(list_element,SEMI) -> list_element
## In state 728, spurious reduction of production sep_or_term_list(list_element,SEMI) -> nsepseq(list_element,SEMI)
##

Ill-formed list expression.
At this point, if the list element is complete, one of the following
is expected:
  * another element;
  * a closing bracket ']' if the list is complete.

interactive_expr: Set LBRACKET UIdent End
##
## Ends in an error in state: 777.
##
## compound(Set,set_element) -> Set LBRACKET sep_or_term_list(set_element,SEMI) . RBRACKET [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## Set LBRACKET sep_or_term_list(set_element,SEMI)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 227, spurious reduction of production ctor_app_expr -> UIdent
## In state 295, spurious reduction of production core_expr -> ctor_app_expr
## In state 315, spurious reduction of production update_expr_level -> core_expr
## In state 280, spurious reduction of production unary_expr_level -> update_expr_level
## In state 309, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 311, spurious reduction of production add_expr_level -> mult_expr_level
## In state 332, spurious reduction of production cons_expr_level -> add_expr_level
## In state 322, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 352, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 339, spurious reduction of production set_mem_level -> comp_expr_level
## In state 360, spurious reduction of production conj_expr_level -> set_mem_level
## In state 385, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 379, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 387, spurious reduction of production expr -> base_expr(expr)
## In state 776, spurious reduction of production set_element -> expr
## In state 772, spurious reduction of production nsepseq(set_element,SEMI) -> set_element
## In state 780, spurious reduction of production sep_or_term_list(set_element,SEMI) -> nsepseq(set_element,SEMI)
##

Ill-formed set expression.
At this point, if the set element is complete, one of the following is
expected:
  * another element;
  * a closing bracket ']' if the set is complete.

interactive_expr: Begin Patch UIdent With Set With
##
## Ends in an error in state: 430.
##
## compound(Set,set_element) -> Set . LBRACKET RBRACKET [ VBAR SEMI RBRACKET RBRACE End Else ]
## compound(Set,set_element) -> Set . LBRACKET sep_or_term_list(set_element,SEMI) RBRACKET [ VBAR SEMI RBRACKET RBRACE End Else ]
## patch_expr -> Set . call_expr [ VBAR SEMI RBRACKET RBRACE End Else ]
## patch_expr -> Set . par(expr) [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## Set
##

Ill-formed set expression.
At this point, one of the following is expected:
  * an opening bracket '[' followed by set elements;
  * a function call denoting a set;
  * a parenthesised expression denoting a set.

interactive_expr: Set With
##
## Ends in an error in state: 230.
##
## compound(Set,set_element) -> Set . LBRACKET RBRACKET [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
## compound(Set,set_element) -> Set . LBRACKET sep_or_term_list(set_element,SEMI) RBRACKET [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## Set
##

Ill-formed set expression.
At this point, an opening bracket '[' is expected.

interactive_expr: List With
##
## Ends in an error in state: 245.
##
## compound(List,list_element) -> List . LBRACKET RBRACKET [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
## compound(List,list_element) -> List . LBRACKET sep_or_term_list(list_element,SEMI) RBRACKET [ With VBAR Type To Then TIMES Step SLASH SHARP SEMI Recursive RPAR RBRACKET RBRACE PLUS Or Of NE Module Mod MINUS LT LE LBRACE GT GE Function From End Else EQ EOF Directive Contains Const COMMA COLON CARET Block Begin Attr And ARROW ]
##
## The known suffix of the stack is as follows:
## List
##

Ill-formed list expression.
At this point, an opening bracket '[' is expected.

interactive_expr: Begin For Ident In Set UIdent While
##
## Ends in an error in state: 531.
##
## for_in -> For Ident In Set expr . block [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## For Ident In Set expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 227, spurious reduction of production ctor_app_expr -> UIdent
## In state 295, spurious reduction of production core_expr -> ctor_app_expr
## In state 315, spurious reduction of production update_expr_level -> core_expr
## In state 280, spurious reduction of production unary_expr_level -> update_expr_level
## In state 309, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 311, spurious reduction of production add_expr_level -> mult_expr_level
## In state 332, spurious reduction of production cons_expr_level -> add_expr_level
## In state 322, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 352, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 339, spurious reduction of production set_mem_level -> comp_expr_level
## In state 360, spurious reduction of production conj_expr_level -> set_mem_level
## In state 385, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 379, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 387, spurious reduction of production expr -> base_expr(expr)
##

Ill-formed iteration over a set.
At this point, if the expression is complete, the body of the loop is
expected as a block of statements (declarations and instructions).

interactive_expr: Begin For Ident In List UIdent While
##
## Ends in an error in state: 534.
##
## for_in -> For Ident In List expr . block [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## For Ident In List expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 227, spurious reduction of production ctor_app_expr -> UIdent
## In state 295, spurious reduction of production core_expr -> ctor_app_expr
## In state 315, spurious reduction of production update_expr_level -> core_expr
## In state 280, spurious reduction of production unary_expr_level -> update_expr_level
## In state 309, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 311, spurious reduction of production add_expr_level -> mult_expr_level
## In state 332, spurious reduction of production cons_expr_level -> add_expr_level
## In state 322, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 352, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 339, spurious reduction of production set_mem_level -> comp_expr_level
## In state 360, spurious reduction of production conj_expr_level -> set_mem_level
## In state 385, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 379, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 387, spurious reduction of production expr -> base_expr(expr)
##

Ill-formed iteration over a list.
At this point, if the expression is complete, the body of the loop is
expected as a block of statements (declarations and instructions).

contract: Const UIdent COLON UIdent DOT UIdent With
##
## Ends in an error in state: 16.
##
## module_path(__anonymous_2) -> UIdent . DOT module_path(__anonymous_2) [ VBAR Type TIMES SEMI Recursive RPAR RBRACKET RBRACE Module Is Function End EQ EOF Directive Const COMMA Attr ASS ARROW ]
## module_path(__anonymous_2) -> UIdent . DOT Ident [ VBAR Type TIMES SEMI Recursive RPAR RBRACKET RBRACE Module Is Function End EQ EOF Directive Const COMMA Attr ASS ARROW ]
## module_path(__anonymous_3) -> UIdent . DOT module_path(__anonymous_3) [ VBAR Type TIMES SEMI Recursive RPAR RBRACKET RBRACE Module Is Function End EQ EOF Directive Const COMMA Attr ASS ARROW ]
## module_path(__anonymous_3) -> UIdent . DOT par(type_expr) [ VBAR Type TIMES SEMI Recursive RPAR RBRACKET RBRACE Module Is Function End EQ EOF Directive Const COMMA Attr ASS ARROW ]
## module_path(type_ctor) -> UIdent . DOT module_path(type_ctor) [ LPAR ]
## module_path(type_ctor) -> UIdent . DOT Ident [ LPAR ]
##
## The known suffix of the stack is as follows:
## UIdent
##

Ill-formed qualified type expression.
At this point, the selection operator '.' is expected.

contract: Const UIdent COLON UIdent Of Attr With
##
## Ends in an error in state: 71.
##
## attr_type -> Attr . core_type [ VBAR Type TIMES SEMI Recursive RPAR RBRACKET RBRACE Module Is Function End EQ EOF Directive Const COMMA Attr ASS ARROW ]
##
## The known suffix of the stack is as follows:
## Attr
##

Ill-formed type expression.
At this point, one of the following is expected:
  * another attribute;
  * a type expression is expected, other than a functional type, a
    cartesian type or a sum type. (For those, use parentheses.)

contract: Const LPAR UIdent COLON Ident With
##
## Ends in an error in state: 177.
##
## par(in_pattern) -> LPAR in_pattern . RPAR [ SHARP SEMI RPAR RBRACKET LT EQ COMMA COLON ASS ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR in_pattern
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 34, spurious reduction of production core_type -> Ident
## In state 69, spurious reduction of production cartesian_level -> core_type
## In state 76, spurious reduction of production fun_type_level -> cartesian_level
## In state 68, spurious reduction of production type_expr -> fun_type_level
## In state 176, spurious reduction of production typed_pattern -> pattern COLON type_expr
## In state 173, spurious reduction of production in_pattern -> typed_pattern
##

Ill-formed parenthesised pattern.
At this point, a closing parenthesis ')' is expected.

interactive_expr: Begin Var UIdent COLON Ident With
##
## Ends in an error in state: 367.
##
## unqualified_decl(ASS) -> core_pattern COLON type_expr . ASS expr [ SEMI RBRACE End ]
##
## The known suffix of the stack is as follows:
## core_pattern COLON type_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 34, spurious reduction of production core_type -> Ident
## In state 69, spurious reduction of production cartesian_level -> core_type
## In state 76, spurious reduction of production fun_type_level -> cartesian_level
## In state 68, spurious reduction of production type_expr -> fun_type_level
##

Ill-formed variable declaration.
At this point, the assignment symbol ':=' is expected, followed by an
expression whose value is first assigned.

interactive_expr: If UIdent Then Function LT Ident GT LPAR Const UIdent RPAR COLON Ident With
##
## Ends in an error in state: 617.
##
## fun_expr(closed_expr) -> Function type_params parameters COLON type_expr . Is closed_expr [ Else ]
## fun_expr(expr) -> Function type_params parameters COLON type_expr . Is expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
##
## The known suffix of the stack is as follows:
## Function type_params parameters COLON type_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 34, spurious reduction of production core_type -> Ident
## In state 69, spurious reduction of production cartesian_level -> core_type
## In state 76, spurious reduction of production fun_type_level -> cartesian_level
## In state 68, spurious reduction of production type_expr -> fun_type_level
##
interactive_expr: Function LT Ident GT LPAR Const UIdent RPAR COLON Ident With
##
## Ends in an error in state: 699.
##
## fun_expr(expr) -> Function type_params parameters COLON type_expr . Is expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
##
## The known suffix of the stack is as follows:
## Function type_params parameters COLON type_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 34, spurious reduction of production core_type -> Ident
## In state 69, spurious reduction of production cartesian_level -> core_type
## In state 76, spurious reduction of production fun_type_level -> cartesian_level
## In state 68, spurious reduction of production type_expr -> fun_type_level
##
interactive_expr: If UIdent Then Function LPAR Const Ident RPAR COLON Ident With
##
## Ends in an error in state: 626.
##
## fun_expr(closed_expr) -> Function parameters COLON type_expr . Is closed_expr [ Else ]
## fun_expr(expr) -> Function parameters COLON type_expr . Is expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
##
## The known suffix of the stack is as follows:
## Function parameters COLON type_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 34, spurious reduction of production core_type -> Ident
## In state 69, spurious reduction of production cartesian_level -> core_type
## In state 76, spurious reduction of production fun_type_level -> cartesian_level
## In state 68, spurious reduction of production type_expr -> fun_type_level
##
interactive_expr: Function LPAR Const Ident RPAR COLON Ident With
##
## Ends in an error in state: 704.
##
## fun_expr(expr) -> Function parameters COLON type_expr . Is expr [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End EOF Directive Const COMMA Block Begin Attr ARROW ]
##
## The known suffix of the stack is as follows:
## Function parameters COLON type_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 34, spurious reduction of production core_type -> Ident
## In state 69, spurious reduction of production cartesian_level -> core_type
## In state 76, spurious reduction of production fun_type_level -> cartesian_level
## In state 68, spurious reduction of production type_expr -> fun_type_level
##

Ill-formed function expression.
At this point, the keyword 'is' is expected, followed by the function
body as an expression.

interactive_expr: Begin Attr With
##
## Ends in an error in state: 652.
##
## statement -> nseq(Attr) . attr_statement [ SEMI RBRACE End ]
##
## The known suffix of the stack is as follows:
## nseq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 647, spurious reduction of production nseq(Attr) -> Attr
##

Ill-formed attributed statement.
At this point, if the attribute is complete, one of the following is
expected:
  * a variable declaration, starting with the keyword 'var';
  * an instruction.

interactive_expr: Begin Patch UIdent With Record With
##
## Ends in an error in state: 435.
##
## compound(Record,field_path_assignment) -> Record . LBRACKET RBRACKET [ VBAR SEMI RBRACKET RBRACE End Else ]
## compound(Record,field_path_assignment) -> Record . LBRACKET sep_or_term_list(field_path_assignment,SEMI) RBRACKET [ VBAR SEMI RBRACKET RBRACE End Else ]
## patch_expr -> Record . call_expr [ VBAR SEMI RBRACKET RBRACE End Else ]
## patch_expr -> Record . par(expr) [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## Record
##

Ill-formed patch of a record.
At this point, one of the following is expected:
  * an opening bracket '[';
  * a function call whose value is a record;
  * a parenthesised expression denoting a record.

contract: Type Ident Is Map With
##
## Ends in an error in state: 29.
##
## type_ctor_app -> Map . type_tuple [ VBAR Type TIMES SEMI Recursive RPAR RBRACKET RBRACE Module Is Function End EQ EOF Directive Const COMMA Attr ASS ARROW ]
##
## The known suffix of the stack is as follows:
## Map
##

Ill-formed map type.
At this point, a pair of types is expected: the type of the keys and
the type of the values, respectively. For example: '(int, string)'.

contract: Const UIdent COLON Record LBRACKET Ident COLON With
##
## Ends in an error in state: 28.
##
## field_decl -> Ident COLON . type_expr [ SEMI RBRACKET ]
##
## The known suffix of the stack is as follows:
## Ident COLON
##
contract: Const UIdent COLON Record LBRACKET Attr Ident COLON With
##
## Ends in an error in state: 89.
##
## field_decl -> nseq(Attr) Ident COLON . type_expr [ SEMI RBRACKET ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Ident COLON
##

Ill-formed record declaration.
At this point, the type of the field is expected.

contract: Const UIdent COLON Record LBRACKET Attr With
##
## Ends in an error in state: 87.
##
## field_decl -> nseq(Attr) . Ident [ SEMI RBRACKET ]
## field_decl -> nseq(Attr) . Ident COLON type_expr [ SEMI RBRACKET ]
##
## The known suffix of the stack is as follows:
## nseq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 83, spurious reduction of production nseq(Attr) -> Attr
##

Ill-formed record type.
At this point, if the attribute is complete, the following is
expected:
  * another attribute of the field;
  * the name of the field.

contract: Const UIdent LPAR With
##
## Ends in an error in state: 128.
##
## par(nsepseq(ctor_param,COMMA)) -> LPAR . nsepseq(ctor_param,COMMA) RPAR [ SHARP SEMI RPAR RBRACKET LT EQ COMMA COLON ASS ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR
##

Ill-formed constructor pattern.
At this point, a constructor parameter is expected as a pattern.

contract: Const List With
##
## Ends in an error in state: 136.
##
## compound(List,pattern) -> List . LBRACKET RBRACKET [ SHARP SEMI RPAR RBRACKET LT EQ COMMA COLON ASS ARROW ]
## compound(List,pattern) -> List . LBRACKET sep_or_term_list(pattern,SEMI) RBRACKET [ SHARP SEMI RPAR RBRACKET LT EQ COMMA COLON ASS ARROW ]
##
## The known suffix of the stack is as follows:
## List
##

Ill-formed list pattern.
At this point, an opening bracket `[` is expected.

contract: Const List LBRACKET With
##
## Ends in an error in state: 137.
##
## compound(List,pattern) -> List LBRACKET . RBRACKET [ SHARP SEMI RPAR RBRACKET LT EQ COMMA COLON ASS ARROW ]
## compound(List,pattern) -> List LBRACKET . sep_or_term_list(pattern,SEMI) RBRACKET [ SHARP SEMI RPAR RBRACKET LT EQ COMMA COLON ASS ARROW ]
##
## The known suffix of the stack is as follows:
## List LBRACKET
##

Ill-formed list pattern.
At this point, one of the following is expected:
  * a list element as a pattern;
  * a closing bracket ']' if the list is empty.

contract: Const LPAR With
##
## Ends in an error in state: 139.
##
## par(__anonymous_6(pattern)) -> LPAR . pattern COMMA nsepseq(pattern,COMMA) RPAR [ SHARP SEMI RPAR RBRACKET LT EQ COMMA COLON ASS ARROW ]
## par(in_pattern) -> LPAR . in_pattern RPAR [ SHARP SEMI RPAR RBRACKET LT EQ COMMA COLON ASS ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR
##

Ill-formed tuple pattern or parenthesised pattern.
At this point, a pattern is expected.

contract: Const LPAR UIdent COMMA With
##
## Ends in an error in state: 152.
##
## par(__anonymous_6(pattern)) -> LPAR pattern COMMA . nsepseq(pattern,COMMA) RPAR [ SHARP SEMI RPAR RBRACKET LT EQ COMMA COLON ASS ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR pattern COMMA
##

Ill-formed tuple pattern.
At this point, a component as a pattern is expected.

contract: Const LPAR UIdent SHARP With
##
## Ends in an error in state: 164.
##
## pattern -> core_pattern SHARP . pattern [ SEMI RPAR RBRACKET EQ COMMA COLON ARROW ]
##
## The known suffix of the stack is as follows:
## core_pattern SHARP
##

Ill-formed list pattern.
At this point, a list is expected as a pattern.

contract: Const LPAR UIdent With
##
## Ends in an error in state: 174.
##
## in_pattern -> pattern . [ RPAR ]
## par(__anonymous_6(pattern)) -> LPAR pattern . COMMA nsepseq(pattern,COMMA) RPAR [ SHARP SEMI RPAR RBRACKET LT EQ COMMA COLON ASS ARROW ]
## typed_pattern -> pattern . COLON type_expr [ RPAR ]
##
## The known suffix of the stack is as follows:
## LPAR pattern
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 127, spurious reduction of production ctor_app_pattern -> UIdent
## In state 162, spurious reduction of production core_pattern -> ctor_app_pattern
## In state 163, spurious reduction of production pattern -> core_pattern
##

Ill-formed parenthesised/tuple/typed pattern.
At this point, if the pattern is complete, one of the following is
expected:
  * a closing parenthesis ')' if writing a parenthesised pattern;
  * a type annotation starting with a colon ':', if writing a typed
    pattern;
  * a comma ',' if writing a tuple pattern.

contract: Const List LBRACKET UIdent With
##
## Ends in an error in state: 179.
##
## compound(List,pattern) -> List LBRACKET sep_or_term_list(pattern,SEMI) . RBRACKET [ SHARP SEMI RPAR RBRACKET LT EQ COMMA COLON ASS ARROW ]
##
## The known suffix of the stack is as follows:
## List LBRACKET sep_or_term_list(pattern,SEMI)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 127, spurious reduction of production ctor_app_pattern -> UIdent
## In state 162, spurious reduction of production core_pattern -> ctor_app_pattern
## In state 163, spurious reduction of production pattern -> core_pattern
## In state 181, spurious reduction of production nsepseq(pattern,SEMI) -> pattern
## In state 186, spurious reduction of production sep_or_term_list(pattern,SEMI) -> nsepseq(pattern,SEMI)
##

Ill-formed list pattern.
At this point, if the list element is complete, one of the following
is expected:
  * another element as a pattern;
  * a closing bracket ']' if the list is complete.

contract: Const Record LBRACKET UIdent EQ With
##
## Ends in an error in state: 190.
##
## field_pattern -> pattern EQ . pattern [ SEMI RBRACKET ]
##
## The known suffix of the stack is as follows:
## pattern EQ
##

Ill-formed record pattern.
At this point, the right-hand side of the field assignment is expected
as a pattern.

interactive_expr: Record LBRACKET UIdent With
##
## Ends in an error in state: 234.
##
## module_path(__anonymous_5) -> UIdent . DOT module_path(__anonymous_5) [ SEMI RBRACKET ]
## module_path(__anonymous_5) -> UIdent . DOT Ident [ SEMI RBRACKET ]
## module_path(field_path) -> UIdent . DOT module_path(field_path) [ VBAR_EQ TIMES_EQ SLASH_EQ PLUS_EQ MINUS_EQ EQ ]
## module_path(field_path) -> UIdent . DOT field_path [ VBAR_EQ TIMES_EQ SLASH_EQ PLUS_EQ MINUS_EQ EQ ]
##
## The known suffix of the stack is as follows:
## UIdent
##

Ill-formed qualified pattern.
At this point, the selection operator '.' is expected.

interactive_expr: Record LBRACKET UIdent DOT With
##
## Ends in an error in state: 235.
##
## module_path(__anonymous_5) -> UIdent DOT . module_path(__anonymous_5) [ SEMI RBRACKET ]
## module_path(__anonymous_5) -> UIdent DOT . Ident [ SEMI RBRACKET ]
## module_path(field_path) -> UIdent DOT . module_path(field_path) [ VBAR_EQ TIMES_EQ SLASH_EQ PLUS_EQ MINUS_EQ EQ ]
## module_path(field_path) -> UIdent DOT . field_path [ VBAR_EQ TIMES_EQ SLASH_EQ PLUS_EQ MINUS_EQ EQ ]
##
## The known suffix of the stack is as follows:
## UIdent DOT
##

Ill-formed record expression or record patch.
At this point, one of the following is expected:
  * a field name, if defining a record;
  * a selection of a record field in a module, like 'A.B.x';
  * a selection from modules, records or/and tuples, like 'x.y.1.0',
    if defining a patch;
  * parenthesised expression as one of the above.

interactive_expr: Begin Case UIdent Of LBRACKET VBAR With
##
## Ends in an error in state: 555.
##
## case(test_clause(instruction)) -> Case expr Of LBRACKET VBAR . cases(test_clause(instruction)) RBRACKET [ VBAR SEMI RBRACKET RBRACE End Else ]
##
## The known suffix of the stack is as follows:
## Case expr Of LBRACKET VBAR
##
interactive_expr: Begin Case UIdent Of LBRACKET UIdent ARROW Skip VBAR With
##
## Ends in an error in state: 581.
##
## nsepseq(case_clause(test_clause(instruction)),VBAR) -> case_clause(test_clause(instruction)) VBAR . nsepseq(case_clause(test_clause(instruction)),VBAR) [ RBRACKET ]
##
## The known suffix of the stack is as follows:
## case_clause(test_clause(instruction)) VBAR
##

Ill-formed case instruction.
At this point, a clause is expected, starting with a pattern.

interactive_expr: Begin Case UIdent Of LBRACKET UIdent With
##
## Ends in an error in state: 556.
##
## case_clause(test_clause(instruction)) -> pattern . ARROW test_clause(instruction) [ VBAR RBRACKET ]
##
## The known suffix of the stack is as follows:
## pattern
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 127, spurious reduction of production ctor_app_pattern -> UIdent
## In state 162, spurious reduction of production core_pattern -> ctor_app_pattern
## In state 163, spurious reduction of production pattern -> core_pattern
##

Ill-formed clause of a case instruction.
At this point, if the pattern is complete, an arrow '->' is expected.

interactive_expr: Begin Case UIdent Of LBRACKET UIdent ARROW With
##
## Ends in an error in state: 557.
##
## case_clause(test_clause(instruction)) -> pattern ARROW . test_clause(instruction) [ VBAR RBRACKET ]
##
## The known suffix of the stack is as follows:
## pattern ARROW
##

Ill-formed clause of a case instruction.
At this point, one of the following is expected:
  * a single instruction;
  * a block of statements (instructions and declarations).

interactive_expr: BigMap LBRACKET UIdent Type
##
## Ends in an error in state: 676.
##
## binding -> expr . ARROW expr [ SEMI RBRACKET ]
##
## The known suffix of the stack is as follows:
## expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 227, spurious reduction of production ctor_app_expr -> UIdent
## In state 295, spurious reduction of production core_expr -> ctor_app_expr
## In state 315, spurious reduction of production update_expr_level -> core_expr
## In state 280, spurious reduction of production unary_expr_level -> update_expr_level
## In state 309, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 311, spurious reduction of production add_expr_level -> mult_expr_level
## In state 332, spurious reduction of production cons_expr_level -> add_expr_level
## In state 322, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 352, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 339, spurious reduction of production set_mem_level -> comp_expr_level
## In state 360, spurious reduction of production conj_expr_level -> set_mem_level
## In state 385, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 379, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 387, spurious reduction of production expr -> base_expr(expr)
##

Ill-formed key-value binding in a map.
At this point, if the key is complete, an arrow '->' is expected.

interactive_expr: BigMap LBRACKET UIdent ARROW With
##
## Ends in an error in state: 677.
##
## binding -> expr ARROW . expr [ SEMI RBRACKET ]
##
## The known suffix of the stack is as follows:
## expr ARROW
##

Ill-formed key-value binding in a map.
At this point, the value is expected as an expression.
Note: A binding is made of two expressions (a key and a value)
separated by an arrow '->'.

interactive_expr: Case UIdent Of LBRACKET VBAR With
##
## Ends in an error in state: 686.
##
## case(expr) -> Case expr Of LBRACKET VBAR . cases(expr) RBRACKET [ VBAR Type To Then Step SEMI Recursive RPAR RBRACKET RBRACE Of Module LBRACE Function From End Else EOF Directive Const COMMA Block Begin Attr ARROW ]
##
## The known suffix of the stack is as follows:
## Case expr Of LBRACKET VBAR
##
interactive_expr: Case UIdent Of LBRACKET UIdent ARROW UIdent VBAR With
##
## Ends in an error in state: 694.
##
## nsepseq(case_clause(expr),VBAR) -> case_clause(expr) VBAR . nsepseq(case_clause(expr),VBAR) [ RBRACKET ]
##
## The known suffix of the stack is as follows:
## case_clause(expr) VBAR
##

Ill-formed case expression.
At this point, a clause is expected, starting with a pattern.

interactive_expr: Case UIdent Of LBRACKET UIdent With
##
## Ends in an error in state: 687.
##
## case_clause(expr) -> pattern . ARROW expr [ VBAR RBRACKET ]
##
## The known suffix of the stack is as follows:
## pattern
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 127, spurious reduction of production ctor_app_pattern -> UIdent
## In state 162, spurious reduction of production core_pattern -> ctor_app_pattern
## In state 163, spurious reduction of production pattern -> core_pattern
##

Ill-formed clause of a case expression.
At this point, if the pattern is complete, an arrow '->' is expected,
followed by one of the following:
  * a single instruction;
  * a block of statements (instructions and declarations).

interactive_expr: Case UIdent Of LBRACKET UIdent ARROW With
##
## Ends in an error in state: 688.
##
## case_clause(expr) -> pattern ARROW . expr [ VBAR RBRACKET ]
##
## The known suffix of the stack is as follows:
## pattern ARROW
##

Ill-formed clause of a case expression.
At this point, the right-hand side of the clause is expected as an
expression.

interactive_expr: Record LBRACKET Attr With
##
## Ends in an error in state: 748.
##
## field_path_assignment -> nseq(Attr) . field_path_lhs field_lens expr [ SEMI RBRACKET ]
## field_path_assignment -> nseq(Attr) . field_path_pun [ SEMI RBRACKET ]
##
## The known suffix of the stack is as follows:
## nseq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 83, spurious reduction of production nseq(Attr) -> Attr
##

Ill-formed record expression or patch.
At this point, if the attribute is complete, one of the following is
expected:
  * another attribute;
  * a field name, if defining a record;
  * a selection of a record field in a module, like 'A.B.x';
  * a selection from modules, records or/and tuples, like 'x.y.1.0',
    if defining a patch.

interactive_expr: Record LBRACKET Attr Ident EQ With
##
## Ends in an error in state: 759.
##
## field_path_assignment -> nseq(Attr) field_path_lhs field_lens . expr [ SEMI RBRACKET ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) field_path_lhs field_lens
##
interactive_expr: Record LBRACKET Ident EQ With
##
## Ends in an error in state: 765.
##
## field_path_assignment -> field_path_lhs field_lens . expr [ SEMI RBRACKET ]
##
## The known suffix of the stack is as follows:
## field_path_lhs field_lens
##

Ill-formed record expression or record patch.
At this point, the right-hand side of the field assignment is expected
as an expression.

contract: Function Ident LT With
##
## Ends in an error in state: 114.
##
## chevrons(nsepseq(variable,COMMA)) -> LT . nsepseq(variable,COMMA) GT [ LPAR EQ COLON ASS ]
##
## The known suffix of the stack is as follows:
## LT
##

Ill-formed type parameters.
At this point, type parameters are expected, separated by commas ','.

contract: Function Ident LT Ident With
##
## Ends in an error in state: 115.
##
## nsepseq(variable,COMMA) -> Ident . [ GT ]
## nsepseq(variable,COMMA) -> Ident . COMMA nsepseq(variable,COMMA) [ GT ]
##
## The known suffix of the stack is as follows:
## Ident
##

Ill-formed type parameters.
At this point, one of the following is expected:
  * a comma ',' followed by another type parameter;
  * a closing chevron '>' if there are no more parameters.

contract: Function Ident LT Ident COMMA With
##
## Ends in an error in state: 116.
##
## nsepseq(variable,COMMA) -> Ident COMMA . nsepseq(variable,COMMA) [ GT ]
##
## The known suffix of the stack is as follows:
## Ident COMMA
##

Ill-formed type parameters.
At this point, a type parameter is expected.
