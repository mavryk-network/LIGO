contract: ZWSP
##
## Ends in an error in state: 0.
##
## contract' -> . contract [ # ]
##
## The known suffix of the stack is as follows:
##
##

Ill-formed contract.
At this point, a top-level declaration is expected.

contract: Type ZWSP
##
## Ends in an error in state: 304.
##
## type_decl -> Type . type_binder EQ type_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case Break Attr ]
## type_decl -> Type . type_binder type_vars EQ type_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case Break Attr ]
##
## The known suffix of the stack is as follows:
## Type
##

Ill-formed type declaration.
At this point, a new type name is expected.

contract: Type Ident ZWSP
##
## Ends in an error in state: 309.
##
## type_decl -> Type type_binder . EQ type_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case Break Attr ]
## type_decl -> Type type_binder . type_vars EQ type_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case Break Attr ]
##
## The known suffix of the stack is as follows:
## Type type_binder
##

Ill-formed type declaration.
At this point, one of the following is expected:
  * the assignment symbol '=' followed by a type expression;
  * type parameters (variables) between chevrons ('<', '>') if the
    type is generic.

interactive_expr: LT ZWSP
##
## Ends in an error in state: 83.
##
## chevrons(sep_or_term(type_var,COMMA)) -> LT . sep_or_term(type_var,COMMA) GT [ WILD VBAR UIdent String ParameterOf LPAR LBRACKET LBRACE Int Ident ES6FUN EQ Attr ]
## chevrons(sep_or_term(type_var,COMMA)) -> LT . sep_or_term(type_var,COMMA) GT ZWSP [ WILD VBAR UIdent String ParameterOf LPAR LBRACKET LBRACE Int Ident ES6FUN EQ Attr ]
##
## The known suffix of the stack is as follows:
## LT
##

Ill-formed generic declaration.
At this point, a type parameter is expected as a variable.

interactive_expr: LT Ident ZWSP
##
## Ends in an error in state: 86.
##
## nsepseq(type_var,COMMA) -> type_var . [ GT ]
## nsepseq(type_var,COMMA) -> type_var . COMMA nsepseq(type_var,COMMA) [ GT ]
## nseq(__anonymous_0(type_var,COMMA)) -> type_var . COMMA [ GT ]
## nseq(__anonymous_0(type_var,COMMA)) -> type_var . COMMA nseq(__anonymous_0(type_var,COMMA)) [ GT ]
##
## The known suffix of the stack is as follows:
## type_var
##

Ill-formed generic declaration.
At this point, one of the following is expected:
  * a comma ',' followed by another type parameter (variable);
  * a closing chevron '>' if there are no more parameters.

interactive_expr: LT Ident COMMA ZWSP
##
## Ends in an error in state: 87.
##
## nsepseq(type_var,COMMA) -> type_var COMMA . nsepseq(type_var,COMMA) [ GT ]
## nseq(__anonymous_0(type_var,COMMA)) -> type_var COMMA . [ GT ]
## nseq(__anonymous_0(type_var,COMMA)) -> type_var COMMA . nseq(__anonymous_0(type_var,COMMA)) [ GT ]
##
## The known suffix of the stack is as follows:
## type_var COMMA
##

Ill-formed generic declaration.
At this point, one of the following is expected:
  * another type parameter (variable);
  * a closing chevron '>' if there are no more parameters.

contract: Type Ident EQ ZWSP
##
## Ends in an error in state: 310.
##
## type_decl -> Type type_binder EQ . type_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case Break Attr ]
##
## The known suffix of the stack is as follows:
## Type type_binder EQ
##

Ill-formed type declaration.
At this point, a type expression is expected.

interactive_expr: UIdent As VBAR ZWSP
##
## Ends in an error in state: 142.
##
## nseq(__anonymous_1(object_type,VBAR)) -> VBAR . object_type [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If GT For Export Else EQ EOF Default Continue Const Case COMMA COLON Break Attr ]
## nseq(__anonymous_1(object_type,VBAR)) -> VBAR . object_type nseq(__anonymous_1(object_type,VBAR)) [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If GT For Export Else EQ EOF Default Continue Const Case COMMA COLON Break Attr ]
## nseq(__anonymous_3) -> VBAR . variant [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If GT For Export Else EQ EOF Default Continue Const Case COMMA COLON Break Attr ]
## nseq(__anonymous_3) -> VBAR . variant nseq(__anonymous_3) [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If GT For Export Else EQ EOF Default Continue Const Case COMMA COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## VBAR
##

Ill-formed variant or union type.
At this point, one of the following is expected:
  * an object type, starting with an opening brace '{';
  * a variant, starting with an opening bracket '['.

interactive_expr: UIdent As VBAR LBRACKET ZWSP
##
## Ends in an error in state: 143.
##
## brackets(variant_comp) -> LBRACKET . String RBRACKET [ While When VBAR Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If GT For Export Else EQ EOF Default Continue Const Case COMMA COLON Break Attr ]
## brackets(variant_comp) -> LBRACKET . String COMMA ctor_params RBRACKET [ While When VBAR Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If GT For Export Else EQ EOF Default Continue Const Case COMMA COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## LBRACKET
##

Ill-formed variant.
At this point, a data constructor is expected as a string.

interactive_expr: UIdent As LBRACKET String ZWSP
##
## Ends in an error in state: 144.
##
## brackets(variant_comp) -> LBRACKET String . RBRACKET [ While When VBAR Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If GT For Export Else EQ EOF Default Continue Const Case COMMA COLON Break Attr ]
## brackets(variant_comp) -> LBRACKET String . COMMA ctor_params RBRACKET [ While When VBAR Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If GT For Export Else EQ EOF Default Continue Const Case COMMA COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## LBRACKET String
##

Ill-formed variant.
At this point, one of the following is expected:
  * a comma ',' followed by a constructor argument as a type
    expression;
  * a closing bracket ']' if the constructor is constant (no
    argument).

interactive_expr: UIdent As LBRACKET String COMMA ZWSP
##
## Ends in an error in state: 146.
##
## brackets(variant_comp) -> LBRACKET String COMMA . ctor_params RBRACKET [ While When VBAR Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If GT For Export Else EQ EOF Default Continue Const Case COMMA COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## LBRACKET String COMMA
##

Ill-formed variant.
At this point, the first constructor's argument is expected as a type
expression

interactive_expr: UIdent As ParameterOf ZWSP
##
## Ends in an error in state: 149.
##
## parameter_of_type -> ParameterOf . namespace_selection [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If GT For Export Else EQ EOF Default Continue Const Case COMMA COLON Break Attr ARROW ]
##
## The known suffix of the stack is as follows:
## ParameterOf
##

Ill-formed parameter of a contract.
At this point, one of the following is expected:
  * a namespace name;
  * a qualified namespace (e.g. 'A.B.C').

interactive_expr: ContractOf LPAR UIdent DOT ZWSP
##
## Ends in an error in state: 154.
##
## namespace_path(namespace_name) -> namespace_name DOT . namespace_path(namespace_name) [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If GT For Export Else EQ EOF Default Continue Const Case COMMA COLON Break Attr ARROW ]
## namespace_path(namespace_name) -> namespace_name DOT . namespace_name [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If GT For Export Else EQ EOF Default Continue Const Case COMMA COLON Break Attr ARROW ]
##
## The known suffix of the stack is as follows:
## namespace_name DOT
##

Ill-formed namespace selection.
At this point, a namespace name is expected.

interactive_expr: UIdent As LPAR ZWSP
##
## Ends in an error in state: 157.
##
## par(type_expr) -> LPAR . type_expr RPAR [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If GT For Export Else EQ EOF Default Continue Const Case COMMA COLON Break Attr ARROW ]
## par(type_expr) -> LPAR . type_expr PARAMS RPAR [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If GT For Export Else EQ EOF Default Continue Const Case COMMA COLON Break Attr ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR
##

Ill-formed parenthesised type expression.
At this point, a type expression is expected.

interactive_expr: UIdent As LBRACKET ZWSP
##
## Ends in an error in state: 158.
##
## brackets(type_elements) -> LBRACKET . type_elements RBRACKET [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If GT For Export Else EQ EOF Default Continue Const Case COMMA COLON Break Attr ]
## brackets(variant_comp) -> LBRACKET . String RBRACKET [ While When VBAR Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If GT For Export Else EQ EOF Default Continue Const Case COMMA COLON Break Attr ]
## brackets(variant_comp) -> LBRACKET . String COMMA ctor_params RBRACKET [ While When VBAR Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If GT For Export Else EQ EOF Default Continue Const Case COMMA COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## LBRACKET
##

Ill-formed array type or variant.
At this point, one of the following is expected:
  * a data constructor as a string, if defining a variant type;
  * the type of the first element of an array type.

interactive_expr: UIdent As LBRACE ZWSP
##
## Ends in an error in state: 159.
##
## braces(sep_or_term(property_decl,property_sep)) -> LBRACE . sep_or_term(property_decl,property_sep) RBRACE [ While When VBAR Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If GT For Export Else EQ EOF Default Continue Const Case COMMA COLON Break Attr ARROW ]
##
## The known suffix of the stack is as follows:
## LBRACE
##
interactive_expr: UIdent As LBRACE Attr ZWSP
##
## Ends in an error in state: 160.
##
## property_decl -> Attr . property_decl [ SEMI RBRACE COMMA ]
##
## The known suffix of the stack is as follows:
## Attr
##

Ill-formed object type.
At this point, one of the following is expected:
  * a property name,
  * an integer denoting the property,
  * a string denoting the property.

interactive_expr: UIdent As LBRACE Ident ZWSP
##
## Ends in an error in state: 161.
##
## property_decl -> property_id . [ SEMI RBRACE COMMA ]
## property_decl -> property_id . type_annotation(type_expr) [ SEMI RBRACE COMMA ]
##
## The known suffix of the stack is as follows:
## property_id
##

Ill-formed object type.
At thuis point, one of the following is expected:
  * a property separator (',' or ';');
  * a closing brace '}' if no more properties;
  * a colon ':' followed by the type of the property.

interactive_expr: ES6FUN LPAR Ident COLON ZWSP
##
## Ends in an error in state: 140.
##
## type_annotation(type_expr) -> COLON . type_expr [ SEMI RPAR RBRACE PARAMS COMMA ]
##
## The known suffix of the stack is as follows:
## COLON
##

Ill-formed type annotation.
At this point, a type expression is expected.

interactive_expr: UIdent As ES6FUN ZWSP
##
## Ends in an error in state: 175.
##
## fun_type -> ES6FUN . fun_type_params ARROW type_expr [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If GT For Export Else EQ EOF Default Continue Const Case COMMA COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## ES6FUN
##

Ill-formed function type.
At this point, an opening parenthesis '(' is expected.

interactive_expr: UIdent As ES6FUN LPAR ZWSP
##
## Ends in an error in state: 176.
##
## par(sep_or_term(fun_type_param,COMMA)) -> LPAR . sep_or_term(fun_type_param,COMMA) RPAR [ ARROW ]
## par(sep_or_term(fun_type_param,COMMA)) -> LPAR . sep_or_term(fun_type_param,COMMA) PARAMS RPAR [ ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR
##

Ill-formed function type.
At this point, one of the following is expected:
  * the first parameter (variable);
  * a closing parenthesis ')' if no parameters.

interactive_expr: UIdent As ES6FUN LPAR Ident ZWSP
##
## Ends in an error in state: 177.
##
## fun_type_param -> Ident . type_annotation(type_expr) [ RPAR PARAMS COMMA ]
##
## The known suffix of the stack is as follows:
## Ident
##

Ill-formed function type.
At this point, a colon ':' is expected, followed by the type of the
parameter.

interactive_expr: UIdent As ES6FUN LPAR PARAMS ZWSP
##
## Ends in an error in state: 181.
##
## par(sep_or_term(fun_type_param,COMMA)) -> LPAR sep_or_term(fun_type_param,COMMA) PARAMS . RPAR [ ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR sep_or_term(fun_type_param,COMMA) PARAMS
##

Ill-formed function type.
At this point, a closing parenthesis ')' is expected.

interactive_expr: UIdent As ES6FUN LPAR Ident COLON Ident XOR
##
## Ends in an error in state: 186.
##
## nsepseq(fun_type_param,COMMA) -> fun_type_param . [ RPAR PARAMS ]
## nsepseq(fun_type_param,COMMA) -> fun_type_param . COMMA nsepseq(fun_type_param,COMMA) [ RPAR PARAMS ]
## nseq(__anonymous_0(fun_type_param,COMMA)) -> fun_type_param . COMMA [ RPAR PARAMS ]
## nseq(__anonymous_0(fun_type_param,COMMA)) -> fun_type_param . COMMA nseq(__anonymous_0(fun_type_param,COMMA)) [ RPAR PARAMS ]
##
## The known suffix of the stack is as follows:
## fun_type_param
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 174, spurious reduction of production type_name -> Ident
## In state 196, spurious reduction of production no_par_type_expr -> type_name
## In state 227, spurious reduction of production core_type_no_string -> no_par_type_expr
## In state 237, spurious reduction of production core_type -> core_type_no_string
## In state 238, spurious reduction of production type_expr -> core_type
## In state 287, spurious reduction of production type_annotation(type_expr) -> COLON type_expr
## In state 178, spurious reduction of production fun_type_param -> Ident type_annotation(type_expr)
##

Ill-formed function type.
At this point, one of the following is expected:
  * a comma ',' followed by another parameter;
  * a closing parenthesis ')', if no more parameters.

interactive_expr: UIdent As ES6FUN LPAR Ident COLON Ident COMMA ZWSP
##
## Ends in an error in state: 187.
##
## nsepseq(fun_type_param,COMMA) -> fun_type_param COMMA . nsepseq(fun_type_param,COMMA) [ RPAR PARAMS ]
## nseq(__anonymous_0(fun_type_param,COMMA)) -> fun_type_param COMMA . [ RPAR PARAMS ]
## nseq(__anonymous_0(fun_type_param,COMMA)) -> fun_type_param COMMA . nseq(__anonymous_0(fun_type_param,COMMA)) [ RPAR PARAMS ]
##
## The known suffix of the stack is as follows:
## fun_type_param COMMA
##

Ill-formed function type.
At this point, one of the following is expected:
  * another parameter as a variable;
  * a closing parenthesis ')' if no more parameters.

interactive_expr: UIdent As ES6FUN LPAR PARAMS RPAR ZWSP
##
## Ends in an error in state: 191.
##
## fun_type -> ES6FUN fun_type_params . ARROW type_expr [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If GT For Export Else EQ EOF Default Continue Const Case COMMA COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## ES6FUN fun_type_params
##

Ill-formed function type.
At this point, an arrow '=>' is expected, followed by the return type.

interactive_expr: UIdent As ES6FUN LPAR PARAMS RPAR ARROW ZWSP
##
## Ends in an error in state: 192.
##
## fun_type -> ES6FUN fun_type_params ARROW . type_expr [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If GT For Export Else EQ EOF Default Continue Const Case COMMA COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## ES6FUN fun_type_params ARROW
##

Ill-formed function type.
At this point, the return type is expected.

interactive_expr: UIdent As Attr ZWSP
##
## Ends in an error in state: 193.
##
## attr_type -> Attr . core_type_no_string [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If GT For Export Else EQ EOF Default Continue Const Case COMMA COLON Break Attr ]
## attr_variant -> Attr . attr_variant [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If GT For Export Else EQ EOF Default Continue Const Case COMMA COLON Break Attr ]
## variant -> Attr . variant [ While When VBAR Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If GT For Export Else EQ EOF Default Continue Const Case COMMA COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## Attr
##

Ill-formed decorated type or variant.
At this point, one of the following is expected:
  * another decorator;
  * a type expression;
  * a variant starting with an opening bracket '['.

interactive_expr: UIdent As Ident LT ZWSP
##
## Ends in an error in state: 199.
##
## chevrons(nsep_or_term(type_ctor_arg(type_expr),COMMA)) -> LT . nsep_or_term(type_ctor_arg(type_expr),COMMA) GT [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If GT For Export Else EQ EOF Default Continue Const Case COMMA COLON Break Attr ARROW ]
## chevrons(nsep_or_term(type_ctor_arg(type_expr),COMMA)) -> LT . nsep_or_term(type_ctor_arg(type_expr),COMMA) GT ZWSP [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If GT For Export Else EQ EOF Default Continue Const Case COMMA COLON Break Attr ARROW ]
##
## The known suffix of the stack is as follows:
## LT
##

Ill-formed generic type.
At this point, a type argument is expected as a type expression.

interactive_expr: UIdent As LBRACKET String RBRACKET VBAR ZWSP
##
## Ends in an error in state: 202.
##
## nsepseq(variant,VBAR) -> variant VBAR . nsepseq(variant,VBAR) [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If GT For Export Else EQ EOF Default Continue Const Case COMMA COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## variant VBAR
##
interactive_expr: UIdent As VBAR Attr ZWSP
##
## Ends in an error in state: 203.
##
## variant -> Attr . variant [ While When VBAR Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If GT For Export Else EQ EOF Default Continue Const Case COMMA COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## Attr
##

Ill-formed variant type.
At his point, a variant is expected to start with an opening bracket '['.

interactive_expr: UIdent As Ident LT Ident XOR
##
## Ends in an error in state: 207.
##
## nsepseq(type_ctor_arg(type_expr),COMMA) -> type_ctor_arg(type_expr) . [ GT ]
## nsepseq(type_ctor_arg(type_expr),COMMA) -> type_ctor_arg(type_expr) . COMMA nsepseq(type_ctor_arg(type_expr),COMMA) [ GT ]
## nseq(__anonymous_0(type_ctor_arg(type_expr),COMMA)) -> type_ctor_arg(type_expr) . COMMA [ GT ]
## nseq(__anonymous_0(type_ctor_arg(type_expr),COMMA)) -> type_ctor_arg(type_expr) . COMMA nseq(__anonymous_0(type_ctor_arg(type_expr),COMMA)) [ GT ]
##
## The known suffix of the stack is as follows:
## type_ctor_arg(type_expr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 174, spurious reduction of production type_name -> Ident
## In state 196, spurious reduction of production no_par_type_expr -> type_name
## In state 227, spurious reduction of production core_type_no_string -> no_par_type_expr
## In state 237, spurious reduction of production core_type -> core_type_no_string
## In state 238, spurious reduction of production type_expr -> core_type
## In state 206, spurious reduction of production type_ctor_arg(type_expr) -> type_expr
##

Ill-formed generic type.
At this point, one of the following is expected:
  * a comma ',' followed by another type argument as a type
    expression;
  * a closing chevron '>' if no more arguments.

interactive_expr: UIdent As Ident LT Ident COMMA ZWSP
##
## Ends in an error in state: 208.
##
## nsepseq(type_ctor_arg(type_expr),COMMA) -> type_ctor_arg(type_expr) COMMA . nsepseq(type_ctor_arg(type_expr),COMMA) [ GT ]
## nseq(__anonymous_0(type_ctor_arg(type_expr),COMMA)) -> type_ctor_arg(type_expr) COMMA . [ GT ]
## nseq(__anonymous_0(type_ctor_arg(type_expr),COMMA)) -> type_ctor_arg(type_expr) COMMA . nseq(__anonymous_0(type_ctor_arg(type_expr),COMMA)) [ GT ]
##
## The known suffix of the stack is as follows:
## type_ctor_arg(type_expr) COMMA
##

Ill-formed generic type.
At his point, one of the following is expected:
  * a type argument as a type expression;
  * a closing chevron '>' if no more arguments.

interactive_expr: UIdent As LBRACE RBRACE VBAR ZWSP
##
## Ends in an error in state: 217.
##
## nsepseq(object_type,VBAR) -> object_type VBAR . nsepseq(object_type,VBAR) [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If GT For Export Else EQ EOF Default Continue Const Case COMMA COLON Break Attr ARROW ]
##
## The known suffix of the stack is as follows:
## object_type VBAR
##

Ill-formed object type.
At this point, an object type is expected to start with an opening
brace '{'.

interactive_expr: UIdent As UIdent DOT ZWSP
##
## Ends in an error in state: 231.
##
## namespace_path(__anonymous_4) -> namespace_name DOT . namespace_path(__anonymous_4) [ LT ]
## namespace_path(__anonymous_4) -> namespace_name DOT . type_ctor [ LT ]
## namespace_path(__anonymous_5) -> namespace_name DOT . namespace_path(__anonymous_5) [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If GT For Export Else EQ EOF Default Continue Const Case COMMA COLON Break Attr ARROW ]
## namespace_path(__anonymous_5) -> namespace_name DOT . type_name [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If GT For Export Else EQ EOF Default Continue Const Case COMMA COLON Break Attr ARROW ]
##
## The known suffix of the stack is as follows:
## namespace_name DOT
##

Ill-formed selection of a type in a namespace.
At this point, one of the following is expected:
  * a type name,
  * another namespace name.

interactive_expr: UIdent As LBRACE Ident COLON Ident XOR
##
## Ends in an error in state: 166.
##
## nsepseq(property_decl,property_sep) -> property_decl . [ RBRACE ]
## nsepseq(property_decl,property_sep) -> property_decl . property_sep nsepseq(property_decl,property_sep) [ RBRACE ]
## nseq(__anonymous_0(property_decl,property_sep)) -> property_decl . property_sep [ RBRACE ]
## nseq(__anonymous_0(property_decl,property_sep)) -> property_decl . property_sep nseq(__anonymous_0(property_decl,property_sep)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## property_decl
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 174, spurious reduction of production type_name -> Ident
## In state 196, spurious reduction of production no_par_type_expr -> type_name
## In state 227, spurious reduction of production core_type_no_string -> no_par_type_expr
## In state 237, spurious reduction of production core_type -> core_type_no_string
## In state 238, spurious reduction of production type_expr -> core_type
## In state 287, spurious reduction of production type_annotation(type_expr) -> COLON type_expr
## In state 162, spurious reduction of production property_decl -> property_id type_annotation(type_expr)
##

Ill-formed object type.
At this point, one of the following is expected:
  * a property separator (';' or ',') followed by another property
    declaration;
  * a closing brace '}' if no more properties.

interactive_expr: UIdent As LBRACE Ident COMMA ZWSP
##
## Ends in an error in state: 167.
##
## nsepseq(property_decl,property_sep) -> property_decl property_sep . nsepseq(property_decl,property_sep) [ RBRACE ]
## nseq(__anonymous_0(property_decl,property_sep)) -> property_decl property_sep . [ RBRACE ]
## nseq(__anonymous_0(property_decl,property_sep)) -> property_decl property_sep . nseq(__anonymous_0(property_decl,property_sep)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## property_decl property_sep
##

Ill-formed object type.
At this point, one of the following is expected:
  * another property declaration;
  * a closing brace '}' if no more properties.

interactive_expr: UIdent As LBRACKET Ident XOR
##
## Ends in an error in state: 255.
##
## type_elements -> type_element_no_string . [ RBRACKET ]
## type_elements -> type_element_no_string . COMMA nsep_or_term(type_element,COMMA) [ RBRACKET ]
##
## The known suffix of the stack is as follows:
## type_element_no_string
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 174, spurious reduction of production type_name -> Ident
## In state 196, spurious reduction of production no_par_type_expr -> type_name
## In state 227, spurious reduction of production core_type_no_string -> no_par_type_expr
## In state 266, spurious reduction of production type_element_no_string -> core_type_no_string
##
interactive_expr: UIdent As LBRACKET Ident COMMA Ident XOR
##
## Ends in an error in state: 258.
##
## nsepseq(type_element,COMMA) -> type_element . [ RBRACKET ]
## nsepseq(type_element,COMMA) -> type_element . COMMA nsepseq(type_element,COMMA) [ RBRACKET ]
## nseq(__anonymous_0(type_element,COMMA)) -> type_element . COMMA [ RBRACKET ]
## nseq(__anonymous_0(type_element,COMMA)) -> type_element . COMMA nseq(__anonymous_0(type_element,COMMA)) [ RBRACKET ]
##
## The known suffix of the stack is as follows:
## type_element
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 174, spurious reduction of production type_name -> Ident
## In state 196, spurious reduction of production no_par_type_expr -> type_name
## In state 227, spurious reduction of production core_type_no_string -> no_par_type_expr
## In state 237, spurious reduction of production core_type -> core_type_no_string
## In state 238, spurious reduction of production type_expr -> core_type
## In state 257, spurious reduction of production type_element -> type_expr
##

Ill-formed array type.
At this point, if the type element is complete, one of the following
is expected:
  * a comma ',' followed by the type of the next element;
  * a closing bracket ']' if no more elements.

interactive_expr: UIdent As LBRACKET Ident COMMA ZWSP
##
## Ends in an error in state: 256.
##
## type_elements -> type_element_no_string COMMA . nsep_or_term(type_element,COMMA) [ RBRACKET ]
##
## The known suffix of the stack is as follows:
## type_element_no_string COMMA
##

Ill-formed array type.
At this point, the type of an element is expected.

interactive_expr: UIdent As LBRACKET Ident COMMA Ident COMMA ZWSP
##
## Ends in an error in state: 259.
##
## nsepseq(type_element,COMMA) -> type_element COMMA . nsepseq(type_element,COMMA) [ RBRACKET ]
## nseq(__anonymous_0(type_element,COMMA)) -> type_element COMMA . [ RBRACKET ]
## nseq(__anonymous_0(type_element,COMMA)) -> type_element COMMA . nseq(__anonymous_0(type_element,COMMA)) [ RBRACKET ]
##
## The known suffix of the stack is as follows:
## type_element COMMA
##

Ill-formed array type.
At this point, one of the following is expected:
  * the type of the next element;
  * a closing bracket ']' if no more elements.

interactive_expr: UIdent As LPAR Ident XOR
##
## Ends in an error in state: 267.
##
## par(type_expr) -> LPAR type_expr . RPAR [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If GT For Export Else EQ EOF Default Continue Const Case COMMA COLON Break Attr ARROW ]
## par(type_expr) -> LPAR type_expr . PARAMS RPAR [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If GT For Export Else EQ EOF Default Continue Const Case COMMA COLON Break Attr ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR type_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 174, spurious reduction of production type_name -> Ident
## In state 196, spurious reduction of production no_par_type_expr -> type_name
## In state 227, spurious reduction of production core_type_no_string -> no_par_type_expr
## In state 237, spurious reduction of production core_type -> core_type_no_string
## In state 238, spurious reduction of production type_expr -> core_type
##

Ill-formed parenthesised type expression.
At this point, if the type expression is complete, a closing
parenthesis ')' is expected.

interactive_expr: UIdent As LPAR Ident PARAMS ZWSP
##
## Ends in an error in state: 269.
##
## par(type_expr) -> LPAR type_expr PARAMS . RPAR [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If GT For Export Else EQ EOF Default Continue Const Case COMMA COLON Break Attr ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR type_expr PARAMS
##

Ill-formed parenthesised type expression.
At this point, a closing parenthesis ')' is expected.

interactive_expr: UIdent As LBRACKET String COMMA Ident XOR
##
## Ends in an error in state: 277.
##
## nsepseq(ctor_param,COMMA) -> ctor_param . [ RBRACKET ]
## nsepseq(ctor_param,COMMA) -> ctor_param . COMMA nsepseq(ctor_param,COMMA) [ RBRACKET ]
## nseq(__anonymous_0(ctor_param,COMMA)) -> ctor_param . COMMA [ RBRACKET ]
## nseq(__anonymous_0(ctor_param,COMMA)) -> ctor_param . COMMA nseq(__anonymous_0(ctor_param,COMMA)) [ RBRACKET ]
##
## The known suffix of the stack is as follows:
## ctor_param
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 174, spurious reduction of production type_name -> Ident
## In state 196, spurious reduction of production no_par_type_expr -> type_name
## In state 227, spurious reduction of production core_type_no_string -> no_par_type_expr
## In state 237, spurious reduction of production core_type -> core_type_no_string
## In state 238, spurious reduction of production type_expr -> core_type
## In state 271, spurious reduction of production ctor_param -> type_expr
##

Ill-formed variant type.
At this point, one of the following is expected:
  * a comma ',' followed by another constructor parameter as a type
    expression;
  * a closing bracket ']' if no more parameters.

interactive_expr: UIdent As LBRACKET String COMMA Ident COMMA ZWSP
##
## Ends in an error in state: 278.
##
## nsepseq(ctor_param,COMMA) -> ctor_param COMMA . nsepseq(ctor_param,COMMA) [ RBRACKET ]
## nseq(__anonymous_0(ctor_param,COMMA)) -> ctor_param COMMA . [ RBRACKET ]
## nseq(__anonymous_0(ctor_param,COMMA)) -> ctor_param COMMA . nseq(__anonymous_0(ctor_param,COMMA)) [ RBRACKET ]
##
## The known suffix of the stack is as follows:
## ctor_param COMMA
##

Ill-formed variant type.
At this point, one of the following is expected:
  * a constructor parameter as a type expression;
  * a closing bracket ']' if no more parameters.

interactive_expr: UIdent As VBAR LBRACKET String RBRACKET VBAR ZWSP
##
## Ends in an error in state: 282.
##
## nseq(__anonymous_3) -> VBAR . variant [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If GT For Export Else EQ EOF Default Continue Const Case COMMA COLON Break Attr ]
## nseq(__anonymous_3) -> VBAR . variant nseq(__anonymous_3) [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If GT For Export Else EQ EOF Default Continue Const Case COMMA COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## VBAR
##

Ill-formed variant type.
At this point, a variant is expected to start with an opening bracket '['.

interactive_expr: UIdent As VBAR LBRACKET String RBRACKET ZWSP
##
## Ends in an error in state: 1112.
##
## interactive_expr -> expr . EOF [ # ]
##
## The known suffix of the stack is as follows:
## expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 281, spurious reduction of production nseq(__anonymous_3) -> VBAR variant
## In state 220, spurious reduction of production attr_variant -> nseq(__anonymous_3)
## In state 240, spurious reduction of production variant_type -> attr_variant
## In state 200, spurious reduction of production type_expr -> variant_type
## In state 493, spurious reduction of production typed_expr -> app_expr_level As type_expr
## In state 375, spurious reduction of production non_object_expr -> typed_expr
## In state 466, spurious reduction of production no_attr_expr -> non_object_expr
## In state 467, spurious reduction of production expr -> no_attr_expr
##

Ill-formed expression.
At this point, if the expression is complete, the end of the input is
expected.

interactive_expr: UIdent As VBAR LBRACE RBRACE VBAR ZWSP
##
## Ends in an error in state: 285.
##
## nseq(__anonymous_1(object_type,VBAR)) -> VBAR . object_type [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If GT For Export Else EQ EOF Default Continue Const Case COMMA COLON Break Attr ARROW ]
## nseq(__anonymous_1(object_type,VBAR)) -> VBAR . object_type nseq(__anonymous_1(object_type,VBAR)) [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If GT For Export Else EQ EOF Default Continue Const Case COMMA COLON Break Attr ARROW ]
##
## The known suffix of the stack is as follows:
## VBAR
##

Ill-formed union type.
At this point, an object type is expected.

contract: Type Ident LT GT XOR
##
## Ends in an error in state: 312.
##
## type_decl -> Type type_binder type_vars . EQ type_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case Break Attr ]
##
## The known suffix of the stack is as follows:
## Type type_binder type_vars
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 91, spurious reduction of production chevrons(sep_or_term(type_var,COMMA)) -> LT sep_or_term(type_var,COMMA) GT
## In state 315, spurious reduction of production type_vars -> chevrons(sep_or_term(type_var,COMMA))
##

Ill-formed generic type declaration.
At this point, if the type parameters are complete, the assignment
symbol '=' is expected, followed by a type expression.

contract: Type Ident LT GT EQ ZWSP
##
## Ends in an error in state: 313.
##
## type_decl -> Type type_binder type_vars EQ . type_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case Break Attr ]
##
## The known suffix of the stack is as follows:
## Type type_binder type_vars EQ
##

Ill-formed generic type declaration.
At this point, a type expression is expected.

contract: Namespace ZWSP
##
## Ends in an error in state: 563.
##
## namespace_decl -> Namespace . namespace_binder braces(statements) [ While Verbatim UIdent Type True Switch String SEMI_ELSE SEMI Return RBRACE PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export Else EOF Directive Default Continue Const Case Bytes Break Attr ]
## namespace_decl -> Namespace . namespace_binder interface braces(statements) [ While Verbatim UIdent Type True Switch String SEMI_ELSE SEMI Return RBRACE PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export Else EOF Directive Default Continue Const Case Bytes Break Attr ]
##
## The known suffix of the stack is as follows:
## Namespace
##

Ill-formed namespace declaration.
At this point, a namespace name is expected.

contract: Namespace UIdent ZWSP
##
## Ends in an error in state: 566.
##
## namespace_decl -> Namespace namespace_binder . braces(statements) [ While Verbatim UIdent Type True Switch String SEMI_ELSE SEMI Return RBRACE PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export Else EOF Directive Default Continue Const Case Bytes Break Attr ]
## namespace_decl -> Namespace namespace_binder . interface braces(statements) [ While Verbatim UIdent Type True Switch String SEMI_ELSE SEMI Return RBRACE PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export Else EOF Directive Default Continue Const Case Bytes Break Attr ]
##
## The known suffix of the stack is as follows:
## Namespace namespace_binder
##

Ill-formed namespace declaration.
At this point, one of the following is expected:
  * the keyword 'implements' followed by an interface;
  * a block of statements starting with an opening brace '{'.

contract: Namespace UIdent LBRACE ZWSP
##
## Ends in an error in state: 303.
##
## braces(statements) -> LBRACE . statements RBRACE [ While When Verbatim UIdent Type True Switch String SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PLUS2 PARAMS Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export Else EOF Directive Default Continue Const Case COMMA COLON Bytes Break Attr ]
##
## The known suffix of the stack is as follows:
## LBRACE
##

Ill-formed block of statements.
At this point, a statement is expected.

contract: Namespace UIdent LBRACE While ZWSP
##
## Ends in an error in state: 1.
##
## while_stmt(poly_stmt) -> While . par(while_cond) poly_stmt [ While Verbatim UIdent Type True Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export Directive Continue Const Bytes Break Attr ]
## while_stmt(statement) -> While . par(while_cond) statement [ SEMI RBRACE EOF Default Case ]
## while_stmt(stmt_ending_with_expr) -> While . par(while_cond) stmt_ending_with_expr [ While Type Switch Return Namespace Let LBRACE Interface Import If For Export Continue Const Break Attr ]
##
## The known suffix of the stack is as follows:
## While
##

Ill-formed while-loop.
At this point, the condition between parentheses is expected.

contract: Namespace UIdent LBRACE While LPAR ZWSP
##
## Ends in an error in state: 2.
##
## par(while_cond) -> LPAR . while_cond RPAR [ While Verbatim UIdent Type True Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export Directive Continue Const Bytes Break Attr ]
## par(while_cond) -> LPAR . while_cond PARAMS RPAR [ While Verbatim UIdent Type True Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export Directive Continue Const Bytes Break Attr ]
##
## The known suffix of the stack is as follows:
## LPAR
##

Ill-formed while-loop.
At this point, the condition is expected as a boolean expression.

interactive_expr: PLUS2 ZWSP
##
## Ends in an error in state: 7.
##
## pre_incr_expr -> PLUS2 . Ident [ XOR While When VBAR Type TIMES Switch SLASH SEMI_ELSE SEMI Return RPAR REM RBRACKET RBRACE QMARK PLUS PARAMS OR Namespace NE MINUS Let LT LE LBRACE Interface Import If GT For Export Else EQ2 EOF Default Continue Const Case COMMA COLON Break BIT_XOR BIT_SR BIT_SL BIT_AND Attr AND ]
##
## The known suffix of the stack is as follows:
## PLUS2
##

Ill-formed increment.
At this point, the incremented variable is expected.

interactive_expr: LPAR ZWSP
##
## Ends in an error in state: 12.
##
## par(expr) -> LPAR . expr RPAR [ XOR While When VBAR Type TIMES Switch SLASH SEMI_ELSE SEMI Return RPAR REM RBRACKET RBRACE QMARK PLUS PARAMS OR Namespace NE MINUS Let LT LPAR LE LBRACKET LBRACE Interface Import If GT For Export Else EQ2 EOF Default DOT Continue Const Case COMMA COLON Break BIT_XOR BIT_SR BIT_SL BIT_AND Attr As AND ]
## par(expr) -> LPAR . expr PARAMS RPAR [ XOR While When VBAR Type TIMES Switch SLASH SEMI_ELSE SEMI Return RPAR REM RBRACKET RBRACE QMARK PLUS PARAMS OR Namespace NE MINUS Let LT LPAR LE LBRACKET LBRACE Interface Import If GT For Export Else EQ2 EOF Default DOT Continue Const Case COMMA COLON Break BIT_XOR BIT_SR BIT_SL BIT_AND Attr As AND ]
##
## The known suffix of the stack is as follows:
## LPAR
##

Ill-formed parenthesised expression.
At this point, an expression is expected.

interactive_expr: Match ZWSP
##
## Ends in an error in state: 13.
##
## match_expr -> Match . match_subject braces(match_clauses) [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COMMA COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## Match
##

Ill-formed pattern matching.
At this point, the matched expression is expected.

interactive_expr: Match LPAR UIdent RPAR ZWSP
##
## Ends in an error in state: 15.
##
## match_expr -> Match match_subject . braces(match_clauses) [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COMMA COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## Match match_subject
##

Ill-formed pattern matching.
At this point, an opening brace '{' is expected.

interactive_expr: Match LPAR UIdent RPAR LBRACE ZWSP
##
## Ends in an error in state: 16.
##
## braces(match_clauses) -> LBRACE . match_clauses RBRACE [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COMMA COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## LBRACE
##

Ill-formed pattern matching.
At this point, one of the following is expected:
  * the keyword 'when' for a normal clause;
  * the keyword 'default' for the default clause.

interactive_expr: Match LPAR UIdent RPAR LBRACE When ZWSP
##
## Ends in an error in state: 17.
##
## match_clause -> When . par(pattern) COLON expr [ When RBRACE Default ]
## match_clause -> When . par(pattern) COLON expr SEMI [ When RBRACE Default ]
##
## The known suffix of the stack is as follows:
## When
##

Ill-formed pattern matching.
At this point, a pattern is expected between parentheses.

interactive_expr: Match LPAR UIdent RPAR LBRACE When LPAR ZWSP
##
## Ends in an error in state: 18.
##
## par(pattern) -> LPAR . pattern RPAR [ COLON ]
## par(pattern) -> LPAR . pattern PARAMS RPAR [ COLON ]
##
## The known suffix of the stack is as follows:
## LPAR
##

Ill-formed pattern matching.
At his point, a pattern for the clause is expected.

contract: Const LBRACKET ZWSP
##
## Ends in an error in state: 26.
##
## brackets(sep_or_term(element(pattern),COMMA)) -> LBRACKET . sep_or_term(element(pattern),COMMA) RBRACKET [ SEMI RPAR RBRACKET RBRACE PARAMS EQ COMMA COLON ]
##
## The known suffix of the stack is as follows:
## LBRACKET
##
interactive_expr: ES6FUN LPAR LBRACKET ZWSP
##
## Ends in an error in state: 105.
##
## brackets(sep_or_term(element(param_pattern),COMMA)) -> LBRACKET . sep_or_term(element(param_pattern),COMMA) RBRACKET [ SEMI RPAR RBRACKET RBRACE PARAMS COMMA COLON ]
##
## The known suffix of the stack is as follows:
## LBRACKET
##

Ill-formed array pattern.
At this point, a pattern matching the first element is expected.

contract: Const LBRACE ZWSP
##
## Ends in an error in state: 27.
##
## braces(sep_or_term(property_pattern(pattern),property_sep)) -> LBRACE . sep_or_term(property_pattern(pattern),property_sep) RBRACE [ SEMI RPAR RBRACKET RBRACE PARAMS EQ COMMA COLON ]
##
## The known suffix of the stack is as follows:
## LBRACE
##
interactive_expr: ES6FUN LPAR LBRACE ZWSP
##
## Ends in an error in state: 106.
##
## braces(sep_or_term(property_pattern(param_pattern),property_sep)) -> LBRACE . sep_or_term(property_pattern(param_pattern),property_sep) RBRACE [ SEMI RPAR RBRACKET RBRACE PARAMS COMMA COLON ]
##
## The known suffix of the stack is as follows:
## LBRACE
##

Ill-formed object pattern.
At this point, a pattern for the first property is expected.

contract: Const LBRACE Attr ZWSP
##
## Ends in an error in state: 32.
##
## property_pattern(pattern) -> Attr . property_pattern(pattern) [ SEMI RBRACE COMMA ]
##
## The known suffix of the stack is as follows:
## Attr
##

Ill-formed decorated property pattern.
At this point, one of the following is expected:
  * another decorator;
  * a property name;
  * an integer denoting the property;
  * a string denoting the property.

contract: Const LBRACE Ident ZWSP
##
## Ends in an error in state: 35.
##
## property_pattern(pattern) -> property_id . [ SEMI RBRACE COMMA ]
## property_pattern(pattern) -> property_id . COLON pattern [ SEMI RBRACE COMMA ]
##
## The known suffix of the stack is as follows:
## property_id
##
interactive_expr: ES6FUN LPAR LBRACE Ident ZWSP
##
## Ends in an error in state: 109.
##
## property_pattern(param_pattern) -> property_id . [ SEMI RBRACE COMMA ]
## property_pattern(param_pattern) -> property_id . COLON param_pattern [ SEMI RBRACE COMMA ]
##
## The known suffix of the stack is as follows:
## property_id
##

Ill-formed object pattern.
At this point, one of the following is expected:
  * a colon ':' followed by a pattern matching the property;
  * a property separator (';' or ',') to match any property;
  * a closing brace '}' if no more properties.

contract: Const LBRACE Ident COLON ZWSP
##
## Ends in an error in state: 36.
##
## property_pattern(pattern) -> property_id COLON . pattern [ SEMI RBRACE COMMA ]
##
## The known suffix of the stack is as follows:
## property_id COLON
##
interactive_expr: ES6FUN LPAR LBRACE Ident COLON ZWSP
##
## Ends in an error in state: 110.
##
## property_pattern(param_pattern) -> property_id COLON . param_pattern [ SEMI RBRACE COMMA ]
##
## The known suffix of the stack is as follows:
## property_id COLON
##

Ill-formed object pattern.
At this point, a pattern matching the property is expected.

contract: Const Attr ZWSP
##
## Ends in an error in state: 41.
##
## pattern -> Attr . pattern [ SEMI RPAR RBRACKET RBRACE PARAMS EQ COMMA COLON ]
##
## The known suffix of the stack is as follows:
## Attr
##
interactive_expr: ES6FUN LPAR LBRACE Attr ZWSP
##
## Ends in an error in state: 107.
##
## property_pattern(param_pattern) -> Attr . property_pattern(param_pattern) [ SEMI RBRACE COMMA ]
##
## The known suffix of the stack is as follows:
## Attr
##

Ill-formed decorated pattern.
At this point, one of the follwing is expected:
  * another decorator;
  * a pattern.

contract: Const LBRACE Ident COLON Bytes ZWSP
##
## Ends in an error in state: 52.
##
## nsepseq(property_pattern(pattern),property_sep) -> property_pattern(pattern) . [ RBRACE ]
## nsepseq(property_pattern(pattern),property_sep) -> property_pattern(pattern) . property_sep nsepseq(property_pattern(pattern),property_sep) [ RBRACE ]
## nseq(__anonymous_0(property_pattern(pattern),property_sep)) -> property_pattern(pattern) . property_sep [ RBRACE ]
## nseq(__anonymous_0(property_pattern(pattern),property_sep)) -> property_pattern(pattern) . property_sep nseq(__anonymous_0(property_pattern(pattern),property_sep)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## property_pattern(pattern)
##
interactive_expr: ES6FUN LPAR LBRACE Ident COLON Ident ZWSP
##
## Ends in an error in state: 119.
##
## nsepseq(property_pattern(param_pattern),property_sep) -> property_pattern(param_pattern) . [ RBRACE ]
## nsepseq(property_pattern(param_pattern),property_sep) -> property_pattern(param_pattern) . property_sep nsepseq(property_pattern(param_pattern),property_sep) [ RBRACE ]
## nseq(__anonymous_0(property_pattern(param_pattern),property_sep)) -> property_pattern(param_pattern) . property_sep [ RBRACE ]
## nseq(__anonymous_0(property_pattern(param_pattern),property_sep)) -> property_pattern(param_pattern) . property_sep nseq(__anonymous_0(property_pattern(param_pattern),property_sep)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## property_pattern(param_pattern)
##

Ill-formed object pattern.
At this point, one of the following is expected:
  * a property separator (';' or ',');
  * a closing brace '}' if no more properties.

contract: Const LBRACE Ident COMMA ZWSP
##
## Ends in an error in state: 55.
##
## nsepseq(property_pattern(pattern),property_sep) -> property_pattern(pattern) property_sep . nsepseq(property_pattern(pattern),property_sep) [ RBRACE ]
## nseq(__anonymous_0(property_pattern(pattern),property_sep)) -> property_pattern(pattern) property_sep . [ RBRACE ]
## nseq(__anonymous_0(property_pattern(pattern),property_sep)) -> property_pattern(pattern) property_sep . nseq(__anonymous_0(property_pattern(pattern),property_sep)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## property_pattern(pattern) property_sep
##
interactive_expr: ES6FUN LPAR LBRACE Ident COMMA ZWSP
##
## Ends in an error in state: 120.
##
## nsepseq(property_pattern(param_pattern),property_sep) -> property_pattern(param_pattern) property_sep . nsepseq(property_pattern(param_pattern),property_sep) [ RBRACE ]
## nseq(__anonymous_0(property_pattern(param_pattern),property_sep)) -> property_pattern(param_pattern) property_sep . [ RBRACE ]
## nseq(__anonymous_0(property_pattern(param_pattern),property_sep)) -> property_pattern(param_pattern) property_sep . nseq(__anonymous_0(property_pattern(param_pattern),property_sep)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## property_pattern(param_pattern) property_sep
##

Ill-formed object pattern.
At this point, one of the following is expected:
  * a property pattern;
  * a closing brace '}' if no more properties.

contract: Const LBRACKET ELLIPSIS ZWSP
##
## Ends in an error in state: 61.
##
## element(pattern) -> ELLIPSIS . pattern [ RBRACKET COMMA ]
##
## The known suffix of the stack is as follows:
## ELLIPSIS
##
interactive_expr: ES6FUN LPAR LBRACKET ELLIPSIS ZWSP
##
## Ends in an error in state: 126.
##
## element(param_pattern) -> ELLIPSIS . param_pattern [ RBRACKET COMMA ]
##
## The known suffix of the stack is as follows:
## ELLIPSIS
##

Ill-formed array pattern.
At this point, a rest pattern is expected.

contract: Const LBRACKET Bytes ZWSP
##
## Ends in an error in state: 69.
##
## nsepseq(element(pattern),COMMA) -> element(pattern) . [ RBRACKET ]
## nsepseq(element(pattern),COMMA) -> element(pattern) . COMMA nsepseq(element(pattern),COMMA) [ RBRACKET ]
## nseq(__anonymous_0(element(pattern),COMMA)) -> element(pattern) . COMMA [ RBRACKET ]
## nseq(__anonymous_0(element(pattern),COMMA)) -> element(pattern) . COMMA nseq(__anonymous_0(element(pattern),COMMA)) [ RBRACKET ]
##
## The known suffix of the stack is as follows:
## element(pattern)
##
interactive_expr: ES6FUN LPAR LBRACKET Ident ZWSP
##
## Ends in an error in state: 134.
##
## nsepseq(element(param_pattern),COMMA) -> element(param_pattern) . [ RBRACKET ]
## nsepseq(element(param_pattern),COMMA) -> element(param_pattern) . COMMA nsepseq(element(param_pattern),COMMA) [ RBRACKET ]
## nseq(__anonymous_0(element(param_pattern),COMMA)) -> element(param_pattern) . COMMA [ RBRACKET ]
## nseq(__anonymous_0(element(param_pattern),COMMA)) -> element(param_pattern) . COMMA nseq(__anonymous_0(element(param_pattern),COMMA)) [ RBRACKET ]
##
## The known suffix of the stack is as follows:
## element(param_pattern)
##

Ill-formed array pattern.
At this point, one of following is expected:
  * a comma ',' followed by another element pattern;
  * a closing bracket ']' is no more elements.

contract: Const LBRACKET Bytes COMMA ZWSP
##
## Ends in an error in state: 70.
##
## nsepseq(element(pattern),COMMA) -> element(pattern) COMMA . nsepseq(element(pattern),COMMA) [ RBRACKET ]
## nseq(__anonymous_0(element(pattern),COMMA)) -> element(pattern) COMMA . [ RBRACKET ]
## nseq(__anonymous_0(element(pattern),COMMA)) -> element(pattern) COMMA . nseq(__anonymous_0(element(pattern),COMMA)) [ RBRACKET ]
##
## The known suffix of the stack is as follows:
## element(pattern) COMMA
##
interactive_expr: ES6FUN LPAR LBRACKET Ident COMMA ZWSP
##
## Ends in an error in state: 135.
##
## nsepseq(element(param_pattern),COMMA) -> element(param_pattern) COMMA . nsepseq(element(param_pattern),COMMA) [ RBRACKET ]
## nseq(__anonymous_0(element(param_pattern),COMMA)) -> element(param_pattern) COMMA . [ RBRACKET ]
## nseq(__anonymous_0(element(param_pattern),COMMA)) -> element(param_pattern) COMMA . nseq(__anonymous_0(element(param_pattern),COMMA)) [ RBRACKET ]
##
## The known suffix of the stack is as follows:
## element(param_pattern) COMMA
##

Ill-formed array pattern.
At this point, one of the following is expected:
  * a pattern matching an element;
  * a closing bracket ']' is no more elements.

interactive_expr: Match LPAR UIdent RPAR LBRACE When LPAR Bytes ZWSP
##
## Ends in an error in state: 73.
##
## par(pattern) -> LPAR pattern . RPAR [ COLON ]
## par(pattern) -> LPAR pattern . PARAMS RPAR [ COLON ]
##
## The known suffix of the stack is as follows:
## LPAR pattern
##
interactive_expr: Match LPAR UIdent RPAR LBRACE When LPAR Bytes PARAMS ZWSP
##
## Ends in an error in state: 75.
##
## par(pattern) -> LPAR pattern PARAMS . RPAR [ COLON ]
##
## The known suffix of the stack is as follows:
## LPAR pattern PARAMS
##

Ill-formed pattern matching.
At this point, a closing parenthesis ')' is expected.

interactive_expr: Match LPAR UIdent RPAR LBRACE When LPAR Bytes RPAR ZWSP
##
## Ends in an error in state: 77.
##
## match_clause -> When par(pattern) . COLON expr [ When RBRACE Default ]
## match_clause -> When par(pattern) . COLON expr SEMI [ When RBRACE Default ]
##
## The known suffix of the stack is as follows:
## When par(pattern)
##

Ill-formed pattern matching.
At this point, a colon ':' is expected, followed by an expression.

interactive_expr: Match LPAR UIdent RPAR LBRACE When LPAR Bytes RPAR COLON ZWSP
##
## Ends in an error in state: 78.
##
## match_clause -> When par(pattern) COLON . expr [ When RBRACE Default ]
## match_clause -> When par(pattern) COLON . expr SEMI [ When RBRACE Default ]
##
## The known suffix of the stack is as follows:
## When par(pattern) COLON
##

Ill-formed pattern matching.
At this point, the case clause is expected as an expression.

interactive_expr: MINUS2 ZWSP
##
## Ends in an error in state: 79.
##
## pre_decr_expr -> MINUS2 . Ident [ XOR While When VBAR Type TIMES Switch SLASH SEMI_ELSE SEMI Return RPAR REM RBRACKET RBRACE QMARK PLUS PARAMS OR Namespace NE MINUS Let LT LE LBRACE Interface Import If GT For Export Else EQ2 EOF Default Continue Const Case COMMA COLON Break BIT_XOR BIT_SR BIT_SL BIT_AND Attr AND ]
##
## The known suffix of the stack is as follows:
## MINUS2
##

Ill-formed decrement.
At this point, the decremented variable is expected.

interactive_expr: LBRACKET ZWSP
##
## Ends in an error in state: 82.
##
## brackets(sep_or_term(element(expr),COMMA)) -> LBRACKET . sep_or_term(element(expr),COMMA) RBRACKET [ XOR While When VBAR Type TIMES Switch SLASH SEMI_ELSE SEMI Return RPAR REM RBRACKET RBRACE QMARK PLUS PARAMS OR Namespace NE MINUS Let LT LPAR LE LBRACE Interface Import If GT For Export Else EQ2 EOF Default Continue Const Case COMMA COLON Break BIT_XOR BIT_SR BIT_SL BIT_AND Attr As AND ]
##
## The known suffix of the stack is as follows:
## LBRACKET
##

Ill-formed array expression.
At this point, the first element is expected as an expression.

interactive_expr: LBRACE ZWSP
##
## Ends in an error in state: 96.
##
## braces(sep_or_term(property(expr),property_sep)) -> LBRACE . sep_or_term(property(expr),property_sep) RBRACE [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COMMA COLON Break Attr ]
## braces(update_expr) -> LBRACE . update_expr RBRACE [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COMMA COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## LBRACE
##

Ill-formed object or object update.
At this point, one of the following is expected:
  * the first property of an object;
  * a rest expression ('...') denoting the object being updated.

interactive_expr: LBRACE ELLIPSIS ZWSP
##
## Ends in an error in state: 97.
##
## update_expr -> ELLIPSIS . expr property_sep updates [ RBRACE ]
##
## The known suffix of the stack is as follows:
## ELLIPSIS
##

Ill-formed object update.
At this point, the object to update is expected as an expression.

interactive_expr: Function ZWSP
##
## Ends in an error in state: 102.
##
## function_expr -> Function . fun_par_params braces(statements) [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COMMA COLON Break Attr ]
## function_expr -> Function . fun_par_params ret_type braces(statements) [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COMMA COLON Break Attr ]
## function_expr -> Function . type_vars fun_par_params braces(statements) [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COMMA COLON Break Attr ]
## function_expr -> Function . type_vars fun_par_params ret_type braces(statements) [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COMMA COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## Function
##

Ill-formed function expression.
At this point, one of the following is expected:
  * an opening parenthesis '(' optionally followed by function
    parameters;
  * an opening chevron '<' optionally followed by type parameters.

interactive_expr: ES6FUN LPAR ZWSP
##
## Ends in an error in state: 103.
##
## par(fun_params) -> LPAR . fun_params RPAR [ LBRACE COLON ARROW ]
## par(fun_params) -> LPAR . fun_params PARAMS RPAR [ LBRACE COLON ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR
##

Ill-formed function.
At this point, one of the following is expected:
  * the first parameter (variable);
  * a closing parenthesis ')' if no parameters.

interactive_expr: ES6FUN LPAR Ident ZWSP
##
## Ends in an error in state: 139.
##
## fun_param -> param_pattern . type_annotation(type_expr) [ RPAR PARAMS COMMA ]
## fun_param -> param_pattern . [ RPAR PARAMS COMMA ]
##
## The known suffix of the stack is as follows:
## param_pattern
##

Ill-formed function parameter.
At this point, one of the following is expected:
  * a comma ',' followed by another parameter;
  * a colon ':' followed by the type of the parameter;
  * a closing parenthesis ')' if no more parameters.

interactive_expr: ES6FUN LPAR PARAMS ZWSP
##
## Ends in an error in state: 294.
##
## par(fun_params) -> LPAR fun_params PARAMS . RPAR [ LBRACE COLON ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR fun_params PARAMS
##

Ill-formed function.
At this point, a closing parenthesis ')' is expected.

interactive_expr: ES6FUN LPAR Ident COLON Ident XOR
##
## Ends in an error in state: 296.
##
## nsepseq(fun_param,COMMA) -> fun_param . [ RPAR PARAMS ]
## nsepseq(fun_param,COMMA) -> fun_param . COMMA nsepseq(fun_param,COMMA) [ RPAR PARAMS ]
## nseq(__anonymous_0(fun_param,COMMA)) -> fun_param . COMMA [ RPAR PARAMS ]
## nseq(__anonymous_0(fun_param,COMMA)) -> fun_param . COMMA nseq(__anonymous_0(fun_param,COMMA)) [ RPAR PARAMS ]
##
## The known suffix of the stack is as follows:
## fun_param
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 174, spurious reduction of production type_name -> Ident
## In state 196, spurious reduction of production no_par_type_expr -> type_name
## In state 227, spurious reduction of production core_type_no_string -> no_par_type_expr
## In state 237, spurious reduction of production core_type -> core_type_no_string
## In state 238, spurious reduction of production type_expr -> core_type
## In state 287, spurious reduction of production type_annotation(type_expr) -> COLON type_expr
## In state 288, spurious reduction of production fun_param -> param_pattern type_annotation(type_expr)
##

Ill-formed function.
At this point, one of the following is expected:
  * a comma ',' followed by another parameter;
  * a closing parenthesis ')', if no more parameters.

interactive_expr: ES6FUN LPAR Ident COMMA ZWSP
##
## Ends in an error in state: 297.
##
## nsepseq(fun_param,COMMA) -> fun_param COMMA . nsepseq(fun_param,COMMA) [ RPAR PARAMS ]
## nseq(__anonymous_0(fun_param,COMMA)) -> fun_param COMMA . [ RPAR PARAMS ]
## nseq(__anonymous_0(fun_param,COMMA)) -> fun_param COMMA . nseq(__anonymous_0(fun_param,COMMA)) [ RPAR PARAMS ]
##
## The known suffix of the stack is as follows:
## fun_param COMMA
##

Ill-formed function.
At this point, one of the following is expected:
  * another parameter as a variable;
  * a closing parenthesis ')' if no more parameters.

interactive_expr: Function LT GT XOR
##
## Ends in an error in state: 300.
##
## function_expr -> Function type_vars . fun_par_params braces(statements) [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COMMA COLON Break Attr ]
## function_expr -> Function type_vars . fun_par_params ret_type braces(statements) [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COMMA COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## Function type_vars
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 91, spurious reduction of production chevrons(sep_or_term(type_var,COMMA)) -> LT sep_or_term(type_var,COMMA) GT
## In state 315, spurious reduction of production type_vars -> chevrons(sep_or_term(type_var,COMMA))
##

Ill-formed function expression.
At this point, an opening parenthesis '(' is expected.

interactive_expr: Function LT GT LPAR PARAMS RPAR ZWSP
##
## Ends in an error in state: 302.
##
## function_expr -> Function type_vars fun_par_params . braces(statements) [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COMMA COLON Break Attr ]
## function_expr -> Function type_vars fun_par_params . ret_type braces(statements) [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COMMA COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## Function type_vars fun_par_params
##
interactive_expr: Function LPAR PARAMS RPAR ZWSP
##
## Ends in an error in state: 1045.
##
## function_expr -> Function fun_par_params . braces(statements) [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COMMA COLON Break Attr ]
## function_expr -> Function fun_par_params . ret_type braces(statements) [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COMMA COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## Function fun_par_params
##
interactive_expr: LT GT ES6FUN LPAR PARAMS RPAR ZWSP
##
## Ends in an error in state: 499.
##
## arrow_fun_expr -> type_vars ES6FUN fun_par_params . ARROW fun_body [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COMMA COLON Break Attr ]
## arrow_fun_expr -> type_vars ES6FUN fun_par_params . ret_type ARROW fun_body [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COMMA COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## type_vars ES6FUN fun_par_params
##
interactive_expr: ES6FUN LPAR PARAMS RPAR ZWSP
##
## Ends in an error in state: 546.
##
## arrow_fun_expr -> ES6FUN fun_par_params . ARROW fun_body [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COMMA COLON Break Attr ]
## arrow_fun_expr -> ES6FUN fun_par_params . ret_type ARROW fun_body [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COMMA COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## ES6FUN fun_par_params
##

Ill-formed function.
At this point, one of the following is expected:
  * a colon ':' followed by the return type;
  * an opening brace '{' followed by the body as statements.

interactive_expr: ES6FUN LPAR PARAMS RPAR COLON ZWSP
##
## Ends in an error in state: 500.
##
## type_annotation(__anonymous_6) -> COLON . option(ES6FUN) no_par_type_expr [ LBRACE ARROW ]
##
## The known suffix of the stack is as follows:
## COLON
##
interactive_expr: ES6FUN LPAR PARAMS RPAR COLON ES6FUN ZWSP
##
## Ends in an error in state: 502.
##
## type_annotation(__anonymous_6) -> COLON option(ES6FUN) . no_par_type_expr [ LBRACE ARROW ]
##
## The known suffix of the stack is as follows:
## COLON option(ES6FUN)
##

Ill-formed function.
At this point, a type expression without parentheses is expected.

interactive_expr: ES6FUN LPAR PARAMS RPAR COLON LBRACKET ZWSP
##
## Ends in an error in state: 503.
##
## brackets(type_elements) -> LBRACKET . type_elements RBRACKET [ LBRACE ARROW ]
##
## The known suffix of the stack is as follows:
## LBRACKET
##

Ill-formed array type.
At this point, the type of the first element is expected.

interactive_expr: ES6FUN LPAR PARAMS RPAR COLON Attr ZWSP
##
## Ends in an error in state: 504.
##
## attr_type -> Attr . core_type_no_string [ LBRACE ARROW ]
##
## The known suffix of the stack is as follows:
## Attr
##

Ill-formed decorated type.
At this point, one of the following is expected:
  * another decorator;
  * a type expression.

interactive_expr: Function LT GT LPAR PARAMS RPAR COLON Ident XOR
##
## Ends in an error in state: 1042.
##
## function_expr -> Function type_vars fun_par_params ret_type . braces(statements) [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COMMA COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## Function type_vars fun_par_params ret_type
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 174, spurious reduction of production type_name -> Ident
## In state 196, spurious reduction of production no_par_type_expr -> type_name
## In state 505, spurious reduction of production type_annotation(__anonymous_6) -> COLON option(ES6FUN) no_par_type_expr
## In state 508, spurious reduction of production ret_type -> type_annotation(__anonymous_6)
##
interactive_expr: Function LPAR PARAMS RPAR COLON Ident XOR
##
## Ends in an error in state: 1046.
##
## function_expr -> Function fun_par_params ret_type . braces(statements) [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COMMA COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## Function fun_par_params ret_type
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 174, spurious reduction of production type_name -> Ident
## In state 196, spurious reduction of production no_par_type_expr -> type_name
## In state 505, spurious reduction of production type_annotation(__anonymous_6) -> COLON option(ES6FUN) no_par_type_expr
## In state 508, spurious reduction of production ret_type -> type_annotation(__anonymous_6)
##

Ill-formed function expression.
At this point, an opening brace '{' is expected, followed by statements.

interactive_expr: ES6FUN ZWSP
##
## Ends in an error in state: 319.
##
## arrow_fun_expr -> ES6FUN . fun_par_params ARROW fun_body [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COMMA COLON Break Attr ]
## arrow_fun_expr -> ES6FUN . fun_par_params ret_type ARROW fun_body [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COMMA COLON Break Attr ]
## arrow_fun_expr -> ES6FUN . fun_var_param ARROW fun_body [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COMMA COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## ES6FUN
##
interactive_expr: LT GT XOR
##
## Ends in an error in state: 376.
##
## arrow_fun_expr -> type_vars . ES6FUN fun_par_params ARROW fun_body [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COMMA COLON Break Attr ]
## arrow_fun_expr -> type_vars . ES6FUN fun_par_params ret_type ARROW fun_body [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COMMA COLON Break Attr ]
## arrow_fun_expr -> type_vars . ES6FUN fun_var_param ARROW fun_body [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COMMA COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## type_vars
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 91, spurious reduction of production chevrons(sep_or_term(type_var,COMMA)) -> LT sep_or_term(type_var,COMMA) GT
## In state 315, spurious reduction of production type_vars -> chevrons(sep_or_term(type_var,COMMA))
##
interactive_expr: LT GT ES6FUN ZWSP
##
## Ends in an error in state: 377.
##
## arrow_fun_expr -> type_vars ES6FUN . fun_par_params ARROW fun_body [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COMMA COLON Break Attr ]
## arrow_fun_expr -> type_vars ES6FUN . fun_par_params ret_type ARROW fun_body [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COMMA COLON Break Attr ]
## arrow_fun_expr -> type_vars ES6FUN . fun_var_param ARROW fun_body [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COMMA COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## type_vars ES6FUN
##

Ill-formed arrow function.
At this point, an opening parenthesis '(' is expected.

interactive_expr: ES6FUN Ident ZWSP
##
## Ends in an error in state: 322.
##
## arrow_fun_expr -> ES6FUN fun_var_param . ARROW fun_body [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COMMA COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## ES6FUN fun_var_param
##
interactive_expr: LT GT ES6FUN Ident ZWSP
##
## Ends in an error in state: 378.
##
## arrow_fun_expr -> type_vars ES6FUN fun_var_param . ARROW fun_body [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COMMA COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## type_vars ES6FUN fun_var_param
##

Ill-formed arrow function.
At this point, an arrow '=>' is expected.

interactive_expr: ES6FUN Ident ARROW ZWSP
##
## Ends in an error in state: 323.
##
## arrow_fun_expr -> ES6FUN fun_var_param ARROW . fun_body [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COMMA COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## ES6FUN fun_var_param ARROW
##
interactive_expr: LT GT ES6FUN Ident ARROW ZWSP
##
## Ends in an error in state: 379.
##
## arrow_fun_expr -> type_vars ES6FUN fun_var_param ARROW . fun_body [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COMMA COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## type_vars ES6FUN fun_var_param ARROW
##
interactive_expr: LT GT ES6FUN LPAR RPAR COLON Ident ARROW ZWSP
##
## Ends in an error in state: 510.
##
## arrow_fun_expr -> type_vars ES6FUN fun_par_params ret_type ARROW . fun_body [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COMMA COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## type_vars ES6FUN fun_par_params ret_type ARROW
##
interactive_expr: ES6FUN LPAR RPAR COLON Ident ARROW ZWSP
##
## Ends in an error in state: 550.
##
## arrow_fun_expr -> ES6FUN fun_par_params ret_type ARROW . fun_body [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COMMA COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## ES6FUN fun_par_params ret_type ARROW
##
interactive_expr: LT GT ES6FUN LPAR PARAMS RPAR ARROW ZWSP
##
## Ends in an error in state: 506.
##
## arrow_fun_expr -> type_vars ES6FUN fun_par_params ARROW . fun_body [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COMMA COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## type_vars ES6FUN fun_par_params ARROW
##
interactive_expr: ES6FUN LPAR PARAMS RPAR ARROW ZWSP
##
## Ends in an error in state: 547.
##
## arrow_fun_expr -> ES6FUN fun_par_params ARROW . fun_body [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COMMA COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## ES6FUN fun_par_params ARROW
##

Ill-formed arrow function.
At this point, one of the following is expected:
  * the body as a non-object expression (use parentheses otherwise);
  * an opening brace '{' followed by a statement.

interactive_expr: ContractOf ZWSP
##
## Ends in an error in state: 324.
##
## contract_of_expr -> ContractOf . par(namespace_selection) [ XOR While When VBAR Type TIMES Switch SLASH SEMI_ELSE SEMI Return RPAR REM RBRACKET RBRACE QMARK PLUS PARAMS OR Namespace NE MINUS Let LT LE LBRACE Interface Import If GT For Export Else EQ2 EOF Default Continue Const Case COMMA COLON Break BIT_XOR BIT_SR BIT_SL BIT_AND Attr As AND ]
##
## The known suffix of the stack is as follows:
## ContractOf
##

Ill-formed contract from a namespace.
At this point, an opening parenthesis '(' is expected.

interactive_expr: ContractOf LPAR ZWSP
##
## Ends in an error in state: 325.
##
## par(namespace_selection) -> LPAR . namespace_selection RPAR [ XOR While When VBAR Type TIMES Switch SLASH SEMI_ELSE SEMI Return RPAR REM RBRACKET RBRACE QMARK PLUS PARAMS OR Namespace NE MINUS Let LT LE LBRACE Interface Import If GT For Export Else EQ2 EOF Default Continue Const Case COMMA COLON Break BIT_XOR BIT_SR BIT_SL BIT_AND Attr As AND ]
## par(namespace_selection) -> LPAR . namespace_selection PARAMS RPAR [ XOR While When VBAR Type TIMES Switch SLASH SEMI_ELSE SEMI Return RPAR REM RBRACKET RBRACE QMARK PLUS PARAMS OR Namespace NE MINUS Let LT LE LBRACE Interface Import If GT For Export Else EQ2 EOF Default Continue Const Case COMMA COLON Break BIT_XOR BIT_SR BIT_SL BIT_AND Attr As AND ]
##
## The known suffix of the stack is as follows:
## LPAR
##

Ill-formed contract from a namespace.
At this point, one of the following is expected:
  * a namespace name;
  * a qualified namespace (e.g. 'A.B.C').

interactive_expr: ContractOf LPAR UIdent ZWSP
##
## Ends in an error in state: 326.
##
## par(namespace_selection) -> LPAR namespace_selection . RPAR [ XOR While When VBAR Type TIMES Switch SLASH SEMI_ELSE SEMI Return RPAR REM RBRACKET RBRACE QMARK PLUS PARAMS OR Namespace NE MINUS Let LT LE LBRACE Interface Import If GT For Export Else EQ2 EOF Default Continue Const Case COMMA COLON Break BIT_XOR BIT_SR BIT_SL BIT_AND Attr As AND ]
## par(namespace_selection) -> LPAR namespace_selection . PARAMS RPAR [ XOR While When VBAR Type TIMES Switch SLASH SEMI_ELSE SEMI Return RPAR REM RBRACKET RBRACE QMARK PLUS PARAMS OR Namespace NE MINUS Let LT LE LBRACE Interface Import If GT For Export Else EQ2 EOF Default Continue Const Case COMMA COLON Break BIT_XOR BIT_SR BIT_SL BIT_AND Attr As AND ]
##
## The known suffix of the stack is as follows:
## LPAR namespace_selection
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 153, spurious reduction of production namespace_selection -> namespace_name
##
interactive_expr: ContractOf LPAR UIdent PARAMS ZWSP
##
## Ends in an error in state: 328.
##
## par(namespace_selection) -> LPAR namespace_selection PARAMS . RPAR [ XOR While When VBAR Type TIMES Switch SLASH SEMI_ELSE SEMI Return RPAR REM RBRACKET RBRACE QMARK PLUS PARAMS OR Namespace NE MINUS Let LT LE LBRACE Interface Import If GT For Export Else EQ2 EOF Default Continue Const Case COMMA COLON Break BIT_XOR BIT_SR BIT_SL BIT_AND Attr As AND ]
##
## The known suffix of the stack is as follows:
## LPAR namespace_selection PARAMS
##

Ill-formed contract from a namespace.
At this point, a closing parenthesis ')' is expected.

interactive_expr: BIT_NOT ZWSP
##
## Ends in an error in state: 332.
##
## neg_expr -> BIT_NOT . app_expr_level [ XOR While When VBAR Type TIMES Switch SLASH SEMI_ELSE SEMI Return RPAR REM RBRACKET RBRACE QMARK PLUS PARAMS OR Namespace NE MINUS Let LT LE LBRACE Interface Import If GT For Export Else EQ2 EOF Default Continue Const Case COMMA COLON Break BIT_XOR BIT_SR BIT_SL BIT_AND Attr AND ]
##
## The known suffix of the stack is as follows:
## BIT_NOT
##

Ill-formed bitwise negation.
At this point, an expression is expected.

interactive_expr: Ident LBRACKET ZWSP
##
## Ends in an error in state: 340.
##
## brackets(Int) -> LBRACKET . Int RBRACKET [ XOR While When VBAR Type TIMES Switch SLASH SEMI_ELSE SEMI Return RPAR REM_EQ REM RBRACKET RBRACE QMARK PLUS_EQ PLUS PARAMS OR Namespace NE MULT_EQ MINUS_EQ MINUS Let LT LPAR LE LBRACKET LBRACE Interface Import If GT For Export Else EQ2 EQ EOF Default DOT DIV_EQ Continue Const Case COMMA COLON Break BIT_XOR_EQ BIT_XOR BIT_SR_EQ BIT_SR BIT_SL_EQ BIT_SL BIT_OR_EQ BIT_AND_EQ BIT_AND Attr As AND ]
## brackets(String) -> LBRACKET . String RBRACKET [ XOR While When VBAR Type TIMES Switch SLASH SEMI_ELSE SEMI Return RPAR REM_EQ REM RBRACKET RBRACE QMARK PLUS_EQ PLUS PARAMS OR Namespace NE MULT_EQ MINUS_EQ MINUS Let LT LPAR LE LBRACKET LBRACE Interface Import If GT For Export Else EQ2 EQ EOF Default DOT DIV_EQ Continue Const Case COMMA COLON Break BIT_XOR_EQ BIT_XOR BIT_SR_EQ BIT_SR BIT_SL_EQ BIT_SL BIT_OR_EQ BIT_AND_EQ BIT_AND Attr As AND ]
##
## The known suffix of the stack is as follows:
## LBRACKET
##

Ill-formed property selection.
At this point, one of the following is expected:
  * an integer denoting the property,
  * a string denoting the property.

interactive_expr: Ident LBRACKET String ZWSP
##
## Ends in an error in state: 341.
##
## brackets(String) -> LBRACKET String . RBRACKET [ XOR While When VBAR Type TIMES Switch SLASH SEMI_ELSE SEMI Return RPAR REM_EQ REM RBRACKET RBRACE QMARK PLUS_EQ PLUS PARAMS OR Namespace NE MULT_EQ MINUS_EQ MINUS Let LT LPAR LE LBRACKET LBRACE Interface Import If GT For Export Else EQ2 EQ EOF Default DOT DIV_EQ Continue Const Case COMMA COLON Break BIT_XOR_EQ BIT_XOR BIT_SR_EQ BIT_SR BIT_SL_EQ BIT_SL BIT_OR_EQ BIT_AND_EQ BIT_AND Attr As AND ]
##
## The known suffix of the stack is as follows:
## LBRACKET String
##
interactive_expr: Ident LBRACKET Int ZWSP
##
## Ends in an error in state: 343.
##
## brackets(Int) -> LBRACKET Int . RBRACKET [ XOR While When VBAR Type TIMES Switch SLASH SEMI_ELSE SEMI Return RPAR REM_EQ REM RBRACKET RBRACE QMARK PLUS_EQ PLUS PARAMS OR Namespace NE MULT_EQ MINUS_EQ MINUS Let LT LPAR LE LBRACKET LBRACE Interface Import If GT For Export Else EQ2 EQ EOF Default DOT DIV_EQ Continue Const Case COMMA COLON Break BIT_XOR_EQ BIT_XOR BIT_SR_EQ BIT_SR BIT_SL_EQ BIT_SL BIT_OR_EQ BIT_AND_EQ BIT_AND Attr As AND ]
##
## The known suffix of the stack is as follows:
## LBRACKET Int
##

Ill-formed property selection.
At this point, a closing bracket ']' is expected.

interactive_expr: Ident DOT ZWSP
##
## Ends in an error in state: 345.
##
## selection -> DOT . property_name [ XOR While When VBAR Type TIMES Switch SLASH SEMI_ELSE SEMI Return RPAR REM_EQ REM RBRACKET RBRACE QMARK PLUS_EQ PLUS PARAMS OR Namespace NE MULT_EQ MINUS_EQ MINUS Let LT LPAR LE LBRACKET LBRACE Interface Import If GT For Export Else EQ2 EQ EOF Default DOT DIV_EQ Continue Const Case COMMA COLON Break BIT_XOR_EQ BIT_XOR BIT_SR_EQ BIT_SR BIT_SL_EQ BIT_SL BIT_OR_EQ BIT_AND_EQ BIT_AND Attr As AND ]
##
## The known suffix of the stack is as follows:
## DOT
##

Ill-formed property selection.
At this point, a property name is expected.

interactive_expr: UIdent DOT ZWSP
##
## Ends in an error in state: 356.
##
## namespace_path(selected_expr) -> namespace_name DOT . namespace_path(selected_expr) [ XOR While When VBAR Type TIMES Switch SLASH SEMI_ELSE SEMI Return RPAR REM RBRACKET RBRACE QMARK PLUS PARAMS OR Namespace NE MINUS Let LT LPAR LE LBRACE Interface Import If GT For Export Else EQ2 EOF Default Continue Const Case COMMA COLON Break BIT_XOR BIT_SR BIT_SL BIT_AND Attr As AND ]
## namespace_path(selected_expr) -> namespace_name DOT . selected_expr [ XOR While When VBAR Type TIMES Switch SLASH SEMI_ELSE SEMI Return RPAR REM RBRACKET RBRACE QMARK PLUS PARAMS OR Namespace NE MINUS Let LT LPAR LE LBRACE Interface Import If GT For Export Else EQ2 EOF Default Continue Const Case COMMA COLON Break BIT_XOR BIT_SR BIT_SL BIT_AND Attr As AND ]
##
## The known suffix of the stack is as follows:
## namespace_name DOT
##

Ill-formed namespace selection.
At this point, one of the following is expected:
  * a variable,
  * a selection through arrays and objects.

contract: Namespace UIdent LBRACE Switch LPAR UIdent RPAR LBRACE Case UIdent ZWSP
##
## Ends in an error in state: 366.
##
## app_expr -> lambda . arguments [ XOR While When VBAR Type TIMES Switch SLASH SEMI_ELSE SEMI Return RPAR REM RBRACKET RBRACE QMARK PLUS PARAMS OR Namespace NE MINUS Let LT LPAR LE LBRACKET LBRACE Interface Import If GT For Export Else EQ2 EOF Default DOT Continue Const Case COMMA COLON Break BIT_XOR BIT_SR BIT_SL BIT_AND Attr As AND ]
##
## The known suffix of the stack is as follows:
## lambda
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 4, spurious reduction of production ctor -> UIdent
## In state 1026, spurious reduction of production core_expr -> ctor
## In state 1027, spurious reduction of production lambda -> core_expr
##

Ill-formed function call.
At this point, the arguments are expected between parentheses.

interactive_expr: UIdent LPAR ZWSP
##
## Ends in an error in state: 367.
##
## par(ioption(nsepseq(argument,COMMA))) -> LPAR . RPAR [ XOR While When VBAR Type TIMES Switch SLASH SEMI_ELSE SEMI Return RPAR REM RBRACKET RBRACE QMARK PLUS PARAMS OR Namespace NE MINUS Let LT LPAR LE LBRACKET LBRACE Interface Import If GT For Export Else EQ2 EOF Default DOT Continue Const Case COMMA COLON Break BIT_XOR BIT_SR BIT_SL BIT_AND Attr As AND ]
## par(ioption(nsepseq(argument,COMMA))) -> LPAR . nsepseq(argument,COMMA) RPAR [ XOR While When VBAR Type TIMES Switch SLASH SEMI_ELSE SEMI Return RPAR REM RBRACKET RBRACE QMARK PLUS PARAMS OR Namespace NE MINUS Let LT LPAR LE LBRACKET LBRACE Interface Import If GT For Export Else EQ2 EOF Default DOT Continue Const Case COMMA COLON Break BIT_XOR BIT_SR BIT_SL BIT_AND Attr As AND ]
## par(ioption(nsepseq(argument,COMMA))) -> LPAR . PARAMS RPAR [ XOR While When VBAR Type TIMES Switch SLASH SEMI_ELSE SEMI Return RPAR REM RBRACKET RBRACE QMARK PLUS PARAMS OR Namespace NE MINUS Let LT LPAR LE LBRACKET LBRACE Interface Import If GT For Export Else EQ2 EOF Default DOT Continue Const Case COMMA COLON Break BIT_XOR BIT_SR BIT_SL BIT_AND Attr As AND ]
## par(ioption(nsepseq(argument,COMMA))) -> LPAR . nsepseq(argument,COMMA) PARAMS RPAR [ XOR While When VBAR Type TIMES Switch SLASH SEMI_ELSE SEMI Return RPAR REM RBRACKET RBRACE QMARK PLUS PARAMS OR Namespace NE MINUS Let LT LPAR LE LBRACKET LBRACE Interface Import If GT For Export Else EQ2 EOF Default DOT Continue Const Case COMMA COLON Break BIT_XOR BIT_SR BIT_SL BIT_AND Attr As AND ]
##
## The known suffix of the stack is as follows:
## LPAR
##

Ill-formed function call.
At this point, one of the following is expected:
  * a argument as an expression;
  * a closing parenthesis ')' if no argument.

interactive_expr: UIdent LPAR PARAMS ZWSP
##
## Ends in an error in state: 369.
##
## par(ioption(nsepseq(argument,COMMA))) -> LPAR PARAMS . RPAR [ XOR While When VBAR Type TIMES Switch SLASH SEMI_ELSE SEMI Return RPAR REM RBRACKET RBRACE QMARK PLUS PARAMS OR Namespace NE MINUS Let LT LPAR LE LBRACKET LBRACE Interface Import If GT For Export Else EQ2 EOF Default DOT Continue Const Case COMMA COLON Break BIT_XOR BIT_SR BIT_SL BIT_AND Attr As AND ]
##
## The known suffix of the stack is as follows:
## LPAR PARAMS
##
interactive_expr: UIdent LPAR UIdent PARAMS ZWSP
##
## Ends in an error in state: 536.
##
## par(ioption(nsepseq(argument,COMMA))) -> LPAR nsepseq(argument,COMMA) PARAMS . RPAR [ XOR While When VBAR Type TIMES Switch SLASH SEMI_ELSE SEMI Return RPAR REM RBRACKET RBRACE QMARK PLUS PARAMS OR Namespace NE MINUS Let LT LPAR LE LBRACKET LBRACE Interface Import If GT For Export Else EQ2 EOF Default DOT Continue Const Case COMMA COLON Break BIT_XOR BIT_SR BIT_SL BIT_AND Attr As AND ]
##
## The known suffix of the stack is as follows:
## LPAR nsepseq(argument,COMMA) PARAMS
##

Ill-formed function call.
At this point, a closing parenthesis ')' is expected.

interactive_expr: Attr ZWSP
##
## Ends in an error in state: 371.
##
## expr -> Attr . expr [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COMMA COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## Attr
##

Ill-formed decorated expression.
At this point, one of the following is expected:
  * another decorator;
  * an expression.

interactive_expr: Ident REM_EQ ZWSP
##
## Ends in an error in state: 373.
##
## bin_op(var_path,REM_EQ,expr) -> var_path REM_EQ . expr [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COMMA COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## var_path REM_EQ
##
interactive_expr: Ident PLUS_EQ ZWSP
##
## Ends in an error in state: 513.
##
## bin_op(var_path,PLUS_EQ,expr) -> var_path PLUS_EQ . expr [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COMMA COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## var_path PLUS_EQ
##
interactive_expr: Ident MULT_EQ ZWSP
##
## Ends in an error in state: 515.
##
## bin_op(var_path,MULT_EQ,expr) -> var_path MULT_EQ . expr [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COMMA COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## var_path MULT_EQ
##
interactive_expr: Ident MINUS_EQ ZWSP
##
## Ends in an error in state: 517.
##
## bin_op(var_path,MINUS_EQ,expr) -> var_path MINUS_EQ . expr [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COMMA COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## var_path MINUS_EQ
##
interactive_expr: Ident EQ ZWSP
##
## Ends in an error in state: 519.
##
## bin_op(var_path,EQ,expr) -> var_path EQ . expr [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COMMA COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## var_path EQ
##
interactive_expr: Ident DIV_EQ ZWSP
##
## Ends in an error in state: 521.
##
## bin_op(var_path,DIV_EQ,expr) -> var_path DIV_EQ . expr [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COMMA COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## var_path DIV_EQ
##
interactive_expr: Ident BIT_XOR_EQ ZWSP
##
## Ends in an error in state: 523.
##
## bin_op(var_path,BIT_XOR_EQ,expr) -> var_path BIT_XOR_EQ . expr [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COMMA COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## var_path BIT_XOR_EQ
##
interactive_expr: Ident BIT_SR_EQ ZWSP
##
## Ends in an error in state: 525.
##
## bin_op(var_path,BIT_SR_EQ,expr) -> var_path BIT_SR_EQ . expr [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COMMA COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## var_path BIT_SR_EQ
##
interactive_expr: Ident BIT_SL_EQ ZWSP
##
## Ends in an error in state: 527.
##
## bin_op(var_path,BIT_SL_EQ,expr) -> var_path BIT_SL_EQ . expr [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COMMA COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## var_path BIT_SL_EQ
##
interactive_expr: Ident BIT_OR_EQ ZWSP
##
## Ends in an error in state: 529.
##
## bin_op(var_path,BIT_OR_EQ,expr) -> var_path BIT_OR_EQ . expr [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COMMA COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## var_path BIT_OR_EQ
##
interactive_expr: Ident BIT_AND_EQ ZWSP
##
## Ends in an error in state: 531.
##
## bin_op(var_path,BIT_AND_EQ,expr) -> var_path BIT_AND_EQ . expr [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COMMA COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## var_path BIT_AND_EQ
##

Ill-formed assigment.
At this point, the right-hand side is expected as an expression.

interactive_expr: MINUS ZWSP
##
## Ends in an error in state: 81.
##
## minus_expr -> MINUS . app_expr_level [ XOR While When VBAR Type TIMES Switch SLASH SEMI_ELSE SEMI Return RPAR REM RBRACKET RBRACE QMARK PLUS PARAMS OR Namespace NE MINUS Let LT LE LBRACE Interface Import If GT For Export Else EQ2 EOF Default Continue Const Case COMMA COLON Break BIT_XOR BIT_SR BIT_SL BIT_AND Attr AND ]
##
## The known suffix of the stack is as follows:
## MINUS
##
interactive_expr: NOT ZWSP
##
## Ends in an error in state: 10.
##
## not_expr -> NOT . app_expr_level [ XOR While When VBAR Type TIMES Switch SLASH SEMI_ELSE SEMI Return RPAR REM RBRACKET RBRACE QMARK PLUS PARAMS OR Namespace NE MINUS Let LT LE LBRACE Interface Import If GT For Export Else EQ2 EOF Default Continue Const Case COMMA COLON Break BIT_XOR BIT_SR BIT_SL BIT_AND Attr AND ]
##
## The known suffix of the stack is as follows:
## NOT
##
interactive_expr: UIdent TIMES ZWSP
##
## Ends in an error in state: 389.
##
## bin_op(mult_expr_level,TIMES,unary_expr_level) -> mult_expr_level TIMES . unary_expr_level [ XOR While When VBAR Type TIMES Switch SLASH SEMI_ELSE SEMI Return RPAR REM RBRACKET RBRACE QMARK PLUS PARAMS OR Namespace NE MINUS Let LT LE LBRACE Interface Import If GT For Export Else EQ2 EOF Default Continue Const Case COMMA COLON Break BIT_XOR BIT_SR BIT_SL BIT_AND Attr AND ]
##
## The known suffix of the stack is as follows:
## mult_expr_level TIMES
##
interactive_expr: UIdent SLASH ZWSP
##
## Ends in an error in state: 403.
##
## bin_op(mult_expr_level,SLASH,unary_expr_level) -> mult_expr_level SLASH . unary_expr_level [ XOR While When VBAR Type TIMES Switch SLASH SEMI_ELSE SEMI Return RPAR REM RBRACKET RBRACE QMARK PLUS PARAMS OR Namespace NE MINUS Let LT LE LBRACE Interface Import If GT For Export Else EQ2 EOF Default Continue Const Case COMMA COLON Break BIT_XOR BIT_SR BIT_SL BIT_AND Attr AND ]
##
## The known suffix of the stack is as follows:
## mult_expr_level SLASH
##
interactive_expr: UIdent REM ZWSP
##
## Ends in an error in state: 405.
##
## bin_op(mult_expr_level,REM,unary_expr_level) -> mult_expr_level REM . unary_expr_level [ XOR While When VBAR Type TIMES Switch SLASH SEMI_ELSE SEMI Return RPAR REM RBRACKET RBRACE QMARK PLUS PARAMS OR Namespace NE MINUS Let LT LE LBRACE Interface Import If GT For Export Else EQ2 EOF Default Continue Const Case COMMA COLON Break BIT_XOR BIT_SR BIT_SL BIT_AND Attr AND ]
##
## The known suffix of the stack is as follows:
## mult_expr_level REM
##
interactive_expr: UIdent XOR ZWSP
##
## Ends in an error in state: 413.
##
## bin_op(disj_expr_level,XOR,conj_expr_level) -> disj_expr_level XOR . conj_expr_level [ XOR While When VBAR Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE QMARK PARAMS OR Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COMMA COLON Break BIT_XOR Attr ]
##
## The known suffix of the stack is as follows:
## disj_expr_level XOR
##
interactive_expr: UIdent BIT_AND ZWSP
##
## Ends in an error in state: 415.
##
## bin_op(conj_expr_level,BIT_AND,bit_shift_level) -> conj_expr_level BIT_AND . bit_shift_level [ XOR While When VBAR Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE QMARK PARAMS OR Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COMMA COLON Break BIT_XOR BIT_AND Attr AND ]
##
## The known suffix of the stack is as follows:
## conj_expr_level BIT_AND
##
interactive_expr: UIdent LT ZWSP
##
## Ends in an error in state: 417.
##
## bin_op(comp_expr_level,LT,add_expr_level) -> comp_expr_level LT . add_expr_level [ XOR While When VBAR Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE QMARK PARAMS OR Namespace Let LT LE LBRACE Interface Import If GT For Export Else EOF Default Continue Const Case COMMA COLON Break BIT_XOR BIT_SR BIT_SL BIT_AND Attr AND ]
##
## The known suffix of the stack is as follows:
## comp_expr_level LT
##
interactive_expr: UIdent PLUS ZWSP
##
## Ends in an error in state: 424.
##
## bin_op(add_expr_level,PLUS,mult_expr_level) -> add_expr_level PLUS . mult_expr_level [ XOR While When VBAR Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE QMARK PLUS PARAMS OR Namespace NE MINUS Let LT LE LBRACE Interface Import If GT For Export Else EQ2 EOF Default Continue Const Case COMMA COLON Break BIT_XOR BIT_SR BIT_SL BIT_AND Attr AND ]
##
## The known suffix of the stack is as follows:
## add_expr_level PLUS
##
interactive_expr: UIdent MINUS ZWSP
##
## Ends in an error in state: 426.
##
## bin_op(add_expr_level,MINUS,mult_expr_level) -> add_expr_level MINUS . mult_expr_level [ XOR While When VBAR Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE QMARK PLUS PARAMS OR Namespace NE MINUS Let LT LE LBRACE Interface Import If GT For Export Else EQ2 EOF Default Continue Const Case COMMA COLON Break BIT_XOR BIT_SR BIT_SL BIT_AND Attr AND ]
##
## The known suffix of the stack is as follows:
## add_expr_level MINUS
##
interactive_expr: UIdent LE ZWSP
##
## Ends in an error in state: 428.
##
## bin_op(comp_expr_level,LE,add_expr_level) -> comp_expr_level LE . add_expr_level [ XOR While When VBAR Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE QMARK PARAMS OR Namespace Let LT LE LBRACE Interface Import If GT For Export Else EOF Default Continue Const Case COMMA COLON Break BIT_XOR BIT_SR BIT_SL BIT_AND Attr AND ]
##
## The known suffix of the stack is as follows:
## comp_expr_level LE
##
interactive_expr: UIdent GT XOR
##
## Ends in an error in state: 433.
##
## bin_op(comp_expr_level,gt,add_expr_level) -> comp_expr_level gt . add_expr_level [ XOR While When VBAR Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE QMARK PARAMS OR Namespace Let LT LE LBRACE Interface Import If GT For Export Else EOF Default Continue Const Case COMMA COLON Break BIT_XOR BIT_SR BIT_SL BIT_AND Attr AND ]
##
## The known suffix of the stack is as follows:
## comp_expr_level gt
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 430, spurious reduction of production gt -> GT
##
interactive_expr: UIdent GT ZWSP EQ ZWSP
##
## Ends in an error in state: 435.
##
## bin_op(comp_expr_level,ge,add_expr_level) -> comp_expr_level ge . add_expr_level [ XOR While When VBAR Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE QMARK PARAMS OR Namespace Let LT LE LBRACE Interface Import If GT For Export Else EOF Default Continue Const Case COMMA COLON Break BIT_XOR BIT_SR BIT_SL BIT_AND Attr AND ]
##
## The known suffix of the stack is as follows:
## comp_expr_level ge
##
interactive_expr: UIdent BIT_SR ZWSP
##
## Ends in an error in state: 438.
##
## bin_op(bit_shift_level,BIT_SR,comp_expr_level) -> bit_shift_level BIT_SR . comp_expr_level [ XOR While When VBAR Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE QMARK PARAMS OR Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COMMA COLON Break BIT_XOR BIT_SR BIT_SL BIT_AND Attr AND ]
##
## The known suffix of the stack is as follows:
## bit_shift_level BIT_SR
##
interactive_expr: UIdent NE ZWSP
##
## Ends in an error in state: 447.
##
## bin_op(add_expr_level,NE,eq_expr_level) -> add_expr_level NE . eq_expr_level [ XOR While When VBAR Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE QMARK PARAMS OR Namespace Let LT LE LBRACE Interface Import If GT For Export Else EOF Default Continue Const Case COMMA COLON Break BIT_XOR BIT_SR BIT_SL BIT_AND Attr AND ]
##
## The known suffix of the stack is as follows:
## add_expr_level NE
##
interactive_expr: UIdent EQ2 ZWSP
##
## Ends in an error in state: 449.
##
## bin_op(add_expr_level,EQ2,eq_expr_level) -> add_expr_level EQ2 . eq_expr_level [ XOR While When VBAR Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE QMARK PARAMS OR Namespace Let LT LE LBRACE Interface Import If GT For Export Else EOF Default Continue Const Case COMMA COLON Break BIT_XOR BIT_SR BIT_SL BIT_AND Attr AND ]
##
## The known suffix of the stack is as follows:
## add_expr_level EQ2
##
interactive_expr: UIdent BIT_SL ZWSP
##
## Ends in an error in state: 451.
##
## bin_op(bit_shift_level,BIT_SL,comp_expr_level) -> bit_shift_level BIT_SL . comp_expr_level [ XOR While When VBAR Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE QMARK PARAMS OR Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COMMA COLON Break BIT_XOR BIT_SR BIT_SL BIT_AND Attr AND ]
##
## The known suffix of the stack is as follows:
## bit_shift_level BIT_SL
##
interactive_expr: UIdent AND ZWSP
##
## Ends in an error in state: 455.
##
## bin_op(conj_expr_level,AND,bit_shift_level) -> conj_expr_level AND . bit_shift_level [ XOR While When VBAR Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE QMARK PARAMS OR Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COMMA COLON Break BIT_XOR BIT_AND Attr AND ]
##
## The known suffix of the stack is as follows:
## conj_expr_level AND
##
interactive_expr: UIdent VBAR ZWSP
##
## Ends in an error in state: 460.
##
## bin_op(disj_expr_level,VBAR,conj_expr_level) -> disj_expr_level VBAR . conj_expr_level [ XOR While When VBAR Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE QMARK PARAMS OR Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COMMA COLON Break BIT_XOR Attr ]
##
## The known suffix of the stack is as follows:
## disj_expr_level VBAR
##
interactive_expr: UIdent QMARK ZWSP
##
## Ends in an error in state: 462.
##
## ternary_expr(disj_expr_level,expr) -> disj_expr_level QMARK . expr COLON expr [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COMMA COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## disj_expr_level QMARK
##
interactive_expr: UIdent OR ZWSP
##
## Ends in an error in state: 494.
##
## bin_op(disj_expr_level,OR,conj_expr_level) -> disj_expr_level OR . conj_expr_level [ XOR While When VBAR Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE QMARK PARAMS OR Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COMMA COLON Break BIT_XOR Attr ]
##
## The known suffix of the stack is as follows:
## disj_expr_level OR
##
interactive_expr: UIdent BIT_XOR ZWSP
##
## Ends in an error in state: 496.
##
## bin_op(disj_expr_level,BIT_XOR,conj_expr_level) -> disj_expr_level BIT_XOR . conj_expr_level [ XOR While When VBAR Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE QMARK PARAMS OR Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COMMA COLON Break BIT_XOR Attr ]
##
## The known suffix of the stack is as follows:
## disj_expr_level BIT_XOR
##

Ill-formed expression.
At this point, an expression is expected.

interactive_expr: UIdent QMARK UIdent While
##
## Ends in an error in state: 468.
##
## ternary_expr(disj_expr_level,expr) -> disj_expr_level QMARK expr . COLON expr [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COMMA COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## disj_expr_level QMARK expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 4, spurious reduction of production ctor -> UIdent
## In state 394, spurious reduction of production core_expr -> ctor
## In state 395, spurious reduction of production app_expr_level -> core_expr
## In state 491, spurious reduction of production unary_expr_level -> app_expr_level
## In state 374, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 388, spurious reduction of production add_expr_level -> mult_expr_level
## In state 446, spurious reduction of production eq_expr_level -> add_expr_level
## In state 411, spurious reduction of production comp_expr_level -> eq_expr_level
## In state 416, spurious reduction of production bit_shift_level -> comp_expr_level
## In state 457, spurious reduction of production conj_expr_level -> bit_shift_level
## In state 471, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 412, spurious reduction of production non_object_expr -> disj_expr_level
## In state 466, spurious reduction of production no_attr_expr -> non_object_expr
## In state 467, spurious reduction of production expr -> no_attr_expr
##

Ill-formed ternary conditional expression.
At this point, a colon ':' is expected, followed by an expresion.

interactive_expr: UIdent QMARK UIdent COLON ZWSP
##
## Ends in an error in state: 469.
##
## ternary_expr(disj_expr_level,expr) -> disj_expr_level QMARK expr COLON . expr [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COMMA COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## disj_expr_level QMARK expr COLON
##

Ill-formed ternary conditional expression.
At this point, an expression is expected.

interactive_expr: UIdent As ZWSP
##
## Ends in an error in state: 492.
##
## typed_expr -> app_expr_level As . type_expr [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COMMA COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## app_expr_level As
##

Ill-formed typed expression.
At this point, a type expression is expected.

interactive_expr: LT GT ES6FUN LPAR PARAMS RPAR COLON Ident XOR
##
## Ends in an error in state: 509.
##
## arrow_fun_expr -> type_vars ES6FUN fun_par_params ret_type . ARROW fun_body [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COMMA COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## type_vars ES6FUN fun_par_params ret_type
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 174, spurious reduction of production type_name -> Ident
## In state 196, spurious reduction of production no_par_type_expr -> type_name
## In state 505, spurious reduction of production type_annotation(__anonymous_6) -> COLON option(ES6FUN) no_par_type_expr
## In state 508, spurious reduction of production ret_type -> type_annotation(__anonymous_6)
##
interactive_expr: ES6FUN LPAR PARAMS RPAR COLON Ident XOR
##
## Ends in an error in state: 549.
##
## arrow_fun_expr -> ES6FUN fun_par_params ret_type . ARROW fun_body [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COMMA COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## ES6FUN fun_par_params ret_type
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 174, spurious reduction of production type_name -> Ident
## In state 196, spurious reduction of production no_par_type_expr -> type_name
## In state 505, spurious reduction of production type_annotation(__anonymous_6) -> COLON option(ES6FUN) no_par_type_expr
## In state 508, spurious reduction of production ret_type -> type_annotation(__anonymous_6)
##

Ill-formed arrow function.
At this point, if the return type is complete, an arrow '=>' is
expected.

interactive_expr: UIdent LPAR UIdent While
##
## Ends in an error in state: 539.
##
## nsepseq(argument,COMMA) -> argument . [ RPAR PARAMS ]
## nsepseq(argument,COMMA) -> argument . COMMA nsepseq(argument,COMMA) [ RPAR PARAMS ]
##
## The known suffix of the stack is as follows:
## argument
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 4, spurious reduction of production ctor -> UIdent
## In state 394, spurious reduction of production core_expr -> ctor
## In state 395, spurious reduction of production app_expr_level -> core_expr
## In state 491, spurious reduction of production unary_expr_level -> app_expr_level
## In state 374, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 388, spurious reduction of production add_expr_level -> mult_expr_level
## In state 446, spurious reduction of production eq_expr_level -> add_expr_level
## In state 411, spurious reduction of production comp_expr_level -> eq_expr_level
## In state 416, spurious reduction of production bit_shift_level -> comp_expr_level
## In state 457, spurious reduction of production conj_expr_level -> bit_shift_level
## In state 471, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 412, spurious reduction of production non_object_expr -> disj_expr_level
## In state 466, spurious reduction of production no_attr_expr -> non_object_expr
## In state 467, spurious reduction of production expr -> no_attr_expr
## In state 538, spurious reduction of production argument -> expr
##

Ill-formed function call.
At this point, one of the following is expected:
   * a comma ',' followed by another argument;
   * a closing parenthesis ')' if no more arguments.

interactive_expr: UIdent LPAR UIdent COMMA ZWSP
##
## Ends in an error in state: 540.
##
## nsepseq(argument,COMMA) -> argument COMMA . nsepseq(argument,COMMA) [ RPAR PARAMS ]
##
## The known suffix of the stack is as follows:
## argument COMMA
##

Ill-formed function call.
At this point, another argument is expected.

interactive_expr: LBRACE ELLIPSIS UIdent While
##
## Ends in an error in state: 1049.
##
## update_expr -> ELLIPSIS expr . property_sep updates [ RBRACE ]
##
## The known suffix of the stack is as follows:
## ELLIPSIS expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 4, spurious reduction of production ctor -> UIdent
## In state 394, spurious reduction of production core_expr -> ctor
## In state 395, spurious reduction of production app_expr_level -> core_expr
## In state 491, spurious reduction of production unary_expr_level -> app_expr_level
## In state 374, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 388, spurious reduction of production add_expr_level -> mult_expr_level
## In state 446, spurious reduction of production eq_expr_level -> add_expr_level
## In state 411, spurious reduction of production comp_expr_level -> eq_expr_level
## In state 416, spurious reduction of production bit_shift_level -> comp_expr_level
## In state 457, spurious reduction of production conj_expr_level -> bit_shift_level
## In state 471, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 412, spurious reduction of production non_object_expr -> disj_expr_level
## In state 466, spurious reduction of production no_attr_expr -> non_object_expr
## In state 467, spurious reduction of production expr -> no_attr_expr
##

Ill-formed object update.
At this point, a property separator (';' or ',') is expected.

interactive_expr: LBRACE ELLIPSIS UIdent COMMA ZWSP
##
## Ends in an error in state: 1050.
##
## update_expr -> ELLIPSIS expr property_sep . updates [ RBRACE ]
##
## The known suffix of the stack is as follows:
## ELLIPSIS expr property_sep
##

Ill-formed object update.
At this point, property assignments are expected.

interactive_expr: LBRACE Attr ZWSP
##
## Ends in an error in state: 1051.
##
## property(expr) -> Attr . property(expr) [ SEMI RBRACE COMMA ]
##
## The known suffix of the stack is as follows:
## Attr
##

Ill-formed decorated property.
At this point, one of the following is expected:
  * another decorator;
  * a property.

interactive_expr: LBRACE Ident ZWSP
##
## Ends in an error in state: 1052.
##
## property(expr) -> property_id . [ SEMI RBRACE COMMA ]
## property(expr) -> property_id . COLON expr [ SEMI RBRACE COMMA ]
##
## The known suffix of the stack is as follows:
## property_id
##

Ill-formed object.
At this point, one of the following is expected:
  * a colon ':' followed by a pattern matching the property;
  * a property separator (';' or ',') to match any property;
  * a closing brace '}' if no more properties.

interactive_expr: LBRACE Ident COLON ZWSP
##
## Ends in an error in state: 1053.
##
## property(expr) -> property_id COLON . expr [ SEMI RBRACE COMMA ]
##
## The known suffix of the stack is as follows:
## property_id COLON
##

Ill-formed object.
Att his point, an expression is expected for the property.

interactive_expr: LBRACE Ident COLON UIdent While
##
## Ends in an error in state: 1058.
##
## nsepseq(property(expr),property_sep) -> property(expr) . [ RBRACE ]
## nsepseq(property(expr),property_sep) -> property(expr) . property_sep nsepseq(property(expr),property_sep) [ RBRACE ]
## nseq(__anonymous_0(property(expr),property_sep)) -> property(expr) . property_sep [ RBRACE ]
## nseq(__anonymous_0(property(expr),property_sep)) -> property(expr) . property_sep nseq(__anonymous_0(property(expr),property_sep)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## property(expr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 4, spurious reduction of production ctor -> UIdent
## In state 394, spurious reduction of production core_expr -> ctor
## In state 395, spurious reduction of production app_expr_level -> core_expr
## In state 491, spurious reduction of production unary_expr_level -> app_expr_level
## In state 374, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 388, spurious reduction of production add_expr_level -> mult_expr_level
## In state 446, spurious reduction of production eq_expr_level -> add_expr_level
## In state 411, spurious reduction of production comp_expr_level -> eq_expr_level
## In state 416, spurious reduction of production bit_shift_level -> comp_expr_level
## In state 457, spurious reduction of production conj_expr_level -> bit_shift_level
## In state 471, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 412, spurious reduction of production non_object_expr -> disj_expr_level
## In state 466, spurious reduction of production no_attr_expr -> non_object_expr
## In state 467, spurious reduction of production expr -> no_attr_expr
## In state 1054, spurious reduction of production property(expr) -> property_id COLON expr
##

Ill-formed object.
At this point, one of the following is expected:
  * a property separator (';' or ',');
  * a closing brace '}' if no more properties.

interactive_expr: LBRACE Ident COMMA ZWSP
##
## Ends in an error in state: 1059.
##
## nsepseq(property(expr),property_sep) -> property(expr) property_sep . nsepseq(property(expr),property_sep) [ RBRACE ]
## nseq(__anonymous_0(property(expr),property_sep)) -> property(expr) property_sep . [ RBRACE ]
## nseq(__anonymous_0(property(expr),property_sep)) -> property(expr) property_sep . nseq(__anonymous_0(property(expr),property_sep)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## property(expr) property_sep
##

Ill-formed object.
At this point, one of the following is expected:
  * a property pattern;
  * a closing brace '}' if no more properties.

interactive_expr: LBRACKET ELLIPSIS ZWSP
##
## Ends in an error in state: 1069.
##
## element(expr) -> ELLIPSIS . expr [ RBRACKET COMMA ]
##
## The known suffix of the stack is as follows:
## ELLIPSIS
##

Ill-formed array.
At this point, and expression denoting an array is expected.

interactive_expr: LBRACKET UIdent While
##
## Ends in an error in state: 1077.
##
## nsepseq(element(expr),COMMA) -> element(expr) . [ RBRACKET ]
## nsepseq(element(expr),COMMA) -> element(expr) . COMMA nsepseq(element(expr),COMMA) [ RBRACKET ]
## nseq(__anonymous_0(element(expr),COMMA)) -> element(expr) . COMMA [ RBRACKET ]
## nseq(__anonymous_0(element(expr),COMMA)) -> element(expr) . COMMA nseq(__anonymous_0(element(expr),COMMA)) [ RBRACKET ]
##
## The known suffix of the stack is as follows:
## element(expr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 4, spurious reduction of production ctor -> UIdent
## In state 394, spurious reduction of production core_expr -> ctor
## In state 395, spurious reduction of production app_expr_level -> core_expr
## In state 491, spurious reduction of production unary_expr_level -> app_expr_level
## In state 374, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 388, spurious reduction of production add_expr_level -> mult_expr_level
## In state 446, spurious reduction of production eq_expr_level -> add_expr_level
## In state 411, spurious reduction of production comp_expr_level -> eq_expr_level
## In state 416, spurious reduction of production bit_shift_level -> comp_expr_level
## In state 457, spurious reduction of production conj_expr_level -> bit_shift_level
## In state 471, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 412, spurious reduction of production non_object_expr -> disj_expr_level
## In state 466, spurious reduction of production no_attr_expr -> non_object_expr
## In state 467, spurious reduction of production expr -> no_attr_expr
## In state 1076, spurious reduction of production element(expr) -> expr
##

Ill-formed array.
At this point, one of following is expected:
  * a comma ',' followed by another element;
  * a closing bracket ']' is no more elements.

interactive_expr: LBRACKET UIdent COMMA ZWSP
##
## Ends in an error in state: 1078.
##
## nsepseq(element(expr),COMMA) -> element(expr) COMMA . nsepseq(element(expr),COMMA) [ RBRACKET ]
## nseq(__anonymous_0(element(expr),COMMA)) -> element(expr) COMMA . [ RBRACKET ]
## nseq(__anonymous_0(element(expr),COMMA)) -> element(expr) COMMA . nseq(__anonymous_0(element(expr),COMMA)) [ RBRACKET ]
##
## The known suffix of the stack is as follows:
## element(expr) COMMA
##

Ill-formed array.
At this point, one of the following is expected:
  * another element;
  * a closing bracket ']' is no more elements.

interactive_expr: Match LPAR UIdent RPAR LBRACE Default ZWSP
##
## Ends in an error in state: 1084.
##
## match_default -> Default . COLON expr [ RBRACE ]
## match_default -> Default . COLON expr SEMI [ RBRACE ]
##
## The known suffix of the stack is as follows:
## Default
##

Ill-formed default matching clause.
At this point, a colon ':' is expected, followed by an expression.

interactive_expr: Match LPAR UIdent RPAR LBRACE Default COLON ZWSP
##
## Ends in an error in state: 1085.
##
## match_default -> Default COLON . expr [ RBRACE ]
## match_default -> Default COLON . expr SEMI [ RBRACE ]
##
## The known suffix of the stack is as follows:
## Default COLON
##

Ill-formed default matching clause.
At this point, the clause expression is expected.

interactive_expr: Match LPAR UIdent RPAR LBRACE Default COLON UIdent While
##
## Ends in an error in state: 1086.
##
## match_default -> Default COLON expr . [ RBRACE ]
## match_default -> Default COLON expr . SEMI [ RBRACE ]
##
## The known suffix of the stack is as follows:
## Default COLON expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 4, spurious reduction of production ctor -> UIdent
## In state 394, spurious reduction of production core_expr -> ctor
## In state 395, spurious reduction of production app_expr_level -> core_expr
## In state 491, spurious reduction of production unary_expr_level -> app_expr_level
## In state 374, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 388, spurious reduction of production add_expr_level -> mult_expr_level
## In state 446, spurious reduction of production eq_expr_level -> add_expr_level
## In state 411, spurious reduction of production comp_expr_level -> eq_expr_level
## In state 416, spurious reduction of production bit_shift_level -> comp_expr_level
## In state 457, spurious reduction of production conj_expr_level -> bit_shift_level
## In state 471, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 412, spurious reduction of production non_object_expr -> disj_expr_level
## In state 466, spurious reduction of production no_attr_expr -> non_object_expr
## In state 467, spurious reduction of production expr -> no_attr_expr
##
contract: Match LPAR UIdent RPAR LBRACE Default COLON UIdent SEMI ZWSP
##
## Ends in an error in state: 1091.
##
## braces(match_clauses) -> LBRACE match_clauses . RBRACE [ While When Type Switch SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PARAMS Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COMMA COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## LBRACE match_clauses
##

Ill-formed pattern matching.
At this point, a closing brace '}' is expected.

interactive_expr: Match LPAR UIdent RPAR LBRACE When LPAR Bytes RPAR COLON UIdent While
##
## Ends in an error in state: 1082.
##
## match_clause -> When par(pattern) COLON expr . [ When RBRACE Default ]
## match_clause -> When par(pattern) COLON expr . SEMI [ When RBRACE Default ]
##
## The known suffix of the stack is as follows:
## When par(pattern) COLON expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 4, spurious reduction of production ctor -> UIdent
## In state 394, spurious reduction of production core_expr -> ctor
## In state 395, spurious reduction of production app_expr_level -> core_expr
## In state 491, spurious reduction of production unary_expr_level -> app_expr_level
## In state 374, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 388, spurious reduction of production add_expr_level -> mult_expr_level
## In state 446, spurious reduction of production eq_expr_level -> add_expr_level
## In state 411, spurious reduction of production comp_expr_level -> eq_expr_level
## In state 416, spurious reduction of production bit_shift_level -> comp_expr_level
## In state 457, spurious reduction of production conj_expr_level -> bit_shift_level
## In state 471, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 412, spurious reduction of production non_object_expr -> disj_expr_level
## In state 466, spurious reduction of production no_attr_expr -> non_object_expr
## In state 467, spurious reduction of production expr -> no_attr_expr
##
contract: Match LPAR UIdent RPAR LBRACE When LPAR UIdent RPAR COLON UIdent SEMI ZWSP
##
## Ends in an error in state: 1093.
##
## nseq(match_clause) -> match_clause . [ RBRACE Default ]
## nseq(match_clause) -> match_clause . nseq(match_clause) [ RBRACE Default ]
##
## The known suffix of the stack is as follows:
## match_clause
##

Ill-formed pattern matching.
At this point, if the previous clause is complete, one of the
following is expected:
  * the keyword 'when' to introduce a new clause;
  * the keyword 'default' to introduce the default clause;
  * a closing brace '}' if no more clauses.

interactive_expr: LPAR UIdent While
##
## Ends in an error in state: 1096.
##
## par(expr) -> LPAR expr . RPAR [ XOR While When VBAR Type TIMES Switch SLASH SEMI_ELSE SEMI Return RPAR REM RBRACKET RBRACE QMARK PLUS PARAMS OR Namespace NE MINUS Let LT LPAR LE LBRACKET LBRACE Interface Import If GT For Export Else EQ2 EOF Default DOT Continue Const Case COMMA COLON Break BIT_XOR BIT_SR BIT_SL BIT_AND Attr As AND ]
## par(expr) -> LPAR expr . PARAMS RPAR [ XOR While When VBAR Type TIMES Switch SLASH SEMI_ELSE SEMI Return RPAR REM RBRACKET RBRACE QMARK PLUS PARAMS OR Namespace NE MINUS Let LT LPAR LE LBRACKET LBRACE Interface Import If GT For Export Else EQ2 EOF Default DOT Continue Const Case COMMA COLON Break BIT_XOR BIT_SR BIT_SL BIT_AND Attr As AND ]
##
## The known suffix of the stack is as follows:
## LPAR expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 4, spurious reduction of production ctor -> UIdent
## In state 394, spurious reduction of production core_expr -> ctor
## In state 395, spurious reduction of production app_expr_level -> core_expr
## In state 491, spurious reduction of production unary_expr_level -> app_expr_level
## In state 374, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 388, spurious reduction of production add_expr_level -> mult_expr_level
## In state 446, spurious reduction of production eq_expr_level -> add_expr_level
## In state 411, spurious reduction of production comp_expr_level -> eq_expr_level
## In state 416, spurious reduction of production bit_shift_level -> comp_expr_level
## In state 457, spurious reduction of production conj_expr_level -> bit_shift_level
## In state 471, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 412, spurious reduction of production non_object_expr -> disj_expr_level
## In state 466, spurious reduction of production no_attr_expr -> non_object_expr
## In state 467, spurious reduction of production expr -> no_attr_expr
##
interactive_expr: LPAR UIdent PARAMS ZWSP
##
## Ends in an error in state: 1098.
##
## par(expr) -> LPAR expr PARAMS . RPAR [ XOR While When VBAR Type TIMES Switch SLASH SEMI_ELSE SEMI Return RPAR REM RBRACKET RBRACE QMARK PLUS PARAMS OR Namespace NE MINUS Let LT LPAR LE LBRACKET LBRACE Interface Import If GT For Export Else EQ2 EOF Default DOT Continue Const Case COMMA COLON Break BIT_XOR BIT_SR BIT_SL BIT_AND Attr As AND ]
##
## The known suffix of the stack is as follows:
## LPAR expr PARAMS
##

Ill-formed parenthesised expression.
At this point, if the expression is complete, a closing parenthesis
')' is expected.

contract: Namespace UIdent LBRACE While LPAR UIdent While
##
## Ends in an error in state: 1101.
##
## par(while_cond) -> LPAR while_cond . RPAR [ While Verbatim UIdent Type True Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export Directive Continue Const Bytes Break Attr ]
## par(while_cond) -> LPAR while_cond . PARAMS RPAR [ While Verbatim UIdent Type True Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export Directive Continue Const Bytes Break Attr ]
##
## The known suffix of the stack is as follows:
## LPAR while_cond
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 4, spurious reduction of production ctor -> UIdent
## In state 394, spurious reduction of production core_expr -> ctor
## In state 395, spurious reduction of production app_expr_level -> core_expr
## In state 491, spurious reduction of production unary_expr_level -> app_expr_level
## In state 374, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 388, spurious reduction of production add_expr_level -> mult_expr_level
## In state 446, spurious reduction of production eq_expr_level -> add_expr_level
## In state 411, spurious reduction of production comp_expr_level -> eq_expr_level
## In state 416, spurious reduction of production bit_shift_level -> comp_expr_level
## In state 457, spurious reduction of production conj_expr_level -> bit_shift_level
## In state 471, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 412, spurious reduction of production non_object_expr -> disj_expr_level
## In state 466, spurious reduction of production no_attr_expr -> non_object_expr
## In state 467, spurious reduction of production expr -> no_attr_expr
## In state 1105, spurious reduction of production while_cond -> expr
##
contract: Namespace UIdent LBRACE While LPAR UIdent PARAMS ZWSP
##
## Ends in an error in state: 1103.
##
## par(while_cond) -> LPAR while_cond PARAMS . RPAR [ While Verbatim UIdent Type True Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export Directive Continue Const Bytes Break Attr ]
##
## The known suffix of the stack is as follows:
## LPAR while_cond PARAMS
##

Ill-formed while-loop.
At this point, a closing parenthesis ')' is expected.

contract: Namespace UIdent LBRACE While LPAR UIdent RPAR ZWSP
##
## Ends in an error in state: 1106.
##
## while_stmt(poly_stmt) -> While par(while_cond) . poly_stmt [ While Verbatim UIdent Type True Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export Directive Continue Const Bytes Break Attr ]
## while_stmt(statement) -> While par(while_cond) . statement [ SEMI RBRACE EOF Default Case ]
## while_stmt(stmt_ending_with_expr) -> While par(while_cond) . stmt_ending_with_expr [ While Type Switch Return Namespace Let LBRACE Interface Import If For Export Continue Const Break Attr ]
##
## The known suffix of the stack is as follows:
## While par(while_cond)
##

Ill-formed while-loop.
At this point, the body is expectes as a statement.

contract: Namespace UIdent LBRACE Switch ZWSP
##
## Ends in an error in state: 316.
##
## switch_stmt -> Switch . par(switch_subject) braces(cases) [ While Verbatim UIdent Type True Switch String SEMI_ELSE SEMI Return RBRACE PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export Else EOF Directive Default Continue Const Case Bytes Break Attr ]
##
## The known suffix of the stack is as follows:
## Switch
##

Ill-formed switch.
At this point, an opening parenthesis '(' is expected, followed by an
expression.

contract: Namespace UIdent LBRACE Switch LPAR ZWSP
##
## Ends in an error in state: 317.
##
## par(switch_subject) -> LPAR . switch_subject RPAR [ LBRACE ]
## par(switch_subject) -> LPAR . switch_subject PARAMS RPAR [ LBRACE ]
##
## The known suffix of the stack is as follows:
## LPAR
##

Ill-formed switch.
At this point, the expression used to switch is expected.

contract: Namespace UIdent LBRACE Switch LPAR UIdent While
##
## Ends in an error in state: 552.
##
## par(switch_subject) -> LPAR switch_subject . RPAR [ LBRACE ]
## par(switch_subject) -> LPAR switch_subject . PARAMS RPAR [ LBRACE ]
##
## The known suffix of the stack is as follows:
## LPAR switch_subject
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 4, spurious reduction of production ctor -> UIdent
## In state 394, spurious reduction of production core_expr -> ctor
## In state 395, spurious reduction of production app_expr_level -> core_expr
## In state 491, spurious reduction of production unary_expr_level -> app_expr_level
## In state 374, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 388, spurious reduction of production add_expr_level -> mult_expr_level
## In state 446, spurious reduction of production eq_expr_level -> add_expr_level
## In state 411, spurious reduction of production comp_expr_level -> eq_expr_level
## In state 416, spurious reduction of production bit_shift_level -> comp_expr_level
## In state 457, spurious reduction of production conj_expr_level -> bit_shift_level
## In state 471, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 412, spurious reduction of production non_object_expr -> disj_expr_level
## In state 466, spurious reduction of production no_attr_expr -> non_object_expr
## In state 467, spurious reduction of production expr -> no_attr_expr
## In state 556, spurious reduction of production switch_subject -> expr
##
contract: Namespace UIdent LBRACE Switch LPAR UIdent PARAMS ZWSP
##
## Ends in an error in state: 554.
##
## par(switch_subject) -> LPAR switch_subject PARAMS . RPAR [ LBRACE ]
##
## The known suffix of the stack is as follows:
## LPAR switch_subject PARAMS
##

Ill-formed switch.
At this point, a closing parenthesis ')' is expected.

contract: Namespace UIdent LBRACE Switch LPAR UIdent RPAR ZWSP
##
## Ends in an error in state: 557.
##
## switch_stmt -> Switch par(switch_subject) . braces(cases) [ While Verbatim UIdent Type True Switch String SEMI_ELSE SEMI Return RBRACE PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export Else EOF Directive Default Continue Const Case Bytes Break Attr ]
##
## The known suffix of the stack is as follows:
## Switch par(switch_subject)
##

Ill-formed switch.
At this point, an opening brace '{' is expected, followed by cases.

contract: Namespace UIdent LBRACE Switch LPAR UIdent RPAR LBRACE ZWSP
##
## Ends in an error in state: 558.
##
## braces(cases) -> LBRACE . cases RBRACE [ While Verbatim UIdent Type True Switch String SEMI_ELSE SEMI Return RBRACE PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export Else EOF Directive Default Continue Const Case Bytes Break Attr ]
##
## The known suffix of the stack is as follows:
## LBRACE
##

Ill-formed switch.
At this point, one of the following is expected:
  * the keyword 'case' introducing a new case;
  * the keyword 'default' introducting the default case.

contract: Namespace UIdent LBRACE Switch LPAR UIdent RPAR LBRACE Default ZWSP
##
## Ends in an error in state: 559.
##
## switch_default -> Default . COLON [ RBRACE ]
## switch_default -> Default . COLON statements [ RBRACE ]
##
## The known suffix of the stack is as follows:
## Default
##

Ill-formed default switch case
At this point, a colon ':' is expected.

contract: Namespace UIdent LBRACE Switch LPAR UIdent RPAR LBRACE Default COLON ZWSP
##
## Ends in an error in state: 560.
##
## switch_default -> Default COLON . [ RBRACE ]
## switch_default -> Default COLON . statements [ RBRACE ]
##
## The known suffix of the stack is as follows:
## Default COLON
##

Ill-formed default switch case
At this point, one of the following is expected:
  * a colon ':' optionally followed by statements;
  * a closing brace '}' if nor more cases.

contract: Let ZWSP
##
## Ends in an error in state: 597.
##
## value_decl -> Let . bindings [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case Break Attr ]
##
## The known suffix of the stack is as follows:
## Let
##
contract: Const Bytes EQ UIdent COMMA ZWSP
##
## Ends in an error in state: 599.
##
## nsepseq(val_binding,COMMA) -> val_binding COMMA . nsepseq(val_binding,COMMA) [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case Break Attr ]
##
## The known suffix of the stack is as follows:
## val_binding COMMA
##

Ill-formed value declaration.
At this point, a pattern is expected, e.g. a variable.

contract: Const Bytes ZWSP
##
## Ends in an error in state: 600.
##
## val_binding -> pattern . option(binding_type) EQ expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COMMA Break Attr ]
##
## The known suffix of the stack is as follows:
## pattern
##

Ill-formed value declaration.
At this point, one of the following is expected:
  * a colon ':' followed by the type of the value;
  * the assignment symbol '=' followed by an expression.

contract: Const Bytes COLON ZWSP
##
## Ends in an error in state: 601.
##
## type_annotation(__anonymous_2) -> COLON . type_expr [ EQ ]
## type_annotation(__anonymous_2) -> COLON . type_vars type_expr [ EQ ]
##
## The known suffix of the stack is as follows:
## COLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Const Bytes COLON LT GT XOR
##
## Ends in an error in state: 602.
##
## type_annotation(__anonymous_2) -> COLON type_vars . type_expr [ EQ ]
##
## The known suffix of the stack is as follows:
## COLON type_vars
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 91, spurious reduction of production chevrons(sep_or_term(type_var,COMMA)) -> LT sep_or_term(type_var,COMMA) GT
## In state 315, spurious reduction of production type_vars -> chevrons(sep_or_term(type_var,COMMA))
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Const Bytes COLON Ident XOR
##
## Ends in an error in state: 606.
##
## val_binding -> pattern option(binding_type) . EQ expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COMMA Break Attr ]
##
## The known suffix of the stack is as follows:
## pattern option(binding_type)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 174, spurious reduction of production type_name -> Ident
## In state 196, spurious reduction of production no_par_type_expr -> type_name
## In state 227, spurious reduction of production core_type_no_string -> no_par_type_expr
## In state 237, spurious reduction of production core_type -> core_type_no_string
## In state 238, spurious reduction of production type_expr -> core_type
## In state 604, spurious reduction of production type_annotation(__anonymous_2) -> COLON type_expr
## In state 605, spurious reduction of production binding_type -> type_annotation(__anonymous_2)
## In state 609, spurious reduction of production option(binding_type) -> binding_type
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Const Bytes EQ ZWSP
##
## Ends in an error in state: 607.
##
## val_binding -> pattern option(binding_type) EQ . expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COMMA Break Attr ]
##
## The known suffix of the stack is as follows:
## pattern option(binding_type) EQ
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Interface ZWSP
##
## Ends in an error in state: 613.
##
## interface_decl -> Interface . intf_name intf_body [ While Verbatim UIdent Type True Switch String SEMI_ELSE SEMI Return RBRACE PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export Else EOF Directive Default Continue Const Case Bytes Break Attr ]
##
## The known suffix of the stack is as follows:
## Interface
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Interface UIdent ZWSP
##
## Ends in an error in state: 615.
##
## interface_decl -> Interface intf_name . intf_body [ While Verbatim UIdent Type True Switch String SEMI_ELSE SEMI Return RBRACE PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export Else EOF Directive Default Continue Const Case Bytes Break Attr ]
##
## The known suffix of the stack is as follows:
## Interface intf_name
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Interface UIdent LBRACE ZWSP
##
## Ends in an error in state: 568.
##
## braces(intf_entries) -> LBRACE . intf_entries RBRACE [ While Verbatim UIdent Type True Switch String SEMI_ELSE SEMI Return RBRACE PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export Else EOF Directive Default Continue Const Case Bytes Break Attr ]
##
## The known suffix of the stack is as follows:
## LBRACE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Interface UIdent LBRACE Type ZWSP
##
## Ends in an error in state: 569.
##
## intf_type -> Type . type_name EQ type_expr [ SEMI RBRACE ]
## intf_type -> Type . type_name [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## Type
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Interface UIdent LBRACE Type Ident ZWSP
##
## Ends in an error in state: 570.
##
## intf_type -> Type type_name . EQ type_expr [ SEMI RBRACE ]
## intf_type -> Type type_name . [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## Type type_name
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Interface UIdent LBRACE Type Ident EQ ZWSP
##
## Ends in an error in state: 571.
##
## intf_type -> Type type_name EQ . type_expr [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## Type type_name EQ
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Interface UIdent LBRACE Const ZWSP
##
## Ends in an error in state: 573.
##
## intf_const -> Const . Ident type_annotation(type_expr) [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## Const
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Interface UIdent LBRACE Const Ident ZWSP
##
## Ends in an error in state: 574.
##
## intf_const -> Const Ident . type_annotation(type_expr) [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## Const Ident
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Interface UIdent LBRACE Attr ZWSP
##
## Ends in an error in state: 576.
##
## intf_entry -> Attr . intf_entry [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## Attr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Interface UIdent LBRACE Const Ident COLON Ident XOR
##
## Ends in an error in state: 584.
##
## nsepseq(intf_entry,SEMI) -> intf_entry . [ RBRACE ]
## nsepseq(intf_entry,SEMI) -> intf_entry . SEMI nsepseq(intf_entry,SEMI) [ RBRACE ]
## nseq(__anonymous_0(intf_entry,SEMI)) -> intf_entry . SEMI [ RBRACE ]
## nseq(__anonymous_0(intf_entry,SEMI)) -> intf_entry . SEMI nseq(__anonymous_0(intf_entry,SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## intf_entry
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 174, spurious reduction of production type_name -> Ident
## In state 196, spurious reduction of production no_par_type_expr -> type_name
## In state 227, spurious reduction of production core_type_no_string -> no_par_type_expr
## In state 237, spurious reduction of production core_type -> core_type_no_string
## In state 238, spurious reduction of production type_expr -> core_type
## In state 287, spurious reduction of production type_annotation(type_expr) -> COLON type_expr
## In state 575, spurious reduction of production intf_const -> Const Ident type_annotation(type_expr)
## In state 579, spurious reduction of production intf_entry -> intf_const
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Interface UIdent LBRACE Type Ident SEMI ZWSP
##
## Ends in an error in state: 585.
##
## nsepseq(intf_entry,SEMI) -> intf_entry SEMI . nsepseq(intf_entry,SEMI) [ RBRACE ]
## nseq(__anonymous_0(intf_entry,SEMI)) -> intf_entry SEMI . [ RBRACE ]
## nseq(__anonymous_0(intf_entry,SEMI)) -> intf_entry SEMI . nseq(__anonymous_0(intf_entry,SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## intf_entry SEMI
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Import ZWSP
##
## Ends in an error in state: 617.
##
## import_decl -> Import . namespace_name EQ namespace_selection [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case Break Attr ]
## import_decl -> Import . TIMES As namespace_name From file_path [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case Break Attr ]
## import_decl -> Import . braces(sep_or_term(variable,COMMA)) From file_path [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case Break Attr ]
##
## The known suffix of the stack is as follows:
## Import
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Import TIMES ZWSP
##
## Ends in an error in state: 618.
##
## import_decl -> Import TIMES . As namespace_name From file_path [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case Break Attr ]
##
## The known suffix of the stack is as follows:
## Import TIMES
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Import TIMES As ZWSP
##
## Ends in an error in state: 619.
##
## import_decl -> Import TIMES As . namespace_name From file_path [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case Break Attr ]
##
## The known suffix of the stack is as follows:
## Import TIMES As
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Import TIMES As UIdent ZWSP
##
## Ends in an error in state: 620.
##
## import_decl -> Import TIMES As namespace_name . From file_path [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case Break Attr ]
##
## The known suffix of the stack is as follows:
## Import TIMES As namespace_name
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Import TIMES As UIdent From ZWSP
##
## Ends in an error in state: 621.
##
## import_decl -> Import TIMES As namespace_name From . file_path [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case Break Attr ]
##
## The known suffix of the stack is as follows:
## Import TIMES As namespace_name From
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Import LBRACE ZWSP
##
## Ends in an error in state: 624.
##
## braces(sep_or_term(variable,COMMA)) -> LBRACE . sep_or_term(variable,COMMA) RBRACE [ From ]
##
## The known suffix of the stack is as follows:
## LBRACE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Import LBRACE Ident ZWSP
##
## Ends in an error in state: 625.
##
## nsepseq(variable,COMMA) -> Ident . [ RBRACE ]
## nsepseq(variable,COMMA) -> Ident . COMMA nsepseq(variable,COMMA) [ RBRACE ]
## nseq(__anonymous_0(variable,COMMA)) -> Ident . COMMA [ RBRACE ]
## nseq(__anonymous_0(variable,COMMA)) -> Ident . COMMA nseq(__anonymous_0(variable,COMMA)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## Ident
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Import LBRACE Ident COMMA ZWSP
##
## Ends in an error in state: 626.
##
## nsepseq(variable,COMMA) -> Ident COMMA . nsepseq(variable,COMMA) [ RBRACE ]
## nseq(__anonymous_0(variable,COMMA)) -> Ident COMMA . [ RBRACE ]
## nseq(__anonymous_0(variable,COMMA)) -> Ident COMMA . nseq(__anonymous_0(variable,COMMA)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## Ident COMMA
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Import UIdent ZWSP
##
## Ends in an error in state: 634.
##
## import_decl -> Import namespace_name . EQ namespace_selection [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case Break Attr ]
##
## The known suffix of the stack is as follows:
## Import namespace_name
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Import UIdent EQ ZWSP
##
## Ends in an error in state: 635.
##
## import_decl -> Import namespace_name EQ . namespace_selection [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case Break Attr ]
##
## The known suffix of the stack is as follows:
## Import namespace_name EQ
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Import LBRACE RBRACE ZWSP
##
## Ends in an error in state: 637.
##
## import_decl -> Import braces(sep_or_term(variable,COMMA)) . From file_path [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case Break Attr ]
##
## The known suffix of the stack is as follows:
## Import braces(sep_or_term(variable,COMMA))
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Import LBRACE RBRACE From ZWSP
##
## Ends in an error in state: 638.
##
## import_decl -> Import braces(sep_or_term(variable,COMMA)) From . file_path [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case Break Attr ]
##
## The known suffix of the stack is as follows:
## Import braces(sep_or_term(variable,COMMA)) From
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Namespace UIdent LBRACE If ZWSP
##
## Ends in an error in state: 640.
##
## if_else_stmt(poly_stmt) -> If . par(if_cond) closed_non_if_stmt Else poly_stmt [ While Verbatim UIdent Type True Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export Directive Continue Const Bytes Break Attr ]
## if_else_stmt(poly_stmt) -> If . par(if_cond) closed_non_if_stmt SEMI_ELSE poly_stmt [ While Verbatim UIdent Type True Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export Directive Continue Const Bytes Break Attr ]
## if_else_stmt(statement) -> If . par(if_cond) closed_non_if_stmt Else statement [ SEMI RBRACE EOF Default Case ]
## if_else_stmt(statement) -> If . par(if_cond) closed_non_if_stmt SEMI_ELSE statement [ SEMI RBRACE EOF Default Case ]
## if_else_stmt(stmt_ending_with_expr) -> If . par(if_cond) closed_non_if_stmt Else stmt_ending_with_expr [ While Type Switch Return Namespace Let LBRACE Interface Import If For Export Continue Const Break Attr ]
## if_else_stmt(stmt_ending_with_expr) -> If . par(if_cond) closed_non_if_stmt SEMI_ELSE stmt_ending_with_expr [ While Type Switch Return Namespace Let LBRACE Interface Import If For Export Continue Const Break Attr ]
## if_stmt(poly_stmt) -> If . par(if_cond) poly_stmt [ While Verbatim UIdent Type True Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export Directive Continue Const Bytes Break Attr ]
## if_stmt(statement) -> If . par(if_cond) statement [ SEMI RBRACE EOF Default Case ]
## if_stmt(stmt_ending_with_expr) -> If . par(if_cond) stmt_ending_with_expr [ While Type Switch Return Namespace Let LBRACE Interface Import If For Export Continue Const Break Attr ]
##
## The known suffix of the stack is as follows:
## If
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Namespace UIdent LBRACE If LPAR ZWSP
##
## Ends in an error in state: 641.
##
## par(if_cond) -> LPAR . if_cond RPAR [ While Verbatim UIdent Type True Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export Directive Continue Const Bytes Break Attr ]
## par(if_cond) -> LPAR . if_cond PARAMS RPAR [ While Verbatim UIdent Type True Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export Directive Continue Const Bytes Break Attr ]
##
## The known suffix of the stack is as follows:
## LPAR
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Namespace UIdent LBRACE If LPAR UIdent While
##
## Ends in an error in state: 642.
##
## par(if_cond) -> LPAR if_cond . RPAR [ While Verbatim UIdent Type True Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export Directive Continue Const Bytes Break Attr ]
## par(if_cond) -> LPAR if_cond . PARAMS RPAR [ While Verbatim UIdent Type True Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export Directive Continue Const Bytes Break Attr ]
##
## The known suffix of the stack is as follows:
## LPAR if_cond
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 4, spurious reduction of production ctor -> UIdent
## In state 394, spurious reduction of production core_expr -> ctor
## In state 395, spurious reduction of production app_expr_level -> core_expr
## In state 491, spurious reduction of production unary_expr_level -> app_expr_level
## In state 374, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 388, spurious reduction of production add_expr_level -> mult_expr_level
## In state 446, spurious reduction of production eq_expr_level -> add_expr_level
## In state 411, spurious reduction of production comp_expr_level -> eq_expr_level
## In state 416, spurious reduction of production bit_shift_level -> comp_expr_level
## In state 457, spurious reduction of production conj_expr_level -> bit_shift_level
## In state 471, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 412, spurious reduction of production non_object_expr -> disj_expr_level
## In state 466, spurious reduction of production no_attr_expr -> non_object_expr
## In state 467, spurious reduction of production expr -> no_attr_expr
## In state 646, spurious reduction of production if_cond -> expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Namespace UIdent LBRACE If LPAR UIdent PARAMS ZWSP
##
## Ends in an error in state: 644.
##
## par(if_cond) -> LPAR if_cond PARAMS . RPAR [ While Verbatim UIdent Type True Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export Directive Continue Const Bytes Break Attr ]
##
## The known suffix of the stack is as follows:
## LPAR if_cond PARAMS
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Namespace UIdent LBRACE If LPAR UIdent RPAR ZWSP
##
## Ends in an error in state: 647.
##
## if_else_stmt(poly_stmt) -> If par(if_cond) . closed_non_if_stmt Else poly_stmt [ While Verbatim UIdent Type True Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export Directive Continue Const Bytes Break Attr ]
## if_else_stmt(poly_stmt) -> If par(if_cond) . closed_non_if_stmt SEMI_ELSE poly_stmt [ While Verbatim UIdent Type True Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export Directive Continue Const Bytes Break Attr ]
## if_else_stmt(statement) -> If par(if_cond) . closed_non_if_stmt Else statement [ SEMI RBRACE EOF Default Case ]
## if_else_stmt(statement) -> If par(if_cond) . closed_non_if_stmt SEMI_ELSE statement [ SEMI RBRACE EOF Default Case ]
## if_else_stmt(stmt_ending_with_expr) -> If par(if_cond) . closed_non_if_stmt Else stmt_ending_with_expr [ While Type Switch Return Namespace Let LBRACE Interface Import If For Export Continue Const Break Attr ]
## if_else_stmt(stmt_ending_with_expr) -> If par(if_cond) . closed_non_if_stmt SEMI_ELSE stmt_ending_with_expr [ While Type Switch Return Namespace Let LBRACE Interface Import If For Export Continue Const Break Attr ]
## if_stmt(poly_stmt) -> If par(if_cond) . poly_stmt [ While Verbatim UIdent Type True Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export Directive Continue Const Bytes Break Attr ]
## if_stmt(statement) -> If par(if_cond) . statement [ SEMI RBRACE EOF Default Case ]
## if_stmt(stmt_ending_with_expr) -> If par(if_cond) . stmt_ending_with_expr [ While Type Switch Return Namespace Let LBRACE Interface Import If For Export Continue Const Break Attr ]
##
## The known suffix of the stack is as follows:
## If par(if_cond)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Namespace UIdent LBRACE If LPAR UIdent RPAR While ZWSP
##
## Ends in an error in state: 648.
##
## while_stmt(closed_non_if_stmt) -> While . par(while_cond) closed_non_if_stmt [ SEMI_ELSE Else ]
## while_stmt(poly_stmt) -> While . par(while_cond) poly_stmt [ While Verbatim UIdent Type True Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export Directive Continue Const Bytes Break Attr ]
## while_stmt(statement) -> While . par(while_cond) statement [ SEMI RBRACE EOF Default Case ]
## while_stmt(stmt_ending_with_expr) -> While . par(while_cond) stmt_ending_with_expr [ While Type Switch Return Namespace Let LBRACE Interface Import If For Export Continue Const Break Attr ]
##
## The known suffix of the stack is as follows:
## While
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Namespace UIdent LBRACE If LPAR UIdent RPAR While LPAR UIdent RPAR ZWSP
##
## Ends in an error in state: 649.
##
## while_stmt(closed_non_if_stmt) -> While par(while_cond) . closed_non_if_stmt [ SEMI_ELSE Else ]
## while_stmt(poly_stmt) -> While par(while_cond) . poly_stmt [ While Verbatim UIdent Type True Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export Directive Continue Const Bytes Break Attr ]
## while_stmt(statement) -> While par(while_cond) . statement [ SEMI RBRACE EOF Default Case ]
## while_stmt(stmt_ending_with_expr) -> While par(while_cond) . stmt_ending_with_expr [ While Type Switch Return Namespace Let LBRACE Interface Import If For Export Continue Const Break Attr ]
##
## The known suffix of the stack is as follows:
## While par(while_cond)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Namespace UIdent LBRACE If LPAR UIdent RPAR If ZWSP
##
## Ends in an error in state: 650.
##
## if_else_stmt(closed_non_if_stmt) -> If . par(if_cond) closed_non_if_stmt Else closed_non_if_stmt [ SEMI_ELSE Else ]
## if_else_stmt(closed_non_if_stmt) -> If . par(if_cond) closed_non_if_stmt SEMI_ELSE closed_non_if_stmt [ SEMI_ELSE Else ]
## if_else_stmt(poly_stmt) -> If . par(if_cond) closed_non_if_stmt Else poly_stmt [ While Verbatim UIdent Type True Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export Directive Continue Const Bytes Break Attr ]
## if_else_stmt(poly_stmt) -> If . par(if_cond) closed_non_if_stmt SEMI_ELSE poly_stmt [ While Verbatim UIdent Type True Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export Directive Continue Const Bytes Break Attr ]
## if_else_stmt(statement) -> If . par(if_cond) closed_non_if_stmt Else statement [ SEMI RBRACE EOF Default Case ]
## if_else_stmt(statement) -> If . par(if_cond) closed_non_if_stmt SEMI_ELSE statement [ SEMI RBRACE EOF Default Case ]
## if_else_stmt(stmt_ending_with_expr) -> If . par(if_cond) closed_non_if_stmt Else stmt_ending_with_expr [ While Type Switch Return Namespace Let LBRACE Interface Import If For Export Continue Const Break Attr ]
## if_else_stmt(stmt_ending_with_expr) -> If . par(if_cond) closed_non_if_stmt SEMI_ELSE stmt_ending_with_expr [ While Type Switch Return Namespace Let LBRACE Interface Import If For Export Continue Const Break Attr ]
## if_stmt(poly_stmt) -> If . par(if_cond) poly_stmt [ While Verbatim UIdent Type True Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export Directive Continue Const Bytes Break Attr ]
## if_stmt(statement) -> If . par(if_cond) statement [ SEMI RBRACE EOF Default Case ]
## if_stmt(stmt_ending_with_expr) -> If . par(if_cond) stmt_ending_with_expr [ While Type Switch Return Namespace Let LBRACE Interface Import If For Export Continue Const Break Attr ]
##
## The known suffix of the stack is as follows:
## If
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Namespace UIdent LBRACE If LPAR UIdent RPAR If LPAR UIdent RPAR ZWSP
##
## Ends in an error in state: 651.
##
## if_else_stmt(closed_non_if_stmt) -> If par(if_cond) . closed_non_if_stmt Else closed_non_if_stmt [ SEMI_ELSE Else ]
## if_else_stmt(closed_non_if_stmt) -> If par(if_cond) . closed_non_if_stmt SEMI_ELSE closed_non_if_stmt [ SEMI_ELSE Else ]
## if_else_stmt(poly_stmt) -> If par(if_cond) . closed_non_if_stmt Else poly_stmt [ While Verbatim UIdent Type True Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export Directive Continue Const Bytes Break Attr ]
## if_else_stmt(poly_stmt) -> If par(if_cond) . closed_non_if_stmt SEMI_ELSE poly_stmt [ While Verbatim UIdent Type True Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export Directive Continue Const Bytes Break Attr ]
## if_else_stmt(statement) -> If par(if_cond) . closed_non_if_stmt Else statement [ SEMI RBRACE EOF Default Case ]
## if_else_stmt(statement) -> If par(if_cond) . closed_non_if_stmt SEMI_ELSE statement [ SEMI RBRACE EOF Default Case ]
## if_else_stmt(stmt_ending_with_expr) -> If par(if_cond) . closed_non_if_stmt Else stmt_ending_with_expr [ While Type Switch Return Namespace Let LBRACE Interface Import If For Export Continue Const Break Attr ]
## if_else_stmt(stmt_ending_with_expr) -> If par(if_cond) . closed_non_if_stmt SEMI_ELSE stmt_ending_with_expr [ While Type Switch Return Namespace Let LBRACE Interface Import If For Export Continue Const Break Attr ]
## if_stmt(poly_stmt) -> If par(if_cond) . poly_stmt [ While Verbatim UIdent Type True Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export Directive Continue Const Bytes Break Attr ]
## if_stmt(statement) -> If par(if_cond) . statement [ SEMI RBRACE EOF Default Case ]
## if_stmt(stmt_ending_with_expr) -> If par(if_cond) . stmt_ending_with_expr [ While Type Switch Return Namespace Let LBRACE Interface Import If For Export Continue Const Break Attr ]
##
## The known suffix of the stack is as follows:
## If par(if_cond)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Function ZWSP
##
## Ends in an error in state: 652.
##
## fun_decl -> Function . fun_name option(ES6FUN) par(fun_params) braces(statements) [ SEMI_ELSE SEMI RBRACE Else EOF Default Case ]
## fun_decl -> Function . fun_name option(ES6FUN) par(fun_params) ret_type braces(statements) [ SEMI_ELSE SEMI RBRACE Else EOF Default Case ]
## fun_decl -> Function . fun_name type_vars option(ES6FUN) par(fun_params) braces(statements) [ SEMI_ELSE SEMI RBRACE Else EOF Default Case ]
## fun_decl -> Function . fun_name type_vars option(ES6FUN) par(fun_params) ret_type braces(statements) [ SEMI_ELSE SEMI RBRACE Else EOF Default Case ]
##
## The known suffix of the stack is as follows:
## Function
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Function Ident ZWSP
##
## Ends in an error in state: 654.
##
## fun_decl -> Function fun_name . option(ES6FUN) par(fun_params) braces(statements) [ SEMI_ELSE SEMI RBRACE Else EOF Default Case ]
## fun_decl -> Function fun_name . option(ES6FUN) par(fun_params) ret_type braces(statements) [ SEMI_ELSE SEMI RBRACE Else EOF Default Case ]
## fun_decl -> Function fun_name . type_vars option(ES6FUN) par(fun_params) braces(statements) [ SEMI_ELSE SEMI RBRACE Else EOF Default Case ]
## fun_decl -> Function fun_name . type_vars option(ES6FUN) par(fun_params) ret_type braces(statements) [ SEMI_ELSE SEMI RBRACE Else EOF Default Case ]
##
## The known suffix of the stack is as follows:
## Function fun_name
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Function Ident LT GT XOR
##
## Ends in an error in state: 655.
##
## fun_decl -> Function fun_name type_vars . option(ES6FUN) par(fun_params) braces(statements) [ SEMI_ELSE SEMI RBRACE Else EOF Default Case ]
## fun_decl -> Function fun_name type_vars . option(ES6FUN) par(fun_params) ret_type braces(statements) [ SEMI_ELSE SEMI RBRACE Else EOF Default Case ]
##
## The known suffix of the stack is as follows:
## Function fun_name type_vars
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 91, spurious reduction of production chevrons(sep_or_term(type_var,COMMA)) -> LT sep_or_term(type_var,COMMA) GT
## In state 315, spurious reduction of production type_vars -> chevrons(sep_or_term(type_var,COMMA))
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Function Ident LT GT ES6FUN ZWSP
##
## Ends in an error in state: 656.
##
## fun_decl -> Function fun_name type_vars option(ES6FUN) . par(fun_params) braces(statements) [ SEMI_ELSE SEMI RBRACE Else EOF Default Case ]
## fun_decl -> Function fun_name type_vars option(ES6FUN) . par(fun_params) ret_type braces(statements) [ SEMI_ELSE SEMI RBRACE Else EOF Default Case ]
##
## The known suffix of the stack is as follows:
## Function fun_name type_vars option(ES6FUN)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Function Ident LT GT LPAR RPAR ZWSP
##
## Ends in an error in state: 657.
##
## fun_decl -> Function fun_name type_vars option(ES6FUN) par(fun_params) . braces(statements) [ SEMI_ELSE SEMI RBRACE Else EOF Default Case ]
## fun_decl -> Function fun_name type_vars option(ES6FUN) par(fun_params) . ret_type braces(statements) [ SEMI_ELSE SEMI RBRACE Else EOF Default Case ]
##
## The known suffix of the stack is as follows:
## Function fun_name type_vars option(ES6FUN) par(fun_params)
##
contract: Function Ident LPAR RPAR ZWSP
##
## Ends in an error in state: 662.
##
## fun_decl -> Function fun_name option(ES6FUN) par(fun_params) . braces(statements) [ SEMI_ELSE SEMI RBRACE Else EOF Default Case ]
## fun_decl -> Function fun_name option(ES6FUN) par(fun_params) . ret_type braces(statements) [ SEMI_ELSE SEMI RBRACE Else EOF Default Case ]
##
## The known suffix of the stack is as follows:
## Function fun_name option(ES6FUN) par(fun_params)
##

Ill-formed function declaration.
At this point, one of the following is expected:
  * a colon ':' followed by the return type;
  * an opening brace '{' followed by the body as statements.

contract: Function Ident LT GT LPAR RPAR COLON Ident XOR
##
## Ends in an error in state: 658.
##
## fun_decl -> Function fun_name type_vars option(ES6FUN) par(fun_params) ret_type . braces(statements) [ SEMI_ELSE SEMI RBRACE Else EOF Default Case ]
##
## The known suffix of the stack is as follows:
## Function fun_name type_vars option(ES6FUN) par(fun_params) ret_type
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 174, spurious reduction of production type_name -> Ident
## In state 196, spurious reduction of production no_par_type_expr -> type_name
## In state 505, spurious reduction of production type_annotation(__anonymous_6) -> COLON option(ES6FUN) no_par_type_expr
## In state 508, spurious reduction of production ret_type -> type_annotation(__anonymous_6)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Function Ident ES6FUN ZWSP
##
## Ends in an error in state: 661.
##
## fun_decl -> Function fun_name option(ES6FUN) . par(fun_params) braces(statements) [ SEMI_ELSE SEMI RBRACE Else EOF Default Case ]
## fun_decl -> Function fun_name option(ES6FUN) . par(fun_params) ret_type braces(statements) [ SEMI_ELSE SEMI RBRACE Else EOF Default Case ]
##
## The known suffix of the stack is as follows:
## Function fun_name option(ES6FUN)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Function Ident LPAR RPAR COLON Ident XOR
##
## Ends in an error in state: 663.
##
## fun_decl -> Function fun_name option(ES6FUN) par(fun_params) ret_type . braces(statements) [ SEMI_ELSE SEMI RBRACE Else EOF Default Case ]
##
## The known suffix of the stack is as follows:
## Function fun_name option(ES6FUN) par(fun_params) ret_type
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 174, spurious reduction of production type_name -> Ident
## In state 196, spurious reduction of production no_par_type_expr -> type_name
## In state 505, spurious reduction of production type_annotation(__anonymous_6) -> COLON option(ES6FUN) no_par_type_expr
## In state 508, spurious reduction of production ret_type -> type_annotation(__anonymous_6)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Namespace UIdent LBRACE If LPAR UIdent RPAR For ZWSP
##
## Ends in an error in state: 666.
##
## empty_for_stmt -> For . par(range_for) [ SEMI_ELSE SEMI RBRACE Else EOF Default Case ]
## for_of_stmt(closed_non_if_stmt) -> For . par(range_of) closed_non_if_stmt [ SEMI_ELSE Else ]
## for_of_stmt(poly_stmt) -> For . par(range_of) poly_stmt [ While Verbatim UIdent Type True Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export Directive Continue Const Bytes Break Attr ]
## for_of_stmt(statement) -> For . par(range_of) statement [ SEMI RBRACE EOF Default Case ]
## for_of_stmt(stmt_ending_with_expr) -> For . par(range_of) stmt_ending_with_expr [ While Type Switch Return Namespace Let LBRACE Interface Import If For Export Continue Const Break Attr ]
## full_for_stmt(closed_non_if_stmt) -> For . par(range_for) closed_non_if_stmt [ SEMI_ELSE Else ]
## full_for_stmt(poly_stmt) -> For . par(range_for) poly_stmt [ While Verbatim UIdent Type True Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export Directive Continue Const Bytes Break Attr ]
## full_for_stmt(statement) -> For . par(range_for) statement [ SEMI RBRACE EOF Default Case ]
## full_for_stmt(stmt_ending_with_expr) -> For . par(range_for) stmt_ending_with_expr [ While Type Switch Return Namespace Let LBRACE Interface Import If For Export Continue Const Break Attr ]
##
## The known suffix of the stack is as follows:
## For
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Namespace UIdent LBRACE For LPAR ZWSP
##
## Ends in an error in state: 667.
##
## par(range_for) -> LPAR . range_for RPAR [ While Verbatim UIdent Type True Switch String SEMI_ELSE SEMI Return RBRACE PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export Else EOF Directive Default Continue Const Case Bytes Break Attr ]
## par(range_for) -> LPAR . range_for PARAMS RPAR [ While Verbatim UIdent Type True Switch String SEMI_ELSE SEMI Return RBRACE PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export Else EOF Directive Default Continue Const Case Bytes Break Attr ]
## par(range_of) -> LPAR . range_of RPAR [ While Verbatim UIdent Type True Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export Directive Continue Const Bytes Break Attr ]
## par(range_of) -> LPAR . range_of PARAMS RPAR [ While Verbatim UIdent Type True Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export Directive Continue Const Bytes Break Attr ]
##
## The known suffix of the stack is as follows:
## LPAR
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Namespace UIdent LBRACE For LPAR SEMI ZWSP
##
## Ends in an error in state: 668.
##
## range_for -> SEMI . SEMI [ RPAR PARAMS ]
## range_for -> SEMI . SEMI afterthought [ RPAR PARAMS ]
## range_for -> SEMI . condition SEMI [ RPAR PARAMS ]
## range_for -> SEMI . condition SEMI afterthought [ RPAR PARAMS ]
##
## The known suffix of the stack is as follows:
## SEMI
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Namespace UIdent LBRACE For LPAR SEMI SEMI ZWSP
##
## Ends in an error in state: 669.
##
## range_for -> SEMI SEMI . [ RPAR PARAMS ]
## range_for -> SEMI SEMI . afterthought [ RPAR PARAMS ]
##
## The known suffix of the stack is as follows:
## SEMI SEMI
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Namespace UIdent LBRACE For LPAR SEMI SEMI UIdent While
##
## Ends in an error in state: 671.
##
## nsepseq(expr,COMMA) -> expr . [ RPAR PARAMS ]
## nsepseq(expr,COMMA) -> expr . COMMA nsepseq(expr,COMMA) [ RPAR PARAMS ]
##
## The known suffix of the stack is as follows:
## expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 4, spurious reduction of production ctor -> UIdent
## In state 394, spurious reduction of production core_expr -> ctor
## In state 395, spurious reduction of production app_expr_level -> core_expr
## In state 491, spurious reduction of production unary_expr_level -> app_expr_level
## In state 374, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 388, spurious reduction of production add_expr_level -> mult_expr_level
## In state 446, spurious reduction of production eq_expr_level -> add_expr_level
## In state 411, spurious reduction of production comp_expr_level -> eq_expr_level
## In state 416, spurious reduction of production bit_shift_level -> comp_expr_level
## In state 457, spurious reduction of production conj_expr_level -> bit_shift_level
## In state 471, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 412, spurious reduction of production non_object_expr -> disj_expr_level
## In state 466, spurious reduction of production no_attr_expr -> non_object_expr
## In state 467, spurious reduction of production expr -> no_attr_expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Namespace UIdent LBRACE For LPAR SEMI SEMI UIdent COMMA ZWSP
##
## Ends in an error in state: 672.
##
## nsepseq(expr,COMMA) -> expr COMMA . nsepseq(expr,COMMA) [ RPAR PARAMS ]
##
## The known suffix of the stack is as follows:
## expr COMMA
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Namespace UIdent LBRACE For LPAR SEMI UIdent While
##
## Ends in an error in state: 676.
##
## range_for -> SEMI condition . SEMI [ RPAR PARAMS ]
## range_for -> SEMI condition . SEMI afterthought [ RPAR PARAMS ]
##
## The known suffix of the stack is as follows:
## SEMI condition
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 4, spurious reduction of production ctor -> UIdent
## In state 394, spurious reduction of production core_expr -> ctor
## In state 395, spurious reduction of production app_expr_level -> core_expr
## In state 491, spurious reduction of production unary_expr_level -> app_expr_level
## In state 374, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 388, spurious reduction of production add_expr_level -> mult_expr_level
## In state 446, spurious reduction of production eq_expr_level -> add_expr_level
## In state 411, spurious reduction of production comp_expr_level -> eq_expr_level
## In state 416, spurious reduction of production bit_shift_level -> comp_expr_level
## In state 457, spurious reduction of production conj_expr_level -> bit_shift_level
## In state 471, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 412, spurious reduction of production non_object_expr -> disj_expr_level
## In state 466, spurious reduction of production no_attr_expr -> non_object_expr
## In state 467, spurious reduction of production expr -> no_attr_expr
## In state 675, spurious reduction of production condition -> expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Namespace UIdent LBRACE For LPAR SEMI UIdent SEMI ZWSP
##
## Ends in an error in state: 677.
##
## range_for -> SEMI condition SEMI . [ RPAR PARAMS ]
## range_for -> SEMI condition SEMI . afterthought [ RPAR PARAMS ]
##
## The known suffix of the stack is as follows:
## SEMI condition SEMI
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Namespace UIdent LBRACE For LPAR Let ZWSP
##
## Ends in an error in state: 679.
##
## range_of -> Let . Ident Of expr [ RPAR PARAMS ]
## value_decl -> Let . bindings [ SEMI ]
##
## The known suffix of the stack is as follows:
## Let
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Namespace UIdent LBRACE For LPAR Let Ident ZWSP
##
## Ends in an error in state: 680.
##
## pattern -> Ident . [ EQ COLON ]
## range_of -> Let Ident . Of expr [ RPAR PARAMS ]
##
## The known suffix of the stack is as follows:
## Let Ident
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Namespace UIdent LBRACE For LPAR Let Ident Of ZWSP
##
## Ends in an error in state: 681.
##
## range_of -> Let Ident Of . expr [ RPAR PARAMS ]
##
## The known suffix of the stack is as follows:
## Let Ident Of
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Namespace UIdent LBRACE For LPAR Const ZWSP
##
## Ends in an error in state: 683.
##
## range_of -> Const . Ident Of expr [ RPAR PARAMS ]
## value_decl -> Const . bindings [ SEMI ]
##
## The known suffix of the stack is as follows:
## Const
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Namespace UIdent LBRACE For LPAR Const Ident ZWSP
##
## Ends in an error in state: 684.
##
## pattern -> Ident . [ EQ COLON ]
## range_of -> Const Ident . Of expr [ RPAR PARAMS ]
##
## The known suffix of the stack is as follows:
## Const Ident
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Namespace UIdent LBRACE For LPAR Const Ident Of ZWSP
##
## Ends in an error in state: 685.
##
## range_of -> Const Ident Of . expr [ RPAR PARAMS ]
##
## The known suffix of the stack is as follows:
## Const Ident Of
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Namespace UIdent LBRACE For LPAR Const Ident Of UIdent While
##
## Ends in an error in state: 691.
##
## par(range_of) -> LPAR range_of . RPAR [ While Verbatim UIdent Type True Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export Directive Continue Const Bytes Break Attr ]
## par(range_of) -> LPAR range_of . PARAMS RPAR [ While Verbatim UIdent Type True Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export Directive Continue Const Bytes Break Attr ]
##
## The known suffix of the stack is as follows:
## LPAR range_of
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 4, spurious reduction of production ctor -> UIdent
## In state 394, spurious reduction of production core_expr -> ctor
## In state 395, spurious reduction of production app_expr_level -> core_expr
## In state 491, spurious reduction of production unary_expr_level -> app_expr_level
## In state 374, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 388, spurious reduction of production add_expr_level -> mult_expr_level
## In state 446, spurious reduction of production eq_expr_level -> add_expr_level
## In state 411, spurious reduction of production comp_expr_level -> eq_expr_level
## In state 416, spurious reduction of production bit_shift_level -> comp_expr_level
## In state 457, spurious reduction of production conj_expr_level -> bit_shift_level
## In state 471, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 412, spurious reduction of production non_object_expr -> disj_expr_level
## In state 466, spurious reduction of production no_attr_expr -> non_object_expr
## In state 467, spurious reduction of production expr -> no_attr_expr
## In state 686, spurious reduction of production range_of -> Const Ident Of expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Namespace UIdent LBRACE For LPAR Const Ident Of UIdent PARAMS ZWSP
##
## Ends in an error in state: 693.
##
## par(range_of) -> LPAR range_of PARAMS . RPAR [ While Verbatim UIdent Type True Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export Directive Continue Const Bytes Break Attr ]
##
## The known suffix of the stack is as follows:
## LPAR range_of PARAMS
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Namespace UIdent LBRACE For LPAR SEMI SEMI PARAMS ZWSP
##
## Ends in an error in state: 697.
##
## par(range_for) -> LPAR range_for PARAMS . RPAR [ While Verbatim UIdent Type True Switch String SEMI_ELSE SEMI Return RBRACE PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export Else EOF Directive Default Continue Const Case Bytes Break Attr ]
##
## The known suffix of the stack is as follows:
## LPAR range_for PARAMS
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Namespace UIdent LBRACE For LPAR Ident MINUS2 BIT_AND
##
## Ends in an error in state: 703.
##
## range_for -> initialiser . SEMI SEMI [ RPAR PARAMS ]
## range_for -> initialiser . SEMI SEMI afterthought [ RPAR PARAMS ]
## range_for -> initialiser . SEMI condition SEMI [ RPAR PARAMS ]
## range_for -> initialiser . SEMI condition SEMI afterthought [ RPAR PARAMS ]
##
## The known suffix of the stack is as follows:
## initialiser
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Namespace UIdent LBRACE For LPAR Ident MINUS2 SEMI ZWSP
##
## Ends in an error in state: 704.
##
## range_for -> initialiser SEMI . SEMI [ RPAR PARAMS ]
## range_for -> initialiser SEMI . SEMI afterthought [ RPAR PARAMS ]
## range_for -> initialiser SEMI . condition SEMI [ RPAR PARAMS ]
## range_for -> initialiser SEMI . condition SEMI afterthought [ RPAR PARAMS ]
##
## The known suffix of the stack is as follows:
## initialiser SEMI
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Namespace UIdent LBRACE For LPAR Ident MINUS2 SEMI SEMI ZWSP
##
## Ends in an error in state: 705.
##
## range_for -> initialiser SEMI SEMI . [ RPAR PARAMS ]
## range_for -> initialiser SEMI SEMI . afterthought [ RPAR PARAMS ]
##
## The known suffix of the stack is as follows:
## initialiser SEMI SEMI
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Namespace UIdent LBRACE For LPAR Ident MINUS2 SEMI UIdent While
##
## Ends in an error in state: 707.
##
## range_for -> initialiser SEMI condition . SEMI [ RPAR PARAMS ]
## range_for -> initialiser SEMI condition . SEMI afterthought [ RPAR PARAMS ]
##
## The known suffix of the stack is as follows:
## initialiser SEMI condition
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 4, spurious reduction of production ctor -> UIdent
## In state 394, spurious reduction of production core_expr -> ctor
## In state 395, spurious reduction of production app_expr_level -> core_expr
## In state 491, spurious reduction of production unary_expr_level -> app_expr_level
## In state 374, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 388, spurious reduction of production add_expr_level -> mult_expr_level
## In state 446, spurious reduction of production eq_expr_level -> add_expr_level
## In state 411, spurious reduction of production comp_expr_level -> eq_expr_level
## In state 416, spurious reduction of production bit_shift_level -> comp_expr_level
## In state 457, spurious reduction of production conj_expr_level -> bit_shift_level
## In state 471, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 412, spurious reduction of production non_object_expr -> disj_expr_level
## In state 466, spurious reduction of production no_attr_expr -> non_object_expr
## In state 467, spurious reduction of production expr -> no_attr_expr
## In state 675, spurious reduction of production condition -> expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Namespace UIdent LBRACE For LPAR Ident MINUS2 SEMI UIdent SEMI ZWSP
##
## Ends in an error in state: 708.
##
## range_for -> initialiser SEMI condition SEMI . [ RPAR PARAMS ]
## range_for -> initialiser SEMI condition SEMI . afterthought [ RPAR PARAMS ]
##
## The known suffix of the stack is as follows:
## initialiser SEMI condition SEMI
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Namespace UIdent LBRACE UIdent COLON
##
## Ends in an error in state: 717.
##
## lambda -> core_expr . [ LPAR ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr . QMARK app_expr COLON app_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr . QMARK app_expr COLON incr_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr . QMARK app_expr COLON decr_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr . QMARK app_expr COLON assign_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr . QMARK app_expr COLON match_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr . QMARK app_expr COLON ternary_expr(core_expr,pre_expr_stmt) [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr . QMARK app_expr COLON par(expr) [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr . QMARK incr_expr COLON app_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr . QMARK incr_expr COLON incr_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr . QMARK incr_expr COLON decr_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr . QMARK incr_expr COLON assign_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr . QMARK incr_expr COLON match_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr . QMARK incr_expr COLON ternary_expr(core_expr,pre_expr_stmt) [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr . QMARK incr_expr COLON par(expr) [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr . QMARK decr_expr COLON app_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr . QMARK decr_expr COLON incr_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr . QMARK decr_expr COLON decr_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr . QMARK decr_expr COLON assign_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr . QMARK decr_expr COLON match_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr . QMARK decr_expr COLON ternary_expr(core_expr,pre_expr_stmt) [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr . QMARK decr_expr COLON par(expr) [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr . QMARK assign_expr COLON app_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr . QMARK assign_expr COLON incr_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr . QMARK assign_expr COLON decr_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr . QMARK assign_expr COLON assign_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr . QMARK assign_expr COLON match_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr . QMARK assign_expr COLON ternary_expr(core_expr,pre_expr_stmt) [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr . QMARK assign_expr COLON par(expr) [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr . QMARK match_expr COLON app_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr . QMARK match_expr COLON incr_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr . QMARK match_expr COLON decr_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr . QMARK match_expr COLON assign_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr . QMARK match_expr COLON match_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr . QMARK match_expr COLON ternary_expr(core_expr,pre_expr_stmt) [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr . QMARK match_expr COLON par(expr) [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr . QMARK ternary_expr(core_expr,pre_expr_stmt) COLON app_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr . QMARK ternary_expr(core_expr,pre_expr_stmt) COLON incr_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr . QMARK ternary_expr(core_expr,pre_expr_stmt) COLON decr_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr . QMARK ternary_expr(core_expr,pre_expr_stmt) COLON assign_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr . QMARK ternary_expr(core_expr,pre_expr_stmt) COLON match_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr . QMARK ternary_expr(core_expr,pre_expr_stmt) COLON ternary_expr(core_expr,pre_expr_stmt) [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr . QMARK ternary_expr(core_expr,pre_expr_stmt) COLON par(expr) [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr . QMARK par(expr) COLON app_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr . QMARK par(expr) COLON incr_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr . QMARK par(expr) COLON decr_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr . QMARK par(expr) COLON assign_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr . QMARK par(expr) COLON match_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr . QMARK par(expr) COLON ternary_expr(core_expr,pre_expr_stmt) [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr . QMARK par(expr) COLON par(expr) [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## core_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 4, spurious reduction of production ctor -> UIdent
## In state 394, spurious reduction of production core_expr -> ctor
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Namespace UIdent LBRACE UIdent QMARK ZWSP
##
## Ends in an error in state: 718.
##
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK . app_expr COLON app_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK . app_expr COLON incr_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK . app_expr COLON decr_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK . app_expr COLON assign_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK . app_expr COLON match_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK . app_expr COLON ternary_expr(core_expr,pre_expr_stmt) [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK . app_expr COLON par(expr) [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK . incr_expr COLON app_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK . incr_expr COLON incr_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK . incr_expr COLON decr_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK . incr_expr COLON assign_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK . incr_expr COLON match_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK . incr_expr COLON ternary_expr(core_expr,pre_expr_stmt) [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK . incr_expr COLON par(expr) [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK . decr_expr COLON app_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK . decr_expr COLON incr_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK . decr_expr COLON decr_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK . decr_expr COLON assign_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK . decr_expr COLON match_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK . decr_expr COLON ternary_expr(core_expr,pre_expr_stmt) [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK . decr_expr COLON par(expr) [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK . assign_expr COLON app_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK . assign_expr COLON incr_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK . assign_expr COLON decr_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK . assign_expr COLON assign_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK . assign_expr COLON match_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK . assign_expr COLON ternary_expr(core_expr,pre_expr_stmt) [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK . assign_expr COLON par(expr) [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK . match_expr COLON app_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK . match_expr COLON incr_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK . match_expr COLON decr_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK . match_expr COLON assign_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK . match_expr COLON match_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK . match_expr COLON ternary_expr(core_expr,pre_expr_stmt) [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK . match_expr COLON par(expr) [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK . ternary_expr(core_expr,pre_expr_stmt) COLON app_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK . ternary_expr(core_expr,pre_expr_stmt) COLON incr_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK . ternary_expr(core_expr,pre_expr_stmt) COLON decr_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK . ternary_expr(core_expr,pre_expr_stmt) COLON assign_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK . ternary_expr(core_expr,pre_expr_stmt) COLON match_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK . ternary_expr(core_expr,pre_expr_stmt) COLON ternary_expr(core_expr,pre_expr_stmt) [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK . ternary_expr(core_expr,pre_expr_stmt) COLON par(expr) [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK . par(expr) COLON app_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK . par(expr) COLON incr_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK . par(expr) COLON decr_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK . par(expr) COLON assign_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK . par(expr) COLON match_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK . par(expr) COLON ternary_expr(core_expr,pre_expr_stmt) [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK . par(expr) COLON par(expr) [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## core_expr QMARK
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Namespace UIdent LBRACE UIdent QMARK UIdent QMARK Ident MINUS2 COLON Ident MINUS2 BIT_AND
##
## Ends in an error in state: 719.
##
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK ternary_expr(core_expr,pre_expr_stmt) . COLON app_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK ternary_expr(core_expr,pre_expr_stmt) . COLON incr_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK ternary_expr(core_expr,pre_expr_stmt) . COLON decr_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK ternary_expr(core_expr,pre_expr_stmt) . COLON assign_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK ternary_expr(core_expr,pre_expr_stmt) . COLON match_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK ternary_expr(core_expr,pre_expr_stmt) . COLON ternary_expr(core_expr,pre_expr_stmt) [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK ternary_expr(core_expr,pre_expr_stmt) . COLON par(expr) [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## core_expr QMARK ternary_expr(core_expr,pre_expr_stmt)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Namespace UIdent LBRACE UIdent QMARK UIdent QMARK Ident MINUS2 COLON Ident MINUS2 COLON ZWSP
##
## Ends in an error in state: 720.
##
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK ternary_expr(core_expr,pre_expr_stmt) COLON . app_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK ternary_expr(core_expr,pre_expr_stmt) COLON . incr_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK ternary_expr(core_expr,pre_expr_stmt) COLON . decr_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK ternary_expr(core_expr,pre_expr_stmt) COLON . assign_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK ternary_expr(core_expr,pre_expr_stmt) COLON . match_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK ternary_expr(core_expr,pre_expr_stmt) COLON . ternary_expr(core_expr,pre_expr_stmt) [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK ternary_expr(core_expr,pre_expr_stmt) COLON . par(expr) [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## core_expr QMARK ternary_expr(core_expr,pre_expr_stmt) COLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Namespace UIdent LBRACE UIdent QMARK LPAR UIdent RPAR COLON ZWSP
##
## Ends in an error in state: 729.
##
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK par(expr) COLON . app_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK par(expr) COLON . incr_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK par(expr) COLON . decr_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK par(expr) COLON . assign_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK par(expr) COLON . match_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK par(expr) COLON . ternary_expr(core_expr,pre_expr_stmt) [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK par(expr) COLON . par(expr) [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## core_expr QMARK par(expr) COLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Namespace UIdent LBRACE UIdent QMARK Match LPAR UIdent RPAR LBRACE Default COLON UIdent RBRACE ZWSP
##
## Ends in an error in state: 737.
##
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK match_expr . COLON app_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK match_expr . COLON incr_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK match_expr . COLON decr_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK match_expr . COLON assign_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK match_expr . COLON match_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK match_expr . COLON ternary_expr(core_expr,pre_expr_stmt) [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK match_expr . COLON par(expr) [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## core_expr QMARK match_expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Namespace UIdent LBRACE UIdent QMARK Match LPAR UIdent RPAR LBRACE Default COLON UIdent RBRACE COLON ZWSP
##
## Ends in an error in state: 738.
##
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK match_expr COLON . app_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK match_expr COLON . incr_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK match_expr COLON . decr_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK match_expr COLON . assign_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK match_expr COLON . match_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK match_expr COLON . ternary_expr(core_expr,pre_expr_stmt) [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK match_expr COLON . par(expr) [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## core_expr QMARK match_expr COLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Namespace UIdent LBRACE UIdent QMARK Ident PLUS2 ZWSP
##
## Ends in an error in state: 746.
##
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK incr_expr . COLON app_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK incr_expr . COLON incr_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK incr_expr . COLON decr_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK incr_expr . COLON assign_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK incr_expr . COLON match_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK incr_expr . COLON ternary_expr(core_expr,pre_expr_stmt) [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK incr_expr . COLON par(expr) [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## core_expr QMARK incr_expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Namespace UIdent LBRACE UIdent QMARK Ident PLUS2 COLON ZWSP
##
## Ends in an error in state: 747.
##
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK incr_expr COLON . app_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK incr_expr COLON . incr_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK incr_expr COLON . decr_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK incr_expr COLON . assign_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK incr_expr COLON . match_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK incr_expr COLON . ternary_expr(core_expr,pre_expr_stmt) [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK incr_expr COLON . par(expr) [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## core_expr QMARK incr_expr COLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Namespace UIdent LBRACE UIdent QMARK Ident MINUS2 ZWSP
##
## Ends in an error in state: 755.
##
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK decr_expr . COLON app_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK decr_expr . COLON incr_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK decr_expr . COLON decr_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK decr_expr . COLON assign_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK decr_expr . COLON match_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK decr_expr . COLON ternary_expr(core_expr,pre_expr_stmt) [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK decr_expr . COLON par(expr) [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## core_expr QMARK decr_expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Namespace UIdent LBRACE UIdent QMARK Ident MINUS2 COLON ZWSP
##
## Ends in an error in state: 756.
##
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK decr_expr COLON . app_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK decr_expr COLON . incr_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK decr_expr COLON . decr_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK decr_expr COLON . assign_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK decr_expr COLON . match_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK decr_expr COLON . ternary_expr(core_expr,pre_expr_stmt) [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK decr_expr COLON . par(expr) [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## core_expr QMARK decr_expr COLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Namespace UIdent LBRACE UIdent QMARK Ident BIT_AND_EQ UIdent While
##
## Ends in an error in state: 764.
##
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK assign_expr . COLON app_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK assign_expr . COLON incr_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK assign_expr . COLON decr_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK assign_expr . COLON assign_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK assign_expr . COLON match_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK assign_expr . COLON ternary_expr(core_expr,pre_expr_stmt) [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK assign_expr . COLON par(expr) [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## core_expr QMARK assign_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 4, spurious reduction of production ctor -> UIdent
## In state 394, spurious reduction of production core_expr -> ctor
## In state 395, spurious reduction of production app_expr_level -> core_expr
## In state 491, spurious reduction of production unary_expr_level -> app_expr_level
## In state 374, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 388, spurious reduction of production add_expr_level -> mult_expr_level
## In state 446, spurious reduction of production eq_expr_level -> add_expr_level
## In state 411, spurious reduction of production comp_expr_level -> eq_expr_level
## In state 416, spurious reduction of production bit_shift_level -> comp_expr_level
## In state 457, spurious reduction of production conj_expr_level -> bit_shift_level
## In state 471, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 412, spurious reduction of production non_object_expr -> disj_expr_level
## In state 466, spurious reduction of production no_attr_expr -> non_object_expr
## In state 467, spurious reduction of production expr -> no_attr_expr
## In state 532, spurious reduction of production bin_op(var_path,BIT_AND_EQ,expr) -> var_path BIT_AND_EQ expr
## In state 484, spurious reduction of production assign_expr -> bin_op(var_path,BIT_AND_EQ,expr)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Namespace UIdent LBRACE UIdent QMARK Ident BIT_AND_EQ UIdent COLON ZWSP
##
## Ends in an error in state: 765.
##
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK assign_expr COLON . app_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK assign_expr COLON . incr_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK assign_expr COLON . decr_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK assign_expr COLON . assign_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK assign_expr COLON . match_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK assign_expr COLON . ternary_expr(core_expr,pre_expr_stmt) [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK assign_expr COLON . par(expr) [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## core_expr QMARK assign_expr COLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Namespace UIdent LBRACE UIdent QMARK UIdent LPAR RPAR ZWSP
##
## Ends in an error in state: 773.
##
## lambda -> app_expr . [ LPAR ]
## path(app_expr) -> app_expr . nseq(selection) [ QMARK LPAR ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK app_expr . COLON app_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK app_expr . COLON incr_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK app_expr . COLON decr_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK app_expr . COLON assign_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK app_expr . COLON match_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK app_expr . COLON ternary_expr(core_expr,pre_expr_stmt) [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK app_expr . COLON par(expr) [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## core_expr QMARK app_expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Namespace UIdent LBRACE UIdent QMARK UIdent LPAR RPAR COLON ZWSP
##
## Ends in an error in state: 774.
##
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK app_expr COLON . app_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK app_expr COLON . incr_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK app_expr COLON . decr_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK app_expr COLON . assign_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK app_expr COLON . match_expr [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK app_expr COLON . ternary_expr(core_expr,pre_expr_stmt) [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
## ternary_expr(core_expr,pre_expr_stmt) -> core_expr QMARK app_expr COLON . par(expr) [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case COLON Break Attr ]
##
## The known suffix of the stack is as follows:
## core_expr QMARK app_expr COLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Namespace UIdent LBRACE If LPAR UIdent RPAR For LPAR Const Ident Of UIdent RPAR ZWSP
##
## Ends in an error in state: 784.
##
## for_of_stmt(closed_non_if_stmt) -> For par(range_of) . closed_non_if_stmt [ SEMI_ELSE Else ]
## for_of_stmt(poly_stmt) -> For par(range_of) . poly_stmt [ While Verbatim UIdent Type True Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export Directive Continue Const Bytes Break Attr ]
## for_of_stmt(statement) -> For par(range_of) . statement [ SEMI RBRACE EOF Default Case ]
## for_of_stmt(stmt_ending_with_expr) -> For par(range_of) . stmt_ending_with_expr [ While Type Switch Return Namespace Let LBRACE Interface Import If For Export Continue Const Break Attr ]
##
## The known suffix of the stack is as follows:
## For par(range_of)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Const ZWSP
##
## Ends in an error in state: 786.
##
## value_decl -> Const . bindings [ While Type Switch SEMI_ELSE SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export Else EOF Default Continue Const Case Break Attr ]
##
## The known suffix of the stack is as follows:
## Const
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Namespace UIdent LBRACE If LPAR UIdent RPAR Attr ZWSP
##
## Ends in an error in state: 796.
##
## core_stmt(closed_non_if_stmt) -> Attr . closed_non_if_stmt [ SEMI_ELSE Else ]
## core_stmt(statement) -> Attr . statement [ SEMI RBRACE EOF Default Case ]
## right_rec_stmt(poly_stmt) -> Attr . poly_stmt [ While Verbatim UIdent Type True Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export Directive Continue Const Bytes Break Attr ]
## right_rec_stmt(stmt_ending_with_expr) -> Attr . stmt_ending_with_expr [ While Type Switch Return Namespace Let LBRACE Interface Import If For Export Continue Const Break Attr ]
##
## The known suffix of the stack is as follows:
## Attr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Namespace UIdent LBRACE If LPAR UIdent RPAR If LPAR UIdent RPAR Break SEMI_ELSE ZWSP
##
## Ends in an error in state: 866.
##
## if_else_stmt(closed_non_if_stmt) -> If par(if_cond) closed_non_if_stmt SEMI_ELSE . closed_non_if_stmt [ SEMI_ELSE Else ]
## if_else_stmt(poly_stmt) -> If par(if_cond) closed_non_if_stmt SEMI_ELSE . poly_stmt [ While Verbatim UIdent Type True Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export Directive Continue Const Bytes Break Attr ]
## if_else_stmt(statement) -> If par(if_cond) closed_non_if_stmt SEMI_ELSE . statement [ SEMI RBRACE EOF Default Case ]
## if_else_stmt(stmt_ending_with_expr) -> If par(if_cond) closed_non_if_stmt SEMI_ELSE . stmt_ending_with_expr [ While Type Switch Return Namespace Let LBRACE Interface Import If For Export Continue Const Break Attr ]
##
## The known suffix of the stack is as follows:
## If par(if_cond) closed_non_if_stmt SEMI_ELSE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Namespace UIdent LBRACE If LPAR UIdent RPAR If LPAR UIdent RPAR Break Else ZWSP
##
## Ends in an error in state: 871.
##
## if_else_stmt(closed_non_if_stmt) -> If par(if_cond) closed_non_if_stmt Else . closed_non_if_stmt [ SEMI_ELSE Else ]
## if_else_stmt(poly_stmt) -> If par(if_cond) closed_non_if_stmt Else . poly_stmt [ While Verbatim UIdent Type True Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export Directive Continue Const Bytes Break Attr ]
## if_else_stmt(statement) -> If par(if_cond) closed_non_if_stmt Else . statement [ SEMI RBRACE EOF Default Case ]
## if_else_stmt(stmt_ending_with_expr) -> If par(if_cond) closed_non_if_stmt Else . stmt_ending_with_expr [ While Type Switch Return Namespace Let LBRACE Interface Import If For Export Continue Const Break Attr ]
##
## The known suffix of the stack is as follows:
## If par(if_cond) closed_non_if_stmt Else
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Namespace UIdent LBRACE If LPAR UIdent RPAR Break SEMI_ELSE ZWSP
##
## Ends in an error in state: 881.
##
## if_else_stmt(poly_stmt) -> If par(if_cond) closed_non_if_stmt SEMI_ELSE . poly_stmt [ While Verbatim UIdent Type True Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export Directive Continue Const Bytes Break Attr ]
## if_else_stmt(statement) -> If par(if_cond) closed_non_if_stmt SEMI_ELSE . statement [ SEMI RBRACE EOF Default Case ]
## if_else_stmt(stmt_ending_with_expr) -> If par(if_cond) closed_non_if_stmt SEMI_ELSE . stmt_ending_with_expr [ While Type Switch Return Namespace Let LBRACE Interface Import If For Export Continue Const Break Attr ]
##
## The known suffix of the stack is as follows:
## If par(if_cond) closed_non_if_stmt SEMI_ELSE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Namespace UIdent LBRACE For ZWSP
##
## Ends in an error in state: 882.
##
## empty_for_stmt -> For . par(range_for) [ SEMI RBRACE EOF Default Case ]
## for_of_stmt(poly_stmt) -> For . par(range_of) poly_stmt [ While Verbatim UIdent Type True Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export Directive Continue Const Bytes Break Attr ]
## for_of_stmt(statement) -> For . par(range_of) statement [ SEMI RBRACE EOF Default Case ]
## for_of_stmt(stmt_ending_with_expr) -> For . par(range_of) stmt_ending_with_expr [ While Type Switch Return Namespace Let LBRACE Interface Import If For Export Continue Const Break Attr ]
## full_for_stmt(poly_stmt) -> For . par(range_for) poly_stmt [ While Verbatim UIdent Type True Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export Directive Continue Const Bytes Break Attr ]
## full_for_stmt(statement) -> For . par(range_for) statement [ SEMI RBRACE EOF Default Case ]
## full_for_stmt(stmt_ending_with_expr) -> For . par(range_for) stmt_ending_with_expr [ While Type Switch Return Namespace Let LBRACE Interface Import If For Export Continue Const Break Attr ]
##
## The known suffix of the stack is as follows:
## For
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Namespace UIdent LBRACE For LPAR Const Ident Of UIdent RPAR ZWSP
##
## Ends in an error in state: 883.
##
## for_of_stmt(poly_stmt) -> For par(range_of) . poly_stmt [ While Verbatim UIdent Type True Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export Directive Continue Const Bytes Break Attr ]
## for_of_stmt(statement) -> For par(range_of) . statement [ SEMI RBRACE EOF Default Case ]
## for_of_stmt(stmt_ending_with_expr) -> For par(range_of) . stmt_ending_with_expr [ While Type Switch Return Namespace Let LBRACE Interface Import If For Export Continue Const Break Attr ]
##
## The known suffix of the stack is as follows:
## For par(range_of)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Namespace UIdent LBRACE If LPAR UIdent RPAR Break Else ZWSP
##
## Ends in an error in state: 895.
##
## if_else_stmt(poly_stmt) -> If par(if_cond) closed_non_if_stmt Else . poly_stmt [ While Verbatim UIdent Type True Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export Directive Continue Const Bytes Break Attr ]
## if_else_stmt(statement) -> If par(if_cond) closed_non_if_stmt Else . statement [ SEMI RBRACE EOF Default Case ]
## if_else_stmt(stmt_ending_with_expr) -> If par(if_cond) closed_non_if_stmt Else . stmt_ending_with_expr [ While Type Switch Return Namespace Let LBRACE Interface Import If For Export Continue Const Break Attr ]
##
## The known suffix of the stack is as follows:
## If par(if_cond) closed_non_if_stmt Else
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Namespace UIdent LBRACE Return While ZWSP
##
## Ends in an error in state: 897.
##
## while_stmt(stmt_not_starting_with_expr_nor_block1) -> While . par(while_cond) stmt_not_starting_with_expr_nor_block1 [ While Type Switch SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export EOF Default Continue Const Case Break Attr ]
## while_stmt(stmt_not_starting_with_expr_nor_block2) -> While . par(while_cond) stmt_not_starting_with_expr_nor_block2 [ While Verbatim UIdent Type True Switch String SEMI Return RBRACE PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EOF Directive Default Continue Const Case Bytes Break Attr ]
##
## The known suffix of the stack is as follows:
## While
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Namespace UIdent LBRACE Return While LPAR UIdent RPAR ZWSP
##
## Ends in an error in state: 898.
##
## while_stmt(stmt_not_starting_with_expr_nor_block1) -> While par(while_cond) . stmt_not_starting_with_expr_nor_block1 [ While Type Switch SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export EOF Default Continue Const Case Break Attr ]
## while_stmt(stmt_not_starting_with_expr_nor_block2) -> While par(while_cond) . stmt_not_starting_with_expr_nor_block2 [ While Verbatim UIdent Type True Switch String SEMI Return RBRACE PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EOF Directive Default Continue Const Case Bytes Break Attr ]
##
## The known suffix of the stack is as follows:
## While par(while_cond)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Namespace UIdent LBRACE Return Attr Return ZWSP
##
## Ends in an error in state: 899.
##
## full_return_stmt -> Return . no_attr_expr [ While Type Switch SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export EOF Default Continue Const Case Break Attr ]
##
## The known suffix of the stack is as follows:
## Return
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Namespace UIdent LBRACE Return If ZWSP
##
## Ends in an error in state: 900.
##
## if_else_stmt(stmt_not_starting_with_expr_nor_block1) -> If . par(if_cond) closed_non_if_stmt Else stmt_not_starting_with_expr_nor_block1 [ While Type Switch SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export EOF Default Continue Const Case Break Attr ]
## if_else_stmt(stmt_not_starting_with_expr_nor_block1) -> If . par(if_cond) closed_non_if_stmt SEMI_ELSE stmt_not_starting_with_expr_nor_block1 [ While Type Switch SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export EOF Default Continue Const Case Break Attr ]
## if_else_stmt(stmt_not_starting_with_expr_nor_block2) -> If . par(if_cond) closed_non_if_stmt Else stmt_not_starting_with_expr_nor_block2 [ While Verbatim UIdent Type True Switch String SEMI Return RBRACE PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EOF Directive Default Continue Const Case Bytes Break Attr ]
## if_else_stmt(stmt_not_starting_with_expr_nor_block2) -> If . par(if_cond) closed_non_if_stmt SEMI_ELSE stmt_not_starting_with_expr_nor_block2 [ While Verbatim UIdent Type True Switch String SEMI Return RBRACE PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EOF Directive Default Continue Const Case Bytes Break Attr ]
## if_stmt(stmt_not_starting_with_expr_nor_block1) -> If . par(if_cond) stmt_not_starting_with_expr_nor_block1 [ While Type Switch SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export EOF Default Continue Const Case Break Attr ]
## if_stmt(stmt_not_starting_with_expr_nor_block2) -> If . par(if_cond) stmt_not_starting_with_expr_nor_block2 [ While Verbatim UIdent Type True Switch String SEMI Return RBRACE PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EOF Directive Default Continue Const Case Bytes Break Attr ]
##
## The known suffix of the stack is as follows:
## If
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Namespace UIdent LBRACE Return If LPAR UIdent RPAR ZWSP
##
## Ends in an error in state: 901.
##
## if_else_stmt(stmt_not_starting_with_expr_nor_block1) -> If par(if_cond) . closed_non_if_stmt Else stmt_not_starting_with_expr_nor_block1 [ While Type Switch SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export EOF Default Continue Const Case Break Attr ]
## if_else_stmt(stmt_not_starting_with_expr_nor_block1) -> If par(if_cond) . closed_non_if_stmt SEMI_ELSE stmt_not_starting_with_expr_nor_block1 [ While Type Switch SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export EOF Default Continue Const Case Break Attr ]
## if_else_stmt(stmt_not_starting_with_expr_nor_block2) -> If par(if_cond) . closed_non_if_stmt Else stmt_not_starting_with_expr_nor_block2 [ While Verbatim UIdent Type True Switch String SEMI Return RBRACE PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EOF Directive Default Continue Const Case Bytes Break Attr ]
## if_else_stmt(stmt_not_starting_with_expr_nor_block2) -> If par(if_cond) . closed_non_if_stmt SEMI_ELSE stmt_not_starting_with_expr_nor_block2 [ While Verbatim UIdent Type True Switch String SEMI Return RBRACE PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EOF Directive Default Continue Const Case Bytes Break Attr ]
## if_stmt(stmt_not_starting_with_expr_nor_block1) -> If par(if_cond) . stmt_not_starting_with_expr_nor_block1 [ While Type Switch SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export EOF Default Continue Const Case Break Attr ]
## if_stmt(stmt_not_starting_with_expr_nor_block2) -> If par(if_cond) . stmt_not_starting_with_expr_nor_block2 [ While Verbatim UIdent Type True Switch String SEMI Return RBRACE PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EOF Directive Default Continue Const Case Bytes Break Attr ]
##
## The known suffix of the stack is as follows:
## If par(if_cond)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Namespace UIdent LBRACE Return If LPAR UIdent RPAR While ZWSP
##
## Ends in an error in state: 902.
##
## while_stmt(closed_non_if_stmt) -> While . par(while_cond) closed_non_if_stmt [ SEMI_ELSE Else ]
## while_stmt(stmt_not_starting_with_expr_nor_block1) -> While . par(while_cond) stmt_not_starting_with_expr_nor_block1 [ While Type Switch SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export EOF Default Continue Const Case Break Attr ]
## while_stmt(stmt_not_starting_with_expr_nor_block2) -> While . par(while_cond) stmt_not_starting_with_expr_nor_block2 [ While Verbatim UIdent Type True Switch String SEMI Return RBRACE PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EOF Directive Default Continue Const Case Bytes Break Attr ]
##
## The known suffix of the stack is as follows:
## While
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Namespace UIdent LBRACE Return If LPAR UIdent RPAR While LPAR UIdent RPAR ZWSP
##
## Ends in an error in state: 903.
##
## while_stmt(closed_non_if_stmt) -> While par(while_cond) . closed_non_if_stmt [ SEMI_ELSE Else ]
## while_stmt(stmt_not_starting_with_expr_nor_block1) -> While par(while_cond) . stmt_not_starting_with_expr_nor_block1 [ While Type Switch SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export EOF Default Continue Const Case Break Attr ]
## while_stmt(stmt_not_starting_with_expr_nor_block2) -> While par(while_cond) . stmt_not_starting_with_expr_nor_block2 [ While Verbatim UIdent Type True Switch String SEMI Return RBRACE PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EOF Directive Default Continue Const Case Bytes Break Attr ]
##
## The known suffix of the stack is as follows:
## While par(while_cond)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Namespace UIdent LBRACE Return If LPAR UIdent RPAR If ZWSP
##
## Ends in an error in state: 904.
##
## if_else_stmt(closed_non_if_stmt) -> If . par(if_cond) closed_non_if_stmt Else closed_non_if_stmt [ SEMI_ELSE Else ]
## if_else_stmt(closed_non_if_stmt) -> If . par(if_cond) closed_non_if_stmt SEMI_ELSE closed_non_if_stmt [ SEMI_ELSE Else ]
## if_else_stmt(stmt_not_starting_with_expr_nor_block1) -> If . par(if_cond) closed_non_if_stmt Else stmt_not_starting_with_expr_nor_block1 [ While Type Switch SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export EOF Default Continue Const Case Break Attr ]
## if_else_stmt(stmt_not_starting_with_expr_nor_block1) -> If . par(if_cond) closed_non_if_stmt SEMI_ELSE stmt_not_starting_with_expr_nor_block1 [ While Type Switch SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export EOF Default Continue Const Case Break Attr ]
## if_else_stmt(stmt_not_starting_with_expr_nor_block2) -> If . par(if_cond) closed_non_if_stmt Else stmt_not_starting_with_expr_nor_block2 [ While Verbatim UIdent Type True Switch String SEMI Return RBRACE PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EOF Directive Default Continue Const Case Bytes Break Attr ]
## if_else_stmt(stmt_not_starting_with_expr_nor_block2) -> If . par(if_cond) closed_non_if_stmt SEMI_ELSE stmt_not_starting_with_expr_nor_block2 [ While Verbatim UIdent Type True Switch String SEMI Return RBRACE PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EOF Directive Default Continue Const Case Bytes Break Attr ]
## if_stmt(stmt_not_starting_with_expr_nor_block1) -> If . par(if_cond) stmt_not_starting_with_expr_nor_block1 [ While Type Switch SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export EOF Default Continue Const Case Break Attr ]
## if_stmt(stmt_not_starting_with_expr_nor_block2) -> If . par(if_cond) stmt_not_starting_with_expr_nor_block2 [ While Verbatim UIdent Type True Switch String SEMI Return RBRACE PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EOF Directive Default Continue Const Case Bytes Break Attr ]
##
## The known suffix of the stack is as follows:
## If
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Namespace UIdent LBRACE Return If LPAR UIdent RPAR If LPAR UIdent RPAR ZWSP
##
## Ends in an error in state: 905.
##
## if_else_stmt(closed_non_if_stmt) -> If par(if_cond) . closed_non_if_stmt Else closed_non_if_stmt [ SEMI_ELSE Else ]
## if_else_stmt(closed_non_if_stmt) -> If par(if_cond) . closed_non_if_stmt SEMI_ELSE closed_non_if_stmt [ SEMI_ELSE Else ]
## if_else_stmt(stmt_not_starting_with_expr_nor_block1) -> If par(if_cond) . closed_non_if_stmt Else stmt_not_starting_with_expr_nor_block1 [ While Type Switch SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export EOF Default Continue Const Case Break Attr ]
## if_else_stmt(stmt_not_starting_with_expr_nor_block1) -> If par(if_cond) . closed_non_if_stmt SEMI_ELSE stmt_not_starting_with_expr_nor_block1 [ While Type Switch SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export EOF Default Continue Const Case Break Attr ]
## if_else_stmt(stmt_not_starting_with_expr_nor_block2) -> If par(if_cond) . closed_non_if_stmt Else stmt_not_starting_with_expr_nor_block2 [ While Verbatim UIdent Type True Switch String SEMI Return RBRACE PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EOF Directive Default Continue Const Case Bytes Break Attr ]
## if_else_stmt(stmt_not_starting_with_expr_nor_block2) -> If par(if_cond) . closed_non_if_stmt SEMI_ELSE stmt_not_starting_with_expr_nor_block2 [ While Verbatim UIdent Type True Switch String SEMI Return RBRACE PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EOF Directive Default Continue Const Case Bytes Break Attr ]
## if_stmt(stmt_not_starting_with_expr_nor_block1) -> If par(if_cond) . stmt_not_starting_with_expr_nor_block1 [ While Type Switch SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export EOF Default Continue Const Case Break Attr ]
## if_stmt(stmt_not_starting_with_expr_nor_block2) -> If par(if_cond) . stmt_not_starting_with_expr_nor_block2 [ While Verbatim UIdent Type True Switch String SEMI Return RBRACE PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EOF Directive Default Continue Const Case Bytes Break Attr ]
##
## The known suffix of the stack is as follows:
## If par(if_cond)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Namespace UIdent LBRACE Return If LPAR UIdent RPAR For ZWSP
##
## Ends in an error in state: 906.
##
## empty_for_stmt -> For . par(range_for) [ SEMI_ELSE Else ]
## for_of_stmt(closed_non_if_stmt) -> For . par(range_of) closed_non_if_stmt [ SEMI_ELSE Else ]
## for_of_stmt(stmt_not_starting_with_expr_nor_block1) -> For . par(range_of) stmt_not_starting_with_expr_nor_block1 [ While Type Switch SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export EOF Default Continue Const Case Break Attr ]
## for_of_stmt(stmt_not_starting_with_expr_nor_block2) -> For . par(range_of) stmt_not_starting_with_expr_nor_block2 [ While Verbatim UIdent Type True Switch String SEMI Return RBRACE PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EOF Directive Default Continue Const Case Bytes Break Attr ]
## full_for_stmt(closed_non_if_stmt) -> For . par(range_for) closed_non_if_stmt [ SEMI_ELSE Else ]
## full_for_stmt(stmt_not_starting_with_expr_nor_block1) -> For . par(range_for) stmt_not_starting_with_expr_nor_block1 [ While Type Switch SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export EOF Default Continue Const Case Break Attr ]
## full_for_stmt(stmt_not_starting_with_expr_nor_block2) -> For . par(range_for) stmt_not_starting_with_expr_nor_block2 [ While Verbatim UIdent Type True Switch String SEMI Return RBRACE PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EOF Directive Default Continue Const Case Bytes Break Attr ]
##
## The known suffix of the stack is as follows:
## For
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Namespace UIdent LBRACE Return If LPAR UIdent RPAR For LPAR Const Ident Of UIdent RPAR ZWSP
##
## Ends in an error in state: 907.
##
## for_of_stmt(closed_non_if_stmt) -> For par(range_of) . closed_non_if_stmt [ SEMI_ELSE Else ]
## for_of_stmt(stmt_not_starting_with_expr_nor_block1) -> For par(range_of) . stmt_not_starting_with_expr_nor_block1 [ While Type Switch SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export EOF Default Continue Const Case Break Attr ]
## for_of_stmt(stmt_not_starting_with_expr_nor_block2) -> For par(range_of) . stmt_not_starting_with_expr_nor_block2 [ While Verbatim UIdent Type True Switch String SEMI Return RBRACE PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EOF Directive Default Continue Const Case Bytes Break Attr ]
##
## The known suffix of the stack is as follows:
## For par(range_of)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Namespace UIdent LBRACE Return If LPAR UIdent RPAR Export ZWSP
##
## Ends in an error in state: 908.
##
## export(declaration) -> Export . declaration [ SEMI_ELSE Else ]
## export(import_decl) -> Export . import_decl [ While Type Switch SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export EOF Default Continue Const Case Break Attr ]
## export(interface_decl) -> Export . interface_decl [ While Verbatim UIdent Type True Switch String SEMI Return RBRACE PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EOF Directive Default Continue Const Case Bytes Break Attr ]
## export(namespace_decl) -> Export . namespace_decl [ While Verbatim UIdent Type True Switch String SEMI Return RBRACE PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EOF Directive Default Continue Const Case Bytes Break Attr ]
## export(type_decl) -> Export . type_decl [ While Type Switch SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export EOF Default Continue Const Case Break Attr ]
## export(value_decl) -> Export . value_decl [ While Type Switch SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export EOF Default Continue Const Case Break Attr ]
##
## The known suffix of the stack is as follows:
## Export
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Namespace UIdent LBRACE Return If LPAR UIdent RPAR Export Const Bytes EQ UIdent When
##
## Ends in an error in state: 969.
##
## if_else_stmt(stmt_not_starting_with_expr_nor_block1) -> If par(if_cond) closed_non_if_stmt . Else stmt_not_starting_with_expr_nor_block1 [ While Type Switch SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export EOF Default Continue Const Case Break Attr ]
## if_else_stmt(stmt_not_starting_with_expr_nor_block1) -> If par(if_cond) closed_non_if_stmt . SEMI_ELSE stmt_not_starting_with_expr_nor_block1 [ While Type Switch SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export EOF Default Continue Const Case Break Attr ]
## if_else_stmt(stmt_not_starting_with_expr_nor_block2) -> If par(if_cond) closed_non_if_stmt . Else stmt_not_starting_with_expr_nor_block2 [ While Verbatim UIdent Type True Switch String SEMI Return RBRACE PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EOF Directive Default Continue Const Case Bytes Break Attr ]
## if_else_stmt(stmt_not_starting_with_expr_nor_block2) -> If par(if_cond) closed_non_if_stmt . SEMI_ELSE stmt_not_starting_with_expr_nor_block2 [ While Verbatim UIdent Type True Switch String SEMI Return RBRACE PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EOF Directive Default Continue Const Case Bytes Break Attr ]
##
## The known suffix of the stack is as follows:
## If par(if_cond) closed_non_if_stmt
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 4, spurious reduction of production ctor -> UIdent
## In state 394, spurious reduction of production core_expr -> ctor
## In state 395, spurious reduction of production app_expr_level -> core_expr
## In state 491, spurious reduction of production unary_expr_level -> app_expr_level
## In state 374, spurious reduction of production mult_expr_level -> unary_expr_level
## In state 388, spurious reduction of production add_expr_level -> mult_expr_level
## In state 446, spurious reduction of production eq_expr_level -> add_expr_level
## In state 411, spurious reduction of production comp_expr_level -> eq_expr_level
## In state 416, spurious reduction of production bit_shift_level -> comp_expr_level
## In state 457, spurious reduction of production conj_expr_level -> bit_shift_level
## In state 471, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 412, spurious reduction of production non_object_expr -> disj_expr_level
## In state 466, spurious reduction of production no_attr_expr -> non_object_expr
## In state 467, spurious reduction of production expr -> no_attr_expr
## In state 608, spurious reduction of production val_binding -> pattern option(binding_type) EQ expr
## In state 598, spurious reduction of production nsepseq(val_binding,COMMA) -> val_binding
## In state 611, spurious reduction of production bindings -> nsepseq(val_binding,COMMA)
## In state 687, spurious reduction of production value_decl -> Const bindings
## In state 909, spurious reduction of production declaration -> value_decl
## In state 792, spurious reduction of production export(declaration) -> Export declaration
## In state 841, spurious reduction of production export_stmt -> export(declaration)
## In state 942, spurious reduction of production non_if_stmt(closed_non_if_stmt) -> export_stmt
## In state 812, spurious reduction of production closed_non_if_stmt -> non_if_stmt(closed_non_if_stmt)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Namespace UIdent LBRACE Return If LPAR UIdent RPAR Attr ZWSP
##
## Ends in an error in state: 914.
##
## core_stmt(closed_non_if_stmt) -> Attr . closed_non_if_stmt [ SEMI_ELSE Else ]
## right_rec_stmt(stmt_not_starting_with_expr_nor_block1) -> Attr . stmt_not_starting_with_expr_nor_block1 [ While Type Switch SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export EOF Default Continue Const Case Break Attr ]
## right_rec_stmt(stmt_not_starting_with_expr_nor_block2) -> Attr . stmt_not_starting_with_expr_nor_block2 [ While Verbatim UIdent Type True Switch String SEMI Return RBRACE PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EOF Directive Default Continue Const Case Bytes Break Attr ]
##
## The known suffix of the stack is as follows:
## Attr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Namespace UIdent LBRACE Return If LPAR UIdent RPAR If LPAR UIdent RPAR Return BIT_AND
##
## Ends in an error in state: 960.
##
## if_else_stmt(closed_non_if_stmt) -> If par(if_cond) closed_non_if_stmt . Else closed_non_if_stmt [ SEMI_ELSE Else ]
## if_else_stmt(closed_non_if_stmt) -> If par(if_cond) closed_non_if_stmt . SEMI_ELSE closed_non_if_stmt [ SEMI_ELSE Else ]
## if_else_stmt(stmt_not_starting_with_expr_nor_block1) -> If par(if_cond) closed_non_if_stmt . Else stmt_not_starting_with_expr_nor_block1 [ While Type Switch SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export EOF Default Continue Const Case Break Attr ]
## if_else_stmt(stmt_not_starting_with_expr_nor_block1) -> If par(if_cond) closed_non_if_stmt . SEMI_ELSE stmt_not_starting_with_expr_nor_block1 [ While Type Switch SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export EOF Default Continue Const Case Break Attr ]
## if_else_stmt(stmt_not_starting_with_expr_nor_block2) -> If par(if_cond) closed_non_if_stmt . Else stmt_not_starting_with_expr_nor_block2 [ While Verbatim UIdent Type True Switch String SEMI Return RBRACE PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EOF Directive Default Continue Const Case Bytes Break Attr ]
## if_else_stmt(stmt_not_starting_with_expr_nor_block2) -> If par(if_cond) closed_non_if_stmt . SEMI_ELSE stmt_not_starting_with_expr_nor_block2 [ While Verbatim UIdent Type True Switch String SEMI Return RBRACE PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EOF Directive Default Continue Const Case Bytes Break Attr ]
##
## The known suffix of the stack is as follows:
## If par(if_cond) closed_non_if_stmt
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 561, spurious reduction of production empty_return_stmt -> Return
## In state 842, spurious reduction of production return_stmt -> empty_return_stmt
## In state 924, spurious reduction of production non_if_stmt(closed_non_if_stmt) -> return_stmt
## In state 812, spurious reduction of production closed_non_if_stmt -> non_if_stmt(closed_non_if_stmt)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Namespace UIdent LBRACE Return If LPAR UIdent RPAR If LPAR UIdent RPAR Return SEMI_ELSE ZWSP
##
## Ends in an error in state: 961.
##
## if_else_stmt(closed_non_if_stmt) -> If par(if_cond) closed_non_if_stmt SEMI_ELSE . closed_non_if_stmt [ SEMI_ELSE Else ]
## if_else_stmt(stmt_not_starting_with_expr_nor_block1) -> If par(if_cond) closed_non_if_stmt SEMI_ELSE . stmt_not_starting_with_expr_nor_block1 [ While Type Switch SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export EOF Default Continue Const Case Break Attr ]
## if_else_stmt(stmt_not_starting_with_expr_nor_block2) -> If par(if_cond) closed_non_if_stmt SEMI_ELSE . stmt_not_starting_with_expr_nor_block2 [ While Verbatim UIdent Type True Switch String SEMI Return RBRACE PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EOF Directive Default Continue Const Case Bytes Break Attr ]
##
## The known suffix of the stack is as follows:
## If par(if_cond) closed_non_if_stmt SEMI_ELSE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Namespace UIdent LBRACE Return If LPAR UIdent RPAR If LPAR UIdent RPAR Return Else ZWSP
##
## Ends in an error in state: 964.
##
## if_else_stmt(closed_non_if_stmt) -> If par(if_cond) closed_non_if_stmt Else . closed_non_if_stmt [ SEMI_ELSE Else ]
## if_else_stmt(stmt_not_starting_with_expr_nor_block1) -> If par(if_cond) closed_non_if_stmt Else . stmt_not_starting_with_expr_nor_block1 [ While Type Switch SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export EOF Default Continue Const Case Break Attr ]
## if_else_stmt(stmt_not_starting_with_expr_nor_block2) -> If par(if_cond) closed_non_if_stmt Else . stmt_not_starting_with_expr_nor_block2 [ While Verbatim UIdent Type True Switch String SEMI Return RBRACE PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EOF Directive Default Continue Const Case Bytes Break Attr ]
##
## The known suffix of the stack is as follows:
## If par(if_cond) closed_non_if_stmt Else
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Namespace UIdent LBRACE Return If LPAR UIdent RPAR Return SEMI_ELSE ZWSP
##
## Ends in an error in state: 970.
##
## if_else_stmt(stmt_not_starting_with_expr_nor_block1) -> If par(if_cond) closed_non_if_stmt SEMI_ELSE . stmt_not_starting_with_expr_nor_block1 [ While Type Switch SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export EOF Default Continue Const Case Break Attr ]
## if_else_stmt(stmt_not_starting_with_expr_nor_block2) -> If par(if_cond) closed_non_if_stmt SEMI_ELSE . stmt_not_starting_with_expr_nor_block2 [ While Verbatim UIdent Type True Switch String SEMI Return RBRACE PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EOF Directive Default Continue Const Case Bytes Break Attr ]
##
## The known suffix of the stack is as follows:
## If par(if_cond) closed_non_if_stmt SEMI_ELSE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Namespace UIdent LBRACE Return For ZWSP
##
## Ends in an error in state: 971.
##
## for_of_stmt(stmt_not_starting_with_expr_nor_block1) -> For . par(range_of) stmt_not_starting_with_expr_nor_block1 [ While Type Switch SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export EOF Default Continue Const Case Break Attr ]
## for_of_stmt(stmt_not_starting_with_expr_nor_block2) -> For . par(range_of) stmt_not_starting_with_expr_nor_block2 [ While Verbatim UIdent Type True Switch String SEMI Return RBRACE PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EOF Directive Default Continue Const Case Bytes Break Attr ]
## full_for_stmt(stmt_not_starting_with_expr_nor_block1) -> For . par(range_for) stmt_not_starting_with_expr_nor_block1 [ While Type Switch SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export EOF Default Continue Const Case Break Attr ]
## full_for_stmt(stmt_not_starting_with_expr_nor_block2) -> For . par(range_for) stmt_not_starting_with_expr_nor_block2 [ While Verbatim UIdent Type True Switch String SEMI Return RBRACE PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EOF Directive Default Continue Const Case Bytes Break Attr ]
##
## The known suffix of the stack is as follows:
## For
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Namespace UIdent LBRACE Return For LPAR Const Ident Of UIdent RPAR ZWSP
##
## Ends in an error in state: 972.
##
## for_of_stmt(stmt_not_starting_with_expr_nor_block1) -> For par(range_of) . stmt_not_starting_with_expr_nor_block1 [ While Type Switch SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export EOF Default Continue Const Case Break Attr ]
## for_of_stmt(stmt_not_starting_with_expr_nor_block2) -> For par(range_of) . stmt_not_starting_with_expr_nor_block2 [ While Verbatim UIdent Type True Switch String SEMI Return RBRACE PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EOF Directive Default Continue Const Case Bytes Break Attr ]
##
## The known suffix of the stack is as follows:
## For par(range_of)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Namespace UIdent LBRACE Return Export ZWSP
##
## Ends in an error in state: 973.
##
## export(import_decl) -> Export . import_decl [ While Type Switch SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export EOF Default Continue Const Case Break Attr ]
## export(interface_decl) -> Export . interface_decl [ While Verbatim UIdent Type True Switch String SEMI Return RBRACE PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EOF Directive Default Continue Const Case Bytes Break Attr ]
## export(namespace_decl) -> Export . namespace_decl [ While Verbatim UIdent Type True Switch String SEMI Return RBRACE PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EOF Directive Default Continue Const Case Bytes Break Attr ]
## export(type_decl) -> Export . type_decl [ While Type Switch SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export EOF Default Continue Const Case Break Attr ]
## export(value_decl) -> Export . value_decl [ While Type Switch SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export EOF Default Continue Const Case Break Attr ]
##
## The known suffix of the stack is as follows:
## Export
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Namespace UIdent LBRACE Return Attr ZWSP
##
## Ends in an error in state: 979.
##
## right_rec_stmt(stmt_not_starting_with_expr_nor_block1) -> Attr . stmt_not_starting_with_expr_nor_block1 [ While Type Switch SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export EOF Default Continue Const Case Break Attr ]
## right_rec_stmt(stmt_not_starting_with_expr_nor_block2) -> Attr . stmt_not_starting_with_expr_nor_block2 [ While Verbatim UIdent Type True Switch String SEMI Return RBRACE PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EOF Directive Default Continue Const Case Bytes Break Attr ]
##
## The known suffix of the stack is as follows:
## Attr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Namespace UIdent LBRACE Return For LPAR SEMI SEMI RPAR ZWSP
##
## Ends in an error in state: 989.
##
## full_for_stmt(stmt_not_starting_with_expr_nor_block1) -> For par(range_for) . stmt_not_starting_with_expr_nor_block1 [ While Type Switch SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export EOF Default Continue Const Case Break Attr ]
## full_for_stmt(stmt_not_starting_with_expr_nor_block2) -> For par(range_for) . stmt_not_starting_with_expr_nor_block2 [ While Verbatim UIdent Type True Switch String SEMI Return RBRACE PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EOF Directive Default Continue Const Case Bytes Break Attr ]
##
## The known suffix of the stack is as follows:
## For par(range_for)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Namespace UIdent LBRACE Return If LPAR UIdent RPAR Return Else ZWSP
##
## Ends in an error in state: 990.
##
## if_else_stmt(stmt_not_starting_with_expr_nor_block1) -> If par(if_cond) closed_non_if_stmt Else . stmt_not_starting_with_expr_nor_block1 [ While Type Switch SEMI Return RBRACE Namespace Let LBRACE Interface Import If For Export EOF Default Continue Const Case Break Attr ]
## if_else_stmt(stmt_not_starting_with_expr_nor_block2) -> If par(if_cond) closed_non_if_stmt Else . stmt_not_starting_with_expr_nor_block2 [ While Verbatim UIdent Type True Switch String SEMI Return RBRACE PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export EOF Directive Default Continue Const Case Bytes Break Attr ]
##
## The known suffix of the stack is as follows:
## If par(if_cond) closed_non_if_stmt Else
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Namespace UIdent LBRACE Switch LPAR UIdent RPAR LBRACE Case ZWSP
##
## Ends in an error in state: 1023.
##
## switch_case -> Case . case_expr COLON [ RBRACE Default Case ]
## switch_case -> Case . case_expr COLON statements [ RBRACE Default Case ]
##
## The known suffix of the stack is as follows:
## Case
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Namespace UIdent LBRACE Switch LPAR UIdent RPAR LBRACE Case UIdent COLON ZWSP
##
## Ends in an error in state: 1029.
##
## switch_case -> Case case_expr COLON . [ RBRACE Default Case ]
## switch_case -> Case case_expr COLON . statements [ RBRACE Default Case ]
##
## The known suffix of the stack is as follows:
## Case case_expr COLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Namespace UIdent LBRACE Switch LPAR UIdent RPAR LBRACE Case UIdent LPAR RPAR ZWSP
##
## Ends in an error in state: 1031.
##
## lambda -> app_expr . [ LPAR ]
## path(app_expr) -> app_expr . nseq(selection) [ LPAR COLON ]
##
## The known suffix of the stack is as follows:
## app_expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Namespace UIdent LBRACE Switch LPAR UIdent RPAR LBRACE Case UIdent COLON Return BIT_AND
##
## Ends in an error in state: 1033.
##
## nseq(switch_case) -> switch_case . [ RBRACE Default ]
## nseq(switch_case) -> switch_case . nseq(switch_case) [ RBRACE Default ]
##
## The known suffix of the stack is as follows:
## switch_case
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 561, spurious reduction of production empty_return_stmt -> Return
## In state 1009, spurious reduction of production return_stmt -> empty_return_stmt
## In state 886, spurious reduction of production non_if_stmt(statement) -> return_stmt
## In state 811, spurious reduction of production statement -> non_if_stmt(statement)
## In state 995, spurious reduction of production last_or_more(statement) -> statement
## In state 1000, spurious reduction of production statements -> last_or_more(statement)
## In state 1030, spurious reduction of production switch_case -> Case case_expr COLON statements
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Namespace UIdent LBRACE Switch LPAR UIdent RPAR LBRACE Default COLON Return BIT_AND
##
## Ends in an error in state: 1037.
##
## braces(cases) -> LBRACE cases . RBRACE [ While Verbatim UIdent Type True Switch String SEMI_ELSE SEMI Return RBRACE PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export Else EOF Directive Default Continue Const Case Bytes Break Attr ]
##
## The known suffix of the stack is as follows:
## LBRACE cases
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 561, spurious reduction of production empty_return_stmt -> Return
## In state 1009, spurious reduction of production return_stmt -> empty_return_stmt
## In state 886, spurious reduction of production non_if_stmt(statement) -> return_stmt
## In state 811, spurious reduction of production statement -> non_if_stmt(statement)
## In state 995, spurious reduction of production last_or_more(statement) -> statement
## In state 1000, spurious reduction of production statements -> last_or_more(statement)
## In state 1022, spurious reduction of production switch_default -> Default COLON statements
## In state 1032, spurious reduction of production cases -> switch_default
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Namespace UIdent LBRACE Return BIT_AND
##
## Ends in an error in state: 1040.
##
## braces(statements) -> LBRACE statements . RBRACE [ While When Verbatim UIdent Type True Switch String SEMI_ELSE SEMI Return RPAR RBRACKET RBRACE PLUS2 PARAMS Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export Else EOF Directive Default Continue Const Case COMMA COLON Bytes Break Attr ]
##
## The known suffix of the stack is as follows:
## LBRACE statements
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 561, spurious reduction of production empty_return_stmt -> Return
## In state 1009, spurious reduction of production return_stmt -> empty_return_stmt
## In state 886, spurious reduction of production non_if_stmt(statement) -> return_stmt
## In state 811, spurious reduction of production statement -> non_if_stmt(statement)
## In state 995, spurious reduction of production last_or_more(statement) -> statement
## In state 1000, spurious reduction of production statements -> last_or_more(statement)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Namespace UIdent Implements ZWSP
##
## Ends in an error in state: 567.
##
## interface -> Implements . intf_expr [ LBRACE ]
##
## The known suffix of the stack is as follows:
## Implements
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Namespace UIdent Implements UIdent ZWSP
##
## Ends in an error in state: 594.
##
## namespace_decl -> Namespace namespace_binder interface . braces(statements) [ While Verbatim UIdent Type True Switch String SEMI_ELSE SEMI Return RBRACE PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export Else EOF Directive Default Continue Const Case Bytes Break Attr ]
##
## The known suffix of the stack is as follows:
## Namespace namespace_binder interface
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 153, spurious reduction of production namespace_selection -> namespace_name
## In state 590, spurious reduction of production intf_expr -> namespace_selection
## In state 591, spurious reduction of production interface -> Implements intf_expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Export ZWSP
##
## Ends in an error in state: 785.
##
## export(declaration) -> Export . declaration [ SEMI_ELSE SEMI RBRACE Else EOF Default Case ]
## export(import_decl) -> Export . import_decl [ While Type Switch Return Namespace Let LBRACE Interface Import If For Export Continue Const Break Attr ]
## export(interface_decl) -> Export . interface_decl [ While Verbatim UIdent Type True Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export Directive Continue Const Bytes Break Attr ]
## export(namespace_decl) -> Export . namespace_decl [ While Verbatim UIdent Type True Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export Directive Continue Const Bytes Break Attr ]
## export(type_decl) -> Export . type_decl [ While Type Switch Return Namespace Let LBRACE Interface Import If For Export Continue Const Break Attr ]
## export(value_decl) -> Export . value_decl [ While Type Switch Return Namespace Let LBRACE Interface Import If For Export Continue Const Break Attr ]
##
## The known suffix of the stack is as follows:
## Export
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Attr ZWSP
##
## Ends in an error in state: 884.
##
## core_stmt(statement) -> Attr . statement [ SEMI RBRACE EOF Default Case ]
## right_rec_stmt(poly_stmt) -> Attr . poly_stmt [ While Verbatim UIdent Type True Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export Directive Continue Const Bytes Break Attr ]
## right_rec_stmt(stmt_ending_with_expr) -> Attr . stmt_ending_with_expr [ While Type Switch Return Namespace Let LBRACE Interface Import If For Export Continue Const Break Attr ]
##
## The known suffix of the stack is as follows:
## Attr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Import UIdent EQ UIdent BIT_AND
##
## Ends in an error in state: 1107.
##
## contract -> statements . EOF [ # ]
##
## The known suffix of the stack is as follows:
## statements
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 153, spurious reduction of production namespace_selection -> namespace_name
## In state 636, spurious reduction of production import_decl -> Import namespace_name EQ namespace_selection
## In state 817, spurious reduction of production declaration -> import_decl
## In state 715, spurious reduction of production decl_stmt -> declaration
## In state 890, spurious reduction of production non_if_stmt(statement) -> decl_stmt
## In state 811, spurious reduction of production statement -> non_if_stmt(statement)
## In state 995, spurious reduction of production last_or_more(statement) -> statement
## In state 1000, spurious reduction of production statements -> last_or_more(statement)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Directive ZWSP
##
## Ends in an error in state: 1014.
##
## poly_stmt -> directive_stmt . [ While Verbatim UIdent Type True Switch String Return PLUS2 Nat Namespace Mutez Match MINUS2 Let LPAR LBRACKET LBRACE Interface Int Import If Ident Function For False Export Directive Continue Const Bytes Break Attr ]
## statements -> directive_stmt . [ RBRACE EOF Default Case ]
##
## The known suffix of the stack is as follows:
## directive_stmt
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: ZWSP
##
## Ends in an error in state: 1110.
##
## interactive_expr' -> . interactive_expr [ # ]
##
## The known suffix of the stack is as follows:
##
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Attr Directive ZWSP
##
## Ends in an error in state: 998.
##
## statements -> poly_stmt . statements [ RBRACE EOF Default Case ]
##
## The known suffix of the stack is as follows:
## poly_stmt
##

<YOUR SYNTAX ERROR MESSAGE HERE>
