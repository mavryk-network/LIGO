interactive_expr: While ZWSP
##
## Ends in an error in state: 1.
##
## while_expr -> While . expr block [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End Else EOF Downto Done Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## While
##

Ill-formed while-loop.
At this point, the condition is expected as an expression.

interactive_expr: While Bytes ZWSP
##
## Ends in an error in state: 1358.
##
## while_expr -> While expr . block [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End Else EOF Downto Done Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## While expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 408, spurious reduction of production call_expr_level -> core_expr
## In state 428, spurious reduction of production unary_expr_level -> call_expr_level
## In state 386, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 417, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 423, spurious reduction of production add_expr_level -> mult_expr_level
## In state 470, spurious reduction of production cons_expr_level -> add_expr_level
## In state 457, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 494, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 501, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 510, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 455, spurious reduction of production tuple_expr_level -> disj_expr_level
## In state 414, spurious reduction of production ass_expr_level -> tuple_expr_level
## In state 525, spurious reduction of production base_expr(expr) -> ass_expr_level
## In state 523, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 524, spurious reduction of production expr -> base_cond__open(expr)
##

Ill-formed while-loop.
At this point, if the condition is complete, then the keyword 'do' is
expected, followed by the loop body.

interactive_expr: For Ident EQ Bytes Downto Bytes ZWSP
##
## Ends in an error in state: 1096.
##
## for_int_expr -> For index EQ expr direction expr . block [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End Else EOF Downto Done Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## For index EQ expr direction expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 408, spurious reduction of production call_expr_level -> core_expr
## In state 428, spurious reduction of production unary_expr_level -> call_expr_level
## In state 386, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 417, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 423, spurious reduction of production add_expr_level -> mult_expr_level
## In state 470, spurious reduction of production cons_expr_level -> add_expr_level
## In state 457, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 494, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 501, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 510, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 455, spurious reduction of production tuple_expr_level -> disj_expr_level
## In state 414, spurious reduction of production ass_expr_level -> tuple_expr_level
## In state 525, spurious reduction of production base_expr(expr) -> ass_expr_level
## In state 523, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 524, spurious reduction of production expr -> base_cond__open(expr)
##

Ill-formed for-loop expression.
At this point, if the final bound is complete, the keyword 'do'
is expected, followed by the loop body.

interactive_expr: For Ident EQ Bytes Downto ZWSP
##
## Ends in an error in state: 1095.
##
## for_int_expr -> For index EQ expr direction . expr block [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End Else EOF Downto Done Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## For index EQ expr direction
##

Ill-formed for-loop expression.
At this point, the upper bound is expected as an expression.

interactive_expr: For Ident EQ Bytes ZWSP
##
## Ends in an error in state: 1092.
##
## for_int_expr -> For index EQ expr . direction expr block [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End Else EOF Downto Done Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## For index EQ expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 408, spurious reduction of production call_expr_level -> core_expr
## In state 428, spurious reduction of production unary_expr_level -> call_expr_level
## In state 386, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 417, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 423, spurious reduction of production add_expr_level -> mult_expr_level
## In state 470, spurious reduction of production cons_expr_level -> add_expr_level
## In state 457, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 494, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 501, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 510, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 455, spurious reduction of production tuple_expr_level -> disj_expr_level
## In state 414, spurious reduction of production ass_expr_level -> tuple_expr_level
## In state 525, spurious reduction of production base_expr(expr) -> ass_expr_level
## In state 523, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 524, spurious reduction of production expr -> base_cond__open(expr)
##

Ill-formed for-loop expression.
At this point, if the expression is complete, one of the following is
expected:
  * the keyword 'to' if iterating up to a value;
  * the keyword 'downto' if iterating down to a value.

interactive_expr: For UIdent ZWSP
##
## Ends in an error in state: 378.
##
## for_in_expr -> For pattern . In expr block [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End Else EOF Downto Done Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## For pattern
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 319, spurious reduction of production ctor_pattern -> UIdent
## In state 340, spurious reduction of production core_pattern -> ctor_pattern
## In state 354, spurious reduction of production cons_pattern_level -> core_pattern
## In state 370, spurious reduction of production pattern -> cons_pattern_level
##

Ill-formed for-loop expression.
At this point, if the pattern is complete, the keyword 'in' is
expected, followed by the collection.

interactive_expr: For Ident EQ ZWSP
##
## Ends in an error in state: 1091.
##
## for_int_expr -> For index EQ . expr direction expr block [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End Else EOF Downto Done Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## For index EQ
##

Ill-formed for-loop expression.
At this point, the initial value of the index is expected as an
expression.

interactive_expr: While Bytes Do Bytes End
##
## Ends in an error in state: 1087.
##
## block -> Do series . Done [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End Else EOF Downto Done Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## Do series
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 408, spurious reduction of production call_expr_level -> core_expr
## In state 428, spurious reduction of production unary_expr_level -> call_expr_level
## In state 386, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 417, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 423, spurious reduction of production add_expr_level -> mult_expr_level
## In state 470, spurious reduction of production cons_expr_level -> add_expr_level
## In state 457, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 494, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 501, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 510, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 455, spurious reduction of production tuple_expr_level -> disj_expr_level
## In state 414, spurious reduction of production ass_expr_level -> tuple_expr_level
## In state 1014, spurious reduction of production seq_expr -> ass_expr_level
## In state 948, spurious reduction of production last_expr -> seq_expr
## In state 1025, spurious reduction of production series -> last_expr
##

Ill-formed loop expression.
At this point, if the expression is complete, one of the following is
expected:
 * a semicolon ';' followed by another expression;
 * the keyword 'done' if the loop body is complete.

interactive_expr: While Bytes Do ZWSP
##
## Ends in an error in state: 1085.
##
## block -> Do . Done [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End Else EOF Downto Done Do Directive Contract COLON Attr ]
## block -> Do . series Done [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End Else EOF Downto Done Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## Do
##

Ill-formed loop expression.
At this point, one of the following is expected:
  * a sequence of expressions separated by semicolons ';';
  * the keyword 'done' is the loop body is empty.

interactive_expr: For Ident In Bytes ZWSP
##
## Ends in an error in state: 1084.
##
## for_in_expr -> For pattern In expr . block [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End Else EOF Downto Done Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## For pattern In expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 408, spurious reduction of production call_expr_level -> core_expr
## In state 428, spurious reduction of production unary_expr_level -> call_expr_level
## In state 386, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 417, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 423, spurious reduction of production add_expr_level -> mult_expr_level
## In state 470, spurious reduction of production cons_expr_level -> add_expr_level
## In state 457, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 494, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 501, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 510, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 455, spurious reduction of production tuple_expr_level -> disj_expr_level
## In state 414, spurious reduction of production ass_expr_level -> tuple_expr_level
## In state 525, spurious reduction of production base_expr(expr) -> ass_expr_level
## In state 523, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 524, spurious reduction of production expr -> base_cond__open(expr)
##

Ill-formed for-loop expresssion.
At this point, the keyword 'do' is expected, followed by the loop
body.

interactive_expr: For Ident In ZWSP
##
## Ends in an error in state: 379.
##
## for_in_expr -> For pattern In . expr block [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End Else EOF Downto Done Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## For pattern In
##

Ill-formed for-loop expresssion.
At this point, the iterated collection is expected as an expression.

interactive_expr: For ZWSP
##
## Ends in an error in state: 316.
##
## for_in_expr -> For . pattern In expr block [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End Else EOF Downto Done Do Directive Contract COLON Attr ]
## for_int_expr -> For . index EQ expr direction expr block [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End Else EOF Downto Done Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## For
##

Ill-formed for-loop expresssion.
At this point, a pattern is expected.

interactive_expr: For Ident ZWSP
##
## Ends in an error in state: 377.
##
## core_pattern -> var_pattern . [ In CONS COMMA ]
## index -> var_pattern . [ EQ ]
##
## The known suffix of the stack is as follows:
## var_pattern
##
interactive_expr: For WILD ZWSP
##
## Ends in an error in state: 317.
##
## core_pattern -> WILD . [ In CONS COMMA ]
## index -> WILD . [ EQ ]
##
## The known suffix of the stack is as follows:
## WILD
##

Ill-formed for-loop expression.
At this point, one of the following is expected:
  * the assignment operator '=' if iterating over a numerical interval;
  * the keyword 'in' if iterating over a collection;
  * a comma ',' if matching a tuple.

interactive_expr: Ident ASS ZWSP
##
## Ends in an error in state: 454.
##
## ass_expr_level -> gen_ident ASS . ass_expr_level [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End Else EOF Downto Done Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## gen_ident ASS
##

Invalid mutable value assignment.
At this point, an expression is expected.

interactive_expr: Let Mut ZWSP
##
## Ends in an error in state: 1230.
##
## let_mut_in_expr(expr) -> Let Mut . let_mut_binding In expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let Mut
##
interactive_expr: If Bytes Then Let Mut ZWSP
##
## Ends in an error in state: 1171.
##
## let_mut_in_expr(closed_expr) -> Let Mut . let_mut_binding In closed_expr [ Else ]
## let_mut_in_expr(expr) -> Let Mut . let_mut_binding In expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let Mut
##
interactive_expr: If Bytes Then Attr Let Mut ZWSP
##
## Ends in an error in state: 1145.
##
## let_mut_in_expr(closed_expr) -> nseq(Attr) Let Mut . let_mut_binding In closed_expr [ Else ]
## let_mut_in_expr(expr) -> nseq(Attr) Let Mut . let_mut_binding In expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let Mut
##
interactive_expr: Begin If Bytes Then Let Mut ZWSP
##
## Ends in an error in state: 1005.
##
## let_mut_in_expr(closed_expr) -> Let Mut . let_mut_binding In closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Let Mut
##
interactive_expr: Begin If Bytes Then Attr Let Mut ZWSP
##
## Ends in an error in state: 982.
##
## let_mut_in_expr(closed_expr) -> nseq(Attr) Let Mut . let_mut_binding In closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let Mut
##
interactive_expr: Match Bytes With UIdent ARROW Let Mut ZWSP
##
## Ends in an error in state: 926.
##
## let_mut_in_expr(base_cond) -> Let Mut . let_mut_binding In base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let Mut
##
interactive_expr: Match Bytes With UIdent ARROW Attr Let Mut ZWSP
##
## Ends in an error in state: 905.
##
## let_mut_in_expr(base_cond) -> nseq(Attr) Let Mut . let_mut_binding In base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let Mut
##
interactive_expr: If Bytes Then Match Bytes With UIdent ARROW Let Mut ZWSP
##
## Ends in an error in state: 866.
##
## let_mut_in_expr(base_cond) -> Let Mut . let_mut_binding In base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## let_mut_in_expr(base_if_then_else) -> Let Mut . let_mut_binding In base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## Let Mut
##
interactive_expr: If Bytes Then Match Bytes With UIdent ARROW Attr Let Mut ZWSP
##
## Ends in an error in state: 832.
##
## let_mut_in_expr(base_cond) -> nseq(Attr) Let Mut . let_mut_binding In base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## let_mut_in_expr(base_if_then_else) -> nseq(Attr) Let Mut . let_mut_binding In base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let Mut
##
interactive_expr: Match Bytes With UIdent ARROW If Bytes Then Let Mut ZWSP
##
## Ends in an error in state: 791.
##
## let_mut_in_expr(base_cond) -> Let Mut . let_mut_binding In base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## let_mut_in_expr(closed_expr) -> Let Mut . let_mut_binding In closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Let Mut
##
interactive_expr: Match Bytes With UIdent ARROW If Bytes Then Attr Let Mut ZWSP
##
## Ends in an error in state: 741.
##
## let_mut_in_expr(base_cond) -> nseq(Attr) Let Mut . let_mut_binding In base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## let_mut_in_expr(closed_expr) -> nseq(Attr) Let Mut . let_mut_binding In closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let Mut
##
interactive_expr: Attr Let Mut ZWSP
##
## Ends in an error in state: 602.
##
## let_mut_in_expr(expr) -> nseq(Attr) Let Mut . let_mut_binding In expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let Mut
##

Ill-formed mutable value declaration.
At this point, a variable is expected.
Hint: If you want "mut" as an identifier, use "@mut" instead.

interactive_expr: Begin Fun WILD ARROW Bytes SEMI
##
## Ends in an error in state: 1082.
##
## sequence -> Begin series . End [ With Verbatim VBAR UIdent Type To Then TIMES String SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Lxor Lsr Lsl Lor Let Lang Land LT LPAR LE LBRACKET LBRACE Int In Ident GT End Else EQ EOF EIdent Downto Done Do Directive Contract CONS COMMA COLON CARET Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## Begin series
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 408, spurious reduction of production call_expr_level -> core_expr
## In state 428, spurious reduction of production unary_expr_level -> call_expr_level
## In state 386, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 417, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 423, spurious reduction of production add_expr_level -> mult_expr_level
## In state 470, spurious reduction of production cons_expr_level -> add_expr_level
## In state 457, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 494, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 501, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 510, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 455, spurious reduction of production tuple_expr_level -> disj_expr_level
## In state 414, spurious reduction of production ass_expr_level -> tuple_expr_level
## In state 1014, spurious reduction of production seq_expr -> ass_expr_level
## In state 941, spurious reduction of production last_expr -> seq_expr
## In state 1050, spurious reduction of production fun_expr(last_expr) -> Fun nseq(core_irrefutable) ARROW last_expr
## In state 1026, spurious reduction of production last_expr -> fun_expr(last_expr)
## In state 1025, spurious reduction of production series -> last_expr
##

Ill-formed sequence of expressions.
At this point, if the expression is complete, one of the following is
expected:
  * a semicolon ';' followed by another expression;
  * the keyword 'end' if the sequence is complete.

interactive_expr: Begin Match UIdent With UIdent ARROW If With
##
## Ends in an error in state: 664.
##
## if_then(base_cond) -> If . expr Then base_cond [ VBAR ]
## if_then_else(base_cond) -> If . expr Then closed_expr Else base_cond [ VBAR ]
## if_then_else(seq_expr) -> If . expr Then closed_expr Else seq_expr [ SEMI End Done ]
##
## The known suffix of the stack is as follows:
## If
##
interactive_expr: If With
##
## Ends in an error in state: 280.
##
## if_then(expr) -> If . expr Then expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## if_then_else(expr) -> If . expr Then closed_expr Else expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## If
##
interactive_expr: If UIdent Then If With
##
## Ends in an error in state: 1124.
##
## if_then(expr) -> If . expr Then expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## if_then_else(closed_expr) -> If . expr Then closed_expr Else closed_expr [ Else ]
## if_then_else(expr) -> If . expr Then closed_expr Else expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## If
##
interactive_expr: Begin If UIdent Then If With
##
## Ends in an error in state: 961.
##
## if_then_else(closed_expr) -> If . expr Then closed_expr Else closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## If
##
interactive_expr: Begin If With
##
## Ends in an error in state: 954.
##
## if_then_else(seq_expr) -> If . expr Then closed_expr Else seq_expr [ SEMI End Done ]
##
## The known suffix of the stack is as follows:
## If
##
interactive_expr: Match UIdent With UIdent ARROW If With
##
## Ends in an error in state: 882.
##
## if_then(base_cond) -> If . expr Then base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## if_then_else(base_cond) -> If . expr Then closed_expr Else base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## If
##
interactive_expr: Match UIdent With UIdent ARROW If UIdent Then If With
##
## Ends in an error in state: 693.
##
## if_then(base_cond) -> If . expr Then base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## if_then_else(base_cond) -> If . expr Then closed_expr Else base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## if_then_else(closed_expr) -> If . expr Then closed_expr Else closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## If
##
interactive_expr: If UIdent Then Match UIdent With UIdent ARROW If With
##
## Ends in an error in state: 677.
##
## if_then(base_cond) -> If . expr Then base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## if_then_else(base_cond) -> If . expr Then closed_expr Else base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## if_then_else(base_if_then_else) -> If . expr Then closed_expr Else base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## If
##

Ill-formed conditional expression.
At this point, the condition is expected as an expression.

interactive_expr: If UIdent Then UIdent Else With
##
## Ends in an error in state: 1179.
##
## if_then_else(expr) -> If expr Then closed_expr Else . expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## If expr Then closed_expr Else
##
interactive_expr: Begin If UIdent Then If UIdent Then UIdent Else With
##
## Ends in an error in state: 1004.
##
## if_then_else(closed_expr) -> If expr Then closed_expr Else . closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## If expr Then closed_expr Else
##
interactive_expr: Match UIdent With UIdent ARROW If UIdent Then UIdent Else With
##
## Ends in an error in state: 886.
##
## if_then_else(base_cond) -> If expr Then closed_expr Else . base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## If expr Then closed_expr Else
##
interactive_expr: If UIdent Then Match UIdent With UIdent ARROW If UIdent Then UIdent Else With
##
## Ends in an error in state: 801.
##
## if_then_else(base_cond) -> If expr Then closed_expr Else . base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## if_then_else(base_if_then_else) -> If expr Then closed_expr Else . base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## If expr Then closed_expr Else
##
interactive_expr: Match UIdent With UIdent ARROW If UIdent Then If UIdent Then UIdent Else With
##
## Ends in an error in state: 785.
##
## if_then_else(base_cond) -> If expr Then closed_expr Else . base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## if_then_else(closed_expr) -> If expr Then closed_expr Else . closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## If expr Then closed_expr Else
##
interactive_expr: Begin Match UIdent With UIdent ARROW If UIdent Then UIdent Else With
##
## Ends in an error in state: 877.
##
## if_then_else(base_cond) -> If expr Then closed_expr Else . base_cond [ VBAR ]
## if_then_else(seq_expr) -> If expr Then closed_expr Else . seq_expr [ SEMI End Done ]
##
## The known suffix of the stack is as follows:
## If expr Then closed_expr Else
##
interactive_expr: If UIdent Then If UIdent Then UIdent Else With
##
## Ends in an error in state: 1168.
##
## if_then_else(closed_expr) -> If expr Then closed_expr Else . closed_expr [ Else ]
## if_then_else(expr) -> If expr Then closed_expr Else . expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## If expr Then closed_expr Else
##
interactive_expr: Begin If Verbatim Then Verbatim Else With
##
## Ends in an error in state: 1011.
##
## if_then_else(seq_expr) -> If expr Then closed_expr Else . seq_expr [ SEMI End Done ]
##
## The known suffix of the stack is as follows:
## If expr Then closed_expr Else
##

Ill-formed conditional expression.
At this point, the expression of the 'else' branch is expected.

interactive_expr: If UIdent Then Attr Fun Ident COLON Ident ARROW With
##
## Ends in an error in state: 1159.
##
## fun_expr(closed_expr) -> nseq(Attr) Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . closed_expr [ Else ]
## fun_expr(expr) -> nseq(Attr) Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW
##
interactive_expr: If UIdent Then Attr Fun Ident ARROW With
##
## Ends in an error in state: 1157.
##
## fun_expr(closed_expr) -> nseq(Attr) Fun nseq(core_irrefutable) ARROW . closed_expr [ Else ]
## fun_expr(expr) -> nseq(Attr) Fun nseq(core_irrefutable) ARROW . expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun nseq(core_irrefutable) ARROW
##
interactive_expr: If UIdent Then Attr Fun LPAR Type Ident RPAR Ident COLON Ident ARROW With
##
## Ends in an error in state: 1155.
##
## fun_expr(closed_expr) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . closed_expr [ Else ]
## fun_expr(expr) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW
##
interactive_expr: If UIdent Then Attr Fun LPAR Type Ident RPAR Ident ARROW With
##
## Ends in an error in state: 1153.
##
## fun_expr(closed_expr) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) ARROW . closed_expr [ Else ]
## fun_expr(expr) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) ARROW . expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) ARROW
##
interactive_expr: Begin Match UIdent With UIdent ARROW Attr Fun Ident COLON Ident ARROW With
##
## Ends in an error in state: 1070.
##
## fun_expr(base_cond) -> nseq(Attr) Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . base_cond [ VBAR ]
## fun_expr(last_expr) -> nseq(Attr) Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . last_expr [ End Done ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW
##
interactive_expr: Begin Match UIdent With UIdent ARROW Attr Fun Ident ARROW With
##
## Ends in an error in state: 1068.
##
## fun_expr(base_cond) -> nseq(Attr) Fun nseq(core_irrefutable) ARROW . base_cond [ VBAR ]
## fun_expr(last_expr) -> nseq(Attr) Fun nseq(core_irrefutable) ARROW . last_expr [ End Done ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun nseq(core_irrefutable) ARROW
##
interactive_expr: Begin Match UIdent With UIdent ARROW Attr Fun LPAR Type Ident RPAR Ident COLON Ident ARROW With
##
## Ends in an error in state: 1066.
##
## fun_expr(base_cond) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . base_cond [ VBAR ]
## fun_expr(last_expr) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . last_expr [ End Done ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW
##
interactive_expr: Begin Match UIdent With UIdent ARROW Attr Fun LPAR Type Ident RPAR Ident ARROW With
##
## Ends in an error in state: 1064.
##
## fun_expr(base_cond) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) ARROW . base_cond [ VBAR ]
## fun_expr(last_expr) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) ARROW . last_expr [ End Done ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) ARROW
##
interactive_expr: Begin Attr Fun Ident COLON Ident ARROW With
##
## Ends in an error in state: 1042.
##
## fun_expr(last_expr) -> nseq(Attr) Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . last_expr [ End Done ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW
##
interactive_expr: Begin Attr Fun Ident ARROW With
##
## Ends in an error in state: 1039.
##
## fun_expr(last_expr) -> nseq(Attr) Fun nseq(core_irrefutable) ARROW . last_expr [ End Done ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun nseq(core_irrefutable) ARROW
##
interactive_expr: Begin Attr Fun LPAR Type Ident RPAR Ident COLON Ident ARROW With
##
## Ends in an error in state: 1036.
##
## fun_expr(last_expr) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . last_expr [ End Done ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW
##
interactive_expr: Begin Attr Fun LPAR Type Ident RPAR Ident ARROW With
##
## Ends in an error in state: 1033.
##
## fun_expr(last_expr) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) ARROW . last_expr [ End Done ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) ARROW
##
interactive_expr: Begin If UIdent Then Attr Fun Ident COLON Ident ARROW With
##
## Ends in an error in state: 996.
##
## fun_expr(closed_expr) -> nseq(Attr) Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW
##
interactive_expr: Begin If UIdent Then Attr Fun Ident ARROW With
##
## Ends in an error in state: 994.
##
## fun_expr(closed_expr) -> nseq(Attr) Fun nseq(core_irrefutable) ARROW . closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun nseq(core_irrefutable) ARROW
##
interactive_expr: Begin If UIdent Then Attr Fun LPAR Type Ident RPAR Ident COLON Ident ARROW With
##
## Ends in an error in state: 992.
##
## fun_expr(closed_expr) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW
##
interactive_expr: Begin If UIdent Then Attr Fun LPAR Type Ident RPAR Ident ARROW With
##
## Ends in an error in state: 990.
##
## fun_expr(closed_expr) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) ARROW . closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) ARROW
##
interactive_expr: Match UIdent With UIdent ARROW Attr Fun Ident COLON Ident ARROW With
##
## Ends in an error in state: 919.
##
## fun_expr(base_cond) -> nseq(Attr) Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW
##
interactive_expr: Match UIdent With UIdent ARROW Attr Fun Ident ARROW With
##
## Ends in an error in state: 917.
##
## fun_expr(base_cond) -> nseq(Attr) Fun nseq(core_irrefutable) ARROW . base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun nseq(core_irrefutable) ARROW
##
interactive_expr: Match UIdent With UIdent ARROW Attr Fun LPAR Type Ident RPAR Ident COLON Ident ARROW With
##
## Ends in an error in state: 915.
##
## fun_expr(base_cond) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW
##
interactive_expr: Match UIdent With UIdent ARROW Attr Fun LPAR Type Ident RPAR Ident ARROW With
##
## Ends in an error in state: 913.
##
## fun_expr(base_cond) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) ARROW . base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) ARROW
##
interactive_expr: If UIdent Then Match UIdent With UIdent ARROW Attr Fun Ident COLON Ident ARROW With
##
## Ends in an error in state: 851.
##
## fun_expr(base_cond) -> nseq(Attr) Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(base_if_then_else) -> nseq(Attr) Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW
##
interactive_expr: If UIdent Then Match UIdent With UIdent ARROW Attr Fun Ident ARROW With
##
## Ends in an error in state: 848.
##
## fun_expr(base_cond) -> nseq(Attr) Fun nseq(core_irrefutable) ARROW . base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(base_if_then_else) -> nseq(Attr) Fun nseq(core_irrefutable) ARROW . base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun nseq(core_irrefutable) ARROW
##
interactive_expr: If UIdent Then Match UIdent With UIdent ARROW Attr Fun LPAR Type Ident RPAR Ident COLON Ident ARROW With
##
## Ends in an error in state: 845.
##
## fun_expr(base_cond) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(base_if_then_else) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW
##
interactive_expr: If UIdent Then Match UIdent With UIdent ARROW Attr Fun LPAR Type Ident RPAR Ident ARROW With
##
## Ends in an error in state: 842.
##
## fun_expr(base_cond) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) ARROW . base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(base_if_then_else) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) ARROW . base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) ARROW
##
interactive_expr: Attr Fun LPAR Type Ident RPAR Ident ARROW With
##
## Ends in an error in state: 618.
##
## fun_expr(expr) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) ARROW . expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) ARROW
##
interactive_expr: Attr Fun LPAR Type Ident RPAR Ident COLON Ident ARROW With
##
## Ends in an error in state: 621.
##
## fun_expr(expr) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW
##
interactive_expr: Attr Fun Ident ARROW With
##
## Ends in an error in state: 626.
##
## fun_expr(expr) -> nseq(Attr) Fun nseq(core_irrefutable) ARROW . expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun nseq(core_irrefutable) ARROW
##
interactive_expr: Attr Fun Ident COLON Ident ARROW With
##
## Ends in an error in state: 629.
##
## fun_expr(expr) -> nseq(Attr) Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW
##
interactive_expr: Match UIdent With UIdent ARROW If UIdent Then Attr Fun LPAR Type Ident RPAR Ident ARROW With
##
## Ends in an error in state: 753.
##
## fun_expr(base_cond) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) ARROW . base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(closed_expr) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) ARROW . closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) ARROW
##
interactive_expr: Match UIdent With UIdent ARROW If UIdent Then Attr Fun LPAR Type Ident RPAR Ident COLON Ident ARROW With
##
## Ends in an error in state: 757.
##
## fun_expr(base_cond) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(closed_expr) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW
##
interactive_expr: Match UIdent With UIdent ARROW If UIdent Then Attr Fun Ident ARROW With
##
## Ends in an error in state: 761.
##
## fun_expr(base_cond) -> nseq(Attr) Fun nseq(core_irrefutable) ARROW . base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(closed_expr) -> nseq(Attr) Fun nseq(core_irrefutable) ARROW . closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun nseq(core_irrefutable) ARROW
##
interactive_expr: Match UIdent With UIdent ARROW If UIdent Then Attr Fun Ident COLON Ident ARROW With
##
## Ends in an error in state: 765.
##
## fun_expr(base_cond) -> nseq(Attr) Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(closed_expr) -> nseq(Attr) Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW
##
interactive_expr: Begin Match Verbatim With WILD ARROW Fun WILD ARROW With
##
## Ends in an error in state: 1074.
##
## fun_expr(base_cond) -> Fun nseq(core_irrefutable) ARROW . base_cond [ VBAR ]
## fun_expr(last_expr) -> Fun nseq(core_irrefutable) ARROW . last_expr [ End Done ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable) ARROW
##
interactive_expr: Fun Ident ARROW With
##
## Ends in an error in state: 1103.
##
## fun_expr(expr) -> Fun nseq(core_irrefutable) ARROW . expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable) ARROW
##
interactive_expr: Match UIdent With UIdent ARROW If UIdent Then Fun Ident ARROW With
##
## Ends in an error in state: 777.
##
## fun_expr(base_cond) -> Fun nseq(core_irrefutable) ARROW . base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(closed_expr) -> Fun nseq(core_irrefutable) ARROW . closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable) ARROW
##
interactive_expr: If UIdent Then Match UIdent With UIdent ARROW Fun Ident ARROW With
##
## Ends in an error in state: 859.
##
## fun_expr(base_cond) -> Fun nseq(core_irrefutable) ARROW . base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(base_if_then_else) -> Fun nseq(core_irrefutable) ARROW . base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable) ARROW
##
interactive_expr: Match UIdent With UIdent ARROW Fun Ident ARROW With
##
## Ends in an error in state: 923.
##
## fun_expr(base_cond) -> Fun nseq(core_irrefutable) ARROW . base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable) ARROW
##
interactive_expr: Begin If UIdent Then Fun Ident ARROW With
##
## Ends in an error in state: 1000.
##
## fun_expr(closed_expr) -> Fun nseq(core_irrefutable) ARROW . closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable) ARROW
##
interactive_expr: Begin Fun Ident ARROW With
##
## Ends in an error in state: 1049.
##
## fun_expr(last_expr) -> Fun nseq(core_irrefutable) ARROW . last_expr [ End Done ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable) ARROW
##
interactive_expr: If UIdent Then Fun Ident ARROW With
##
## Ends in an error in state: 1163.
##
## fun_expr(closed_expr) -> Fun nseq(core_irrefutable) ARROW . closed_expr [ Else ]
## fun_expr(expr) -> Fun nseq(core_irrefutable) ARROW . expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable) ARROW
##
interactive_expr: Fun LPAR Type Ident RPAR Ident ARROW With
##
## Ends in an error in state: 315.
##
## fun_expr(expr) -> Fun par(type_param_list) nseq(core_irrefutable) ARROW . expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun par(type_param_list) nseq(core_irrefutable) ARROW
##
interactive_expr: Match UIdent With UIdent ARROW If UIdent Then Fun LPAR Type Ident RPAR Ident ARROW With
##
## Ends in an error in state: 699.
##
## fun_expr(base_cond) -> Fun par(type_param_list) nseq(core_irrefutable) ARROW . base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(closed_expr) -> Fun par(type_param_list) nseq(core_irrefutable) ARROW . closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Fun par(type_param_list) nseq(core_irrefutable) ARROW
##
interactive_expr: Match UIdent With UIdent ARROW If UIdent Then Fun LPAR Type Ident RPAR Ident COLON Ident ARROW With
##
## Ends in an error in state: 773.
##
## fun_expr(base_cond) -> Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(closed_expr) -> Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW
##
interactive_expr: Match UIdent With UIdent ARROW If UIdent Then Fun Ident COLON Ident ARROW With
##
## Ends in an error in state: 781.
##
## fun_expr(base_cond) -> Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(closed_expr) -> Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW
##
interactive_expr: If UIdent Then Match UIdent With UIdent ARROW Fun LPAR Type Ident RPAR Ident ARROW With
##
## Ends in an error in state: 805.
##
## fun_expr(base_cond) -> Fun par(type_param_list) nseq(core_irrefutable) ARROW . base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(base_if_then_else) -> Fun par(type_param_list) nseq(core_irrefutable) ARROW . base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## Fun par(type_param_list) nseq(core_irrefutable) ARROW
##
interactive_expr: If UIdent Then Match UIdent With UIdent ARROW Fun LPAR Type Ident RPAR Ident COLON Ident ARROW With
##
## Ends in an error in state: 856.
##
## fun_expr(base_cond) -> Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(base_if_then_else) -> Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW
##
interactive_expr: If UIdent Then Match UIdent With UIdent ARROW Fun Ident COLON Ident ARROW With
##
## Ends in an error in state: 862.
##
## fun_expr(base_cond) -> Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(base_if_then_else) -> Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW
##
interactive_expr: Match UIdent With UIdent ARROW Fun LPAR Type Ident RPAR Ident ARROW With
##
## Ends in an error in state: 890.
##
## fun_expr(base_cond) -> Fun par(type_param_list) nseq(core_irrefutable) ARROW . base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun par(type_param_list) nseq(core_irrefutable) ARROW
##
interactive_expr: Match UIdent With UIdent ARROW Fun LPAR Type Ident RPAR Ident COLON Ident ARROW With
##
## Ends in an error in state: 921.
##
## fun_expr(base_cond) -> Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW
##
interactive_expr: Match UIdent With UIdent ARROW Fun Ident COLON Ident ARROW With
##
## Ends in an error in state: 925.
##
## fun_expr(base_cond) -> Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW
##
interactive_expr: Begin Match UIdent With UIdent ARROW Fun LPAR Type Ident RPAR Ident ARROW With
##
## Ends in an error in state: 939.
##
## fun_expr(base_cond) -> Fun par(type_param_list) nseq(core_irrefutable) ARROW . base_cond [ VBAR ]
## fun_expr(last_expr) -> Fun par(type_param_list) nseq(core_irrefutable) ARROW . last_expr [ End Done ]
##
## The known suffix of the stack is as follows:
## Fun par(type_param_list) nseq(core_irrefutable) ARROW
##
interactive_expr: Begin If UIdent Then Fun LPAR Type Ident RPAR Ident ARROW With
##
## Ends in an error in state: 967.
##
## fun_expr(closed_expr) -> Fun par(type_param_list) nseq(core_irrefutable) ARROW . closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Fun par(type_param_list) nseq(core_irrefutable) ARROW
##
interactive_expr: Begin If UIdent Then Fun LPAR Type Ident RPAR Ident COLON Ident ARROW With
##
## Ends in an error in state: 998.
##
## fun_expr(closed_expr) -> Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW
##
interactive_expr: Begin If UIdent Then Fun Ident COLON Ident ARROW With
##
## Ends in an error in state: 1002.
##
## fun_expr(closed_expr) -> Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW
##
interactive_expr: Begin Fun LPAR Type Ident RPAR Ident ARROW With
##
## Ends in an error in state: 1018.
##
## fun_expr(last_expr) -> Fun par(type_param_list) nseq(core_irrefutable) ARROW . last_expr [ End Done ]
##
## The known suffix of the stack is as follows:
## Fun par(type_param_list) nseq(core_irrefutable) ARROW
##
interactive_expr: Begin Fun LPAR Type Ident RPAR Ident COLON Ident ARROW With
##
## Ends in an error in state: 1046.
##
## fun_expr(last_expr) -> Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . last_expr [ End Done ]
##
## The known suffix of the stack is as follows:
## Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW
##
interactive_expr: Begin Fun Ident COLON Ident ARROW With
##
## Ends in an error in state: 1052.
##
## fun_expr(last_expr) -> Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . last_expr [ End Done ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW
##
interactive_expr: Begin Match UIdent With UIdent ARROW Fun LPAR Type Ident RPAR Ident COLON Ident ARROW With
##
## Ends in an error in state: 1072.
##
## fun_expr(base_cond) -> Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . base_cond [ VBAR ]
## fun_expr(last_expr) -> Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . last_expr [ End Done ]
##
## The known suffix of the stack is as follows:
## Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW
##
interactive_expr: Begin Match UIdent With UIdent ARROW Fun Ident COLON Ident ARROW With
##
## Ends in an error in state: 1076.
##
## fun_expr(base_cond) -> Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . base_cond [ VBAR ]
## fun_expr(last_expr) -> Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . last_expr [ End Done ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW
##
interactive_expr: Fun LPAR Type Ident RPAR Ident COLON Ident ARROW With
##
## Ends in an error in state: 1100.
##
## fun_expr(expr) -> Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW
##
interactive_expr: Fun Ident COLON Ident ARROW With
##
## Ends in an error in state: 1106.
##
## fun_expr(expr) -> Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW
##
interactive_expr: If UIdent Then Fun LPAR Type Ident RPAR Ident ARROW With
##
## Ends in an error in state: 1130.
##
## fun_expr(closed_expr) -> Fun par(type_param_list) nseq(core_irrefutable) ARROW . closed_expr [ Else ]
## fun_expr(expr) -> Fun par(type_param_list) nseq(core_irrefutable) ARROW . expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun par(type_param_list) nseq(core_irrefutable) ARROW
##
interactive_expr: If UIdent Then Fun LPAR Type Ident RPAR Ident COLON Ident ARROW With
##
## Ends in an error in state: 1161.
##
## fun_expr(closed_expr) -> Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . closed_expr [ Else ]
## fun_expr(expr) -> Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW
##
interactive_expr: If UIdent Then Fun Ident COLON Ident ARROW With
##
## Ends in an error in state: 1165.
##
## fun_expr(closed_expr) -> Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . closed_expr [ Else ]
## fun_expr(expr) -> Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW
##

Ill-formed functional expression.
At this point, the body of the function is expected as an expression.

interactive_expr: If Verbatim Then Match Verbatim With WILD ARROW With
##
## Ends in an error in state: 672.
##
## case_clause(base_cond) -> pattern ARROW . base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## case_clause(base_if_then_else) -> pattern ARROW . base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## pattern ARROW
##
interactive_expr: Begin Match UIdent With UIdent ARROW With
##
## Ends in an error in state: 648.
##
## case_clause(base_cond) -> pattern ARROW . base_cond [ VBAR ]
## case_clause(last_expr) -> pattern ARROW . last_expr [ End Done ]
##
## The known suffix of the stack is as follows:
## pattern ARROW
##
interactive_expr: Match UIdent With UIdent ARROW With
##
## Ends in an error in state: 1252.
##
## case_clause(base_cond) -> pattern ARROW . base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## pattern ARROW
##

Ill-formed pattern matching.
At this point, the right-hand side of the current clause is expected
as an expression.

interactive_expr: Begin With
##
## Ends in an error in state: 381.
##
## sequence -> Begin . End [ With Verbatim VBAR UIdent Type To Then TIMES String SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Lxor Lsr Lsl Lor Let Lang Land LT LPAR LE LBRACKET LBRACE Int In Ident GT End Else EQ EOF EIdent Downto Done Do Directive Contract CONS COMMA COLON CARET Bytes Begin BOOL_OR BOOL_AND Attr ]
## sequence -> Begin . series End [ With Verbatim VBAR UIdent Type To Then TIMES String SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Lxor Lsr Lsl Lor Let Lang Land LT LPAR LE LBRACKET LBRACE Int In Ident GT End Else EQ EOF EIdent Downto Done Do Directive Contract CONS COMMA COLON CARET Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## Begin
##

Ill-formed sequence of expressions.
At this point, one of the following is expected:
  * an expression;
  * the keyword 'end' if the sequence is empty.

interactive_expr: Begin If Verbatim Then With
##
## Ends in an error in state: 956.
##
## if_then_else(seq_expr) -> If expr Then . closed_expr Else seq_expr [ SEMI End Done ]
##
## The known suffix of the stack is as follows:
## If expr Then
##
interactive_expr: If Verbatim Then With
##
## Ends in an error in state: 1109.
##
## if_then(expr) -> If expr Then . expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## if_then_else(expr) -> If expr Then . closed_expr Else expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## If expr Then
##
interactive_expr: Match Verbatim With WILD ARROW If Verbatim Then With
##
## Ends in an error in state: 884.
##
## if_then(base_cond) -> If expr Then . base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## if_then_else(base_cond) -> If expr Then . closed_expr Else base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## If expr Then
##
interactive_expr: Begin Match UIdent With UIdent ARROW If UIdent Then With
##
## Ends in an error in state: 666.
##
## if_then(base_cond) -> If expr Then . base_cond [ VBAR ]
## if_then_else(base_cond) -> If expr Then . closed_expr Else base_cond [ VBAR ]
## if_then_else(seq_expr) -> If expr Then . closed_expr Else seq_expr [ SEMI End Done ]
##
## The known suffix of the stack is as follows:
## If expr Then
##
interactive_expr: If UIdent Then Match UIdent With UIdent ARROW If UIdent Then With
##
## Ends in an error in state: 679.
##
## if_then(base_cond) -> If expr Then . base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## if_then_else(base_cond) -> If expr Then . closed_expr Else base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## if_then_else(base_if_then_else) -> If expr Then . closed_expr Else base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## If expr Then
##
interactive_expr: Match UIdent With UIdent ARROW If UIdent Then If UIdent Then With
##
## Ends in an error in state: 695.
##
## if_then(base_cond) -> If expr Then . base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## if_then_else(base_cond) -> If expr Then . closed_expr Else base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## if_then_else(closed_expr) -> If expr Then . closed_expr Else closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## If expr Then
##
interactive_expr: Begin If UIdent Then If UIdent Then With
##
## Ends in an error in state: 963.
##
## if_then_else(closed_expr) -> If expr Then . closed_expr Else closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## If expr Then
##
interactive_expr: If UIdent Then If UIdent Then With
##
## Ends in an error in state: 1126.
##
## if_then(expr) -> If expr Then . expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## if_then_else(closed_expr) -> If expr Then . closed_expr Else closed_expr [ Else ]
## if_then_else(expr) -> If expr Then . closed_expr Else expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## If expr Then
##

Ill-formed conditional expression.
At this point, the 'then' branch is expected as an expression.

interactive_expr: Let Mut Ident EQ Bytes In ZWSP
##
## Ends in an error in state: 1232.
##
## let_mut_in_expr(expr) -> Let Mut let_mut_binding In . expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let Mut let_mut_binding In
##
interactive_expr: If Bytes Then Let Mut Ident EQ Bytes In ZWSP
##
## Ends in an error in state: 1173.
##
## let_mut_in_expr(closed_expr) -> Let Mut let_mut_binding In . closed_expr [ Else ]
## let_mut_in_expr(expr) -> Let Mut let_mut_binding In . expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let Mut let_mut_binding In
##
interactive_expr: If Bytes Then Attr Let Mut Ident EQ Bytes In ZWSP
##
## Ends in an error in state: 1147.
##
## let_mut_in_expr(closed_expr) -> nseq(Attr) Let Mut let_mut_binding In . closed_expr [ Else ]
## let_mut_in_expr(expr) -> nseq(Attr) Let Mut let_mut_binding In . expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let Mut let_mut_binding In
##
interactive_expr: Begin If Bytes Then Let Mut Ident EQ Bytes In ZWSP
##
## Ends in an error in state: 1007.
##
## let_mut_in_expr(closed_expr) -> Let Mut let_mut_binding In . closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Let Mut let_mut_binding In
##
interactive_expr: Begin If Bytes Then Attr Let Mut Ident EQ Bytes In ZWSP
##
## Ends in an error in state: 984.
##
## let_mut_in_expr(closed_expr) -> nseq(Attr) Let Mut let_mut_binding In . closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let Mut let_mut_binding In
##
interactive_expr: Match Bytes With UIdent ARROW Let Mut Ident EQ Bytes In ZWSP
##
## Ends in an error in state: 928.
##
## let_mut_in_expr(base_cond) -> Let Mut let_mut_binding In . base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let Mut let_mut_binding In
##
interactive_expr: Match Bytes With UIdent ARROW Attr Let Mut Ident EQ Bytes In ZWSP
##
## Ends in an error in state: 907.
##
## let_mut_in_expr(base_cond) -> nseq(Attr) Let Mut let_mut_binding In . base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let Mut let_mut_binding In
##
interactive_expr: If Bytes Then Match Bytes With UIdent ARROW Let Mut Ident EQ Bytes In ZWSP
##
## Ends in an error in state: 868.
##
## let_mut_in_expr(base_cond) -> Let Mut let_mut_binding In . base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## let_mut_in_expr(base_if_then_else) -> Let Mut let_mut_binding In . base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## Let Mut let_mut_binding In
##
interactive_expr: If Bytes Then Match Bytes With UIdent ARROW Attr Let Mut Ident EQ Bytes In ZWSP
##
## Ends in an error in state: 834.
##
## let_mut_in_expr(base_cond) -> nseq(Attr) Let Mut let_mut_binding In . base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## let_mut_in_expr(base_if_then_else) -> nseq(Attr) Let Mut let_mut_binding In . base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let Mut let_mut_binding In
##
interactive_expr: Match Bytes With UIdent ARROW If Bytes Then Let Mut Ident EQ Bytes In ZWSP
##
## Ends in an error in state: 793.
##
## let_mut_in_expr(base_cond) -> Let Mut let_mut_binding In . base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## let_mut_in_expr(closed_expr) -> Let Mut let_mut_binding In . closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Let Mut let_mut_binding In
##
interactive_expr: Match Bytes With UIdent ARROW If Bytes Then Attr Let Mut Ident EQ Bytes In ZWSP
##
## Ends in an error in state: 743.
##
## let_mut_in_expr(base_cond) -> nseq(Attr) Let Mut let_mut_binding In . base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## let_mut_in_expr(closed_expr) -> nseq(Attr) Let Mut let_mut_binding In . closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let Mut let_mut_binding In
##
interactive_expr: Attr Let Mut Ident EQ Bytes In ZWSP
##
## Ends in an error in state: 610.
##
## let_mut_in_expr(expr) -> nseq(Attr) Let Mut let_mut_binding In . expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let Mut let_mut_binding In
##
interactive_expr: Begin Attr Let Rec Ident EQ UIdent In With
##
## Ends in an error in state: 1023.
##
## let_in_sequence -> nseq(Attr) Let Rec let_binding In . series [ End Done ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let Rec let_binding In
##
interactive_expr: Begin If UIdent Then Attr Let Rec Ident EQ UIdent In With
##
## Ends in an error in state: 975.
##
## let_in_expr(closed_expr) -> nseq(Attr) Let Rec let_binding In . closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let Rec let_binding In
##
interactive_expr: Begin If UIdent Then Let Rec Ident EQ UIdent In With
##
## Ends in an error in state: 960.
##
## let_in_expr(closed_expr) -> Let Rec let_binding In . closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Let Rec let_binding In
##
interactive_expr: Begin Attr Let Ident EQ UIdent In With
##
## Ends in an error in state: 1028.
##
## let_in_sequence -> nseq(Attr) Let let_binding In . series [ End Done ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let let_binding In
##
interactive_expr: Begin Let Ident EQ UIdent In With
##
## Ends in an error in state: 1056.
##
## let_in_sequence -> Let let_binding In . series [ End Done ]
##
## The known suffix of the stack is as follows:
## Let let_binding In
##
interactive_expr: Begin Match UIdent With UIdent ARROW Attr Let Ident EQ UIdent In With
##
## Ends in an error in state: 1060.
##
## let_in_expr(base_cond) -> nseq(Attr) Let let_binding In . base_cond [ VBAR ]
## let_in_sequence -> nseq(Attr) Let let_binding In . series [ End Done ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let let_binding In
##
interactive_expr: Begin Match UIdent With UIdent ARROW Let Ident EQ UIdent In With
##
## Ends in an error in state: 1078.
##
## let_in_expr(base_cond) -> Let let_binding In . base_cond [ VBAR ]
## let_in_sequence -> Let let_binding In . series [ End Done ]
##
## The known suffix of the stack is as follows:
## Let let_binding In
##
interactive_expr: If UIdent Then Let Rec Ident EQ UIdent In With
##
## Ends in an error in state: 1123.
##
## let_in_expr(closed_expr) -> Let Rec let_binding In . closed_expr [ Else ]
## let_in_expr(expr) -> Let Rec let_binding In . expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let Rec let_binding In
##
interactive_expr: If UIdent Then Attr Let Rec Ident EQ UIdent In With
##
## Ends in an error in state: 1138.
##
## let_in_expr(closed_expr) -> nseq(Attr) Let Rec let_binding In . closed_expr [ Else ]
## let_in_expr(expr) -> nseq(Attr) Let Rec let_binding In . expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let Rec let_binding In
##
interactive_expr: If UIdent Then Attr Let Ident EQ UIdent In With
##
## Ends in an error in state: 1149.
##
## let_in_expr(closed_expr) -> nseq(Attr) Let let_binding In . closed_expr [ Else ]
## let_in_expr(expr) -> nseq(Attr) Let let_binding In . expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let let_binding In
##
interactive_expr: If UIdent Then Let Ident EQ UIdent In With
##
## Ends in an error in state: 1176.
##
## let_in_expr(closed_expr) -> Let let_binding In . closed_expr [ Else ]
## let_in_expr(expr) -> Let let_binding In . expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let let_binding In
##
interactive_expr: Let Ident EQ UIdent In With
##
## Ends in an error in state: 1234.
##
## let_in_expr(expr) -> Let let_binding In . expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let let_binding In
##
interactive_expr: Begin If UIdent Then Attr Let Ident EQ UIdent In With
##
## Ends in an error in state: 986.
##
## let_in_expr(closed_expr) -> nseq(Attr) Let let_binding In . closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let let_binding In
##
interactive_expr: Begin If UIdent Then Let Ident EQ UIdent In With
##
## Ends in an error in state: 1009.
##
## let_in_expr(closed_expr) -> Let let_binding In . closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Let let_binding In
##
interactive_expr: Match Verbatim With WILD ARROW Let WILD EQ Bytes In With
##
## Ends in an error in state: 930.
##
## let_in_expr(base_cond) -> Let let_binding In . base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let let_binding In
##
interactive_expr: Let Rec Ident EQ UIdent In With
##
## Ends in an error in state: 1229.
##
## let_in_expr(expr) -> Let Rec let_binding In . expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let Rec let_binding In
##
interactive_expr: Attr Let Rec Ident EQ UIdent In With
##
## Ends in an error in state: 587.
##
## let_in_expr(expr) -> nseq(Attr) Let Rec let_binding In . expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let Rec let_binding In
##
interactive_expr: Attr Let Ident EQ UIdent In With
##
## Ends in an error in state: 613.
##
## let_in_expr(expr) -> nseq(Attr) Let let_binding In . expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let let_binding In
##
interactive_expr: Begin Match UIdent With UIdent ARROW Let Rec Ident EQ UIdent In With
##
## Ends in an error in state: 663.
##
## let_in_expr(base_cond) -> Let Rec let_binding In . base_cond [ VBAR ]
## let_in_sequence -> Let Rec let_binding In . series [ End Done ]
##
## The known suffix of the stack is as follows:
## Let Rec let_binding In
##
interactive_expr: If UIdent Then Match UIdent With UIdent ARROW Let Rec Ident EQ UIdent In With
##
## Ends in an error in state: 676.
##
## let_in_expr(base_cond) -> Let Rec let_binding In . base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## let_in_expr(base_if_then_else) -> Let Rec let_binding In . base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## Let Rec let_binding In
##
interactive_expr: Match UIdent With UIdent ARROW If UIdent Then Let Rec Ident EQ UIdent In With
##
## Ends in an error in state: 692.
##
## let_in_expr(base_cond) -> Let Rec let_binding In . base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## let_in_expr(closed_expr) -> Let Rec let_binding In . closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Let Rec let_binding In
##
interactive_expr: Match UIdent With UIdent ARROW If UIdent Then Attr Let Rec Ident EQ UIdent In With
##
## Ends in an error in state: 708.
##
## let_in_expr(base_cond) -> nseq(Attr) Let Rec let_binding In . base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## let_in_expr(closed_expr) -> nseq(Attr) Let Rec let_binding In . closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let Rec let_binding In
##
interactive_expr: Match UIdent With UIdent ARROW If UIdent Then Attr Let Ident EQ UIdent In With
##
## Ends in an error in state: 747.
##
## let_in_expr(base_cond) -> nseq(Attr) Let let_binding In . base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## let_in_expr(closed_expr) -> nseq(Attr) Let let_binding In . closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let let_binding In
##
interactive_expr: Match UIdent With UIdent ARROW If UIdent Then Let Ident EQ UIdent In With
##
## Ends in an error in state: 797.
##
## let_in_expr(base_cond) -> Let let_binding In . base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## let_in_expr(closed_expr) -> Let let_binding In . closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Let let_binding In
##
interactive_expr: If UIdent Then Match UIdent With UIdent ARROW Attr Let Rec Ident EQ UIdent In With
##
## Ends in an error in state: 813.
##
## let_in_expr(base_cond) -> nseq(Attr) Let Rec let_binding In . base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## let_in_expr(base_if_then_else) -> nseq(Attr) Let Rec let_binding In . base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let Rec let_binding In
##
interactive_expr: If UIdent Then Match UIdent With UIdent ARROW Attr Let Ident EQ UIdent In With
##
## Ends in an error in state: 837.
##
## let_in_expr(base_cond) -> nseq(Attr) Let let_binding In . base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## let_in_expr(base_if_then_else) -> nseq(Attr) Let let_binding In . base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let let_binding In
##
interactive_expr: If UIdent Then Match UIdent With UIdent ARROW Let Ident EQ UIdent In With
##
## Ends in an error in state: 871.
##
## let_in_expr(base_cond) -> Let let_binding In . base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## let_in_expr(base_if_then_else) -> Let let_binding In . base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## Let let_binding In
##
interactive_expr: Match UIdent With UIdent ARROW Let Rec Ident EQ UIdent In With
##
## Ends in an error in state: 881.
##
## let_in_expr(base_cond) -> Let Rec let_binding In . base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let Rec let_binding In
##
interactive_expr: Match UIdent With UIdent ARROW Attr Let Rec Ident EQ UIdent In With
##
## Ends in an error in state: 898.
##
## let_in_expr(base_cond) -> nseq(Attr) Let Rec let_binding In . base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let Rec let_binding In
##
interactive_expr: Match UIdent With UIdent ARROW Attr Let Ident EQ UIdent In With
##
## Ends in an error in state: 909.
##
## let_in_expr(base_cond) -> nseq(Attr) Let let_binding In . base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let let_binding In
##
interactive_expr: Begin Match UIdent With UIdent ARROW Attr Let Rec Ident EQ UIdent In With
##
## Ends in an error in state: 946.
##
## let_in_expr(base_cond) -> nseq(Attr) Let Rec let_binding In . base_cond [ VBAR ]
## let_in_sequence -> nseq(Attr) Let Rec let_binding In . series [ End Done ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let Rec let_binding In
##
interactive_expr: Begin Let Rec Ident EQ UIdent In With
##
## Ends in an error in state: 953.
##
## let_in_sequence -> Let Rec let_binding In . series [ End Done ]
##
## The known suffix of the stack is as follows:
## Let Rec let_binding In
##

Ill-formed local value declaration.
At this point, an expression is expected.

interactive_expr: With
##
## Ends in an error in state: 0.
##
## interactive_expr' -> . interactive_expr [ # ]
##
## The known suffix of the stack is as follows:
##
##

Ill-formed expression.
At this point, an expression is expected.

program: With
##
## Ends in an error in state: 1363.
##
## program' -> . program [ # ]
##
## The known suffix of the stack is as follows:
##
##

Ill-formed program.
At this point, a declaration is expected.

interactive_expr: Begin If Verbatim Then If Verbatim Then Verbatim COMMA Bytes With
##
## Ends in an error in state: 1003.
##
## if_then_else(closed_expr) -> If expr Then closed_expr . Else closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## If expr Then closed_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 408, spurious reduction of production call_expr_level -> core_expr
## In state 428, spurious reduction of production unary_expr_level -> call_expr_level
## In state 386, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 417, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 423, spurious reduction of production add_expr_level -> mult_expr_level
## In state 470, spurious reduction of production cons_expr_level -> add_expr_level
## In state 457, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 494, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 501, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 510, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 507, spurious reduction of production nsepseq(disj_expr_level,COMMA) -> disj_expr_level
## In state 506, spurious reduction of production tuple(disj_expr_level) -> disj_expr_level COMMA nsepseq(disj_expr_level,COMMA)
## In state 415, spurious reduction of production tuple_expr_level -> tuple(disj_expr_level)
## In state 414, spurious reduction of production ass_expr_level -> tuple_expr_level
## In state 981, spurious reduction of production base_expr(closed_expr) -> ass_expr_level
## In state 732, spurious reduction of production base_if_then_else__open(closed_expr) -> base_expr(closed_expr)
## In state 731, spurious reduction of production closed_expr -> base_if_then_else__open(closed_expr)
##
interactive_expr: Begin If Verbatim Then Verbatim With
##
## Ends in an error in state: 1010.
##
## if_then_else(seq_expr) -> If expr Then closed_expr . Else seq_expr [ SEMI End Done ]
##
## The known suffix of the stack is as follows:
## If expr Then closed_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 408, spurious reduction of production call_expr_level -> core_expr
## In state 428, spurious reduction of production unary_expr_level -> call_expr_level
## In state 386, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 417, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 423, spurious reduction of production add_expr_level -> mult_expr_level
## In state 470, spurious reduction of production cons_expr_level -> add_expr_level
## In state 457, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 494, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 501, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 510, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 455, spurious reduction of production tuple_expr_level -> disj_expr_level
## In state 414, spurious reduction of production ass_expr_level -> tuple_expr_level
## In state 981, spurious reduction of production base_expr(closed_expr) -> ass_expr_level
## In state 732, spurious reduction of production base_if_then_else__open(closed_expr) -> base_expr(closed_expr)
## In state 731, spurious reduction of production closed_expr -> base_if_then_else__open(closed_expr)
##
interactive_expr: If Verbatim Then If Verbatim Then Verbatim VBAR
##
## Ends in an error in state: 1167.
##
## if_then_else(closed_expr) -> If expr Then closed_expr . Else closed_expr [ Else ]
## if_then_else(expr) -> If expr Then closed_expr . Else expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## If expr Then closed_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 408, spurious reduction of production call_expr_level -> core_expr
## In state 428, spurious reduction of production unary_expr_level -> call_expr_level
## In state 386, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 417, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 423, spurious reduction of production add_expr_level -> mult_expr_level
## In state 470, spurious reduction of production cons_expr_level -> add_expr_level
## In state 457, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 494, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 501, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 510, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 455, spurious reduction of production tuple_expr_level -> disj_expr_level
## In state 414, spurious reduction of production ass_expr_level -> tuple_expr_level
## In state 1144, spurious reduction of production base_expr(closed_expr) -> ass_expr_level
## In state 732, spurious reduction of production base_if_then_else__open(closed_expr) -> base_expr(closed_expr)
## In state 731, spurious reduction of production closed_expr -> base_if_then_else__open(closed_expr)
##
interactive_expr: If Verbatim Then Verbatim VBAR
##
## Ends in an error in state: 1178.
##
## if_then_else(expr) -> If expr Then closed_expr . Else expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## If expr Then closed_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 408, spurious reduction of production call_expr_level -> core_expr
## In state 428, spurious reduction of production unary_expr_level -> call_expr_level
## In state 386, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 417, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 423, spurious reduction of production add_expr_level -> mult_expr_level
## In state 470, spurious reduction of production cons_expr_level -> add_expr_level
## In state 457, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 494, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 501, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 510, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 455, spurious reduction of production tuple_expr_level -> disj_expr_level
## In state 414, spurious reduction of production ass_expr_level -> tuple_expr_level
## In state 1144, spurious reduction of production base_expr(closed_expr) -> ass_expr_level
## In state 732, spurious reduction of production base_if_then_else__open(closed_expr) -> base_expr(closed_expr)
## In state 731, spurious reduction of production closed_expr -> base_if_then_else__open(closed_expr)
##
interactive_expr: Match Verbatim With WILD ARROW If Verbatim Then Verbatim WILD
##
## Ends in an error in state: 885.
##
## if_then_else(base_cond) -> If expr Then closed_expr . Else base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## If expr Then closed_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 408, spurious reduction of production call_expr_level -> core_expr
## In state 428, spurious reduction of production unary_expr_level -> call_expr_level
## In state 386, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 417, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 423, spurious reduction of production add_expr_level -> mult_expr_level
## In state 470, spurious reduction of production cons_expr_level -> add_expr_level
## In state 457, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 494, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 501, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 510, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 455, spurious reduction of production tuple_expr_level -> disj_expr_level
## In state 414, spurious reduction of production ass_expr_level -> tuple_expr_level
## In state 736, spurious reduction of production base_expr(closed_expr) -> ass_expr_level
## In state 732, spurious reduction of production base_if_then_else__open(closed_expr) -> base_expr(closed_expr)
## In state 731, spurious reduction of production closed_expr -> base_if_then_else__open(closed_expr)
##
interactive_expr: If Bytes Then Match Bytes With UIdent ARROW If Bytes Then Bytes COMMA Ident ZWSP
##
## Ends in an error in state: 800.
##
## if_then_else(base_cond) -> If expr Then closed_expr . Else base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## if_then_else(base_if_then_else) -> If expr Then closed_expr . Else base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## If expr Then closed_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 404, spurious reduction of production core_expr -> gen_ident
## In state 408, spurious reduction of production call_expr_level -> core_expr
## In state 428, spurious reduction of production unary_expr_level -> call_expr_level
## In state 386, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 417, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 423, spurious reduction of production add_expr_level -> mult_expr_level
## In state 470, spurious reduction of production cons_expr_level -> add_expr_level
## In state 457, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 494, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 501, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 510, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 507, spurious reduction of production nsepseq(disj_expr_level,COMMA) -> disj_expr_level
## In state 506, spurious reduction of production tuple(disj_expr_level) -> disj_expr_level COMMA nsepseq(disj_expr_level,COMMA)
## In state 415, spurious reduction of production tuple_expr_level -> tuple(disj_expr_level)
## In state 414, spurious reduction of production ass_expr_level -> tuple_expr_level
## In state 736, spurious reduction of production base_expr(closed_expr) -> ass_expr_level
## In state 732, spurious reduction of production base_if_then_else__open(closed_expr) -> base_expr(closed_expr)
## In state 731, spurious reduction of production closed_expr -> base_if_then_else__open(closed_expr)
##
interactive_expr: Match Bytes With UIdent ARROW If Bytes Then If Bytes Then Bytes COMMA Ident ZWSP
##
## Ends in an error in state: 784.
##
## if_then_else(base_cond) -> If expr Then closed_expr . Else base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## if_then_else(closed_expr) -> If expr Then closed_expr . Else closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## If expr Then closed_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 404, spurious reduction of production core_expr -> gen_ident
## In state 408, spurious reduction of production call_expr_level -> core_expr
## In state 428, spurious reduction of production unary_expr_level -> call_expr_level
## In state 386, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 417, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 423, spurious reduction of production add_expr_level -> mult_expr_level
## In state 470, spurious reduction of production cons_expr_level -> add_expr_level
## In state 457, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 494, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 501, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 510, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 507, spurious reduction of production nsepseq(disj_expr_level,COMMA) -> disj_expr_level
## In state 506, spurious reduction of production tuple(disj_expr_level) -> disj_expr_level COMMA nsepseq(disj_expr_level,COMMA)
## In state 415, spurious reduction of production tuple_expr_level -> tuple(disj_expr_level)
## In state 414, spurious reduction of production ass_expr_level -> tuple_expr_level
## In state 736, spurious reduction of production base_expr(closed_expr) -> ass_expr_level
## In state 732, spurious reduction of production base_if_then_else__open(closed_expr) -> base_expr(closed_expr)
## In state 731, spurious reduction of production closed_expr -> base_if_then_else__open(closed_expr)
##
interactive_expr: Begin Match Bytes With UIdent ARROW If Bytes Then Bytes ZWSP
##
## Ends in an error in state: 876.
##
## if_then_else(base_cond) -> If expr Then closed_expr . Else base_cond [ VBAR ]
## if_then_else(seq_expr) -> If expr Then closed_expr . Else seq_expr [ SEMI End Done ]
##
## The known suffix of the stack is as follows:
## If expr Then closed_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 408, spurious reduction of production call_expr_level -> core_expr
## In state 428, spurious reduction of production unary_expr_level -> call_expr_level
## In state 386, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 417, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 423, spurious reduction of production add_expr_level -> mult_expr_level
## In state 470, spurious reduction of production cons_expr_level -> add_expr_level
## In state 457, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 494, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 501, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 510, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 455, spurious reduction of production tuple_expr_level -> disj_expr_level
## In state 414, spurious reduction of production ass_expr_level -> tuple_expr_level
## In state 736, spurious reduction of production base_expr(closed_expr) -> ass_expr_level
## In state 732, spurious reduction of production base_if_then_else__open(closed_expr) -> base_expr(closed_expr)
## In state 731, spurious reduction of production closed_expr -> base_if_then_else__open(closed_expr)
##

Ill-formed complete conditional expression.
At this point, if the expression of the branch 'then' is complete, the
keyword 'else' is expected, followed by an expression.

interactive_expr: Begin If Verbatim Then If Verbatim With
##
## Ends in an error in state: 962.
##
## if_then_else(closed_expr) -> If expr . Then closed_expr Else closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## If expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 408, spurious reduction of production call_expr_level -> core_expr
## In state 428, spurious reduction of production unary_expr_level -> call_expr_level
## In state 386, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 417, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 423, spurious reduction of production add_expr_level -> mult_expr_level
## In state 470, spurious reduction of production cons_expr_level -> add_expr_level
## In state 457, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 494, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 501, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 510, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 455, spurious reduction of production tuple_expr_level -> disj_expr_level
## In state 414, spurious reduction of production ass_expr_level -> tuple_expr_level
## In state 525, spurious reduction of production base_expr(expr) -> ass_expr_level
## In state 523, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 524, spurious reduction of production expr -> base_cond__open(expr)
##
interactive_expr: Begin If Verbatim With
##
## Ends in an error in state: 955.
##
## if_then_else(seq_expr) -> If expr . Then closed_expr Else seq_expr [ SEMI End Done ]
##
## The known suffix of the stack is as follows:
## If expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 408, spurious reduction of production call_expr_level -> core_expr
## In state 428, spurious reduction of production unary_expr_level -> call_expr_level
## In state 386, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 417, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 423, spurious reduction of production add_expr_level -> mult_expr_level
## In state 470, spurious reduction of production cons_expr_level -> add_expr_level
## In state 457, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 494, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 501, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 510, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 455, spurious reduction of production tuple_expr_level -> disj_expr_level
## In state 414, spurious reduction of production ass_expr_level -> tuple_expr_level
## In state 525, spurious reduction of production base_expr(expr) -> ass_expr_level
## In state 523, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 524, spurious reduction of production expr -> base_cond__open(expr)
##
interactive_expr: Begin Match Verbatim With WILD ARROW If Verbatim With
##
## Ends in an error in state: 665.
##
## if_then(base_cond) -> If expr . Then base_cond [ VBAR ]
## if_then_else(base_cond) -> If expr . Then closed_expr Else base_cond [ VBAR ]
## if_then_else(seq_expr) -> If expr . Then closed_expr Else seq_expr [ SEMI End Done ]
##
## The known suffix of the stack is as follows:
## If expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 408, spurious reduction of production call_expr_level -> core_expr
## In state 428, spurious reduction of production unary_expr_level -> call_expr_level
## In state 386, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 417, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 423, spurious reduction of production add_expr_level -> mult_expr_level
## In state 470, spurious reduction of production cons_expr_level -> add_expr_level
## In state 457, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 494, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 501, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 510, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 455, spurious reduction of production tuple_expr_level -> disj_expr_level
## In state 414, spurious reduction of production ass_expr_level -> tuple_expr_level
## In state 525, spurious reduction of production base_expr(expr) -> ass_expr_level
## In state 523, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 524, spurious reduction of production expr -> base_cond__open(expr)
##
interactive_expr: If Verbatim Then If Verbatim With
##
## Ends in an error in state: 1125.
##
## if_then(expr) -> If expr . Then expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## if_then_else(closed_expr) -> If expr . Then closed_expr Else closed_expr [ Else ]
## if_then_else(expr) -> If expr . Then closed_expr Else expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## If expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 408, spurious reduction of production call_expr_level -> core_expr
## In state 428, spurious reduction of production unary_expr_level -> call_expr_level
## In state 386, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 417, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 423, spurious reduction of production add_expr_level -> mult_expr_level
## In state 470, spurious reduction of production cons_expr_level -> add_expr_level
## In state 457, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 494, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 501, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 510, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 455, spurious reduction of production tuple_expr_level -> disj_expr_level
## In state 414, spurious reduction of production ass_expr_level -> tuple_expr_level
## In state 525, spurious reduction of production base_expr(expr) -> ass_expr_level
## In state 523, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 524, spurious reduction of production expr -> base_cond__open(expr)
##
interactive_expr: If Verbatim Then Match Verbatim With WILD ARROW If Verbatim With
##
## Ends in an error in state: 678.
##
## if_then(base_cond) -> If expr . Then base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## if_then_else(base_cond) -> If expr . Then closed_expr Else base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## if_then_else(base_if_then_else) -> If expr . Then closed_expr Else base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## If expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 408, spurious reduction of production call_expr_level -> core_expr
## In state 428, spurious reduction of production unary_expr_level -> call_expr_level
## In state 386, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 417, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 423, spurious reduction of production add_expr_level -> mult_expr_level
## In state 470, spurious reduction of production cons_expr_level -> add_expr_level
## In state 457, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 494, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 501, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 510, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 455, spurious reduction of production tuple_expr_level -> disj_expr_level
## In state 414, spurious reduction of production ass_expr_level -> tuple_expr_level
## In state 525, spurious reduction of production base_expr(expr) -> ass_expr_level
## In state 523, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 524, spurious reduction of production expr -> base_cond__open(expr)
##
interactive_expr: If Verbatim With
##
## Ends in an error in state: 1108.
##
## if_then(expr) -> If expr . Then expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## if_then_else(expr) -> If expr . Then closed_expr Else expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## If expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 408, spurious reduction of production call_expr_level -> core_expr
## In state 428, spurious reduction of production unary_expr_level -> call_expr_level
## In state 386, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 417, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 423, spurious reduction of production add_expr_level -> mult_expr_level
## In state 470, spurious reduction of production cons_expr_level -> add_expr_level
## In state 457, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 494, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 501, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 510, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 455, spurious reduction of production tuple_expr_level -> disj_expr_level
## In state 414, spurious reduction of production ass_expr_level -> tuple_expr_level
## In state 525, spurious reduction of production base_expr(expr) -> ass_expr_level
## In state 523, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 524, spurious reduction of production expr -> base_cond__open(expr)
##
interactive_expr: Match Verbatim With WILD ARROW If Verbatim Then If Verbatim With
##
## Ends in an error in state: 694.
##
## if_then(base_cond) -> If expr . Then base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## if_then_else(base_cond) -> If expr . Then closed_expr Else base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## if_then_else(closed_expr) -> If expr . Then closed_expr Else closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## If expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 408, spurious reduction of production call_expr_level -> core_expr
## In state 428, spurious reduction of production unary_expr_level -> call_expr_level
## In state 386, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 417, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 423, spurious reduction of production add_expr_level -> mult_expr_level
## In state 470, spurious reduction of production cons_expr_level -> add_expr_level
## In state 457, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 494, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 501, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 510, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 455, spurious reduction of production tuple_expr_level -> disj_expr_level
## In state 414, spurious reduction of production ass_expr_level -> tuple_expr_level
## In state 525, spurious reduction of production base_expr(expr) -> ass_expr_level
## In state 523, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 524, spurious reduction of production expr -> base_cond__open(expr)
##
interactive_expr: Match Verbatim With WILD ARROW If Verbatim With
##
## Ends in an error in state: 883.
##
## if_then(base_cond) -> If expr . Then base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## if_then_else(base_cond) -> If expr . Then closed_expr Else base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## If expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 408, spurious reduction of production call_expr_level -> core_expr
## In state 428, spurious reduction of production unary_expr_level -> call_expr_level
## In state 386, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 417, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 423, spurious reduction of production add_expr_level -> mult_expr_level
## In state 470, spurious reduction of production cons_expr_level -> add_expr_level
## In state 457, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 494, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 501, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 510, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 455, spurious reduction of production tuple_expr_level -> disj_expr_level
## In state 414, spurious reduction of production ass_expr_level -> tuple_expr_level
## In state 525, spurious reduction of production base_expr(expr) -> ass_expr_level
## In state 523, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 524, spurious reduction of production expr -> base_cond__open(expr)
##

Ill-formed conditional expression.
At this point, if the condition is complete, the keyword 'then' is
expected, followed by an expression.

interactive_expr: Match UIdent With UIdent ARROW If UIdent Then Attr Let Rec Ident EQ UIdent With
##
## Ends in an error in state: 707.
##
## let_in_expr(base_cond) -> nseq(Attr) Let Rec let_binding . In base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## let_in_expr(closed_expr) -> nseq(Attr) Let Rec let_binding . In closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let Rec let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 3, spurious reduction of production const_ctor_expr -> UIdent
## In state 426, spurious reduction of production ctor_expr -> const_ctor_expr
## In state 407, spurious reduction of production call_expr_level -> ctor_expr
## In state 428, spurious reduction of production unary_expr_level -> call_expr_level
## In state 386, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 417, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 423, spurious reduction of production add_expr_level -> mult_expr_level
## In state 470, spurious reduction of production cons_expr_level -> add_expr_level
## In state 457, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 494, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 501, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 510, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 455, spurious reduction of production tuple_expr_level -> disj_expr_level
## In state 414, spurious reduction of production ass_expr_level -> tuple_expr_level
## In state 525, spurious reduction of production base_expr(expr) -> ass_expr_level
## In state 523, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 524, spurious reduction of production expr -> base_cond__open(expr)
## In state 1205, spurious reduction of production non_fun_decl -> var_pattern EQ expr
## In state 585, spurious reduction of production let_binding -> non_fun_decl
##
interactive_expr: Match UIdent With UIdent ARROW If UIdent Then Attr Let Ident EQ UIdent With
##
## Ends in an error in state: 746.
##
## let_in_expr(base_cond) -> nseq(Attr) Let let_binding . In base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## let_in_expr(closed_expr) -> nseq(Attr) Let let_binding . In closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 3, spurious reduction of production const_ctor_expr -> UIdent
## In state 426, spurious reduction of production ctor_expr -> const_ctor_expr
## In state 407, spurious reduction of production call_expr_level -> ctor_expr
## In state 428, spurious reduction of production unary_expr_level -> call_expr_level
## In state 386, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 417, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 423, spurious reduction of production add_expr_level -> mult_expr_level
## In state 470, spurious reduction of production cons_expr_level -> add_expr_level
## In state 457, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 494, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 501, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 510, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 455, spurious reduction of production tuple_expr_level -> disj_expr_level
## In state 414, spurious reduction of production ass_expr_level -> tuple_expr_level
## In state 525, spurious reduction of production base_expr(expr) -> ass_expr_level
## In state 523, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 524, spurious reduction of production expr -> base_cond__open(expr)
## In state 1205, spurious reduction of production non_fun_decl -> var_pattern EQ expr
## In state 585, spurious reduction of production let_binding -> non_fun_decl
##
interactive_expr: Begin If UIdent Then Attr Let Ident EQ UIdent With
##
## Ends in an error in state: 985.
##
## let_in_expr(closed_expr) -> nseq(Attr) Let let_binding . In closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 3, spurious reduction of production const_ctor_expr -> UIdent
## In state 426, spurious reduction of production ctor_expr -> const_ctor_expr
## In state 407, spurious reduction of production call_expr_level -> ctor_expr
## In state 428, spurious reduction of production unary_expr_level -> call_expr_level
## In state 386, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 417, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 423, spurious reduction of production add_expr_level -> mult_expr_level
## In state 470, spurious reduction of production cons_expr_level -> add_expr_level
## In state 457, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 494, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 501, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 510, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 455, spurious reduction of production tuple_expr_level -> disj_expr_level
## In state 414, spurious reduction of production ass_expr_level -> tuple_expr_level
## In state 525, spurious reduction of production base_expr(expr) -> ass_expr_level
## In state 523, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 524, spurious reduction of production expr -> base_cond__open(expr)
## In state 1205, spurious reduction of production non_fun_decl -> var_pattern EQ expr
## In state 585, spurious reduction of production let_binding -> non_fun_decl
##
interactive_expr: Begin Attr Let Rec Ident EQ UIdent With
##
## Ends in an error in state: 1022.
##
## let_in_sequence -> nseq(Attr) Let Rec let_binding . In series [ End Done ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let Rec let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 3, spurious reduction of production const_ctor_expr -> UIdent
## In state 426, spurious reduction of production ctor_expr -> const_ctor_expr
## In state 407, spurious reduction of production call_expr_level -> ctor_expr
## In state 428, spurious reduction of production unary_expr_level -> call_expr_level
## In state 386, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 417, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 423, spurious reduction of production add_expr_level -> mult_expr_level
## In state 470, spurious reduction of production cons_expr_level -> add_expr_level
## In state 457, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 494, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 501, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 510, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 455, spurious reduction of production tuple_expr_level -> disj_expr_level
## In state 414, spurious reduction of production ass_expr_level -> tuple_expr_level
## In state 525, spurious reduction of production base_expr(expr) -> ass_expr_level
## In state 523, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 524, spurious reduction of production expr -> base_cond__open(expr)
## In state 1205, spurious reduction of production non_fun_decl -> var_pattern EQ expr
## In state 585, spurious reduction of production let_binding -> non_fun_decl
##
interactive_expr: Begin Attr Let Ident EQ UIdent With
##
## Ends in an error in state: 1027.
##
## let_in_sequence -> nseq(Attr) Let let_binding . In series [ End Done ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 3, spurious reduction of production const_ctor_expr -> UIdent
## In state 426, spurious reduction of production ctor_expr -> const_ctor_expr
## In state 407, spurious reduction of production call_expr_level -> ctor_expr
## In state 428, spurious reduction of production unary_expr_level -> call_expr_level
## In state 386, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 417, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 423, spurious reduction of production add_expr_level -> mult_expr_level
## In state 470, spurious reduction of production cons_expr_level -> add_expr_level
## In state 457, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 494, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 501, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 510, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 455, spurious reduction of production tuple_expr_level -> disj_expr_level
## In state 414, spurious reduction of production ass_expr_level -> tuple_expr_level
## In state 525, spurious reduction of production base_expr(expr) -> ass_expr_level
## In state 523, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 524, spurious reduction of production expr -> base_cond__open(expr)
## In state 1205, spurious reduction of production non_fun_decl -> var_pattern EQ expr
## In state 585, spurious reduction of production let_binding -> non_fun_decl
##
interactive_expr: Begin Match UIdent With UIdent ARROW Attr Let Ident EQ UIdent With
##
## Ends in an error in state: 1059.
##
## let_in_expr(base_cond) -> nseq(Attr) Let let_binding . In base_cond [ VBAR ]
## let_in_sequence -> nseq(Attr) Let let_binding . In series [ End Done ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 3, spurious reduction of production const_ctor_expr -> UIdent
## In state 426, spurious reduction of production ctor_expr -> const_ctor_expr
## In state 407, spurious reduction of production call_expr_level -> ctor_expr
## In state 428, spurious reduction of production unary_expr_level -> call_expr_level
## In state 386, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 417, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 423, spurious reduction of production add_expr_level -> mult_expr_level
## In state 470, spurious reduction of production cons_expr_level -> add_expr_level
## In state 457, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 494, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 501, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 510, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 455, spurious reduction of production tuple_expr_level -> disj_expr_level
## In state 414, spurious reduction of production ass_expr_level -> tuple_expr_level
## In state 525, spurious reduction of production base_expr(expr) -> ass_expr_level
## In state 523, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 524, spurious reduction of production expr -> base_cond__open(expr)
## In state 1205, spurious reduction of production non_fun_decl -> var_pattern EQ expr
## In state 585, spurious reduction of production let_binding -> non_fun_decl
##
interactive_expr: Match UIdent With UIdent ARROW Attr Let Rec Ident EQ UIdent With
##
## Ends in an error in state: 897.
##
## let_in_expr(base_cond) -> nseq(Attr) Let Rec let_binding . In base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let Rec let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 3, spurious reduction of production const_ctor_expr -> UIdent
## In state 426, spurious reduction of production ctor_expr -> const_ctor_expr
## In state 407, spurious reduction of production call_expr_level -> ctor_expr
## In state 428, spurious reduction of production unary_expr_level -> call_expr_level
## In state 386, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 417, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 423, spurious reduction of production add_expr_level -> mult_expr_level
## In state 470, spurious reduction of production cons_expr_level -> add_expr_level
## In state 457, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 494, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 501, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 510, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 455, spurious reduction of production tuple_expr_level -> disj_expr_level
## In state 414, spurious reduction of production ass_expr_level -> tuple_expr_level
## In state 525, spurious reduction of production base_expr(expr) -> ass_expr_level
## In state 523, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 524, spurious reduction of production expr -> base_cond__open(expr)
## In state 1205, spurious reduction of production non_fun_decl -> var_pattern EQ expr
## In state 585, spurious reduction of production let_binding -> non_fun_decl
##
interactive_expr: If UIdent Then Match UIdent With UIdent ARROW Attr Let Rec Ident EQ UIdent With
##
## Ends in an error in state: 812.
##
## let_in_expr(base_cond) -> nseq(Attr) Let Rec let_binding . In base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## let_in_expr(base_if_then_else) -> nseq(Attr) Let Rec let_binding . In base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let Rec let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 3, spurious reduction of production const_ctor_expr -> UIdent
## In state 426, spurious reduction of production ctor_expr -> const_ctor_expr
## In state 407, spurious reduction of production call_expr_level -> ctor_expr
## In state 428, spurious reduction of production unary_expr_level -> call_expr_level
## In state 386, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 417, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 423, spurious reduction of production add_expr_level -> mult_expr_level
## In state 470, spurious reduction of production cons_expr_level -> add_expr_level
## In state 457, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 494, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 501, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 510, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 455, spurious reduction of production tuple_expr_level -> disj_expr_level
## In state 414, spurious reduction of production ass_expr_level -> tuple_expr_level
## In state 525, spurious reduction of production base_expr(expr) -> ass_expr_level
## In state 523, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 524, spurious reduction of production expr -> base_cond__open(expr)
## In state 1205, spurious reduction of production non_fun_decl -> var_pattern EQ expr
## In state 585, spurious reduction of production let_binding -> non_fun_decl
##
interactive_expr: If UIdent Then Match UIdent With UIdent ARROW Attr Let Ident EQ UIdent With
##
## Ends in an error in state: 836.
##
## let_in_expr(base_cond) -> nseq(Attr) Let let_binding . In base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## let_in_expr(base_if_then_else) -> nseq(Attr) Let let_binding . In base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 3, spurious reduction of production const_ctor_expr -> UIdent
## In state 426, spurious reduction of production ctor_expr -> const_ctor_expr
## In state 407, spurious reduction of production call_expr_level -> ctor_expr
## In state 428, spurious reduction of production unary_expr_level -> call_expr_level
## In state 386, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 417, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 423, spurious reduction of production add_expr_level -> mult_expr_level
## In state 470, spurious reduction of production cons_expr_level -> add_expr_level
## In state 457, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 494, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 501, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 510, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 455, spurious reduction of production tuple_expr_level -> disj_expr_level
## In state 414, spurious reduction of production ass_expr_level -> tuple_expr_level
## In state 525, spurious reduction of production base_expr(expr) -> ass_expr_level
## In state 523, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 524, spurious reduction of production expr -> base_cond__open(expr)
## In state 1205, spurious reduction of production non_fun_decl -> var_pattern EQ expr
## In state 585, spurious reduction of production let_binding -> non_fun_decl
##
interactive_expr: Match UIdent With UIdent ARROW Attr Let Ident EQ UIdent With
##
## Ends in an error in state: 908.
##
## let_in_expr(base_cond) -> nseq(Attr) Let let_binding . In base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 3, spurious reduction of production const_ctor_expr -> UIdent
## In state 426, spurious reduction of production ctor_expr -> const_ctor_expr
## In state 407, spurious reduction of production call_expr_level -> ctor_expr
## In state 428, spurious reduction of production unary_expr_level -> call_expr_level
## In state 386, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 417, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 423, spurious reduction of production add_expr_level -> mult_expr_level
## In state 470, spurious reduction of production cons_expr_level -> add_expr_level
## In state 457, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 494, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 501, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 510, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 455, spurious reduction of production tuple_expr_level -> disj_expr_level
## In state 414, spurious reduction of production ass_expr_level -> tuple_expr_level
## In state 525, spurious reduction of production base_expr(expr) -> ass_expr_level
## In state 523, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 524, spurious reduction of production expr -> base_cond__open(expr)
## In state 1205, spurious reduction of production non_fun_decl -> var_pattern EQ expr
## In state 585, spurious reduction of production let_binding -> non_fun_decl
##
interactive_expr: Begin Match UIdent With UIdent ARROW Attr Let Rec Ident EQ UIdent With
##
## Ends in an error in state: 945.
##
## let_in_expr(base_cond) -> nseq(Attr) Let Rec let_binding . In base_cond [ VBAR ]
## let_in_sequence -> nseq(Attr) Let Rec let_binding . In series [ End Done ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let Rec let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 3, spurious reduction of production const_ctor_expr -> UIdent
## In state 426, spurious reduction of production ctor_expr -> const_ctor_expr
## In state 407, spurious reduction of production call_expr_level -> ctor_expr
## In state 428, spurious reduction of production unary_expr_level -> call_expr_level
## In state 386, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 417, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 423, spurious reduction of production add_expr_level -> mult_expr_level
## In state 470, spurious reduction of production cons_expr_level -> add_expr_level
## In state 457, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 494, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 501, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 510, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 455, spurious reduction of production tuple_expr_level -> disj_expr_level
## In state 414, spurious reduction of production ass_expr_level -> tuple_expr_level
## In state 525, spurious reduction of production base_expr(expr) -> ass_expr_level
## In state 523, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 524, spurious reduction of production expr -> base_cond__open(expr)
## In state 1205, spurious reduction of production non_fun_decl -> var_pattern EQ expr
## In state 585, spurious reduction of production let_binding -> non_fun_decl
##
interactive_expr: Begin If UIdent Then Attr Let Rec Ident EQ UIdent With
##
## Ends in an error in state: 974.
##
## let_in_expr(closed_expr) -> nseq(Attr) Let Rec let_binding . In closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let Rec let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 3, spurious reduction of production const_ctor_expr -> UIdent
## In state 426, spurious reduction of production ctor_expr -> const_ctor_expr
## In state 407, spurious reduction of production call_expr_level -> ctor_expr
## In state 428, spurious reduction of production unary_expr_level -> call_expr_level
## In state 386, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 417, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 423, spurious reduction of production add_expr_level -> mult_expr_level
## In state 470, spurious reduction of production cons_expr_level -> add_expr_level
## In state 457, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 494, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 501, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 510, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 455, spurious reduction of production tuple_expr_level -> disj_expr_level
## In state 414, spurious reduction of production ass_expr_level -> tuple_expr_level
## In state 525, spurious reduction of production base_expr(expr) -> ass_expr_level
## In state 523, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 524, spurious reduction of production expr -> base_cond__open(expr)
## In state 1205, spurious reduction of production non_fun_decl -> var_pattern EQ expr
## In state 585, spurious reduction of production let_binding -> non_fun_decl
##
interactive_expr: Begin If Verbatim Then Let Rec WILD EQ Bytes With
##
## Ends in an error in state: 959.
##
## let_in_expr(closed_expr) -> Let Rec let_binding . In closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Let Rec let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 408, spurious reduction of production call_expr_level -> core_expr
## In state 428, spurious reduction of production unary_expr_level -> call_expr_level
## In state 386, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 417, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 423, spurious reduction of production add_expr_level -> mult_expr_level
## In state 470, spurious reduction of production cons_expr_level -> add_expr_level
## In state 457, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 494, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 501, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 510, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 455, spurious reduction of production tuple_expr_level -> disj_expr_level
## In state 414, spurious reduction of production ass_expr_level -> tuple_expr_level
## In state 525, spurious reduction of production base_expr(expr) -> ass_expr_level
## In state 523, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 524, spurious reduction of production expr -> base_cond__open(expr)
## In state 1255, spurious reduction of production non_fun_decl -> WILD EQ expr
## In state 585, spurious reduction of production let_binding -> non_fun_decl
##
interactive_expr: Begin Let Rec WILD EQ Bytes With
##
## Ends in an error in state: 952.
##
## let_in_sequence -> Let Rec let_binding . In series [ End Done ]
##
## The known suffix of the stack is as follows:
## Let Rec let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 408, spurious reduction of production call_expr_level -> core_expr
## In state 428, spurious reduction of production unary_expr_level -> call_expr_level
## In state 386, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 417, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 423, spurious reduction of production add_expr_level -> mult_expr_level
## In state 470, spurious reduction of production cons_expr_level -> add_expr_level
## In state 457, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 494, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 501, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 510, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 455, spurious reduction of production tuple_expr_level -> disj_expr_level
## In state 414, spurious reduction of production ass_expr_level -> tuple_expr_level
## In state 525, spurious reduction of production base_expr(expr) -> ass_expr_level
## In state 523, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 524, spurious reduction of production expr -> base_cond__open(expr)
## In state 1255, spurious reduction of production non_fun_decl -> WILD EQ expr
## In state 585, spurious reduction of production let_binding -> non_fun_decl
##
interactive_expr: Begin Match Verbatim With WILD ARROW Let Rec WILD EQ Bytes With
##
## Ends in an error in state: 662.
##
## let_in_expr(base_cond) -> Let Rec let_binding . In base_cond [ VBAR ]
## let_in_sequence -> Let Rec let_binding . In series [ End Done ]
##
## The known suffix of the stack is as follows:
## Let Rec let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 408, spurious reduction of production call_expr_level -> core_expr
## In state 428, spurious reduction of production unary_expr_level -> call_expr_level
## In state 386, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 417, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 423, spurious reduction of production add_expr_level -> mult_expr_level
## In state 470, spurious reduction of production cons_expr_level -> add_expr_level
## In state 457, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 494, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 501, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 510, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 455, spurious reduction of production tuple_expr_level -> disj_expr_level
## In state 414, spurious reduction of production ass_expr_level -> tuple_expr_level
## In state 525, spurious reduction of production base_expr(expr) -> ass_expr_level
## In state 523, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 524, spurious reduction of production expr -> base_cond__open(expr)
## In state 1255, spurious reduction of production non_fun_decl -> WILD EQ expr
## In state 585, spurious reduction of production let_binding -> non_fun_decl
##
interactive_expr: If Verbatim Then Let Rec WILD EQ Bytes With
##
## Ends in an error in state: 1122.
##
## let_in_expr(closed_expr) -> Let Rec let_binding . In closed_expr [ Else ]
## let_in_expr(expr) -> Let Rec let_binding . In expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let Rec let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 408, spurious reduction of production call_expr_level -> core_expr
## In state 428, spurious reduction of production unary_expr_level -> call_expr_level
## In state 386, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 417, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 423, spurious reduction of production add_expr_level -> mult_expr_level
## In state 470, spurious reduction of production cons_expr_level -> add_expr_level
## In state 457, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 494, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 501, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 510, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 455, spurious reduction of production tuple_expr_level -> disj_expr_level
## In state 414, spurious reduction of production ass_expr_level -> tuple_expr_level
## In state 525, spurious reduction of production base_expr(expr) -> ass_expr_level
## In state 523, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 524, spurious reduction of production expr -> base_cond__open(expr)
## In state 1255, spurious reduction of production non_fun_decl -> WILD EQ expr
## In state 585, spurious reduction of production let_binding -> non_fun_decl
##
interactive_expr: If Verbatim Then Match Verbatim With WILD ARROW Let Rec WILD EQ Bytes With
##
## Ends in an error in state: 675.
##
## let_in_expr(base_cond) -> Let Rec let_binding . In base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## let_in_expr(base_if_then_else) -> Let Rec let_binding . In base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## Let Rec let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 408, spurious reduction of production call_expr_level -> core_expr
## In state 428, spurious reduction of production unary_expr_level -> call_expr_level
## In state 386, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 417, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 423, spurious reduction of production add_expr_level -> mult_expr_level
## In state 470, spurious reduction of production cons_expr_level -> add_expr_level
## In state 457, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 494, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 501, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 510, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 455, spurious reduction of production tuple_expr_level -> disj_expr_level
## In state 414, spurious reduction of production ass_expr_level -> tuple_expr_level
## In state 525, spurious reduction of production base_expr(expr) -> ass_expr_level
## In state 523, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 524, spurious reduction of production expr -> base_cond__open(expr)
## In state 1255, spurious reduction of production non_fun_decl -> WILD EQ expr
## In state 585, spurious reduction of production let_binding -> non_fun_decl
##
interactive_expr: Let Rec WILD EQ Bytes With
##
## Ends in an error in state: 1228.
##
## let_in_expr(expr) -> Let Rec let_binding . In expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let Rec let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 408, spurious reduction of production call_expr_level -> core_expr
## In state 428, spurious reduction of production unary_expr_level -> call_expr_level
## In state 386, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 417, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 423, spurious reduction of production add_expr_level -> mult_expr_level
## In state 470, spurious reduction of production cons_expr_level -> add_expr_level
## In state 457, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 494, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 501, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 510, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 455, spurious reduction of production tuple_expr_level -> disj_expr_level
## In state 414, spurious reduction of production ass_expr_level -> tuple_expr_level
## In state 525, spurious reduction of production base_expr(expr) -> ass_expr_level
## In state 523, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 524, spurious reduction of production expr -> base_cond__open(expr)
## In state 1255, spurious reduction of production non_fun_decl -> WILD EQ expr
## In state 585, spurious reduction of production let_binding -> non_fun_decl
##
interactive_expr: Match Verbatim With WILD ARROW If Verbatim Then Let Rec WILD EQ Bytes With
##
## Ends in an error in state: 691.
##
## let_in_expr(base_cond) -> Let Rec let_binding . In base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## let_in_expr(closed_expr) -> Let Rec let_binding . In closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Let Rec let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 408, spurious reduction of production call_expr_level -> core_expr
## In state 428, spurious reduction of production unary_expr_level -> call_expr_level
## In state 386, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 417, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 423, spurious reduction of production add_expr_level -> mult_expr_level
## In state 470, spurious reduction of production cons_expr_level -> add_expr_level
## In state 457, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 494, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 501, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 510, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 455, spurious reduction of production tuple_expr_level -> disj_expr_level
## In state 414, spurious reduction of production ass_expr_level -> tuple_expr_level
## In state 525, spurious reduction of production base_expr(expr) -> ass_expr_level
## In state 523, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 524, spurious reduction of production expr -> base_cond__open(expr)
## In state 1255, spurious reduction of production non_fun_decl -> WILD EQ expr
## In state 585, spurious reduction of production let_binding -> non_fun_decl
##
interactive_expr: Match Verbatim With WILD ARROW Let Rec WILD EQ Bytes With
##
## Ends in an error in state: 880.
##
## let_in_expr(base_cond) -> Let Rec let_binding . In base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let Rec let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 408, spurious reduction of production call_expr_level -> core_expr
## In state 428, spurious reduction of production unary_expr_level -> call_expr_level
## In state 386, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 417, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 423, spurious reduction of production add_expr_level -> mult_expr_level
## In state 470, spurious reduction of production cons_expr_level -> add_expr_level
## In state 457, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 494, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 501, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 510, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 455, spurious reduction of production tuple_expr_level -> disj_expr_level
## In state 414, spurious reduction of production ass_expr_level -> tuple_expr_level
## In state 525, spurious reduction of production base_expr(expr) -> ass_expr_level
## In state 523, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 524, spurious reduction of production expr -> base_cond__open(expr)
## In state 1255, spurious reduction of production non_fun_decl -> WILD EQ expr
## In state 585, spurious reduction of production let_binding -> non_fun_decl
##
interactive_expr: Begin If Verbatim Then Let WILD EQ Bytes With
##
## Ends in an error in state: 1008.
##
## let_in_expr(closed_expr) -> Let let_binding . In closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Let let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 408, spurious reduction of production call_expr_level -> core_expr
## In state 428, spurious reduction of production unary_expr_level -> call_expr_level
## In state 386, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 417, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 423, spurious reduction of production add_expr_level -> mult_expr_level
## In state 470, spurious reduction of production cons_expr_level -> add_expr_level
## In state 457, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 494, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 501, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 510, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 455, spurious reduction of production tuple_expr_level -> disj_expr_level
## In state 414, spurious reduction of production ass_expr_level -> tuple_expr_level
## In state 525, spurious reduction of production base_expr(expr) -> ass_expr_level
## In state 523, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 524, spurious reduction of production expr -> base_cond__open(expr)
## In state 1255, spurious reduction of production non_fun_decl -> WILD EQ expr
## In state 585, spurious reduction of production let_binding -> non_fun_decl
##
interactive_expr: Begin Let WILD EQ Bytes With
##
## Ends in an error in state: 1055.
##
## let_in_sequence -> Let let_binding . In series [ End Done ]
##
## The known suffix of the stack is as follows:
## Let let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 408, spurious reduction of production call_expr_level -> core_expr
## In state 428, spurious reduction of production unary_expr_level -> call_expr_level
## In state 386, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 417, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 423, spurious reduction of production add_expr_level -> mult_expr_level
## In state 470, spurious reduction of production cons_expr_level -> add_expr_level
## In state 457, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 494, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 501, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 510, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 455, spurious reduction of production tuple_expr_level -> disj_expr_level
## In state 414, spurious reduction of production ass_expr_level -> tuple_expr_level
## In state 525, spurious reduction of production base_expr(expr) -> ass_expr_level
## In state 523, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 524, spurious reduction of production expr -> base_cond__open(expr)
## In state 1255, spurious reduction of production non_fun_decl -> WILD EQ expr
## In state 585, spurious reduction of production let_binding -> non_fun_decl
##
interactive_expr: Begin Match Verbatim With WILD ARROW Let WILD EQ Bytes With
##
## Ends in an error in state: 1077.
##
## let_in_expr(base_cond) -> Let let_binding . In base_cond [ VBAR ]
## let_in_sequence -> Let let_binding . In series [ End Done ]
##
## The known suffix of the stack is as follows:
## Let let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 408, spurious reduction of production call_expr_level -> core_expr
## In state 428, spurious reduction of production unary_expr_level -> call_expr_level
## In state 386, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 417, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 423, spurious reduction of production add_expr_level -> mult_expr_level
## In state 470, spurious reduction of production cons_expr_level -> add_expr_level
## In state 457, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 494, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 501, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 510, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 455, spurious reduction of production tuple_expr_level -> disj_expr_level
## In state 414, spurious reduction of production ass_expr_level -> tuple_expr_level
## In state 525, spurious reduction of production base_expr(expr) -> ass_expr_level
## In state 523, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 524, spurious reduction of production expr -> base_cond__open(expr)
## In state 1255, spurious reduction of production non_fun_decl -> WILD EQ expr
## In state 585, spurious reduction of production let_binding -> non_fun_decl
##
interactive_expr: If Verbatim Then Match Verbatim With WILD ARROW Let WILD EQ Bytes With
##
## Ends in an error in state: 870.
##
## let_in_expr(base_cond) -> Let let_binding . In base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## let_in_expr(base_if_then_else) -> Let let_binding . In base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## Let let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 408, spurious reduction of production call_expr_level -> core_expr
## In state 428, spurious reduction of production unary_expr_level -> call_expr_level
## In state 386, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 417, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 423, spurious reduction of production add_expr_level -> mult_expr_level
## In state 470, spurious reduction of production cons_expr_level -> add_expr_level
## In state 457, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 494, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 501, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 510, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 455, spurious reduction of production tuple_expr_level -> disj_expr_level
## In state 414, spurious reduction of production ass_expr_level -> tuple_expr_level
## In state 525, spurious reduction of production base_expr(expr) -> ass_expr_level
## In state 523, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 524, spurious reduction of production expr -> base_cond__open(expr)
## In state 1255, spurious reduction of production non_fun_decl -> WILD EQ expr
## In state 585, spurious reduction of production let_binding -> non_fun_decl
##
interactive_expr: If Verbatim Then Let WILD EQ Bytes With
##
## Ends in an error in state: 1175.
##
## let_in_expr(closed_expr) -> Let let_binding . In closed_expr [ Else ]
## let_in_expr(expr) -> Let let_binding . In expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 408, spurious reduction of production call_expr_level -> core_expr
## In state 428, spurious reduction of production unary_expr_level -> call_expr_level
## In state 386, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 417, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 423, spurious reduction of production add_expr_level -> mult_expr_level
## In state 470, spurious reduction of production cons_expr_level -> add_expr_level
## In state 457, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 494, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 501, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 510, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 455, spurious reduction of production tuple_expr_level -> disj_expr_level
## In state 414, spurious reduction of production ass_expr_level -> tuple_expr_level
## In state 525, spurious reduction of production base_expr(expr) -> ass_expr_level
## In state 523, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 524, spurious reduction of production expr -> base_cond__open(expr)
## In state 1255, spurious reduction of production non_fun_decl -> WILD EQ expr
## In state 585, spurious reduction of production let_binding -> non_fun_decl
##
interactive_expr: Let WILD EQ Bytes With
##
## Ends in an error in state: 1233.
##
## let_in_expr(expr) -> Let let_binding . In expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 408, spurious reduction of production call_expr_level -> core_expr
## In state 428, spurious reduction of production unary_expr_level -> call_expr_level
## In state 386, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 417, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 423, spurious reduction of production add_expr_level -> mult_expr_level
## In state 470, spurious reduction of production cons_expr_level -> add_expr_level
## In state 457, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 494, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 501, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 510, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 455, spurious reduction of production tuple_expr_level -> disj_expr_level
## In state 414, spurious reduction of production ass_expr_level -> tuple_expr_level
## In state 525, spurious reduction of production base_expr(expr) -> ass_expr_level
## In state 523, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 524, spurious reduction of production expr -> base_cond__open(expr)
## In state 1255, spurious reduction of production non_fun_decl -> WILD EQ expr
## In state 585, spurious reduction of production let_binding -> non_fun_decl
##
interactive_expr: Match Verbatim With WILD ARROW If Verbatim Then Let WILD EQ Bytes With
##
## Ends in an error in state: 796.
##
## let_in_expr(base_cond) -> Let let_binding . In base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## let_in_expr(closed_expr) -> Let let_binding . In closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Let let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 408, spurious reduction of production call_expr_level -> core_expr
## In state 428, spurious reduction of production unary_expr_level -> call_expr_level
## In state 386, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 417, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 423, spurious reduction of production add_expr_level -> mult_expr_level
## In state 470, spurious reduction of production cons_expr_level -> add_expr_level
## In state 457, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 494, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 501, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 510, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 455, spurious reduction of production tuple_expr_level -> disj_expr_level
## In state 414, spurious reduction of production ass_expr_level -> tuple_expr_level
## In state 525, spurious reduction of production base_expr(expr) -> ass_expr_level
## In state 523, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 524, spurious reduction of production expr -> base_cond__open(expr)
## In state 1255, spurious reduction of production non_fun_decl -> WILD EQ expr
## In state 585, spurious reduction of production let_binding -> non_fun_decl
##
interactive_expr: Match Verbatim With WILD ARROW Let WILD EQ Bytes With
##
## Ends in an error in state: 929.
##
## let_in_expr(base_cond) -> Let let_binding . In base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 408, spurious reduction of production call_expr_level -> core_expr
## In state 428, spurious reduction of production unary_expr_level -> call_expr_level
## In state 386, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 417, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 423, spurious reduction of production add_expr_level -> mult_expr_level
## In state 470, spurious reduction of production cons_expr_level -> add_expr_level
## In state 457, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 494, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 501, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 510, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 455, spurious reduction of production tuple_expr_level -> disj_expr_level
## In state 414, spurious reduction of production ass_expr_level -> tuple_expr_level
## In state 525, spurious reduction of production base_expr(expr) -> ass_expr_level
## In state 523, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 524, spurious reduction of production expr -> base_cond__open(expr)
## In state 1255, spurious reduction of production non_fun_decl -> WILD EQ expr
## In state 585, spurious reduction of production let_binding -> non_fun_decl
##
interactive_expr: Attr Let Ident EQ UIdent With
##
## Ends in an error in state: 612.
##
## let_in_expr(expr) -> nseq(Attr) Let let_binding . In expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 3, spurious reduction of production const_ctor_expr -> UIdent
## In state 426, spurious reduction of production ctor_expr -> const_ctor_expr
## In state 407, spurious reduction of production call_expr_level -> ctor_expr
## In state 428, spurious reduction of production unary_expr_level -> call_expr_level
## In state 386, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 417, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 423, spurious reduction of production add_expr_level -> mult_expr_level
## In state 470, spurious reduction of production cons_expr_level -> add_expr_level
## In state 457, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 494, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 501, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 510, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 455, spurious reduction of production tuple_expr_level -> disj_expr_level
## In state 414, spurious reduction of production ass_expr_level -> tuple_expr_level
## In state 525, spurious reduction of production base_expr(expr) -> ass_expr_level
## In state 523, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 524, spurious reduction of production expr -> base_cond__open(expr)
## In state 1205, spurious reduction of production non_fun_decl -> var_pattern EQ expr
## In state 585, spurious reduction of production let_binding -> non_fun_decl
##
interactive_expr: If UIdent Then Attr Let Rec Ident EQ UIdent With
##
## Ends in an error in state: 1137.
##
## let_in_expr(closed_expr) -> nseq(Attr) Let Rec let_binding . In closed_expr [ Else ]
## let_in_expr(expr) -> nseq(Attr) Let Rec let_binding . In expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let Rec let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 3, spurious reduction of production const_ctor_expr -> UIdent
## In state 426, spurious reduction of production ctor_expr -> const_ctor_expr
## In state 407, spurious reduction of production call_expr_level -> ctor_expr
## In state 428, spurious reduction of production unary_expr_level -> call_expr_level
## In state 386, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 417, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 423, spurious reduction of production add_expr_level -> mult_expr_level
## In state 470, spurious reduction of production cons_expr_level -> add_expr_level
## In state 457, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 494, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 501, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 510, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 455, spurious reduction of production tuple_expr_level -> disj_expr_level
## In state 414, spurious reduction of production ass_expr_level -> tuple_expr_level
## In state 525, spurious reduction of production base_expr(expr) -> ass_expr_level
## In state 523, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 524, spurious reduction of production expr -> base_cond__open(expr)
## In state 1205, spurious reduction of production non_fun_decl -> var_pattern EQ expr
## In state 585, spurious reduction of production let_binding -> non_fun_decl
##
interactive_expr: If UIdent Then Attr Let Ident EQ UIdent With
##
## Ends in an error in state: 1148.
##
## let_in_expr(closed_expr) -> nseq(Attr) Let let_binding . In closed_expr [ Else ]
## let_in_expr(expr) -> nseq(Attr) Let let_binding . In expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 3, spurious reduction of production const_ctor_expr -> UIdent
## In state 426, spurious reduction of production ctor_expr -> const_ctor_expr
## In state 407, spurious reduction of production call_expr_level -> ctor_expr
## In state 428, spurious reduction of production unary_expr_level -> call_expr_level
## In state 386, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 417, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 423, spurious reduction of production add_expr_level -> mult_expr_level
## In state 470, spurious reduction of production cons_expr_level -> add_expr_level
## In state 457, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 494, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 501, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 510, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 455, spurious reduction of production tuple_expr_level -> disj_expr_level
## In state 414, spurious reduction of production ass_expr_level -> tuple_expr_level
## In state 525, spurious reduction of production base_expr(expr) -> ass_expr_level
## In state 523, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 524, spurious reduction of production expr -> base_cond__open(expr)
## In state 1205, spurious reduction of production non_fun_decl -> var_pattern EQ expr
## In state 585, spurious reduction of production let_binding -> non_fun_decl
##
interactive_expr: Attr Let Rec Ident EQ UIdent With
##
## Ends in an error in state: 586.
##
## let_in_expr(expr) -> nseq(Attr) Let Rec let_binding . In expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let Rec let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 3, spurious reduction of production const_ctor_expr -> UIdent
## In state 426, spurious reduction of production ctor_expr -> const_ctor_expr
## In state 407, spurious reduction of production call_expr_level -> ctor_expr
## In state 428, spurious reduction of production unary_expr_level -> call_expr_level
## In state 386, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 417, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 423, spurious reduction of production add_expr_level -> mult_expr_level
## In state 470, spurious reduction of production cons_expr_level -> add_expr_level
## In state 457, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 494, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 501, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 510, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 455, spurious reduction of production tuple_expr_level -> disj_expr_level
## In state 414, spurious reduction of production ass_expr_level -> tuple_expr_level
## In state 525, spurious reduction of production base_expr(expr) -> ass_expr_level
## In state 523, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 524, spurious reduction of production expr -> base_cond__open(expr)
## In state 1205, spurious reduction of production non_fun_decl -> var_pattern EQ expr
## In state 585, spurious reduction of production let_binding -> non_fun_decl
##
interactive_expr: If Bytes Then Let Mut Ident EQ Bytes ZWSP
##
## Ends in an error in state: 1172.
##
## let_mut_in_expr(closed_expr) -> Let Mut let_mut_binding . In closed_expr [ Else ]
## let_mut_in_expr(expr) -> Let Mut let_mut_binding . In expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let Mut let_mut_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 408, spurious reduction of production call_expr_level -> core_expr
## In state 428, spurious reduction of production unary_expr_level -> call_expr_level
## In state 386, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 417, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 423, spurious reduction of production add_expr_level -> mult_expr_level
## In state 470, spurious reduction of production cons_expr_level -> add_expr_level
## In state 457, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 494, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 501, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 510, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 455, spurious reduction of production tuple_expr_level -> disj_expr_level
## In state 414, spurious reduction of production ass_expr_level -> tuple_expr_level
## In state 525, spurious reduction of production base_expr(expr) -> ass_expr_level
## In state 523, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 524, spurious reduction of production expr -> base_cond__open(expr)
## In state 605, spurious reduction of production let_mut_binding -> var_pattern EQ expr
##
interactive_expr: If Bytes Then Attr Let Mut Ident EQ Bytes ZWSP
##
## Ends in an error in state: 1146.
##
## let_mut_in_expr(closed_expr) -> nseq(Attr) Let Mut let_mut_binding . In closed_expr [ Else ]
## let_mut_in_expr(expr) -> nseq(Attr) Let Mut let_mut_binding . In expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let Mut let_mut_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 408, spurious reduction of production call_expr_level -> core_expr
## In state 428, spurious reduction of production unary_expr_level -> call_expr_level
## In state 386, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 417, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 423, spurious reduction of production add_expr_level -> mult_expr_level
## In state 470, spurious reduction of production cons_expr_level -> add_expr_level
## In state 457, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 494, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 501, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 510, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 455, spurious reduction of production tuple_expr_level -> disj_expr_level
## In state 414, spurious reduction of production ass_expr_level -> tuple_expr_level
## In state 525, spurious reduction of production base_expr(expr) -> ass_expr_level
## In state 523, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 524, spurious reduction of production expr -> base_cond__open(expr)
## In state 605, spurious reduction of production let_mut_binding -> var_pattern EQ expr
##
interactive_expr: Begin If Bytes Then Let Mut Ident EQ Bytes ZWSP
##
## Ends in an error in state: 1006.
##
## let_mut_in_expr(closed_expr) -> Let Mut let_mut_binding . In closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Let Mut let_mut_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 408, spurious reduction of production call_expr_level -> core_expr
## In state 428, spurious reduction of production unary_expr_level -> call_expr_level
## In state 386, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 417, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 423, spurious reduction of production add_expr_level -> mult_expr_level
## In state 470, spurious reduction of production cons_expr_level -> add_expr_level
## In state 457, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 494, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 501, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 510, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 455, spurious reduction of production tuple_expr_level -> disj_expr_level
## In state 414, spurious reduction of production ass_expr_level -> tuple_expr_level
## In state 525, spurious reduction of production base_expr(expr) -> ass_expr_level
## In state 523, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 524, spurious reduction of production expr -> base_cond__open(expr)
## In state 605, spurious reduction of production let_mut_binding -> var_pattern EQ expr
##
interactive_expr: Begin If Bytes Then Attr Let Mut Ident EQ Bytes ZWSP
##
## Ends in an error in state: 983.
##
## let_mut_in_expr(closed_expr) -> nseq(Attr) Let Mut let_mut_binding . In closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let Mut let_mut_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 408, spurious reduction of production call_expr_level -> core_expr
## In state 428, spurious reduction of production unary_expr_level -> call_expr_level
## In state 386, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 417, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 423, spurious reduction of production add_expr_level -> mult_expr_level
## In state 470, spurious reduction of production cons_expr_level -> add_expr_level
## In state 457, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 494, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 501, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 510, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 455, spurious reduction of production tuple_expr_level -> disj_expr_level
## In state 414, spurious reduction of production ass_expr_level -> tuple_expr_level
## In state 525, spurious reduction of production base_expr(expr) -> ass_expr_level
## In state 523, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 524, spurious reduction of production expr -> base_cond__open(expr)
## In state 605, spurious reduction of production let_mut_binding -> var_pattern EQ expr
##
interactive_expr: Match Bytes With UIdent ARROW Let Mut Ident EQ Bytes ZWSP
##
## Ends in an error in state: 927.
##
## let_mut_in_expr(base_cond) -> Let Mut let_mut_binding . In base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let Mut let_mut_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 408, spurious reduction of production call_expr_level -> core_expr
## In state 428, spurious reduction of production unary_expr_level -> call_expr_level
## In state 386, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 417, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 423, spurious reduction of production add_expr_level -> mult_expr_level
## In state 470, spurious reduction of production cons_expr_level -> add_expr_level
## In state 457, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 494, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 501, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 510, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 455, spurious reduction of production tuple_expr_level -> disj_expr_level
## In state 414, spurious reduction of production ass_expr_level -> tuple_expr_level
## In state 525, spurious reduction of production base_expr(expr) -> ass_expr_level
## In state 523, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 524, spurious reduction of production expr -> base_cond__open(expr)
## In state 605, spurious reduction of production let_mut_binding -> var_pattern EQ expr
##
interactive_expr: Match Bytes With UIdent ARROW Attr Let Mut Ident EQ Bytes ZWSP
##
## Ends in an error in state: 906.
##
## let_mut_in_expr(base_cond) -> nseq(Attr) Let Mut let_mut_binding . In base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let Mut let_mut_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 408, spurious reduction of production call_expr_level -> core_expr
## In state 428, spurious reduction of production unary_expr_level -> call_expr_level
## In state 386, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 417, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 423, spurious reduction of production add_expr_level -> mult_expr_level
## In state 470, spurious reduction of production cons_expr_level -> add_expr_level
## In state 457, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 494, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 501, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 510, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 455, spurious reduction of production tuple_expr_level -> disj_expr_level
## In state 414, spurious reduction of production ass_expr_level -> tuple_expr_level
## In state 525, spurious reduction of production base_expr(expr) -> ass_expr_level
## In state 523, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 524, spurious reduction of production expr -> base_cond__open(expr)
## In state 605, spurious reduction of production let_mut_binding -> var_pattern EQ expr
##
interactive_expr: If Bytes Then Match Bytes With UIdent ARROW Let Mut Ident EQ Bytes ZWSP
##
## Ends in an error in state: 867.
##
## let_mut_in_expr(base_cond) -> Let Mut let_mut_binding . In base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## let_mut_in_expr(base_if_then_else) -> Let Mut let_mut_binding . In base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## Let Mut let_mut_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 408, spurious reduction of production call_expr_level -> core_expr
## In state 428, spurious reduction of production unary_expr_level -> call_expr_level
## In state 386, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 417, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 423, spurious reduction of production add_expr_level -> mult_expr_level
## In state 470, spurious reduction of production cons_expr_level -> add_expr_level
## In state 457, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 494, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 501, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 510, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 455, spurious reduction of production tuple_expr_level -> disj_expr_level
## In state 414, spurious reduction of production ass_expr_level -> tuple_expr_level
## In state 525, spurious reduction of production base_expr(expr) -> ass_expr_level
## In state 523, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 524, spurious reduction of production expr -> base_cond__open(expr)
## In state 605, spurious reduction of production let_mut_binding -> var_pattern EQ expr
##
interactive_expr: If Bytes Then Match Bytes With UIdent ARROW Attr Let Mut Ident EQ Bytes ZWSP
##
## Ends in an error in state: 833.
##
## let_mut_in_expr(base_cond) -> nseq(Attr) Let Mut let_mut_binding . In base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## let_mut_in_expr(base_if_then_else) -> nseq(Attr) Let Mut let_mut_binding . In base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let Mut let_mut_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 408, spurious reduction of production call_expr_level -> core_expr
## In state 428, spurious reduction of production unary_expr_level -> call_expr_level
## In state 386, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 417, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 423, spurious reduction of production add_expr_level -> mult_expr_level
## In state 470, spurious reduction of production cons_expr_level -> add_expr_level
## In state 457, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 494, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 501, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 510, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 455, spurious reduction of production tuple_expr_level -> disj_expr_level
## In state 414, spurious reduction of production ass_expr_level -> tuple_expr_level
## In state 525, spurious reduction of production base_expr(expr) -> ass_expr_level
## In state 523, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 524, spurious reduction of production expr -> base_cond__open(expr)
## In state 605, spurious reduction of production let_mut_binding -> var_pattern EQ expr
##
interactive_expr: Match Bytes With UIdent ARROW If Bytes Then Let Mut Ident EQ Bytes ZWSP
##
## Ends in an error in state: 792.
##
## let_mut_in_expr(base_cond) -> Let Mut let_mut_binding . In base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## let_mut_in_expr(closed_expr) -> Let Mut let_mut_binding . In closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Let Mut let_mut_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 408, spurious reduction of production call_expr_level -> core_expr
## In state 428, spurious reduction of production unary_expr_level -> call_expr_level
## In state 386, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 417, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 423, spurious reduction of production add_expr_level -> mult_expr_level
## In state 470, spurious reduction of production cons_expr_level -> add_expr_level
## In state 457, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 494, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 501, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 510, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 455, spurious reduction of production tuple_expr_level -> disj_expr_level
## In state 414, spurious reduction of production ass_expr_level -> tuple_expr_level
## In state 525, spurious reduction of production base_expr(expr) -> ass_expr_level
## In state 523, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 524, spurious reduction of production expr -> base_cond__open(expr)
## In state 605, spurious reduction of production let_mut_binding -> var_pattern EQ expr
##
interactive_expr: Match Bytes With UIdent ARROW If Bytes Then Attr Let Mut Ident EQ Bytes ZWSP
##
## Ends in an error in state: 742.
##
## let_mut_in_expr(base_cond) -> nseq(Attr) Let Mut let_mut_binding . In base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## let_mut_in_expr(closed_expr) -> nseq(Attr) Let Mut let_mut_binding . In closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let Mut let_mut_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 408, spurious reduction of production call_expr_level -> core_expr
## In state 428, spurious reduction of production unary_expr_level -> call_expr_level
## In state 386, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 417, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 423, spurious reduction of production add_expr_level -> mult_expr_level
## In state 470, spurious reduction of production cons_expr_level -> add_expr_level
## In state 457, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 494, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 501, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 510, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 455, spurious reduction of production tuple_expr_level -> disj_expr_level
## In state 414, spurious reduction of production ass_expr_level -> tuple_expr_level
## In state 525, spurious reduction of production base_expr(expr) -> ass_expr_level
## In state 523, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 524, spurious reduction of production expr -> base_cond__open(expr)
## In state 605, spurious reduction of production let_mut_binding -> var_pattern EQ expr
##
interactive_expr: Attr Let Mut Ident EQ Bytes ZWSP
##
## Ends in an error in state: 609.
##
## let_mut_in_expr(expr) -> nseq(Attr) Let Mut let_mut_binding . In expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let Mut let_mut_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 408, spurious reduction of production call_expr_level -> core_expr
## In state 428, spurious reduction of production unary_expr_level -> call_expr_level
## In state 386, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 417, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 423, spurious reduction of production add_expr_level -> mult_expr_level
## In state 470, spurious reduction of production cons_expr_level -> add_expr_level
## In state 457, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 494, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 501, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 510, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 455, spurious reduction of production tuple_expr_level -> disj_expr_level
## In state 414, spurious reduction of production ass_expr_level -> tuple_expr_level
## In state 525, spurious reduction of production base_expr(expr) -> ass_expr_level
## In state 523, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 524, spurious reduction of production expr -> base_cond__open(expr)
## In state 605, spurious reduction of production let_mut_binding -> var_pattern EQ expr
##
interactive_expr: Let Mut Ident EQ Bytes With
##
## Ends in an error in state: 1231.
##
## let_mut_in_expr(expr) -> Let Mut let_mut_binding . In expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let Mut let_mut_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 408, spurious reduction of production call_expr_level -> core_expr
## In state 428, spurious reduction of production unary_expr_level -> call_expr_level
## In state 386, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 417, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 423, spurious reduction of production add_expr_level -> mult_expr_level
## In state 470, spurious reduction of production cons_expr_level -> add_expr_level
## In state 457, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 494, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 501, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 510, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 455, spurious reduction of production tuple_expr_level -> disj_expr_level
## In state 414, spurious reduction of production ass_expr_level -> tuple_expr_level
## In state 525, spurious reduction of production base_expr(expr) -> ass_expr_level
## In state 523, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 524, spurious reduction of production expr -> base_cond__open(expr)
## In state 605, spurious reduction of production let_mut_binding -> var_pattern EQ expr
##

Ill-formed local value declaration.
At this point, if the expression of the left-hand side is complete,
the keyword 'in' is expected, followed by an expression.

interactive_expr: Begin Match UIdent With UIdent ARROW Let Rec With
##
## Ends in an error in state: 661.
##
## let_in_expr(base_cond) -> Let Rec . let_binding In base_cond [ VBAR ]
## let_in_sequence -> Let Rec . let_binding In series [ End Done ]
##
## The known suffix of the stack is as follows:
## Let Rec
##
interactive_expr: If UIdent Then Attr Let Rec With
##
## Ends in an error in state: 1136.
##
## let_in_expr(closed_expr) -> nseq(Attr) Let Rec . let_binding In closed_expr [ Else ]
## let_in_expr(expr) -> nseq(Attr) Let Rec . let_binding In expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let Rec
##
program: Attr Let Rec With
##
## Ends in an error in state: 1304.
##
## let_decl -> nseq(Attr) Let Rec . let_binding [ Type Module Let End EOF Directive Contract Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let Rec
##
interactive_expr: If UIdent Then Let Rec With
##
## Ends in an error in state: 1121.
##
## let_in_expr(closed_expr) -> Let Rec . let_binding In closed_expr [ Else ]
## let_in_expr(expr) -> Let Rec . let_binding In expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let Rec
##
interactive_expr: Begin Attr Let Rec With
##
## Ends in an error in state: 1021.
##
## let_in_sequence -> nseq(Attr) Let Rec . let_binding In series [ End Done ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let Rec
##
interactive_expr: Begin If UIdent Then Attr Let Rec With
##
## Ends in an error in state: 973.
##
## let_in_expr(closed_expr) -> nseq(Attr) Let Rec . let_binding In closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let Rec
##
interactive_expr: Begin If UIdent Then Let Rec With
##
## Ends in an error in state: 958.
##
## let_in_expr(closed_expr) -> Let Rec . let_binding In closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Let Rec
##
interactive_expr: Begin Let Rec With
##
## Ends in an error in state: 951.
##
## let_in_sequence -> Let Rec . let_binding In series [ End Done ]
##
## The known suffix of the stack is as follows:
## Let Rec
##
interactive_expr: Begin Match UIdent With UIdent ARROW Attr Let Rec With
##
## Ends in an error in state: 944.
##
## let_in_expr(base_cond) -> nseq(Attr) Let Rec . let_binding In base_cond [ VBAR ]
## let_in_sequence -> nseq(Attr) Let Rec . let_binding In series [ End Done ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let Rec
##
interactive_expr: Match UIdent With UIdent ARROW Attr Let Rec With
##
## Ends in an error in state: 896.
##
## let_in_expr(base_cond) -> nseq(Attr) Let Rec . let_binding In base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let Rec
##
interactive_expr: Match UIdent With UIdent ARROW Let Rec With
##
## Ends in an error in state: 879.
##
## let_in_expr(base_cond) -> Let Rec . let_binding In base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let Rec
##
interactive_expr: If UIdent Then Match UIdent With UIdent ARROW Attr Let Rec With
##
## Ends in an error in state: 811.
##
## let_in_expr(base_cond) -> nseq(Attr) Let Rec . let_binding In base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## let_in_expr(base_if_then_else) -> nseq(Attr) Let Rec . let_binding In base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let Rec
##
interactive_expr: Match UIdent With UIdent ARROW If UIdent Then Attr Let Rec With
##
## Ends in an error in state: 706.
##
## let_in_expr(base_cond) -> nseq(Attr) Let Rec . let_binding In base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## let_in_expr(closed_expr) -> nseq(Attr) Let Rec . let_binding In closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let Rec
##
program: Let Rec With
##
## Ends in an error in state: 1265.
##
## let_decl -> Let Rec . let_binding [ Type Module Let End EOF Directive Contract Attr ]
##
## The known suffix of the stack is as follows:
## Let Rec
##
interactive_expr: Let Rec With
##
## Ends in an error in state: 148.
##
## let_in_expr(expr) -> Let Rec . let_binding In expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let Rec
##
interactive_expr: Attr Let Rec With
##
## Ends in an error in state: 420.
##
## let_in_expr(expr) -> nseq(Attr) Let Rec . let_binding In expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let Rec
##
interactive_expr: If UIdent Then Match UIdent With UIdent ARROW Let Rec With
##
## Ends in an error in state: 674.
##
## let_in_expr(base_cond) -> Let Rec . let_binding In base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## let_in_expr(base_if_then_else) -> Let Rec . let_binding In base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## Let Rec
##
interactive_expr: Match UIdent With UIdent ARROW If UIdent Then Let Rec With
##
## Ends in an error in state: 690.
##
## let_in_expr(base_cond) -> Let Rec . let_binding In base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## let_in_expr(closed_expr) -> Let Rec . let_binding In closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Let Rec
##

Ill-formed recursive value declaration.
At this point, a variable is expected.

program: Attr Let With
##
## Ends in an error in state: 1324.
##
## let_decl -> nseq(Attr) Let . let_binding [ Type Module Let End EOF Directive Contract Attr ]
## let_decl -> nseq(Attr) Let . Rec let_binding [ Type Module Let End EOF Directive Contract Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let
##
interactive_expr: If UIdent Then Attr Let With
##
## Ends in an error in state: 1135.
##
## let_in_expr(closed_expr) -> nseq(Attr) Let . let_binding In closed_expr [ Else ]
## let_in_expr(closed_expr) -> nseq(Attr) Let . Rec let_binding In closed_expr [ Else ]
## let_in_expr(expr) -> nseq(Attr) Let . let_binding In expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## let_in_expr(expr) -> nseq(Attr) Let . Rec let_binding In expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## let_mut_in_expr(closed_expr) -> nseq(Attr) Let . Mut let_mut_binding In closed_expr [ Else ]
## let_mut_in_expr(expr) -> nseq(Attr) Let . Mut let_mut_binding In expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let
##
interactive_expr: If UIdent Then Let With
##
## Ends in an error in state: 1120.
##
## let_in_expr(closed_expr) -> Let . let_binding In closed_expr [ Else ]
## let_in_expr(closed_expr) -> Let . Rec let_binding In closed_expr [ Else ]
## let_in_expr(expr) -> Let . let_binding In expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## let_in_expr(expr) -> Let . Rec let_binding In expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## let_mut_in_expr(closed_expr) -> Let . Mut let_mut_binding In closed_expr [ Else ]
## let_mut_in_expr(expr) -> Let . Mut let_mut_binding In expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let
##
interactive_expr: Begin Attr Let With
##
## Ends in an error in state: 1020.
##
## let_in_sequence -> nseq(Attr) Let . let_binding In series [ End Done ]
## let_in_sequence -> nseq(Attr) Let . Rec let_binding In series [ End Done ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let
##
interactive_expr: Begin If UIdent Then Attr Let With
##
## Ends in an error in state: 972.
##
## let_in_expr(closed_expr) -> nseq(Attr) Let . let_binding In closed_expr [ Else ]
## let_in_expr(closed_expr) -> nseq(Attr) Let . Rec let_binding In closed_expr [ Else ]
## let_mut_in_expr(closed_expr) -> nseq(Attr) Let . Mut let_mut_binding In closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let
##
interactive_expr: Begin If UIdent Then Let With
##
## Ends in an error in state: 957.
##
## let_in_expr(closed_expr) -> Let . let_binding In closed_expr [ Else ]
## let_in_expr(closed_expr) -> Let . Rec let_binding In closed_expr [ Else ]
## let_mut_in_expr(closed_expr) -> Let . Mut let_mut_binding In closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Let
##
interactive_expr: Begin Let With
##
## Ends in an error in state: 950.
##
## let_in_sequence -> Let . let_binding In series [ End Done ]
## let_in_sequence -> Let . Rec let_binding In series [ End Done ]
##
## The known suffix of the stack is as follows:
## Let
##
interactive_expr: Begin Match UIdent With UIdent ARROW Attr Let With
##
## Ends in an error in state: 943.
##
## let_in_expr(base_cond) -> nseq(Attr) Let . let_binding In base_cond [ VBAR ]
## let_in_expr(base_cond) -> nseq(Attr) Let . Rec let_binding In base_cond [ VBAR ]
## let_in_sequence -> nseq(Attr) Let . let_binding In series [ End Done ]
## let_in_sequence -> nseq(Attr) Let . Rec let_binding In series [ End Done ]
## let_mut_in_expr(base_cond) -> nseq(Attr) Let . Mut let_mut_binding In base_cond [ VBAR ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let
##
interactive_expr: Match UIdent With UIdent ARROW Attr Let With
##
## Ends in an error in state: 895.
##
## let_in_expr(base_cond) -> nseq(Attr) Let . let_binding In base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## let_in_expr(base_cond) -> nseq(Attr) Let . Rec let_binding In base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## let_mut_in_expr(base_cond) -> nseq(Attr) Let . Mut let_mut_binding In base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let
##
interactive_expr: If UIdent Then Match UIdent With UIdent ARROW Attr Let With
##
## Ends in an error in state: 810.
##
## let_in_expr(base_cond) -> nseq(Attr) Let . let_binding In base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## let_in_expr(base_cond) -> nseq(Attr) Let . Rec let_binding In base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## let_in_expr(base_if_then_else) -> nseq(Attr) Let . let_binding In base_if_then_else [ Else ]
## let_in_expr(base_if_then_else) -> nseq(Attr) Let . Rec let_binding In base_if_then_else [ Else ]
## let_mut_in_expr(base_cond) -> nseq(Attr) Let . Mut let_mut_binding In base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## let_mut_in_expr(base_if_then_else) -> nseq(Attr) Let . Mut let_mut_binding In base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let
##
interactive_expr: Match UIdent With UIdent ARROW Let With
##
## Ends in an error in state: 878.
##
## let_in_expr(base_cond) -> Let . let_binding In base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## let_in_expr(base_cond) -> Let . Rec let_binding In base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## let_mut_in_expr(base_cond) -> Let . Mut let_mut_binding In base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let
##
interactive_expr: Match UIdent With UIdent ARROW If UIdent Then Attr Let With
##
## Ends in an error in state: 705.
##
## let_in_expr(base_cond) -> nseq(Attr) Let . let_binding In base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## let_in_expr(base_cond) -> nseq(Attr) Let . Rec let_binding In base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## let_in_expr(closed_expr) -> nseq(Attr) Let . let_binding In closed_expr [ Else ]
## let_in_expr(closed_expr) -> nseq(Attr) Let . Rec let_binding In closed_expr [ Else ]
## let_mut_in_expr(base_cond) -> nseq(Attr) Let . Mut let_mut_binding In base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## let_mut_in_expr(closed_expr) -> nseq(Attr) Let . Mut let_mut_binding In closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let
##
interactive_expr: Match UIdent With UIdent ARROW If UIdent Then Let With
##
## Ends in an error in state: 689.
##
## let_in_expr(base_cond) -> Let . let_binding In base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## let_in_expr(base_cond) -> Let . Rec let_binding In base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## let_in_expr(closed_expr) -> Let . let_binding In closed_expr [ Else ]
## let_in_expr(closed_expr) -> Let . Rec let_binding In closed_expr [ Else ]
## let_mut_in_expr(base_cond) -> Let . Mut let_mut_binding In base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## let_mut_in_expr(closed_expr) -> Let . Mut let_mut_binding In closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Let
##
interactive_expr: Let With
##
## Ends in an error in state: 146.
##
## let_in_expr(expr) -> Let . let_binding In expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## let_in_expr(expr) -> Let . Rec let_binding In expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## let_mut_in_expr(expr) -> Let . Mut let_mut_binding In expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let
##
program: Let With
##
## Ends in an error in state: 131.
##
## let_decl -> Let . let_binding [ Type Module Let End EOF Directive Contract Attr ]
## let_decl -> Let . Rec let_binding [ Type Module Let End EOF Directive Contract Attr ]
##
## The known suffix of the stack is as follows:
## Let
##
interactive_expr: Attr Let With
##
## Ends in an error in state: 419.
##
## let_in_expr(expr) -> nseq(Attr) Let . let_binding In expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## let_in_expr(expr) -> nseq(Attr) Let . Rec let_binding In expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## let_mut_in_expr(expr) -> nseq(Attr) Let . Mut let_mut_binding In expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let
##
interactive_expr: Begin Match UIdent With UIdent ARROW Let With
##
## Ends in an error in state: 660.
##
## let_in_expr(base_cond) -> Let . let_binding In base_cond [ VBAR ]
## let_in_expr(base_cond) -> Let . Rec let_binding In base_cond [ VBAR ]
## let_in_sequence -> Let . let_binding In series [ End Done ]
## let_in_sequence -> Let . Rec let_binding In series [ End Done ]
## let_mut_in_expr(base_cond) -> Let . Mut let_mut_binding In base_cond [ VBAR ]
##
## The known suffix of the stack is as follows:
## Let
##
interactive_expr: If UIdent Then Match UIdent With UIdent ARROW Let With
##
## Ends in an error in state: 673.
##
## let_in_expr(base_cond) -> Let . let_binding In base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## let_in_expr(base_cond) -> Let . Rec let_binding In base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## let_in_expr(base_if_then_else) -> Let . let_binding In base_if_then_else [ Else ]
## let_in_expr(base_if_then_else) -> Let . Rec let_binding In base_if_then_else [ Else ]
## let_mut_in_expr(base_cond) -> Let . Mut let_mut_binding In base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## let_mut_in_expr(base_if_then_else) -> Let . Mut let_mut_binding In base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## Let
##

Ill-formed value declaration.
At this point, one of the following is expected:
  * a pattern, e.g. an identifier;
  * the keyword 'rec' if defining a recursive function.

interactive_expr: Begin If Verbatim Then Match Verbatim Type
##
## Ends in an error in state: 681.
##
## try_or_match_expr(base_if_then_else) -> Match expr . With option(VBAR) cases(base_if_then_else) [ Else ]
##
## The known suffix of the stack is as follows:
## Match expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 408, spurious reduction of production call_expr_level -> core_expr
## In state 428, spurious reduction of production unary_expr_level -> call_expr_level
## In state 386, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 417, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 423, spurious reduction of production add_expr_level -> mult_expr_level
## In state 470, spurious reduction of production cons_expr_level -> add_expr_level
## In state 457, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 494, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 501, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 510, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 455, spurious reduction of production tuple_expr_level -> disj_expr_level
## In state 414, spurious reduction of production ass_expr_level -> tuple_expr_level
## In state 525, spurious reduction of production base_expr(expr) -> ass_expr_level
## In state 523, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 524, spurious reduction of production expr -> base_cond__open(expr)
##
interactive_expr: Begin Match Verbatim Type
##
## Ends in an error in state: 650.
##
## try_or_match_expr(last_expr) -> Match expr . With option(VBAR) cases(last_expr) [ End Done ]
##
## The known suffix of the stack is as follows:
## Match expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 408, spurious reduction of production call_expr_level -> core_expr
## In state 428, spurious reduction of production unary_expr_level -> call_expr_level
## In state 386, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 417, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 423, spurious reduction of production add_expr_level -> mult_expr_level
## In state 470, spurious reduction of production cons_expr_level -> add_expr_level
## In state 457, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 494, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 501, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 510, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 455, spurious reduction of production tuple_expr_level -> disj_expr_level
## In state 414, spurious reduction of production ass_expr_level -> tuple_expr_level
## In state 525, spurious reduction of production base_expr(expr) -> ass_expr_level
## In state 523, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 524, spurious reduction of production expr -> base_cond__open(expr)
##
interactive_expr: Match Verbatim Type
##
## Ends in an error in state: 1248.
##
## try_or_match_expr(base_cond) -> Match expr . With option(VBAR) cases(base_cond) [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## Match expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 408, spurious reduction of production call_expr_level -> core_expr
## In state 428, spurious reduction of production unary_expr_level -> call_expr_level
## In state 386, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 417, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 423, spurious reduction of production add_expr_level -> mult_expr_level
## In state 470, spurious reduction of production cons_expr_level -> add_expr_level
## In state 457, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 494, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 501, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 510, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 455, spurious reduction of production tuple_expr_level -> disj_expr_level
## In state 414, spurious reduction of production ass_expr_level -> tuple_expr_level
## In state 525, spurious reduction of production base_expr(expr) -> ass_expr_level
## In state 523, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 524, spurious reduction of production expr -> base_cond__open(expr)
##
interactive_expr: If Verbatim Then Match Verbatim Type
##
## Ends in an error in state: 1116.
##
## try_or_match_expr(base_cond) -> Match expr . With option(VBAR) cases(base_cond) [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## try_or_match_expr(base_if_then_else) -> Match expr . With option(VBAR) cases(base_if_then_else) [ Else ]
##
## The known suffix of the stack is as follows:
## Match expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 408, spurious reduction of production call_expr_level -> core_expr
## In state 428, spurious reduction of production unary_expr_level -> call_expr_level
## In state 386, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 417, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 423, spurious reduction of production add_expr_level -> mult_expr_level
## In state 470, spurious reduction of production cons_expr_level -> add_expr_level
## In state 457, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 494, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 501, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 510, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 455, spurious reduction of production tuple_expr_level -> disj_expr_level
## In state 414, spurious reduction of production ass_expr_level -> tuple_expr_level
## In state 525, spurious reduction of production base_expr(expr) -> ass_expr_level
## In state 523, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 524, spurious reduction of production expr -> base_cond__open(expr)
##

Ill-formed pattern matching expression.
At this point, if the matchee expression is complete, then the keyword 'with'
is expected, followed by matching cases.

interactive_expr: Begin Match Verbatim With WILD ARROW Verbatim With
##
## Ends in an error in state: 654.
##
## cases(base_cond) -> cases(base_cond) . VBAR case_clause(base_cond) [ VBAR ]
## cases(last_expr) -> cases(base_cond) . VBAR case_clause(last_expr) [ End Done ]
##
## The known suffix of the stack is as follows:
## cases(base_cond)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 408, spurious reduction of production call_expr_level -> core_expr
## In state 428, spurious reduction of production unary_expr_level -> call_expr_level
## In state 386, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 417, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 423, spurious reduction of production add_expr_level -> mult_expr_level
## In state 470, spurious reduction of production cons_expr_level -> add_expr_level
## In state 457, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 494, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 501, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 510, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 455, spurious reduction of production tuple_expr_level -> disj_expr_level
## In state 414, spurious reduction of production ass_expr_level -> tuple_expr_level
## In state 935, spurious reduction of production base_expr(base_cond) -> ass_expr_level
## In state 733, spurious reduction of production base_cond__open(base_cond) -> base_expr(base_cond)
## In state 734, spurious reduction of production base_cond -> base_cond__open(base_cond)
## In state 874, spurious reduction of production case_clause(base_cond) -> pattern ARROW base_cond
## In state 659, spurious reduction of production cases(base_cond) -> case_clause(base_cond)
##
interactive_expr: Begin If Verbatim Then Match Verbatim With WILD ARROW Bytes With
##
## Ends in an error in state: 685.
##
## cases(base_cond) -> cases(base_cond) . VBAR case_clause(base_cond) [ VBAR ]
## cases(base_if_then_else) -> cases(base_cond) . VBAR case_clause(base_if_then_else) [ Else ]
##
## The known suffix of the stack is as follows:
## cases(base_cond)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 408, spurious reduction of production call_expr_level -> core_expr
## In state 428, spurious reduction of production unary_expr_level -> call_expr_level
## In state 386, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 417, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 423, spurious reduction of production add_expr_level -> mult_expr_level
## In state 470, spurious reduction of production cons_expr_level -> add_expr_level
## In state 457, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 494, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 501, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 510, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 455, spurious reduction of production tuple_expr_level -> disj_expr_level
## In state 414, spurious reduction of production ass_expr_level -> tuple_expr_level
## In state 829, spurious reduction of production base_expr(base_cond) -> ass_expr_level
## In state 733, spurious reduction of production base_cond__open(base_cond) -> base_expr(base_cond)
## In state 734, spurious reduction of production base_cond -> base_cond__open(base_cond)
## In state 874, spurious reduction of production case_clause(base_cond) -> pattern ARROW base_cond
## In state 659, spurious reduction of production cases(base_cond) -> case_clause(base_cond)
##

Ill-formed pattern matching expression.
At this point, if the case is complete, a vertical bar '|' is
expected, followed by another case starting with a pattern.

interactive_expr: Match Verbatim With WILD CONS Bytes SEMI
##
## Ends in an error in state: 1251.
##
## case_clause(base_cond) -> pattern . ARROW base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## pattern
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 354, spurious reduction of production cons_pattern_level -> core_pattern
## In state 356, spurious reduction of production cons_pattern_level -> core_pattern CONS cons_pattern_level
## In state 370, spurious reduction of production pattern -> cons_pattern_level
##
interactive_expr: Begin Match Verbatim With WILD RPAR
##
## Ends in an error in state: 647.
##
## case_clause(base_cond) -> pattern . ARROW base_cond [ VBAR ]
## case_clause(last_expr) -> pattern . ARROW last_expr [ End Done ]
##
## The known suffix of the stack is as follows:
## pattern
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 354, spurious reduction of production cons_pattern_level -> core_pattern
## In state 370, spurious reduction of production pattern -> cons_pattern_level
##
interactive_expr: If Verbatim Then Match Verbatim With WILD RPAR
##
## Ends in an error in state: 671.
##
## case_clause(base_cond) -> pattern . ARROW base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## case_clause(base_if_then_else) -> pattern . ARROW base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## pattern
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 354, spurious reduction of production cons_pattern_level -> core_pattern
## In state 370, spurious reduction of production pattern -> cons_pattern_level
##

Ill-formed pattern matching expression.
At this point, if the pattern is complete, an arrow '->' is expected,
followed by an expression.

interactive_expr: Begin If Verbatim Then Match Verbatim With With
##
## Ends in an error in state: 682.
##
## try_or_match_expr(base_if_then_else) -> Match expr With . option(VBAR) cases(base_if_then_else) [ Else ]
##
## The known suffix of the stack is as follows:
## Match expr With
##
interactive_expr: Begin Match Verbatim With With
##
## Ends in an error in state: 651.
##
## try_or_match_expr(last_expr) -> Match expr With . option(VBAR) cases(last_expr) [ End Done ]
##
## The known suffix of the stack is as follows:
## Match expr With
##
interactive_expr: If Verbatim Then Match Verbatim With With
##
## Ends in an error in state: 1117.
##
## try_or_match_expr(base_cond) -> Match expr With . option(VBAR) cases(base_cond) [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## try_or_match_expr(base_if_then_else) -> Match expr With . option(VBAR) cases(base_if_then_else) [ Else ]
##
## The known suffix of the stack is as follows:
## Match expr With
##
interactive_expr: Match Verbatim With With
##
## Ends in an error in state: 1249.
##
## try_or_match_expr(base_cond) -> Match expr With . option(VBAR) cases(base_cond) [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## Match expr With
##

Ill-formed pattern matching expression.
At this point, the first case is expected to start with a pattern or a
vertical bar.

interactive_expr: Begin UIdent SEMI With
##
## Ends in an error in state: 949.
##
## series -> seq_expr SEMI . series [ End Done ]
##
## The known suffix of the stack is as follows:
## seq_expr SEMI
##

Ill-formed sequence of expressions.
At this point, an expression is expected.
Note: The last expression in a sequence cannot be terminated by a
semicolon ';'.

interactive_expr: Begin Verbatim With
##
## Ends in an error in state: 948.
##
## last_expr -> seq_expr . [ End Done ]
## series -> seq_expr . SEMI series [ End Done ]
##
## The known suffix of the stack is as follows:
## seq_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 408, spurious reduction of production call_expr_level -> core_expr
## In state 428, spurious reduction of production unary_expr_level -> call_expr_level
## In state 386, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 417, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 423, spurious reduction of production add_expr_level -> mult_expr_level
## In state 470, spurious reduction of production cons_expr_level -> add_expr_level
## In state 457, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 494, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 501, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 510, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 455, spurious reduction of production tuple_expr_level -> disj_expr_level
## In state 414, spurious reduction of production ass_expr_level -> tuple_expr_level
## In state 1014, spurious reduction of production seq_expr -> ass_expr_level
##

Ill-formed sequence of expressions.
At this point, if the expression is complete, one of the following is
expected:
  * a semicolon ';' followed by another expression;
  * the keyword 'end' if the sequence is complete.

interactive_expr: UIdent DOT With
##
## Ends in an error in state: 5.
##
## module_access_e -> UIdent DOT . module_var_e [ With Verbatim VBAR UIdent Type To Then TIMES String SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Lxor Lsr Lsl Lor Let Lang Land LT LPAR LE LBRACKET LBRACE Int In Ident GT End Else EQ EOF EIdent Downto Done Do Directive Contract CONS COMMA COLON CARET Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## UIdent DOT
##

Ill-formed selection of a value from a module.
At this point, the qualified name of a value is expected.

program: Type Ident EQ UIdent DOT With
##
## Ends in an error in state: 32.
##
## module_access_t -> UIdent DOT . module_var_t [ VBAR Type TIMES SEMI RPAR RBRACE Module Let In Ident End EQ EOF EIdent Directive Contract COMMA Attr ARROW ]
##
## The known suffix of the stack is as follows:
## UIdent DOT
##

Ill-formed selection of a type in a module.
At this point, the qualified name of a type is expected.

interactive_expr: UIdent DOT Ident DOT With
##
## Ends in an error in state: 405.
##
## projection -> gen_ident DOT . nsepseq(selection,DOT) [ With Verbatim VBAR UIdent Type To Then TIMES String SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Lxor Lsr Lsl Lor Let Lang Land LT LPAR LE LBRACKET LBRACE Int In Ident GT End Else EQ EOF EIdent Downto Done Do Directive Contract CONS COMMA COLON CARET Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## gen_ident DOT
##
interactive_expr: Ident DOT Int DOT With
##
## Ends in an error in state: 397.
##
## nsepseq(selection,DOT) -> selection DOT . nsepseq(selection,DOT) [ With Verbatim VBAR UIdent Type To Then TIMES String SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Lxor Lsr Lsl Lor Let Lang Land LT LPAR LE LBRACKET LBRACE Int In Ident GT End Else EQ EOF EIdent Downto Done Do Directive Contract CONS COMMA COLON CARET Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## selection DOT
##

Ill-formed selection in a record or a tuple.
At this point, one of the following is expected:
  * the name of a record field;
  * the index of a component in a tuple, '0' denoting the first
    component.

interactive_expr: LBRACE Ident DOT Ident Verbatim
##
## Ends in an error in state: 273.
##
## update_record -> LBRACE path . With sep_or_term_list(field_path_assignment,SEMI) RBRACE [ With Verbatim VBAR UIdent Type To Then TIMES String SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Lxor Lsr Lsl Lor Let Lang Land LT LPAR LE LBRACKET LBRACE Int In Ident GT End Else EQ EOF EIdent Downto Done Do Directive Contract CONS COMMA COLON CARET Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## LBRACE path
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 396, spurious reduction of production nsepseq(selection,DOT) -> selection
## In state 406, spurious reduction of production projection -> gen_ident DOT nsepseq(selection,DOT)
## In state 272, spurious reduction of production path -> projection
##

Ill-formed record update.
At this point, if the record is fully qualified, then the keyword
'with' is expected, followed by field updates (assignments) separated
by semicolons ';'.

interactive_expr: LBRACE Ident EQ Bytes SEMI Ident EQ Bytes SEMI With
##
## Ends in an error in state: 1203.
##
## nsepseq(field_assignment,SEMI) -> field_assignment SEMI . nsepseq(field_assignment,SEMI) [ RBRACE ]
## seq(__anonymous_0(field_assignment,SEMI)) -> field_assignment SEMI . seq(__anonymous_0(field_assignment,SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_assignment SEMI
##
interactive_expr: LBRACE Ident EQ Bytes SEMI With
##
## Ends in an error in state: 1198.
##
## nsepseq(field_assignment,SEMI) -> field_assignment SEMI . nsepseq(field_assignment,SEMI) [ RBRACE ]
## nseq(__anonymous_0(field_assignment,SEMI)) -> field_assignment SEMI . seq(__anonymous_0(field_assignment,SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_assignment SEMI
##

Ill-formed record expression.
At this point, more field assignments are expected, separated by
semicolons ';'.

interactive_expr: LBRACE Ident EQ Bytes SEMI Ident EQ Bytes With
##
## Ends in an error in state: 1202.
##
## nsepseq(field_assignment,SEMI) -> field_assignment . [ RBRACE ]
## nsepseq(field_assignment,SEMI) -> field_assignment . SEMI nsepseq(field_assignment,SEMI) [ RBRACE ]
## seq(__anonymous_0(field_assignment,SEMI)) -> field_assignment . SEMI seq(__anonymous_0(field_assignment,SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_assignment
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 408, spurious reduction of production call_expr_level -> core_expr
## In state 428, spurious reduction of production unary_expr_level -> call_expr_level
## In state 386, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 417, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 423, spurious reduction of production add_expr_level -> mult_expr_level
## In state 470, spurious reduction of production cons_expr_level -> add_expr_level
## In state 457, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 494, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 501, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 510, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 455, spurious reduction of production tuple_expr_level -> disj_expr_level
## In state 414, spurious reduction of production ass_expr_level -> tuple_expr_level
## In state 525, spurious reduction of production base_expr(expr) -> ass_expr_level
## In state 523, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 524, spurious reduction of production expr -> base_cond__open(expr)
## In state 1196, spurious reduction of production field_assignment -> gen_ident EQ expr
##
interactive_expr: LBRACE Ident EQ Bytes With
##
## Ends in an error in state: 1197.
##
## nsepseq(field_assignment,SEMI) -> field_assignment . [ RBRACE ]
## nsepseq(field_assignment,SEMI) -> field_assignment . SEMI nsepseq(field_assignment,SEMI) [ RBRACE ]
## nseq(__anonymous_0(field_assignment,SEMI)) -> field_assignment . SEMI seq(__anonymous_0(field_assignment,SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_assignment
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 408, spurious reduction of production call_expr_level -> core_expr
## In state 428, spurious reduction of production unary_expr_level -> call_expr_level
## In state 386, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 417, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 423, spurious reduction of production add_expr_level -> mult_expr_level
## In state 470, spurious reduction of production cons_expr_level -> add_expr_level
## In state 457, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 494, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 501, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 510, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 455, spurious reduction of production tuple_expr_level -> disj_expr_level
## In state 414, spurious reduction of production ass_expr_level -> tuple_expr_level
## In state 525, spurious reduction of production base_expr(expr) -> ass_expr_level
## In state 523, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 524, spurious reduction of production expr -> base_cond__open(expr)
## In state 1196, spurious reduction of production field_assignment -> gen_ident EQ expr
##

Ill-formed record expression.
At this point, if the expression assigned to the field is complete,
one of the following is expected:
  * a semicolon ';' followed by another field assignment;
  * a closing brace '}' if the record is complete.

interactive_expr: LBRACE Ident With Ident EQ Bytes SEMI Ident EQ Bytes With
##
## Ends in an error in state: 1189.
##
## nsepseq(field_path_assignment,SEMI) -> field_path_assignment . [ RBRACE ]
## nsepseq(field_path_assignment,SEMI) -> field_path_assignment . SEMI nsepseq(field_path_assignment,SEMI) [ RBRACE ]
## seq(__anonymous_0(field_path_assignment,SEMI)) -> field_path_assignment . SEMI seq(__anonymous_0(field_path_assignment,SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_path_assignment
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 408, spurious reduction of production call_expr_level -> core_expr
## In state 428, spurious reduction of production unary_expr_level -> call_expr_level
## In state 386, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 417, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 423, spurious reduction of production add_expr_level -> mult_expr_level
## In state 470, spurious reduction of production cons_expr_level -> add_expr_level
## In state 457, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 494, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 501, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 510, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 455, spurious reduction of production tuple_expr_level -> disj_expr_level
## In state 414, spurious reduction of production ass_expr_level -> tuple_expr_level
## In state 525, spurious reduction of production base_expr(expr) -> ass_expr_level
## In state 523, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 524, spurious reduction of production expr -> base_cond__open(expr)
## In state 1180, spurious reduction of production field_path_assignment -> path EQ expr
##
interactive_expr: LBRACE Ident With Ident EQ Bytes With
##
## Ends in an error in state: 1185.
##
## nsepseq(field_path_assignment,SEMI) -> field_path_assignment . [ RBRACE ]
## nsepseq(field_path_assignment,SEMI) -> field_path_assignment . SEMI nsepseq(field_path_assignment,SEMI) [ RBRACE ]
## nseq(__anonymous_0(field_path_assignment,SEMI)) -> field_path_assignment . SEMI seq(__anonymous_0(field_path_assignment,SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_path_assignment
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 408, spurious reduction of production call_expr_level -> core_expr
## In state 428, spurious reduction of production unary_expr_level -> call_expr_level
## In state 386, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 417, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 423, spurious reduction of production add_expr_level -> mult_expr_level
## In state 470, spurious reduction of production cons_expr_level -> add_expr_level
## In state 457, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 494, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 501, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 510, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 455, spurious reduction of production tuple_expr_level -> disj_expr_level
## In state 414, spurious reduction of production ass_expr_level -> tuple_expr_level
## In state 525, spurious reduction of production base_expr(expr) -> ass_expr_level
## In state 523, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 524, spurious reduction of production expr -> base_cond__open(expr)
## In state 1180, spurious reduction of production field_path_assignment -> path EQ expr
##

Ill-formed record update.
At this point, if the expression assigned to the field (update) is
complete, one of the following is expected:
  * a semicolon ';' followed by another field assignment;
  * a closing brace '}' if the update is complete.

interactive_expr: LBRACE Ident EQ Bytes SEMI Ident With
##
## Ends in an error in state: 1201.
##
## field_assignment -> gen_ident . [ SEMI RBRACE ]
## field_assignment -> gen_ident . EQ expr [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## gen_ident
##

Ill-formed assignment to a field in a record.
At this point, one of the following is expected:
  * an assignment symbol '=', followed by an expression;
  * a semicolon ';', followed by another assignment;
  * a closing brace, if the assignments are complete.

interactive_expr: LBRACE Ident WILD
##
## Ends in an error in state: 1194.
##
## field_assignment -> gen_ident . [ SEMI RBRACE ]
## field_assignment -> gen_ident . EQ expr [ SEMI RBRACE ]
## path -> gen_ident . [ With ]
## projection -> gen_ident . DOT nsepseq(selection,DOT) [ With ]
##
## The known suffix of the stack is as follows:
## gen_ident
##

Ill-formed record expression or record update.
At this point, one of the following is expected:
  * a semicolon ';', followed by another assignment;
  * the assignment symbol '=' followed by an expression, if defining
    a record (as opposed to a record update);
  * the keyword 'with' followed by field updates (assignments);
  * the selection symbol '.' if the record to update is not fully
    qualified.
  * a closing brace, if the record is complete.

interactive_expr: LBRACE Ident With Ident DOT Ident With
##
## Ends in an error in state: 277.
##
## field_path_assignment -> path . EQ expr [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## path
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 396, spurious reduction of production nsepseq(selection,DOT) -> selection
## In state 406, spurious reduction of production projection -> gen_ident DOT nsepseq(selection,DOT)
## In state 272, spurious reduction of production path -> projection
##

Ill-formed record update.
At this point, if the field path is complete then the assignment symbol '=' is expected,
followed by an expression (update).

interactive_expr: LBRACE Ident With Ident EQ Bytes SEMI Ident EQ Bytes SEMI With
##
## Ends in an error in state: 1190.
##
## nsepseq(field_path_assignment,SEMI) -> field_path_assignment SEMI . nsepseq(field_path_assignment,SEMI) [ RBRACE ]
## seq(__anonymous_0(field_path_assignment,SEMI)) -> field_path_assignment SEMI . seq(__anonymous_0(field_path_assignment,SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_path_assignment SEMI
##
interactive_expr: LBRACE Ident With Ident EQ Bytes SEMI With
##
## Ends in an error in state: 1186.
##
## nsepseq(field_path_assignment,SEMI) -> field_path_assignment SEMI . nsepseq(field_path_assignment,SEMI) [ RBRACE ]
## nseq(__anonymous_0(field_path_assignment,SEMI)) -> field_path_assignment SEMI . seq(__anonymous_0(field_path_assignment,SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_path_assignment SEMI
##

Ill-formed record update.
At this point, more field assignments (updates) are expected,
separated by semicolons ';'.

interactive_expr: LBRACE Ident With Ident With
##
## Ends in an error in state: 1184.
##
## field_path_assignment -> gen_ident . [ SEMI RBRACE ]
## path -> gen_ident . [ EQ ]
## projection -> gen_ident . DOT nsepseq(selection,DOT) [ EQ ]
##
## The known suffix of the stack is as follows:
## gen_ident
##

Ill-formed record update.
At this point, one of the following is expected:
  * the assignment symbol '=' if the field to update is fully
    qualified;
  * the selection symbol '.' to further qualify the field to update.
  * a semicolon, followed by another assignment;
  * a closing brace '}', if the update is complete.

interactive_expr: LBRACE Ident With With
##
## Ends in an error in state: 274.
##
## update_record -> LBRACE path With . sep_or_term_list(field_path_assignment,SEMI) RBRACE [ With Verbatim VBAR UIdent Type To Then TIMES String SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Lxor Lsr Lsl Lor Let Lang Land LT LPAR LE LBRACKET LBRACE Int In Ident GT End Else EQ EOF EIdent Downto Done Do Directive Contract CONS COMMA COLON CARET Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## LBRACE path With
##

Ill-formed record update.
At this point, assignments to fields (updates) are expected, separated
by semicolons ';' and each starting with fully qualified field names.

interactive_expr: LBRACE With
##
## Ends in an error in state: 269.
##
## record_expr -> LBRACE . sep_or_term_list(field_assignment,SEMI) RBRACE [ With Verbatim VBAR UIdent Type To Then TIMES String SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Lxor Lsr Lsl Lor Let Lang Land LT LPAR LE LBRACKET LBRACE Int In Ident GT End Else EQ EOF EIdent Downto Done Do Directive Contract CONS COMMA COLON CARET Bytes Begin BOOL_OR BOOL_AND Attr ]
## update_record -> LBRACE . path With sep_or_term_list(field_path_assignment,SEMI) RBRACE [ With Verbatim VBAR UIdent Type To Then TIMES String SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Lxor Lsr Lsl Lor Let Lang Land LT LPAR LE LBRACKET LBRACE Int In Ident GT End Else EQ EOF EIdent Downto Done Do Directive Contract CONS COMMA COLON CARET Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## LBRACE
##

Ill-formed record expression or update.
At this point, one of the following is expected:
  * field assignments separated by semicolons ';', if defining a record;
  * the qualified name of the record to update, otherwise.

interactive_expr: LBRACKET Verbatim SEMI Verbatim With
##
## Ends in an error in state: 1244.
##
## nsepseq(expr,SEMI) -> expr . [ RBRACKET ]
## nsepseq(expr,SEMI) -> expr . SEMI nsepseq(expr,SEMI) [ RBRACKET ]
## seq(__anonymous_0(expr,SEMI)) -> expr . SEMI seq(__anonymous_0(expr,SEMI)) [ RBRACKET ]
##
## The known suffix of the stack is as follows:
## expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 408, spurious reduction of production call_expr_level -> core_expr
## In state 428, spurious reduction of production unary_expr_level -> call_expr_level
## In state 386, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 417, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 423, spurious reduction of production add_expr_level -> mult_expr_level
## In state 470, spurious reduction of production cons_expr_level -> add_expr_level
## In state 457, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 494, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 501, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 510, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 455, spurious reduction of production tuple_expr_level -> disj_expr_level
## In state 414, spurious reduction of production ass_expr_level -> tuple_expr_level
## In state 525, spurious reduction of production base_expr(expr) -> ass_expr_level
## In state 523, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 524, spurious reduction of production expr -> base_cond__open(expr)
##
interactive_expr: LBRACKET Verbatim With
##
## Ends in an error in state: 1240.
##
## nsepseq(expr,SEMI) -> expr . [ RBRACKET ]
## nsepseq(expr,SEMI) -> expr . SEMI nsepseq(expr,SEMI) [ RBRACKET ]
## nseq(__anonymous_0(expr,SEMI)) -> expr . SEMI seq(__anonymous_0(expr,SEMI)) [ RBRACKET ]
##
## The known suffix of the stack is as follows:
## expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 408, spurious reduction of production call_expr_level -> core_expr
## In state 428, spurious reduction of production unary_expr_level -> call_expr_level
## In state 386, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 417, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 423, spurious reduction of production add_expr_level -> mult_expr_level
## In state 470, spurious reduction of production cons_expr_level -> add_expr_level
## In state 457, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 494, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 501, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 510, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 455, spurious reduction of production tuple_expr_level -> disj_expr_level
## In state 414, spurious reduction of production ass_expr_level -> tuple_expr_level
## In state 525, spurious reduction of production base_expr(expr) -> ass_expr_level
## In state 523, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 524, spurious reduction of production expr -> base_cond__open(expr)
##

Ill-formed list of expressions.
At this point, if the list element is complete, one of the
following is expected:
  * a semicolon ';' followed by more elements as expressions;
  * a closing bracket ']' if the list is complete.

interactive_expr: LPAR Verbatim COLON Ident VBAR
##
## Ends in an error in state: 410.
##
## par(typed_expr) -> LPAR typed_expr . RPAR [ With Verbatim VBAR UIdent Type To Then TIMES String SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Lxor Lsr Lsl Lor Let Lang Land LT LPAR LE LBRACKET LBRACE Int In Ident GT End Else EQ EOF EIdent Downto Done Do Directive Contract CONS COMMA COLON CARET Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## LPAR typed_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 84, spurious reduction of production prod_type_level -> core_type
## In state 65, spurious reduction of production fun_type_level -> prod_type_level
## In state 83, spurious reduction of production type_expr -> fun_type_level
## In state 635, spurious reduction of production typed_expr -> expr COLON type_expr
##

Ill-formed typed expression.
At this point, if the type annotation is complete, then a closing
parenthesis ')' is expected.

interactive_expr: LPAR Verbatim With
##
## Ends in an error in state: 632.
##
## par(expr) -> LPAR expr . RPAR [ With Verbatim VBAR UIdent Type To Then TIMES String SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Lxor Lsr Lsl Lor Let Lang Land LT LPAR LE LBRACKET LBRACE Int In Ident GT End Else EQ EOF EIdent Downto Done Do Directive DOT Contract CONS COMMA COLON CARET Bytes Begin BOOL_OR BOOL_AND Attr ]
## typed_expr -> expr . COLON type_expr [ RPAR ]
##
## The known suffix of the stack is as follows:
## LPAR expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 408, spurious reduction of production call_expr_level -> core_expr
## In state 428, spurious reduction of production unary_expr_level -> call_expr_level
## In state 386, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 417, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 423, spurious reduction of production add_expr_level -> mult_expr_level
## In state 470, spurious reduction of production cons_expr_level -> add_expr_level
## In state 457, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 494, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 501, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 510, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 455, spurious reduction of production tuple_expr_level -> disj_expr_level
## In state 414, spurious reduction of production ass_expr_level -> tuple_expr_level
## In state 525, spurious reduction of production base_expr(expr) -> ass_expr_level
## In state 523, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 524, spurious reduction of production expr -> base_cond__open(expr)
##

Ill formed parenthesised expression.
At this point, if the expression is complete, one of the following is
expected:
  * a type annotation starting with a colon ':';
  * a closing parenthesis ')'.

interactive_expr: Lang Verbatim With
##
## Ends in an error in state: 1345.
##
## code_inj -> Lang expr . RBRACKET [ With Verbatim VBAR UIdent Type To Then TIMES String SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Lxor Lsr Lsl Lor Let Lang Land LT LPAR LE LBRACKET LBRACE Int In Ident GT End Else EQ EOF EIdent Downto Done Do Directive Contract CONS COMMA COLON CARET Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## Lang expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 408, spurious reduction of production call_expr_level -> core_expr
## In state 428, spurious reduction of production unary_expr_level -> call_expr_level
## In state 386, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 417, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 423, spurious reduction of production add_expr_level -> mult_expr_level
## In state 470, spurious reduction of production cons_expr_level -> add_expr_level
## In state 457, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 494, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 501, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 510, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 455, spurious reduction of production tuple_expr_level -> disj_expr_level
## In state 414, spurious reduction of production ass_expr_level -> tuple_expr_level
## In state 525, spurious reduction of production base_expr(expr) -> ass_expr_level
## In state 523, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 524, spurious reduction of production expr -> base_cond__open(expr)
##

Ill-formed code injection.
At this point, a closing bracket ']' is expected.

interactive_expr: MINUS With
##
## Ends in an error in state: 144.
##
## unary_expr_level -> MINUS . call_expr_level [ With VBAR Type To Then TIMES SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or NE Module Mod MINUS Lxor Lsr Lsl Lor Let Land LT LE In GT End Else EQ EOF Downto Done Do Directive Contract CONS COMMA COLON CARET BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## MINUS
##
interactive_expr: Not With
##
## Ends in an error in state: 121.
##
## unary_expr_level -> Not . call_expr_level [ With VBAR Type To Then TIMES SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or NE Module Mod MINUS Lxor Lsr Lsl Lor Let Land LT LE In GT End Else EQ EOF Downto Done Do Directive Contract CONS COMMA COLON CARET BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## Not
##
interactive_expr: Verbatim BOOL_AND With
##
## Ends in an error in state: 478.
##
## bin_op(conj_expr_level,BOOL_AND,comp_expr_level) -> conj_expr_level BOOL_AND . comp_expr_level [ With VBAR Type To Then SEMI RPAR REV_APP RBRACKET RBRACE Or Module Let In End Else EOF Downto Done Do Directive Contract COMMA COLON BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## conj_expr_level BOOL_AND
##
interactive_expr: Verbatim BOOL_OR With
##
## Ends in an error in state: 514.
##
## bin_op(disj_expr_level,BOOL_OR,conj_expr_level) -> disj_expr_level BOOL_OR . conj_expr_level [ With VBAR Type To Then SEMI RPAR REV_APP RBRACKET RBRACE Or Module Let In End Else EOF Downto Done Do Directive Contract COMMA COLON BOOL_OR Attr ]
##
## The known suffix of the stack is as follows:
## disj_expr_level BOOL_OR
##
interactive_expr: Verbatim Or With
##
## Ends in an error in state: 503.
##
## bin_op(disj_expr_level,Or,conj_expr_level) -> disj_expr_level Or . conj_expr_level [ With VBAR Type To Then SEMI RPAR REV_APP RBRACKET RBRACE Or Module Let In End Else EOF Downto Done Do Directive Contract COMMA COLON BOOL_OR Attr ]
##
## The known suffix of the stack is as follows:
## disj_expr_level Or
##
interactive_expr: Bytes REV_APP With
##
## Ends in an error in state: 456.
##
## bin_op(disj_expr_level,REV_APP,conj_expr_level) -> disj_expr_level REV_APP . conj_expr_level [ With VBAR Type To Then SEMI RPAR REV_APP RBRACKET RBRACE Or Module Let In End Else EOF Downto Done Do Directive Contract COMMA COLON BOOL_OR Attr ]
##
## The known suffix of the stack is as follows:
## disj_expr_level REV_APP
##
interactive_expr: Verbatim CARET With
##
## Ends in an error in state: 458.
##
## bin_op(cons_expr_level,CARET,cat_expr_level) -> cons_expr_level CARET . cat_expr_level [ With VBAR Type To Then SEMI RPAR REV_APP RBRACKET RBRACE Or NE Module Let LT LE In GT End Else EQ EOF Downto Done Do Directive Contract COMMA COLON BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## cons_expr_level CARET
##
interactive_expr: Verbatim EQ With
##
## Ends in an error in state: 490.
##
## bin_op(comp_expr_level,EQ,cat_expr_level) -> comp_expr_level EQ . cat_expr_level [ With VBAR Type To Then SEMI RPAR REV_APP RBRACKET RBRACE Or NE Module Let LT LE In GT End Else EQ EOF Downto Done Do Directive Contract COMMA COLON BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## comp_expr_level EQ
##
interactive_expr: Verbatim GT With
##
## Ends in an error in state: 486.
##
## bin_op(comp_expr_level,GT,cat_expr_level) -> comp_expr_level GT . cat_expr_level [ With VBAR Type To Then SEMI RPAR REV_APP RBRACKET RBRACE Or NE Module Let LT LE In GT End Else EQ EOF Downto Done Do Directive Contract COMMA COLON BOOL_OR BOOL_AND Attr ]
## ge -> GT . ZWSP EQ [ Verbatim UIdent String Originate Not Nat Mutez MINUS Lang LPAR LBRACKET LBRACE Int Ident EIdent Bytes Begin ]
##
## The known suffix of the stack is as follows:
## comp_expr_level GT
##
interactive_expr: Bytes GT ZWSP EQ ZWSP
##
## Ends in an error in state: 492.
##
## bin_op(comp_expr_level,ge,cat_expr_level) -> comp_expr_level ge . cat_expr_level [ With VBAR Type To Then SEMI RPAR REV_APP RBRACKET RBRACE Or NE Module Let LT LE In GT End Else EQ EOF Downto Done Do Directive Contract COMMA COLON BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## comp_expr_level ge
##
interactive_expr: Verbatim LE With
##
## Ends in an error in state: 484.
##
## bin_op(comp_expr_level,LE,cat_expr_level) -> comp_expr_level LE . cat_expr_level [ With VBAR Type To Then SEMI RPAR REV_APP RBRACKET RBRACE Or NE Module Let LT LE In GT End Else EQ EOF Downto Done Do Directive Contract COMMA COLON BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## comp_expr_level LE
##
interactive_expr: Verbatim LT With
##
## Ends in an error in state: 482.
##
## bin_op(comp_expr_level,LT,cat_expr_level) -> comp_expr_level LT . cat_expr_level [ With VBAR Type To Then SEMI RPAR REV_APP RBRACKET RBRACE Or NE Module Let LT LE In GT End Else EQ EOF Downto Done Do Directive Contract COMMA COLON BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## comp_expr_level LT
##
interactive_expr: Verbatim NE With
##
## Ends in an error in state: 480.
##
## bin_op(comp_expr_level,NE,cat_expr_level) -> comp_expr_level NE . cat_expr_level [ With VBAR Type To Then SEMI RPAR REV_APP RBRACKET RBRACE Or NE Module Let LT LE In GT End Else EQ EOF Downto Done Do Directive Contract COMMA COLON BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## comp_expr_level NE
##
interactive_expr: Verbatim MINUS With
##
## Ends in an error in state: 473.
##
## bin_op(add_expr_level,MINUS,mult_expr_level) -> add_expr_level MINUS . mult_expr_level [ With VBAR Type To Then SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or NE Module MINUS Let LT LE In GT End Else EQ EOF Downto Done Do Directive Contract CONS COMMA COLON CARET BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## add_expr_level MINUS
##
interactive_expr: Verbatim Mod With
##
## Ends in an error in state: 434.
##
## bin_op(mult_expr_level,Mod,shift_expr_level) -> mult_expr_level Mod . shift_expr_level [ With VBAR Type To Then TIMES SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or NE Module Mod MINUS Lxor Lor Let Land LT LE In GT End Else EQ EOF Downto Done Do Directive Contract CONS COMMA COLON CARET BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## mult_expr_level Mod
##
interactive_expr: Verbatim PLUS With
##
## Ends in an error in state: 471.
##
## bin_op(add_expr_level,PLUS,mult_expr_level) -> add_expr_level PLUS . mult_expr_level [ With VBAR Type To Then SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or NE Module MINUS Let LT LE In GT End Else EQ EOF Downto Done Do Directive Contract CONS COMMA COLON CARET BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## add_expr_level PLUS
##
interactive_expr: Verbatim SLASH With
##
## Ends in an error in state: 432.
##
## bin_op(mult_expr_level,SLASH,shift_expr_level) -> mult_expr_level SLASH . shift_expr_level [ With VBAR Type To Then TIMES SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or NE Module Mod MINUS Lxor Lor Let Land LT LE In GT End Else EQ EOF Downto Done Do Directive Contract CONS COMMA COLON CARET BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## mult_expr_level SLASH
##
interactive_expr: Verbatim TIMES With
##
## Ends in an error in state: 424.
##
## bin_op(mult_expr_level,TIMES,shift_expr_level) -> mult_expr_level TIMES . shift_expr_level [ With VBAR Type To Then TIMES SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or NE Module Mod MINUS Lxor Lor Let Land LT LE In GT End Else EQ EOF Downto Done Do Directive Contract CONS COMMA COLON CARET BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## mult_expr_level TIMES
##
interactive_expr: Verbatim Lsr With
##
## Ends in an error in state: 387.
##
## bin_op(unary_expr_level,Lsr,shift_expr_level) -> unary_expr_level Lsr . shift_expr_level [ With VBAR Type To Then TIMES SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or NE Module Mod MINUS Lxor Lor Let Land LT LE In GT End Else EQ EOF Downto Done Do Directive Contract CONS COMMA COLON CARET BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## unary_expr_level Lsr
##
interactive_expr: Verbatim Lsl With
##
## Ends in an error in state: 641.
##
## bin_op(unary_expr_level,Lsl,shift_expr_level) -> unary_expr_level Lsl . shift_expr_level [ With VBAR Type To Then TIMES SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or NE Module Mod MINUS Lxor Lor Let Land LT LE In GT End Else EQ EOF Downto Done Do Directive Contract CONS COMMA COLON CARET BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## unary_expr_level Lsl
##
interactive_expr: Verbatim Lxor With
##
## Ends in an error in state: 436.
##
## bin_op(mult_expr_level,Lxor,shift_expr_level) -> mult_expr_level Lxor . shift_expr_level [ With VBAR Type To Then TIMES SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or NE Module Mod MINUS Lxor Lor Let Land LT LE In GT End Else EQ EOF Downto Done Do Directive Contract CONS COMMA COLON CARET BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## mult_expr_level Lxor
##
interactive_expr: Verbatim Lor With
##
## Ends in an error in state: 438.
##
## bin_op(mult_expr_level,Lor,shift_expr_level) -> mult_expr_level Lor . shift_expr_level [ With VBAR Type To Then TIMES SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or NE Module Mod MINUS Lxor Lor Let Land LT LE In GT End Else EQ EOF Downto Done Do Directive Contract CONS COMMA COLON CARET BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## mult_expr_level Lor
##
interactive_expr: Verbatim Land With
##
## Ends in an error in state: 440.
##
## bin_op(mult_expr_level,Land,shift_expr_level) -> mult_expr_level Land . shift_expr_level [ With VBAR Type To Then TIMES SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or NE Module Mod MINUS Lxor Lor Let Land LT LE In GT End Else EQ EOF Downto Done Do Directive Contract CONS COMMA COLON CARET BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## mult_expr_level Land
##

Ill-formed expression.
At this point, an expression is expected.
Hint: To check your understanding of the syntax, try and add
parentheses around what you think is the expression.

interactive_expr: Verbatim COMMA Verbatim COMMA With
##
## Ends in an error in state: 508.
##
## nsepseq(disj_expr_level,COMMA) -> disj_expr_level COMMA . nsepseq(disj_expr_level,COMMA) [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End Else EOF Downto Done Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## disj_expr_level COMMA
##
interactive_expr: Verbatim COMMA With
##
## Ends in an error in state: 505.
##
## tuple(disj_expr_level) -> disj_expr_level COMMA . nsepseq(disj_expr_level,COMMA) [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End Else EOF Downto Done Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## disj_expr_level COMMA
##

Ill-formed tuple of expressions.
At this point, another component is expected as an expression.
Hint: To check your understanding of the syntax, try and add
parentheses around what you think is the expression.

interactive_expr: Verbatim CONS With
##
## Ends in an error in state: 475.
##
## bin_op(add_expr_level,CONS,cons_expr_level) -> add_expr_level CONS . cons_expr_level [ With VBAR Type To Then SEMI RPAR REV_APP RBRACKET RBRACE Or NE Module Let LT LE In GT End Else EQ EOF Downto Done Do Directive Contract COMMA COLON CARET BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## add_expr_level CONS
##

Ill-formed list expression.
At this point, an expression is expected.

interactive_expr: UIdent DOT UIdent With
##
## Ends in an error in state: 6.
##
## module_access_e -> UIdent . DOT module_var_e [ With Verbatim VBAR UIdent Type To Then TIMES String SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Lxor Lsr Lsl Lor Let Lang Land LT LPAR LE LBRACKET LBRACE Int In Ident GT End Else EQ EOF EIdent Downto Done Do Directive Contract CONS COMMA COLON CARET Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## UIdent
##

Ill-formed selection of a value from a module.
At this point, the selection symbol '.' is expected, followed by the
qualified name of a value.

interactive_expr: Let Mut Ident COLON UIdent ARROW
##
## Ends in an error in state: 606.
##
## let_mut_binding -> var_pattern type_annotation(type_expr) . EQ expr [ In ]
##
## The known suffix of the stack is as follows:
## var_pattern type_annotation(type_expr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 38, spurious reduction of production variant(fun_type_level) -> UIdent
## In state 52, spurious reduction of production nsepseq(variant(fun_type_level),VBAR) -> variant(fun_type_level)
## In state 80, spurious reduction of production sum_type(fun_type_level) -> nsepseq(variant(fun_type_level),VBAR)
## In state 63, spurious reduction of production type_expr -> sum_type(fun_type_level)
## In state 215, spurious reduction of production type_annotation(type_expr) -> COLON type_expr
##
program: Let Ident WILD COLON String VBAR
##
## Ends in an error in state: 1212.
##
## fun_decl -> var_pattern parameters type_annotation(type_expr) . EQ expr [ Type Module Let In End EOF Directive Contract Attr ]
##
## The known suffix of the stack is as follows:
## var_pattern parameters type_annotation(type_expr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 84, spurious reduction of production prod_type_level -> core_type
## In state 65, spurious reduction of production fun_type_level -> prod_type_level
## In state 83, spurious reduction of production type_expr -> fun_type_level
## In state 215, spurious reduction of production type_annotation(type_expr) -> COLON type_expr
##
program: Let Ident LPAR Type Ident RPAR WILD COLON UIdent With
##
## Ends in an error in state: 1224.
##
## fun_decl -> var_pattern par(type_param_list) parameters type_annotation(type_expr) . EQ expr [ Type Module Let In End EOF Directive Contract Attr ]
##
## The known suffix of the stack is as follows:
## var_pattern par(type_param_list) parameters type_annotation(type_expr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 38, spurious reduction of production variant(fun_type_level) -> UIdent
## In state 52, spurious reduction of production nsepseq(variant(fun_type_level),VBAR) -> variant(fun_type_level)
## In state 80, spurious reduction of production sum_type(fun_type_level) -> nsepseq(variant(fun_type_level),VBAR)
## In state 63, spurious reduction of production type_expr -> sum_type(fun_type_level)
## In state 215, spurious reduction of production type_annotation(type_expr) -> COLON type_expr
##
program: Let WILD COLON Ident VBAR
##
## Ends in an error in state: 1256.
##
## non_fun_decl -> WILD type_annotation(type_expr) . EQ expr [ Type Module Let In End EOF Directive Contract Attr ]
##
## The known suffix of the stack is as follows:
## WILD type_annotation(type_expr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 84, spurious reduction of production prod_type_level -> core_type
## In state 65, spurious reduction of production fun_type_level -> prod_type_level
## In state 83, spurious reduction of production type_expr -> fun_type_level
## In state 215, spurious reduction of production type_annotation(type_expr) -> COLON type_expr
##
program: Let LPAR RPAR LPAR Type Ident RPAR COLON Ident With
##
## Ends in an error in state: 534.
##
## non_fun_decl -> unit par(type_param_list) type_annotation(type_expr) . EQ expr [ Type Module Let In End EOF Directive Contract Attr ]
##
## The known suffix of the stack is as follows:
## unit par(type_param_list) type_annotation(type_expr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 84, spurious reduction of production prod_type_level -> core_type
## In state 65, spurious reduction of production fun_type_level -> prod_type_level
## In state 83, spurious reduction of production type_expr -> fun_type_level
## In state 215, spurious reduction of production type_annotation(type_expr) -> COLON type_expr
##
program: Let WILD COMMA Ident COLON Ident With
##
## Ends in an error in state: 540.
##
## non_fun_decl -> tuple(core_irrefutable) type_annotation(type_expr) . EQ expr [ Type Module Let In End EOF Directive Contract Attr ]
##
## The known suffix of the stack is as follows:
## tuple(core_irrefutable) type_annotation(type_expr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 84, spurious reduction of production prod_type_level -> core_type
## In state 65, spurious reduction of production fun_type_level -> prod_type_level
## In state 83, spurious reduction of production type_expr -> fun_type_level
## In state 215, spurious reduction of production type_annotation(type_expr) -> COLON type_expr
##
program: Let WILD COMMA Ident LPAR Type Ident RPAR COLON Ident With
##
## Ends in an error in state: 546.
##
## non_fun_decl -> tuple(core_irrefutable) par(type_param_list) type_annotation(type_expr) . EQ expr [ Type Module Let In End EOF Directive Contract Attr ]
##
## The known suffix of the stack is as follows:
## tuple(core_irrefutable) par(type_param_list) type_annotation(type_expr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 84, spurious reduction of production prod_type_level -> core_type
## In state 65, spurious reduction of production fun_type_level -> prod_type_level
## In state 83, spurious reduction of production type_expr -> fun_type_level
## In state 215, spurious reduction of production type_annotation(type_expr) -> COLON type_expr
##
program: Let LBRACE Ident RBRACE COLON Ident With
##
## Ends in an error in state: 552.
##
## non_fun_decl -> record_pattern(irrefutable) type_annotation(type_expr) . EQ expr [ Type Module Let In End EOF Directive Contract Attr ]
##
## The known suffix of the stack is as follows:
## record_pattern(irrefutable) type_annotation(type_expr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 84, spurious reduction of production prod_type_level -> core_type
## In state 65, spurious reduction of production fun_type_level -> prod_type_level
## In state 83, spurious reduction of production type_expr -> fun_type_level
## In state 215, spurious reduction of production type_annotation(type_expr) -> COLON type_expr
##
program: Let LBRACE Ident RBRACE LPAR Type Ident RPAR COLON Ident With
##
## Ends in an error in state: 558.
##
## non_fun_decl -> record_pattern(irrefutable) par(type_param_list) type_annotation(type_expr) . EQ expr [ Type Module Let In End EOF Directive Contract Attr ]
##
## The known suffix of the stack is as follows:
## record_pattern(irrefutable) par(type_param_list) type_annotation(type_expr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 84, spurious reduction of production prod_type_level -> core_type
## In state 65, spurious reduction of production fun_type_level -> prod_type_level
## In state 83, spurious reduction of production type_expr -> fun_type_level
## In state 215, spurious reduction of production type_annotation(type_expr) -> COLON type_expr
##
program: Let LPAR UIdent COLON Ident RPAR COLON Ident With
##
## Ends in an error in state: 564.
##
## non_fun_decl -> par(typed_irrefutable) type_annotation(type_expr) . EQ expr [ Type Module Let In End EOF Directive Contract Attr ]
##
## The known suffix of the stack is as follows:
## par(typed_irrefutable) type_annotation(type_expr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 84, spurious reduction of production prod_type_level -> core_type
## In state 65, spurious reduction of production fun_type_level -> prod_type_level
## In state 83, spurious reduction of production type_expr -> fun_type_level
## In state 215, spurious reduction of production type_annotation(type_expr) -> COLON type_expr
##
program: Let LPAR UIdent COLON Ident RPAR LPAR Type Ident RPAR COLON Ident With
##
## Ends in an error in state: 570.
##
## non_fun_decl -> par(typed_irrefutable) par(type_param_list) type_annotation(type_expr) . EQ expr [ Type Module Let In End EOF Directive Contract Attr ]
##
## The known suffix of the stack is as follows:
## par(typed_irrefutable) par(type_param_list) type_annotation(type_expr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 84, spurious reduction of production prod_type_level -> core_type
## In state 65, spurious reduction of production fun_type_level -> prod_type_level
## In state 83, spurious reduction of production type_expr -> fun_type_level
## In state 215, spurious reduction of production type_annotation(type_expr) -> COLON type_expr
##
program: Let LPAR WILD RPAR COLON Ident With
##
## Ends in an error in state: 576.
##
## non_fun_decl -> par(irrefutable) type_annotation(type_expr) . EQ expr [ Type Module Let In End EOF Directive Contract Attr ]
##
## The known suffix of the stack is as follows:
## par(irrefutable) type_annotation(type_expr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 84, spurious reduction of production prod_type_level -> core_type
## In state 65, spurious reduction of production fun_type_level -> prod_type_level
## In state 83, spurious reduction of production type_expr -> fun_type_level
## In state 215, spurious reduction of production type_annotation(type_expr) -> COLON type_expr
##
program: Let LPAR WILD RPAR LPAR Type Ident RPAR COLON Ident With
##
## Ends in an error in state: 582.
##
## non_fun_decl -> par(irrefutable) par(type_param_list) type_annotation(type_expr) . EQ expr [ Type Module Let In End EOF Directive Contract Attr ]
##
## The known suffix of the stack is as follows:
## par(irrefutable) par(type_param_list) type_annotation(type_expr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 84, spurious reduction of production prod_type_level -> core_type
## In state 65, spurious reduction of production fun_type_level -> prod_type_level
## In state 83, spurious reduction of production type_expr -> fun_type_level
## In state 215, spurious reduction of production type_annotation(type_expr) -> COLON type_expr
##
program: Let UIdent COLON Ident With
##
## Ends in an error in state: 593.
##
## non_fun_decl -> ctor_irrefutable type_annotation(type_expr) . EQ expr [ Type Module Let In End EOF Directive Contract Attr ]
##
## The known suffix of the stack is as follows:
## ctor_irrefutable type_annotation(type_expr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 84, spurious reduction of production prod_type_level -> core_type
## In state 65, spurious reduction of production fun_type_level -> prod_type_level
## In state 83, spurious reduction of production type_expr -> fun_type_level
## In state 215, spurious reduction of production type_annotation(type_expr) -> COLON type_expr
##
program: Let UIdent LPAR Type Ident RPAR COLON Ident With
##
## Ends in an error in state: 599.
##
## non_fun_decl -> ctor_irrefutable par(type_param_list) type_annotation(type_expr) . EQ expr [ Type Module Let In End EOF Directive Contract Attr ]
##
## The known suffix of the stack is as follows:
## ctor_irrefutable par(type_param_list) type_annotation(type_expr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 84, spurious reduction of production prod_type_level -> core_type
## In state 65, spurious reduction of production fun_type_level -> prod_type_level
## In state 83, spurious reduction of production type_expr -> fun_type_level
## In state 215, spurious reduction of production type_annotation(type_expr) -> COLON type_expr
##
program: Let Ident COLON Ident With
##
## Ends in an error in state: 1206.
##
## non_fun_decl -> var_pattern type_annotation(type_expr) . EQ expr [ Type Module Let In End EOF Directive Contract Attr ]
##
## The known suffix of the stack is as follows:
## var_pattern type_annotation(type_expr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 84, spurious reduction of production prod_type_level -> core_type
## In state 65, spurious reduction of production fun_type_level -> prod_type_level
## In state 83, spurious reduction of production type_expr -> fun_type_level
## In state 215, spurious reduction of production type_annotation(type_expr) -> COLON type_expr
##
program: Let Ident LPAR Type Ident RPAR COLON Ident With
##
## Ends in an error in state: 1218.
##
## non_fun_decl -> var_pattern par(type_param_list) type_annotation(type_expr) . EQ expr [ Type Module Let In End EOF Directive Contract Attr ]
##
## The known suffix of the stack is as follows:
## var_pattern par(type_param_list) type_annotation(type_expr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 84, spurious reduction of production prod_type_level -> core_type
## In state 65, spurious reduction of production fun_type_level -> prod_type_level
## In state 83, spurious reduction of production type_expr -> fun_type_level
## In state 215, spurious reduction of production type_annotation(type_expr) -> COLON type_expr
##
program: Let WILD LPAR Type Ident RPAR COLON Ident With
##
## Ends in an error in state: 1262.
##
## non_fun_decl -> WILD par(type_param_list) type_annotation(type_expr) . EQ expr [ Type Module Let In End EOF Directive Contract Attr ]
##
## The known suffix of the stack is as follows:
## WILD par(type_param_list) type_annotation(type_expr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 84, spurious reduction of production prod_type_level -> core_type
## In state 65, spurious reduction of production fun_type_level -> prod_type_level
## In state 83, spurious reduction of production type_expr -> fun_type_level
## In state 215, spurious reduction of production type_annotation(type_expr) -> COLON type_expr
##
program: Let LPAR RPAR COLON Ident With
##
## Ends in an error in state: 528.
##
## non_fun_decl -> unit type_annotation(type_expr) . EQ expr [ Type Module Let In End EOF Directive Contract Attr ]
##
## The known suffix of the stack is as follows:
## unit type_annotation(type_expr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 84, spurious reduction of production prod_type_level -> core_type
## In state 65, spurious reduction of production fun_type_level -> prod_type_level
## In state 83, spurious reduction of production type_expr -> fun_type_level
## In state 215, spurious reduction of production type_annotation(type_expr) -> COLON type_expr
##

Ill-formed value declaration.
At this point, if the type annotation is complete, the assignment
symbol '=' is expected, followed by an expression.

program: Let LBRACE Ident With
##
## Ends in an error in state: 160.
##
## field_pattern(irrefutable) -> gen_ident . [ SEMI RBRACE ]
## field_pattern(irrefutable) -> gen_ident . EQ tuple(core_irrefutable) [ SEMI RBRACE ]
## field_pattern(irrefutable) -> gen_ident . EQ WILD [ SEMI RBRACE ]
## field_pattern(irrefutable) -> gen_ident . EQ var_pattern [ SEMI RBRACE ]
## field_pattern(irrefutable) -> gen_ident . EQ unit [ SEMI RBRACE ]
## field_pattern(irrefutable) -> gen_ident . EQ record_pattern(irrefutable) [ SEMI RBRACE ]
## field_pattern(irrefutable) -> gen_ident . EQ par(typed_irrefutable) [ SEMI RBRACE ]
## field_pattern(irrefutable) -> gen_ident . EQ par(irrefutable) [ SEMI RBRACE ]
## field_pattern(irrefutable) -> gen_ident . EQ ctor_irrefutable [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## gen_ident
##
interactive_expr: Match Verbatim With LBRACE Ident With
##
## Ends in an error in state: 330.
##
## field_pattern(core_pattern) -> gen_ident . [ SEMI RBRACE ]
## field_pattern(core_pattern) -> gen_ident . EQ core_pattern [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## gen_ident
##

Ill-formed record pattern.
At this point, one of the following is expected:
  * the assignment symbol '=' followed by a pattern;
  * a semicolon ';' if the field is punned (that is, a variable with
    the same name denotes implicitly the pattern);
  * a closing brace '}' if the record pattern is complete.

program: Let LBRACE With
##
## Ends in an error in state: 155.
##
## record_pattern(irrefutable) -> LBRACE . sep_or_term_list(field_pattern(irrefutable),SEMI) RBRACE [ WILD UIdent SEMI RPAR RBRACE LPAR LBRACE Ident EQ EIdent COMMA COLON Attr ARROW ]
##
## The known suffix of the stack is as follows:
## LBRACE
##
interactive_expr: Match Verbatim With LBRACE With
##
## Ends in an error in state: 325.
##
## record_pattern(core_pattern) -> LBRACE . sep_or_term_list(field_pattern(core_pattern),SEMI) RBRACE [ SEMI RPAR RBRACKET RBRACE In CONS COMMA COLON ARROW ]
##
## The known suffix of the stack is as follows:
## LBRACE
##

Ill-formed record pattern.
At this point, field patterns are expected, separated by semicolons ';'.

program: Let LPAR UIdent UIdent With
##
## Ends in an error in state: 245.
##
## par(non_const_ctor_irrefutable) -> LPAR non_const_ctor_irrefutable . RPAR [ WILD UIdent SEMI RPAR RBRACE LPAR LBRACE Ident EQ EIdent COMMA COLON Attr ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR non_const_ctor_irrefutable
##

Ill-formed parenthesised pattern.
At this point, if the enclosed pattern is complete, a closing
parenthesis ')' is expected.

interactive_expr: Match Verbatim With LPAR WILD With
##
## Ends in an error in state: 367.
##
## par(pattern) -> LPAR pattern . RPAR [ SEMI RPAR RBRACKET RBRACE In CONS COMMA COLON ARROW ]
## typed_pattern -> pattern . type_annotation(type_expr) [ RPAR ]
##
## The known suffix of the stack is as follows:
## LPAR pattern
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 354, spurious reduction of production cons_pattern_level -> core_pattern
## In state 370, spurious reduction of production pattern -> cons_pattern_level
##
program: Let LPAR WILD COMMA Ident With
##
## Ends in an error in state: 233.
##
## par(irrefutable) -> LPAR tuple(core_irrefutable) . RPAR [ WILD UIdent SEMI RPAR RBRACE LPAR LBRACE Ident EQ EIdent COMMA COLON Attr ARROW ]
## typed_irrefutable -> tuple(core_irrefutable) . type_annotation(type_expr) [ RPAR ]
##
## The known suffix of the stack is as follows:
## LPAR tuple(core_irrefutable)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 165, spurious reduction of production nsepseq(core_irrefutable,COMMA) -> var_pattern
## In state 213, spurious reduction of production tuple(core_irrefutable) -> WILD COMMA nsepseq(core_irrefutable,COMMA)
##

Ill-formed parenthesised pattern.
At this point, if the enclosed pattern is complete, one of the
following is expected:
  * a type annotation starting with a colon ':', followed by a closing
    parenthesis ')';
  * a closing parenthesis ')'.

program: Let WILD With
##
## Ends in an error in state: 132.
##
## non_fun_decl -> WILD . EQ expr [ Type Module Let In End EOF Directive Contract Attr ]
## non_fun_decl -> WILD . type_annotation(type_expr) EQ expr [ Type Module Let In End EOF Directive Contract Attr ]
## non_fun_decl -> WILD . par(type_param_list) EQ expr [ Type Module Let In End EOF Directive Contract Attr ]
## non_fun_decl -> WILD . par(type_param_list) type_annotation(type_expr) EQ expr [ Type Module Let In End EOF Directive Contract Attr ]
## tuple(core_irrefutable) -> WILD . COMMA nsepseq(core_irrefutable,COMMA) [ LPAR EQ COLON ]
##
## The known suffix of the stack is as follows:
## WILD
##
program: Let LPAR RPAR With
##
## Ends in an error in state: 421.
##
## non_fun_decl -> unit . EQ expr [ Type Module Let In End EOF Directive Contract Attr ]
## non_fun_decl -> unit . type_annotation(type_expr) EQ expr [ Type Module Let In End EOF Directive Contract Attr ]
## non_fun_decl -> unit . par(type_param_list) EQ expr [ Type Module Let In End EOF Directive Contract Attr ]
## non_fun_decl -> unit . par(type_param_list) type_annotation(type_expr) EQ expr [ Type Module Let In End EOF Directive Contract Attr ]
## tuple(core_irrefutable) -> unit . COMMA nsepseq(core_irrefutable,COMMA) [ LPAR EQ COLON ]
##
## The known suffix of the stack is as follows:
## unit
##

Ill-formed value declaration.
At this point, one of the following is expected:
  * a type annotation starting with a colon ':';
  * the assignment symbol '=' followed by an expression;
  * an opening parenthesis '(' followed by the keyword 'type' is the
    value is polymorphic;
  * a comma ',' followed by another component as a pattern, if
    defining a tuple.

program: Type Ident EQ LBRACE Ident COLON UIdent SEMI Ident COLON Ident VBAR
##
## Ends in an error in state: 94.
##
## nsepseq(field_decl,SEMI) -> field_decl . [ RBRACE ]
## nsepseq(field_decl,SEMI) -> field_decl . SEMI nsepseq(field_decl,SEMI) [ RBRACE ]
## seq(__anonymous_0(field_decl,SEMI)) -> field_decl . SEMI seq(__anonymous_0(field_decl,SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_decl
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 84, spurious reduction of production prod_type_level -> core_type
## In state 65, spurious reduction of production fun_type_level -> prod_type_level
## In state 83, spurious reduction of production type_expr -> fun_type_level
## In state 76, spurious reduction of production field_decl -> gen_ident COLON type_expr
##
program: Type Ident EQ LBRACE Ident COLON Ident VBAR
##
## Ends in an error in state: 90.
##
## nsepseq(field_decl,SEMI) -> field_decl . [ RBRACE ]
## nsepseq(field_decl,SEMI) -> field_decl . SEMI nsepseq(field_decl,SEMI) [ RBRACE ]
## nseq(__anonymous_0(field_decl,SEMI)) -> field_decl . SEMI seq(__anonymous_0(field_decl,SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_decl
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 84, spurious reduction of production prod_type_level -> core_type
## In state 65, spurious reduction of production fun_type_level -> prod_type_level
## In state 83, spurious reduction of production type_expr -> fun_type_level
## In state 76, spurious reduction of production field_decl -> gen_ident COLON type_expr
##

Ill-formed record type.
At this point, if the field is complete, one of the following is
expected:
  * a semicolon ';' followed by another field declaration;
  * a closing brace '}' if the record type is complete.

program: Type Ident EQ LBRACE With
##
## Ends in an error in state: 40.
##
## record_type -> LBRACE . sep_or_term_list(field_decl,SEMI) RBRACE [ VBAR Type TIMES SEMI RPAR RBRACE Module Let In Ident End EQ EOF EIdent Directive Contract COMMA Attr ARROW ]
##
## The known suffix of the stack is as follows:
## LBRACE
##
program: Let Ident COLON Attr LBRACE With
##
## Ends in an error in state: 70.
##
## record_type -> nseq(Attr) LBRACE . sep_or_term_list(field_decl,SEMI) RBRACE [ VBAR Type TIMES SEMI RPAR RBRACE Module Let In Ident End EQ EOF EIdent Directive Contract COMMA Attr ARROW ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) LBRACE
##

Ill-formed record type.
At this point, field declarations are expected, separated by
semicolons ';'.

program: Type Ident EQ LPAR String COMMA String VBAR
##
## Ends in an error in state: 101.
##
## nsepseq(type_expr,COMMA) -> type_expr . [ RPAR ]
## nsepseq(type_expr,COMMA) -> type_expr . COMMA nsepseq(type_expr,COMMA) [ RPAR ]
##
## The known suffix of the stack is as follows:
## type_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 84, spurious reduction of production prod_type_level -> core_type
## In state 65, spurious reduction of production fun_type_level -> prod_type_level
## In state 83, spurious reduction of production type_expr -> fun_type_level
##

Ill-formed argument to a type constructor.
At this point, if the tuple component is complete, one of the
following is expected:
  * a comma ',' followed by another component as a type expression;
  * a closing parenthesis ')' if the tuple is complete.

program: Type Ident EQ LPAR String VBAR
##
## Ends in an error in state: 98.
##
## par(type_expr) -> LPAR type_expr . RPAR [ VBAR Type TIMES SEMI RPAR RBRACE Module Let In Ident End EQ EOF EIdent Directive Contract COMMA Attr ARROW ]
## tuple(type_expr) -> type_expr . COMMA nsepseq(type_expr,COMMA) [ RPAR ]
##
## The known suffix of the stack is as follows:
## LPAR type_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 84, spurious reduction of production prod_type_level -> core_type
## In state 65, spurious reduction of production fun_type_level -> prod_type_level
## In state 83, spurious reduction of production type_expr -> fun_type_level
##

Ill-formed parenthesised type expression.
At this point, if the type is complete, one of the following is
expected:
  * a closing parenthesis ')';
  * a comma ',' followed by another type expression, if defining the
    argument to a type constructor.

program: Type Ident EQ String ARROW With
##
## Ends in an error in state: 66.
##
## fun_type_level -> prod_type_level ARROW . fun_type_level [ VBAR Type SEMI RPAR RBRACE Module Let In End EQ EOF Directive Contract COMMA Attr ]
##
## The known suffix of the stack is as follows:
## prod_type_level ARROW
##

Ill-formed functional type.
At this point, a type expression is expected.
Note: If you want a sum type, enclose it between parentheses.

interactive_expr: Fun Ident COLON UIdent Of With
##
## Ends in an error in state: 297.
##
## of_type(prod_type_level) -> Of . prod_type_level [ VBAR ARROW ]
##
## The known suffix of the stack is as follows:
## Of
##
program: Let Ident COLON UIdent Of With
##
## Ends in an error in state: 30.
##
## of_type(fun_type_level) -> Of . fun_type_level [ VBAR Type SEMI RPAR RBRACE Module Let In End EQ EOF Directive Contract COMMA Attr ]
##
## The known suffix of the stack is as follows:
## Of
##

Ill-formed parameter of a variant.
At this point, a type expression is expected.
Note: If you want a variant type, enclose it between parentheses.

program: Type Ident EQ String TIMES UIdent With
##
## Ends in an error in state: 31.
##
## module_access_t -> UIdent . DOT module_var_t [ VBAR Type TIMES SEMI RPAR RBRACE Module Let In Ident End EQ EOF EIdent Directive Contract COMMA Attr ARROW ]
##
## The known suffix of the stack is as follows:
## UIdent
##

Ill-formed selection of a type in a module.
At this point, the selection symbol '.' is expected, followed by the
qualified name of a type.

program: Type Ident EQ String TIMES String TIMES With
##
## Ends in an error in state: 88.
##
## nsepseq(core_type,TIMES) -> core_type TIMES . nsepseq(core_type,TIMES) [ VBAR Type SEMI RPAR RBRACE Module Let In End EQ EOF Directive Contract COMMA Attr ARROW ]
##
## The known suffix of the stack is as follows:
## core_type TIMES
##
program: Type Ident EQ String TIMES With
##
## Ends in an error in state: 85.
##
## prod_type_level -> core_type TIMES . nsepseq(core_type,TIMES) [ VBAR Type SEMI RPAR RBRACE Module Let In End EQ EOF Directive Contract COMMA Attr ARROW ]
##
## The known suffix of the stack is as follows:
## core_type TIMES
##

Ill-formed product type.
At this point, a type expression is expected.
Hint: If you want a variant type, put it between parentheses.

interactive_expr: Fun Ident COLON UIdent VBAR With
##
## Ends in an error in state: 301.
##
## nsepseq(variant(prod_type_level),VBAR) -> variant(prod_type_level) VBAR . nsepseq(variant(prod_type_level),VBAR) [ ARROW ]
##
## The known suffix of the stack is as follows:
## variant(prod_type_level) VBAR
##
interactive_expr: Fun Ident COLON Attr VBAR With
##
## Ends in an error in state: 311.
##
## sum_type(prod_type_level) -> nseq(Attr) VBAR . nsepseq(variant(prod_type_level),VBAR) [ ARROW ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) VBAR
##
program: Let Ident COLON Attr VBAR With
##
## Ends in an error in state: 78.
##
## sum_type(fun_type_level) -> nseq(Attr) VBAR . nsepseq(variant(fun_type_level),VBAR) [ Type SEMI RPAR RBRACE Module Let In End EQ EOF Directive Contract COMMA Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) VBAR
##
program: Type Ident EQ VBAR With
##
## Ends in an error in state: 28.
##
## sum_type(fun_type_level) -> VBAR . nsepseq(variant(fun_type_level),VBAR) [ Type SEMI RPAR RBRACE Module Let In End EQ EOF Directive Contract COMMA Attr ]
##
## The known suffix of the stack is as follows:
## VBAR
##
program: Type Ident EQ UIdent VBAR With
##
## Ends in an error in state: 53.
##
## nsepseq(variant(fun_type_level),VBAR) -> variant(fun_type_level) VBAR . nsepseq(variant(fun_type_level),VBAR) [ Type SEMI RPAR RBRACE Module Let In End EQ EOF Directive Contract COMMA Attr ]
##
## The known suffix of the stack is as follows:
## variant(fun_type_level) VBAR
##
interactive_expr: Fun Ident COLON VBAR With
##
## Ends in an error in state: 295.
##
## sum_type(prod_type_level) -> VBAR . nsepseq(variant(prod_type_level),VBAR) [ ARROW ]
##
## The known suffix of the stack is as follows:
## VBAR
##

Ill-formed variant.
At this point, a variant starting with a data constructor is expected.

program: Type With
##
## Ends in an error in state: 9.
##
## type_decl -> Type . gen_ident EQ type_expr [ Type Module Let In End EOF Directive Contract Attr ]
## type_decl -> Type . quoted_type_params gen_ident EQ type_expr [ Type Module Let In End EOF Directive Contract Attr ]
##
## The known suffix of the stack is as follows:
## Type
##

Ill-formed type declaration.
At this point, one of the following is expected:
  * the name of the type being defined;
  * a quoted type parameter, like 'a;
  * a tuple of quoted type parameters, like ('a, 'b).

interactive_expr: Type Ident EQ UIdent With
##
## Ends in an error in state: 412.
##
## local_type_decl(expr) -> type_decl . In expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## type_decl
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 38, spurious reduction of production variant(fun_type_level) -> UIdent
## In state 52, spurious reduction of production nsepseq(variant(fun_type_level),VBAR) -> variant(fun_type_level)
## In state 80, spurious reduction of production sum_type(fun_type_level) -> nsepseq(variant(fun_type_level),VBAR)
## In state 63, spurious reduction of production type_expr -> sum_type(fun_type_level)
## In state 113, spurious reduction of production type_decl -> Type gen_ident EQ type_expr
##
interactive_expr: If Verbatim Then Match Verbatim With WILD ARROW Type Ident EQ UIdent With
##
## Ends in an error in state: 807.
##
## local_type_decl(base_cond) -> type_decl . In base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## local_type_decl(base_if_then_else) -> type_decl . In base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## type_decl
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 38, spurious reduction of production variant(fun_type_level) -> UIdent
## In state 52, spurious reduction of production nsepseq(variant(fun_type_level),VBAR) -> variant(fun_type_level)
## In state 80, spurious reduction of production sum_type(fun_type_level) -> nsepseq(variant(fun_type_level),VBAR)
## In state 63, spurious reduction of production type_expr -> sum_type(fun_type_level)
## In state 113, spurious reduction of production type_decl -> Type gen_ident EQ type_expr
##
interactive_expr: Begin If Verbatim Then Type Ident EQ UIdent With
##
## Ends in an error in state: 969.
##
## local_type_decl(closed_expr) -> type_decl . In closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## type_decl
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 38, spurious reduction of production variant(fun_type_level) -> UIdent
## In state 52, spurious reduction of production nsepseq(variant(fun_type_level),VBAR) -> variant(fun_type_level)
## In state 80, spurious reduction of production sum_type(fun_type_level) -> nsepseq(variant(fun_type_level),VBAR)
## In state 63, spurious reduction of production type_expr -> sum_type(fun_type_level)
## In state 113, spurious reduction of production type_decl -> Type gen_ident EQ type_expr
##
interactive_expr: If Verbatim Then Type Ident EQ UIdent With
##
## Ends in an error in state: 1132.
##
## local_type_decl(closed_expr) -> type_decl . In closed_expr [ Else ]
## local_type_decl(expr) -> type_decl . In expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## type_decl
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 38, spurious reduction of production variant(fun_type_level) -> UIdent
## In state 52, spurious reduction of production nsepseq(variant(fun_type_level),VBAR) -> variant(fun_type_level)
## In state 80, spurious reduction of production sum_type(fun_type_level) -> nsepseq(variant(fun_type_level),VBAR)
## In state 63, spurious reduction of production type_expr -> sum_type(fun_type_level)
## In state 113, spurious reduction of production type_decl -> Type gen_ident EQ type_expr
##
interactive_expr: Match Verbatim With WILD ARROW If Verbatim Then Type Ident EQ UIdent With
##
## Ends in an error in state: 701.
##
## local_type_decl(base_cond) -> type_decl . In base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## local_type_decl(closed_expr) -> type_decl . In closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## type_decl
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 38, spurious reduction of production variant(fun_type_level) -> UIdent
## In state 52, spurious reduction of production nsepseq(variant(fun_type_level),VBAR) -> variant(fun_type_level)
## In state 80, spurious reduction of production sum_type(fun_type_level) -> nsepseq(variant(fun_type_level),VBAR)
## In state 63, spurious reduction of production type_expr -> sum_type(fun_type_level)
## In state 113, spurious reduction of production type_decl -> Type gen_ident EQ type_expr
##
interactive_expr: Match Verbatim With WILD ARROW Type Ident EQ UIdent With
##
## Ends in an error in state: 892.
##
## local_type_decl(base_cond) -> type_decl . In base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## type_decl
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 38, spurious reduction of production variant(fun_type_level) -> UIdent
## In state 52, spurious reduction of production nsepseq(variant(fun_type_level),VBAR) -> variant(fun_type_level)
## In state 80, spurious reduction of production sum_type(fun_type_level) -> nsepseq(variant(fun_type_level),VBAR)
## In state 63, spurious reduction of production type_expr -> sum_type(fun_type_level)
## In state 113, spurious reduction of production type_decl -> Type gen_ident EQ type_expr
##

Ill-formed local type declaration.
At this point, if the type expression is complete, the keyword 'in' is
expected, followed by an expression.

program: Type Ident EQ UIdent End
##
## Ends in an error in state: 1365.
##
## program -> module_ . EOF [ # ]
##
## The known suffix of the stack is as follows:
## module_
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 38, spurious reduction of production variant(fun_type_level) -> UIdent
## In state 52, spurious reduction of production nsepseq(variant(fun_type_level),VBAR) -> variant(fun_type_level)
## In state 80, spurious reduction of production sum_type(fun_type_level) -> nsepseq(variant(fun_type_level),VBAR)
## In state 63, spurious reduction of production type_expr -> sum_type(fun_type_level)
## In state 113, spurious reduction of production type_decl -> Type gen_ident EQ type_expr
## In state 1321, spurious reduction of production declaration -> type_decl
## In state 1330, spurious reduction of production seq(declaration) ->
## In state 1331, spurious reduction of production nseq(declaration) -> declaration seq(declaration)
## In state 1322, spurious reduction of production module_ -> nseq(declaration)
##
program: Directive With
##
## Ends in an error in state: 1330.
##
## nseq(declaration) -> declaration . seq(declaration) [ End EOF ]
##
## The known suffix of the stack is as follows:
## declaration
##
program: Directive Directive With
##
## Ends in an error in state: 1332.
##
## seq(declaration) -> declaration . seq(declaration) [ End EOF ]
##
## The known suffix of the stack is as follows:
## declaration
##

Ill-formed program.
At this point, if the declaration is complete, one of the following is
expected:
  * another declaration;
  * the end of the file.

program: Module UIdent EQ Struct Type Ident EQ UIdent EOF
##
## Ends in an error in state: 1327.
##
## module_decl -> Module UIdent EQ Struct module_ . End [ Type Module Let In End EOF Directive Contract Attr ]
##
## The known suffix of the stack is as follows:
## Module UIdent EQ Struct module_
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 38, spurious reduction of production variant(fun_type_level) -> UIdent
## In state 52, spurious reduction of production nsepseq(variant(fun_type_level),VBAR) -> variant(fun_type_level)
## In state 80, spurious reduction of production sum_type(fun_type_level) -> nsepseq(variant(fun_type_level),VBAR)
## In state 63, spurious reduction of production type_expr -> sum_type(fun_type_level)
## In state 113, spurious reduction of production type_decl -> Type gen_ident EQ type_expr
## In state 1321, spurious reduction of production declaration -> type_decl
## In state 1330, spurious reduction of production seq(declaration) ->
## In state 1331, spurious reduction of production nseq(declaration) -> declaration seq(declaration)
## In state 1322, spurious reduction of production module_ -> nseq(declaration)
##

Ill-formed module declaration.
At this point, if the declaration is complete, one of the following is
expected:
  * another declaration;
  * the end of the file.

program: Module UIdent EQ With
##
## Ends in an error in state: 126.
##
## module_alias -> Module UIdent EQ . nsepseq(module_name,DOT) [ Type Module Let In End EOF Directive Contract Attr ]
## module_decl -> Module UIdent EQ . Struct module_ End [ Type Module Let In End EOF Directive Contract Attr ]
##
## The known suffix of the stack is as follows:
## Module UIdent EQ
##

Ill-formed module declaration or module alias declaration.
At this point, one of the following is expected:
  * the qualified name of a module being aliased;
  * the keyword 'struct' followed by declarations, if
    defining a module.

program: Module UIdent With
##
## Ends in an error in state: 125.
##
## module_alias -> Module UIdent . EQ nsepseq(module_name,DOT) [ Type Module Let In End EOF Directive Contract Attr ]
## module_decl -> Module UIdent . EQ Struct module_ End [ Type Module Let In End EOF Directive Contract Attr ]
##
## The known suffix of the stack is as follows:
## Module UIdent
##

Ill-formed module declaration.
At this point, the assignment symbol '=' is expected to introduce
either the qualified name of a module being aliased, or a module
structure.

program: Module With
##
## Ends in an error in state: 124.
##
## module_alias -> Module . UIdent EQ nsepseq(module_name,DOT) [ Type Module Let In End EOF Directive Contract Attr ]
## module_decl -> Module . UIdent EQ Struct module_ End [ Type Module Let In End EOF Directive Contract Attr ]
##
## The known suffix of the stack is as follows:
## Module
##

Ill-formed module declaration.
At this point, the name of the module being declared is expected.

interactive_expr: Module UIdent EQ Struct Type Ident EQ UIdent End With
##
## Ends in an error in state: 442.
##
## local_module_decl(expr) -> module_decl . In expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## module_decl
##
interactive_expr: Match Verbatim With WILD ARROW If Verbatim Then Module UIdent EQ Struct Type Ident EQ UIdent End With
##
## Ends in an error in state: 709.
##
## local_module_decl(base_cond) -> module_decl . In base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## local_module_decl(closed_expr) -> module_decl . In closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## module_decl
##
interactive_expr: Match Verbatim With WILD ARROW Module UIdent EQ Struct Type Ident EQ UIdent End With
##
## Ends in an error in state: 899.
##
## local_module_decl(base_cond) -> module_decl . In base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## module_decl
##
interactive_expr: If Verbatim Then Match Verbatim With WILD ARROW Module UIdent EQ Struct Type Ident EQ UIdent End With
##
## Ends in an error in state: 814.
##
## local_module_decl(base_cond) -> module_decl . In base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## local_module_decl(base_if_then_else) -> module_decl . In base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## module_decl
##
interactive_expr: If Verbatim Then Module UIdent EQ Struct Type Ident EQ UIdent End With
##
## Ends in an error in state: 1139.
##
## local_module_decl(closed_expr) -> module_decl . In closed_expr [ Else ]
## local_module_decl(expr) -> module_decl . In expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## module_decl
##
interactive_expr: Begin If Verbatim Then Module UIdent EQ Struct Type Ident EQ UIdent End With
##
## Ends in an error in state: 976.
##
## local_module_decl(closed_expr) -> module_decl . In closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## module_decl
##

Ill-formed local module declaration.
At this point, the keyword 'in' is expected, followed by an
expression.

interactive_expr: Module UIdent EQ UIdent Type
##
## Ends in an error in state: 444.
##
## local_module_alias(expr) -> module_alias . In expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## module_alias
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 127, spurious reduction of production nsepseq(module_name,DOT) -> UIdent
## In state 1335, spurious reduction of production module_alias -> Module UIdent EQ nsepseq(module_name,DOT)
##
interactive_expr: Match Verbatim With WILD ARROW If Verbatim Then Module UIdent EQ UIdent Type
##
## Ends in an error in state: 711.
##
## local_module_alias(base_cond) -> module_alias . In base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## local_module_alias(closed_expr) -> module_alias . In closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## module_alias
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 127, spurious reduction of production nsepseq(module_name,DOT) -> UIdent
## In state 1335, spurious reduction of production module_alias -> Module UIdent EQ nsepseq(module_name,DOT)
##
interactive_expr: If Verbatim Then Match Verbatim With WILD ARROW Module UIdent EQ UIdent Type
##
## Ends in an error in state: 816.
##
## local_module_alias(base_cond) -> module_alias . In base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## local_module_alias(base_if_then_else) -> module_alias . In base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## module_alias
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 127, spurious reduction of production nsepseq(module_name,DOT) -> UIdent
## In state 1335, spurious reduction of production module_alias -> Module UIdent EQ nsepseq(module_name,DOT)
##
interactive_expr: Match Verbatim With WILD ARROW Module UIdent EQ UIdent Type
##
## Ends in an error in state: 901.
##
## local_module_alias(base_cond) -> module_alias . In base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## module_alias
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 127, spurious reduction of production nsepseq(module_name,DOT) -> UIdent
## In state 1335, spurious reduction of production module_alias -> Module UIdent EQ nsepseq(module_name,DOT)
##
interactive_expr: Begin If Verbatim Then Module UIdent EQ UIdent Type
##
## Ends in an error in state: 978.
##
## local_module_alias(closed_expr) -> module_alias . In closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## module_alias
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 127, spurious reduction of production nsepseq(module_name,DOT) -> UIdent
## In state 1335, spurious reduction of production module_alias -> Module UIdent EQ nsepseq(module_name,DOT)
##
interactive_expr: If Verbatim Then Module UIdent EQ UIdent Type
##
## Ends in an error in state: 1141.
##
## local_module_alias(closed_expr) -> module_alias . In closed_expr [ Else ]
## local_module_alias(expr) -> module_alias . In expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## module_alias
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 127, spurious reduction of production nsepseq(module_name,DOT) -> UIdent
## In state 1335, spurious reduction of production module_alias -> Module UIdent EQ nsepseq(module_name,DOT)
##

Ill-formed local module declaration.
At this point, if the module to be aliased is fully qualified, the
keyword 'in' is expected, followed by an expression.

program: Module UIdent EQ UIdent DOT With
##
## Ends in an error in state: 128.
##
## nsepseq(module_name,DOT) -> UIdent DOT . nsepseq(module_name,DOT) [ Type Module Let In End EOF Directive Contract Attr ]
##
## The known suffix of the stack is as follows:
## UIdent DOT
##

Ill-formed module qualification.
At this point, a module name is expected.

program: Type QUOTE With
##
## Ends in an error in state: 10.
##
## type_var -> QUOTE . gen_ident [ VBAR Type TIMES SEMI RPAR RBRACE Module Let In Ident End EQ EOF EIdent Directive Contract COMMA Attr ARROW ]
##
## The known suffix of the stack is as follows:
## QUOTE
##

Ill-formed quoted type parameter.
At this point, an identifier is expected.

program: Type QUOTE Ident With
##
## Ends in an error in state: 24.
##
## type_decl -> Type quoted_type_params . gen_ident EQ type_expr [ Type Module Let In End EOF Directive Contract Attr ]
##
## The known suffix of the stack is as follows:
## Type quoted_type_params
##

Ill-formed parametric type declaration.
At this point, the name of the type being defined is expected.

interactive_expr: Match Verbatim With LBRACE Ident SEMI Ident EQ Bytes With
##
## Ends in an error in state: 346.
##
## nsepseq(field_pattern(core_pattern),SEMI) -> field_pattern(core_pattern) . [ RBRACE ]
## nsepseq(field_pattern(core_pattern),SEMI) -> field_pattern(core_pattern) . SEMI nsepseq(field_pattern(core_pattern),SEMI) [ RBRACE ]
## seq(__anonymous_0(field_pattern(core_pattern),SEMI)) -> field_pattern(core_pattern) . SEMI seq(__anonymous_0(field_pattern(core_pattern),SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_pattern(core_pattern)
##
interactive_expr: Match Verbatim With LBRACE Ident EQ Bytes With
##
## Ends in an error in state: 342.
##
## nsepseq(field_pattern(core_pattern),SEMI) -> field_pattern(core_pattern) . [ RBRACE ]
## nsepseq(field_pattern(core_pattern),SEMI) -> field_pattern(core_pattern) . SEMI nsepseq(field_pattern(core_pattern),SEMI) [ RBRACE ]
## nseq(__anonymous_0(field_pattern(core_pattern),SEMI)) -> field_pattern(core_pattern) . SEMI seq(__anonymous_0(field_pattern(core_pattern),SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_pattern(core_pattern)
##
program: Let LBRACE Ident EQ WILD COMMA Ident With
##
## Ends in an error in state: 205.
##
## nsepseq(field_pattern(irrefutable),SEMI) -> field_pattern(irrefutable) . [ RBRACE ]
## nsepseq(field_pattern(irrefutable),SEMI) -> field_pattern(irrefutable) . SEMI nsepseq(field_pattern(irrefutable),SEMI) [ RBRACE ]
## nseq(__anonymous_0(field_pattern(irrefutable),SEMI)) -> field_pattern(irrefutable) . SEMI seq(__anonymous_0(field_pattern(irrefutable),SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_pattern(irrefutable)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 165, spurious reduction of production nsepseq(core_irrefutable,COMMA) -> var_pattern
## In state 213, spurious reduction of production tuple(core_irrefutable) -> WILD COMMA nsepseq(core_irrefutable,COMMA)
## In state 192, spurious reduction of production field_pattern(irrefutable) -> gen_ident EQ tuple(core_irrefutable)
##
program: Let LBRACE Ident SEMI Ident EQ WILD COMMA Ident With
##
## Ends in an error in state: 209.
##
## nsepseq(field_pattern(irrefutable),SEMI) -> field_pattern(irrefutable) . [ RBRACE ]
## nsepseq(field_pattern(irrefutable),SEMI) -> field_pattern(irrefutable) . SEMI nsepseq(field_pattern(irrefutable),SEMI) [ RBRACE ]
## seq(__anonymous_0(field_pattern(irrefutable),SEMI)) -> field_pattern(irrefutable) . SEMI seq(__anonymous_0(field_pattern(irrefutable),SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_pattern(irrefutable)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 165, spurious reduction of production nsepseq(core_irrefutable,COMMA) -> var_pattern
## In state 213, spurious reduction of production tuple(core_irrefutable) -> WILD COMMA nsepseq(core_irrefutable,COMMA)
## In state 192, spurious reduction of production field_pattern(irrefutable) -> gen_ident EQ tuple(core_irrefutable)
##

Ill-formed record pattern.
At this point, if the field pattern is complete, one of the following
is expected:
  * a semicolon ';' followed by another field pattern;
  * a closing brace '}' if the record pattern is complete.

interactive_expr: Fun LBRACE Ident SEMI With
##
## Ends in an error in state: 206.
##
## nsepseq(field_pattern(irrefutable),SEMI) -> field_pattern(irrefutable) SEMI . nsepseq(field_pattern(irrefutable),SEMI) [ RBRACE ]
## nseq(__anonymous_0(field_pattern(irrefutable),SEMI)) -> field_pattern(irrefutable) SEMI . seq(__anonymous_0(field_pattern(irrefutable),SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_pattern(irrefutable) SEMI
##
interactive_expr: Fun LBRACE Ident SEMI Ident SEMI With
##
## Ends in an error in state: 210.
##
## nsepseq(field_pattern(irrefutable),SEMI) -> field_pattern(irrefutable) SEMI . nsepseq(field_pattern(irrefutable),SEMI) [ RBRACE ]
## seq(__anonymous_0(field_pattern(irrefutable),SEMI)) -> field_pattern(irrefutable) SEMI . seq(__anonymous_0(field_pattern(irrefutable),SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_pattern(irrefutable) SEMI
##
interactive_expr: Match Verbatim With LBRACE Ident SEMI With
##
## Ends in an error in state: 343.
##
## nsepseq(field_pattern(core_pattern),SEMI) -> field_pattern(core_pattern) SEMI . nsepseq(field_pattern(core_pattern),SEMI) [ RBRACE ]
## nseq(__anonymous_0(field_pattern(core_pattern),SEMI)) -> field_pattern(core_pattern) SEMI . seq(__anonymous_0(field_pattern(core_pattern),SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_pattern(core_pattern) SEMI
##
interactive_expr: Match Verbatim With LBRACE Ident SEMI Ident SEMI With
##
## Ends in an error in state: 347.
##
## nsepseq(field_pattern(core_pattern),SEMI) -> field_pattern(core_pattern) SEMI . nsepseq(field_pattern(core_pattern),SEMI) [ RBRACE ]
## seq(__anonymous_0(field_pattern(core_pattern),SEMI)) -> field_pattern(core_pattern) SEMI . seq(__anonymous_0(field_pattern(core_pattern),SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_pattern(core_pattern) SEMI
##

Ill-formed record pattern.
At this point, if the field pattern is complete, one of the following
is expected:
  * another field pattern starting with a field name;
  * a closing brace '}' if the record pattern is complete.

program: Let Ident LPAR Type With
##
## Ends in an error in state: 134.
##
## type_param_list -> Type . nseq(variable) [ RPAR ]
##
## The known suffix of the stack is as follows:
## Type
##

Ill-formed type parameter.
At this point, a type parameter without a quote is expected.

program: Let Ident LPAR Type Ident With
##
## Ends in an error in state: 136.
##
## nseq(variable) -> gen_ident . seq(variable) [ RPAR ]
##
## The known suffix of the stack is as follows:
## gen_ident
##
program: Let Ident LPAR Type Ident Ident With
##
## Ends in an error in state: 138.
##
## seq(variable) -> gen_ident . seq(variable) [ RPAR ]
##
## The known suffix of the stack is as follows:
## gen_ident
##

Ill-formed type parameters.
At this point, one of the following is expected:
  * a type parameter without a quote;
  * a closing parenthesis ')' if there are no more parameters.

interactive_expr: Match Verbatim With LBRACKET WILD SEMI WILD With
##
## Ends in an error in state: 361.
##
## nsepseq(cons_pattern_level,SEMI) -> cons_pattern_level . [ RBRACKET ]
## nsepseq(cons_pattern_level,SEMI) -> cons_pattern_level . SEMI nsepseq(cons_pattern_level,SEMI) [ RBRACKET ]
## seq(__anonymous_0(cons_pattern_level,SEMI)) -> cons_pattern_level . SEMI seq(__anonymous_0(cons_pattern_level,SEMI)) [ RBRACKET ]
##
## The known suffix of the stack is as follows:
## cons_pattern_level
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 354, spurious reduction of production cons_pattern_level -> core_pattern
##
interactive_expr: Match Verbatim With LBRACKET WILD With
##
## Ends in an error in state: 357.
##
## nsepseq(cons_pattern_level,SEMI) -> cons_pattern_level . [ RBRACKET ]
## nsepseq(cons_pattern_level,SEMI) -> cons_pattern_level . SEMI nsepseq(cons_pattern_level,SEMI) [ RBRACKET ]
## nseq(__anonymous_0(cons_pattern_level,SEMI)) -> cons_pattern_level . SEMI seq(__anonymous_0(cons_pattern_level,SEMI)) [ RBRACKET ]
##
## The known suffix of the stack is as follows:
## cons_pattern_level
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 354, spurious reduction of production cons_pattern_level -> core_pattern
##

Ill-formed list of patterns.
At this point, if the element as a pattern is complete, one of
the following is expected:
  * a semicolon ';' followed by another pattern;
  * a closing bracket ']' if the list is complete.

interactive_expr: Match Verbatim With LPAR WILD COLON UIdent With
##
## Ends in an error in state: 364.
##
## par(typed_pattern) -> LPAR typed_pattern . RPAR [ SEMI RPAR RBRACKET RBRACE In CONS COMMA COLON ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR typed_pattern
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 38, spurious reduction of production variant(fun_type_level) -> UIdent
## In state 52, spurious reduction of production nsepseq(variant(fun_type_level),VBAR) -> variant(fun_type_level)
## In state 80, spurious reduction of production sum_type(fun_type_level) -> nsepseq(variant(fun_type_level),VBAR)
## In state 63, spurious reduction of production type_expr -> sum_type(fun_type_level)
## In state 215, spurious reduction of production type_annotation(type_expr) -> COLON type_expr
## In state 369, spurious reduction of production typed_pattern -> pattern type_annotation(type_expr)
##

Ill-formed parenthesised pattern.
At this point, if the type annotation is complete, a closing
parenthesis ')' is expected.

program: Type LPAR With
##
## Ends in an error in state: 14.
##
## par(tuple(type_var)) -> LPAR . tuple(type_var) RPAR [ Ident EIdent ]
##
## The known suffix of the stack is as follows:
## LPAR
##
program: Type LPAR QUOTE Ident COMMA QUOTE Ident COMMA With
##
## Ends in an error in state: 18.
##
## nsepseq(type_var,COMMA) -> type_var COMMA . nsepseq(type_var,COMMA) [ RPAR ]
##
## The known suffix of the stack is as follows:
## type_var COMMA
##
program: Type LPAR QUOTE Ident COMMA With
##
## Ends in an error in state: 16.
##
## tuple(type_var) -> type_var COMMA . nsepseq(type_var,COMMA) [ RPAR ]
##
## The known suffix of the stack is as follows:
## type_var COMMA
##

Ill-formed parametric type declaration.
At this point, a quoted type parameter is expected, like 'a.

program: Type LPAR QUOTE Ident With
##
## Ends in an error in state: 15.
##
## tuple(type_var) -> type_var . COMMA nsepseq(type_var,COMMA) [ RPAR ]
##
## The known suffix of the stack is as follows:
## type_var
##

Ill-formed parametric type declaration.
At this point, a comma ',' is expected, followed by another quoted
type parameter, like 'a.

program: Type LPAR QUOTE Ident COMMA QUOTE Ident With
##
## Ends in an error in state: 17.
##
## nsepseq(type_var,COMMA) -> type_var . [ RPAR ]
## nsepseq(type_var,COMMA) -> type_var . COMMA nsepseq(type_var,COMMA) [ RPAR ]
##
## The known suffix of the stack is as follows:
## type_var
##

Ill-formed parametric type declaration.
At this point, one of the following is expected:
  * a comma ',' followed by another quoted type parameter, like 'a;
  * a closing parenthesis ')' if there are no more parameters.

interactive_expr: LPAR UIdent COLON LPAR Ident COMMA Ident RPAR With
##
## Ends in an error in state: 60.
##
## type_ctor_app -> type_ctor_arg . gen_ident [ VBAR Type TIMES SEMI RPAR RBRACE Module Let In Ident End EQ EOF EIdent Directive Contract COMMA Attr ARROW ]
##
## The known suffix of the stack is as follows:
## type_ctor_arg
##

Ill-formed type expression.
At this point, a type constructor is expected.
Note: A type constructor is the analogue of a function name at the
type level. For example, 'list', 'map' and 'set' are type
constructors. Contrary to function names, type constructors are
written after their arguments.

program: Let Ident COLON LBRACE Attr Ident With
##
## Ends in an error in state: 49.
##
## field_decl -> nseq(Attr) gen_ident . COLON type_expr [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) gen_ident
##
program: Type Ident EQ LBRACE Ident With
##
## Ends in an error in state: 74.
##
## field_decl -> gen_ident . COLON type_expr [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## gen_ident
##

Ill-formed record type.
At this point, a type annotation for the field is expected, starting
with a colon ':'.

program: Let Ident COLON LBRACE Ident COLON With
##
## Ends in an error in state: 75.
##
## field_decl -> gen_ident COLON . type_expr [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## gen_ident COLON
##
program: Let Ident COLON LBRACE Attr Ident COLON With
##
## Ends in an error in state: 50.
##
## field_decl -> nseq(Attr) gen_ident COLON . type_expr [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) gen_ident COLON
##

Ill-formed record type.
At this point, the type of the field is expected.

program: Let Ident COLON LBRACE Attr With
##
## Ends in an error in state: 48.
##
## field_decl -> nseq(Attr) . gen_ident COLON type_expr [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## nseq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 41, spurious reduction of production seq(Attr) ->
## In state 44, spurious reduction of production nseq(Attr) -> Attr seq(Attr)
##

Ill-formed record type.
At this point, if the attribute is complete, a field name is expected.

program: Let Ident COLON LBRACE Ident COLON Ident SEMI With
##
## Ends in an error in state: 91.
##
## nsepseq(field_decl,SEMI) -> field_decl SEMI . nsepseq(field_decl,SEMI) [ RBRACE ]
## nseq(__anonymous_0(field_decl,SEMI)) -> field_decl SEMI . seq(__anonymous_0(field_decl,SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_decl SEMI
##
program: Let Ident COLON LBRACE Ident COLON Ident SEMI Ident COLON Ident SEMI With
##
## Ends in an error in state: 95.
##
## nsepseq(field_decl,SEMI) -> field_decl SEMI . nsepseq(field_decl,SEMI) [ RBRACE ]
## seq(__anonymous_0(field_decl,SEMI)) -> field_decl SEMI . seq(__anonymous_0(field_decl,SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_decl SEMI
##

Ill-formed record type.
At this point one of the following is expected:
  * a field declaration, starting with a field name;
  * a closing brace '}' if the record is complete.

program: Let Ident COLON With
##
## Ends in an error in state: 214.
##
## type_annotation(type_expr) -> COLON . type_expr [ RPAR EQ ]
##
## The known suffix of the stack is as follows:
## COLON
##
interactive_expr: Fun Ident COLON With
##
## Ends in an error in state: 294.
##
## type_annotation(lambda_app_type) -> COLON . lambda_app_type [ ARROW ]
##
## The known suffix of the stack is as follows:
## COLON
##

Ill-formed type annotation.
At this point, a type expression is expected.
Note: If you want a functional type, enclose it between parentheses.

interactive_expr: LPAR UIdent COLON With
##
## Ends in an error in state: 634.
##
## typed_expr -> expr COLON . type_expr [ RPAR ]
##
## The known suffix of the stack is as follows:
## expr COLON
##

Ill-formed typed expression.
At this point, a type expression is expected.

program: Let Ident COLON LPAR Ident COMMA With
##
## Ends in an error in state: 100.
##
## tuple(type_expr) -> type_expr COMMA . nsepseq(type_expr,COMMA) [ RPAR ]
##
## The known suffix of the stack is as follows:
## type_expr COMMA
##
program: Let Ident COLON LPAR Ident COMMA Ident COMMA With
##
## Ends in an error in state: 102.
##
## nsepseq(type_expr,COMMA) -> type_expr COMMA . nsepseq(type_expr,COMMA) [ RPAR ]
##
## The known suffix of the stack is as follows:
## type_expr COMMA
##

Ill-formed parametric type expression.
At this point, a type argument is expected as a type expression.

program: Module UIdent EQ Struct With
##
## Ends in an error in state: 130.
##
## module_decl -> Module UIdent EQ Struct . module_ End [ Type Module Let In End EOF Directive Contract Attr ]
##
## The known suffix of the stack is as follows:
## Module UIdent EQ Struct
##

Ill-formed module declaration.
At this point, declarations are expected.

program: Let LPAR With
##
## Ends in an error in state: 149.
##
## par(irrefutable) -> LPAR . tuple(core_irrefutable) RPAR [ WILD UIdent SEMI RPAR RBRACE LPAR LBRACE Ident EQ EIdent COMMA COLON Attr ARROW ]
## par(irrefutable) -> LPAR . WILD RPAR [ WILD UIdent SEMI RPAR RBRACE LPAR LBRACE Ident EQ EIdent COMMA COLON Attr ARROW ]
## par(irrefutable) -> LPAR . var_pattern RPAR [ WILD UIdent SEMI RPAR RBRACE LPAR LBRACE Ident EQ EIdent COMMA COLON Attr ARROW ]
## par(irrefutable) -> LPAR . unit RPAR [ WILD UIdent SEMI RPAR RBRACE LPAR LBRACE Ident EQ EIdent COMMA COLON Attr ARROW ]
## par(irrefutable) -> LPAR . record_pattern(irrefutable) RPAR [ WILD UIdent SEMI RPAR RBRACE LPAR LBRACE Ident EQ EIdent COMMA COLON Attr ARROW ]
## par(irrefutable) -> LPAR . par(typed_irrefutable) RPAR [ WILD UIdent SEMI RPAR RBRACE LPAR LBRACE Ident EQ EIdent COMMA COLON Attr ARROW ]
## par(irrefutable) -> LPAR . par(irrefutable) RPAR [ WILD UIdent SEMI RPAR RBRACE LPAR LBRACE Ident EQ EIdent COMMA COLON Attr ARROW ]
## par(irrefutable) -> LPAR . ctor_irrefutable RPAR [ WILD UIdent SEMI RPAR RBRACE LPAR LBRACE Ident EQ EIdent COMMA COLON Attr ARROW ]
## par(non_const_ctor_irrefutable) -> LPAR . non_const_ctor_irrefutable RPAR [ WILD UIdent SEMI RPAR RBRACE LPAR LBRACE Ident EQ EIdent COMMA COLON Attr ARROW ]
## par(typed_irrefutable) -> LPAR . typed_irrefutable RPAR [ WILD UIdent SEMI RPAR RBRACE LPAR LBRACE Ident EQ EIdent COMMA COLON Attr ARROW ]
## unit -> LPAR . RPAR [ WILD UIdent SEMI RPAR RBRACE LPAR LBRACE Ident EQ EIdent COMMA COLON Attr ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR
##
interactive_expr: Match UIdent With LPAR With
##
## Ends in an error in state: 323.
##
## par(pattern) -> LPAR . pattern RPAR [ SEMI RPAR RBRACKET RBRACE In CONS COMMA COLON ARROW ]
## par(typed_pattern) -> LPAR . typed_pattern RPAR [ SEMI RPAR RBRACKET RBRACE In CONS COMMA COLON ARROW ]
## unit -> LPAR . RPAR [ SEMI RPAR RBRACKET RBRACE In CONS COMMA COLON ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR
##

Ill-formed pattern.
At this point, one of the following is expected:
  * a pattern followed by a closing parenthesis ')';
  * a closing parenthesis ')' if matching the unit value '()'.

program: Let LBRACE Ident EQ With
##
## Ends in an error in state: 161.
##
## field_pattern(irrefutable) -> gen_ident EQ . tuple(core_irrefutable) [ SEMI RBRACE ]
## field_pattern(irrefutable) -> gen_ident EQ . WILD [ SEMI RBRACE ]
## field_pattern(irrefutable) -> gen_ident EQ . var_pattern [ SEMI RBRACE ]
## field_pattern(irrefutable) -> gen_ident EQ . unit [ SEMI RBRACE ]
## field_pattern(irrefutable) -> gen_ident EQ . record_pattern(irrefutable) [ SEMI RBRACE ]
## field_pattern(irrefutable) -> gen_ident EQ . par(typed_irrefutable) [ SEMI RBRACE ]
## field_pattern(irrefutable) -> gen_ident EQ . par(irrefutable) [ SEMI RBRACE ]
## field_pattern(irrefutable) -> gen_ident EQ . ctor_irrefutable [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## gen_ident EQ
##

Ill-formed record pattern.
At this point, an irrefutable pattern matching the field is expected,
e.g. a variable.

interactive_expr: Match UIdent With LBRACE Ident EQ With
##
## Ends in an error in state: 331.
##
## field_pattern(core_pattern) -> gen_ident EQ . core_pattern [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## gen_ident EQ
##

Ill-formed record pattern.
At this point, a pattern matching the field is expected.

program: Let Attr With
##
## Ends in an error in state: 176.
##
## var_pattern -> nseq(Attr) . gen_ident [ WILD UIdent SEMI RPAR RBRACKET RBRACE LPAR LBRACE In Ident EQ EIdent CONS COMMA COLON Attr ARROW ]
##
## The known suffix of the stack is as follows:
## nseq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 41, spurious reduction of production seq(Attr) ->
## In state 44, spurious reduction of production nseq(Attr) -> Attr seq(Attr)
##

Ill-formed attributed variable in a pattern.
At this point, if the attribute is complete, an identifier is
expected.

interactive_expr: Let Mut Ident COLON Ident EQ ZWSP
##
## Ends in an error in state: 607.
##
## let_mut_binding -> var_pattern type_annotation(type_expr) EQ . expr [ In ]
##
## The known suffix of the stack is as follows:
## var_pattern type_annotation(type_expr) EQ
##
interactive_expr: Let Mut Ident EQ ZWSP
##
## Ends in an error in state: 604.
##
## let_mut_binding -> var_pattern EQ . expr [ In ]
##
## The known suffix of the stack is as follows:
## var_pattern EQ
##
program: Let Ident COLON Ident EQ With
##
## Ends in an error in state: 1207.
##
## non_fun_decl -> var_pattern type_annotation(type_expr) EQ . expr [ Type Module Let In End EOF Directive Contract Attr ]
##
## The known suffix of the stack is as follows:
## var_pattern type_annotation(type_expr) EQ
##
program: Let Ident EQ With
##
## Ends in an error in state: 268.
##
## non_fun_decl -> var_pattern EQ . expr [ Type Module Let In End EOF Directive Contract Attr ]
##
## The known suffix of the stack is as follows:
## var_pattern EQ
##
program: Let Ident Ident EQ With
##
## Ends in an error in state: 1210.
##
## fun_decl -> var_pattern parameters EQ . expr [ Type Module Let In End EOF Directive Contract Attr ]
##
## The known suffix of the stack is as follows:
## var_pattern parameters EQ
##
program: Let Ident Ident COLON Ident EQ With
##
## Ends in an error in state: 1213.
##
## fun_decl -> var_pattern parameters type_annotation(type_expr) EQ . expr [ Type Module Let In End EOF Directive Contract Attr ]
##
## The known suffix of the stack is as follows:
## var_pattern parameters type_annotation(type_expr) EQ
##
program: Let WILD EQ With
##
## Ends in an error in state: 142.
##
## non_fun_decl -> WILD EQ . expr [ Type Module Let In End EOF Directive Contract Attr ]
##
## The known suffix of the stack is as follows:
## WILD EQ
##
program: Let LPAR RPAR COLON Ident EQ With
##
## Ends in an error in state: 529.
##
## non_fun_decl -> unit type_annotation(type_expr) EQ . expr [ Type Module Let In End EOF Directive Contract Attr ]
##
## The known suffix of the stack is as follows:
## unit type_annotation(type_expr) EQ
##
program: Let LPAR RPAR EQ With
##
## Ends in an error in state: 422.
##
## non_fun_decl -> unit EQ . expr [ Type Module Let In End EOF Directive Contract Attr ]
##
## The known suffix of the stack is as follows:
## unit EQ
##
program: Let LPAR RPAR LPAR Type Ident RPAR EQ With
##
## Ends in an error in state: 532.
##
## non_fun_decl -> unit par(type_param_list) EQ . expr [ Type Module Let In End EOF Directive Contract Attr ]
##
## The known suffix of the stack is as follows:
## unit par(type_param_list) EQ
##
program: Let LPAR RPAR LPAR Type Ident RPAR COLON Ident EQ With
##
## Ends in an error in state: 535.
##
## non_fun_decl -> unit par(type_param_list) type_annotation(type_expr) EQ . expr [ Type Module Let In End EOF Directive Contract Attr ]
##
## The known suffix of the stack is as follows:
## unit par(type_param_list) type_annotation(type_expr) EQ
##
program: Let WILD COMMA Ident EQ With
##
## Ends in an error in state: 538.
##
## non_fun_decl -> tuple(core_irrefutable) EQ . expr [ Type Module Let In End EOF Directive Contract Attr ]
##
## The known suffix of the stack is as follows:
## tuple(core_irrefutable) EQ
##
program: Let WILD COMMA Ident COLON Ident EQ With
##
## Ends in an error in state: 541.
##
## non_fun_decl -> tuple(core_irrefutable) type_annotation(type_expr) EQ . expr [ Type Module Let In End EOF Directive Contract Attr ]
##
## The known suffix of the stack is as follows:
## tuple(core_irrefutable) type_annotation(type_expr) EQ
##
program: Let WILD COMMA Ident LPAR Type Ident RPAR EQ With
##
## Ends in an error in state: 544.
##
## non_fun_decl -> tuple(core_irrefutable) par(type_param_list) EQ . expr [ Type Module Let In End EOF Directive Contract Attr ]
##
## The known suffix of the stack is as follows:
## tuple(core_irrefutable) par(type_param_list) EQ
##
program: Let WILD COMMA Ident LPAR Type Ident RPAR COLON Ident EQ With
##
## Ends in an error in state: 547.
##
## non_fun_decl -> tuple(core_irrefutable) par(type_param_list) type_annotation(type_expr) EQ . expr [ Type Module Let In End EOF Directive Contract Attr ]
##
## The known suffix of the stack is as follows:
## tuple(core_irrefutable) par(type_param_list) type_annotation(type_expr) EQ
##
program: Let LBRACE Ident RBRACE EQ With
##
## Ends in an error in state: 550.
##
## non_fun_decl -> record_pattern(irrefutable) EQ . expr [ Type Module Let In End EOF Directive Contract Attr ]
##
## The known suffix of the stack is as follows:
## record_pattern(irrefutable) EQ
##
program: Let LBRACE Ident RBRACE COLON Ident EQ With
##
## Ends in an error in state: 553.
##
## non_fun_decl -> record_pattern(irrefutable) type_annotation(type_expr) EQ . expr [ Type Module Let In End EOF Directive Contract Attr ]
##
## The known suffix of the stack is as follows:
## record_pattern(irrefutable) type_annotation(type_expr) EQ
##
program: Let LBRACE Ident RBRACE LPAR Type Ident RPAR EQ With
##
## Ends in an error in state: 556.
##
## non_fun_decl -> record_pattern(irrefutable) par(type_param_list) EQ . expr [ Type Module Let In End EOF Directive Contract Attr ]
##
## The known suffix of the stack is as follows:
## record_pattern(irrefutable) par(type_param_list) EQ
##
program: Let LBRACE Ident RBRACE LPAR Type Ident RPAR COLON Ident EQ With
##
## Ends in an error in state: 559.
##
## non_fun_decl -> record_pattern(irrefutable) par(type_param_list) type_annotation(type_expr) EQ . expr [ Type Module Let In End EOF Directive Contract Attr ]
##
## The known suffix of the stack is as follows:
## record_pattern(irrefutable) par(type_param_list) type_annotation(type_expr) EQ
##
program: Let LPAR UIdent COLON Ident RPAR EQ With
##
## Ends in an error in state: 562.
##
## non_fun_decl -> par(typed_irrefutable) EQ . expr [ Type Module Let In End EOF Directive Contract Attr ]
##
## The known suffix of the stack is as follows:
## par(typed_irrefutable) EQ
##
program: Let LPAR UIdent COLON Ident RPAR COLON Ident EQ With
##
## Ends in an error in state: 565.
##
## non_fun_decl -> par(typed_irrefutable) type_annotation(type_expr) EQ . expr [ Type Module Let In End EOF Directive Contract Attr ]
##
## The known suffix of the stack is as follows:
## par(typed_irrefutable) type_annotation(type_expr) EQ
##
program: Let LPAR UIdent COLON Ident RPAR LPAR Type Ident RPAR EQ With
##
## Ends in an error in state: 568.
##
## non_fun_decl -> par(typed_irrefutable) par(type_param_list) EQ . expr [ Type Module Let In End EOF Directive Contract Attr ]
##
## The known suffix of the stack is as follows:
## par(typed_irrefutable) par(type_param_list) EQ
##
program: Let LPAR UIdent COLON Ident RPAR LPAR Type Ident RPAR COLON Ident EQ With
##
## Ends in an error in state: 571.
##
## non_fun_decl -> par(typed_irrefutable) par(type_param_list) type_annotation(type_expr) EQ . expr [ Type Module Let In End EOF Directive Contract Attr ]
##
## The known suffix of the stack is as follows:
## par(typed_irrefutable) par(type_param_list) type_annotation(type_expr) EQ
##
program: Let LPAR WILD RPAR EQ With
##
## Ends in an error in state: 574.
##
## non_fun_decl -> par(irrefutable) EQ . expr [ Type Module Let In End EOF Directive Contract Attr ]
##
## The known suffix of the stack is as follows:
## par(irrefutable) EQ
##
program: Let LPAR WILD RPAR COLON Ident EQ With
##
## Ends in an error in state: 577.
##
## non_fun_decl -> par(irrefutable) type_annotation(type_expr) EQ . expr [ Type Module Let In End EOF Directive Contract Attr ]
##
## The known suffix of the stack is as follows:
## par(irrefutable) type_annotation(type_expr) EQ
##
program: Let LPAR WILD RPAR LPAR Type Ident RPAR EQ With
##
## Ends in an error in state: 580.
##
## non_fun_decl -> par(irrefutable) par(type_param_list) EQ . expr [ Type Module Let In End EOF Directive Contract Attr ]
##
## The known suffix of the stack is as follows:
## par(irrefutable) par(type_param_list) EQ
##
program: Let LPAR WILD RPAR LPAR Type Ident RPAR COLON Ident EQ With
##
## Ends in an error in state: 583.
##
## non_fun_decl -> par(irrefutable) par(type_param_list) type_annotation(type_expr) EQ . expr [ Type Module Let In End EOF Directive Contract Attr ]
##
## The known suffix of the stack is as follows:
## par(irrefutable) par(type_param_list) type_annotation(type_expr) EQ
##
program: Let UIdent EQ With
##
## Ends in an error in state: 591.
##
## non_fun_decl -> ctor_irrefutable EQ . expr [ Type Module Let In End EOF Directive Contract Attr ]
##
## The known suffix of the stack is as follows:
## ctor_irrefutable EQ
##
program: Let UIdent COLON Ident EQ With
##
## Ends in an error in state: 594.
##
## non_fun_decl -> ctor_irrefutable type_annotation(type_expr) EQ . expr [ Type Module Let In End EOF Directive Contract Attr ]
##
## The known suffix of the stack is as follows:
## ctor_irrefutable type_annotation(type_expr) EQ
##
program: Let UIdent LPAR Type Ident RPAR EQ With
##
## Ends in an error in state: 597.
##
## non_fun_decl -> ctor_irrefutable par(type_param_list) EQ . expr [ Type Module Let In End EOF Directive Contract Attr ]
##
## The known suffix of the stack is as follows:
## ctor_irrefutable par(type_param_list) EQ
##
program: Let UIdent LPAR Type Ident RPAR COLON Ident EQ With
##
## Ends in an error in state: 600.
##
## non_fun_decl -> ctor_irrefutable par(type_param_list) type_annotation(type_expr) EQ . expr [ Type Module Let In End EOF Directive Contract Attr ]
##
## The known suffix of the stack is as follows:
## ctor_irrefutable par(type_param_list) type_annotation(type_expr) EQ
##
program: Let Ident LPAR Type Ident RPAR EQ With
##
## Ends in an error in state: 1216.
##
## non_fun_decl -> var_pattern par(type_param_list) EQ . expr [ Type Module Let In End EOF Directive Contract Attr ]
##
## The known suffix of the stack is as follows:
## var_pattern par(type_param_list) EQ
##
program: Let Ident LPAR Type Ident RPAR COLON Ident EQ With
##
## Ends in an error in state: 1219.
##
## non_fun_decl -> var_pattern par(type_param_list) type_annotation(type_expr) EQ . expr [ Type Module Let In End EOF Directive Contract Attr ]
##
## The known suffix of the stack is as follows:
## var_pattern par(type_param_list) type_annotation(type_expr) EQ
##
program: Let WILD COLON WILD EQ With
##
## Ends in an error in state: 1257.
##
## non_fun_decl -> WILD type_annotation(type_expr) EQ . expr [ Type Module Let In End EOF Directive Contract Attr ]
##
## The known suffix of the stack is as follows:
## WILD type_annotation(type_expr) EQ
##
program: Let WILD LPAR Type Ident RPAR EQ With
##
## Ends in an error in state: 1260.
##
## non_fun_decl -> WILD par(type_param_list) EQ . expr [ Type Module Let In End EOF Directive Contract Attr ]
##
## The known suffix of the stack is as follows:
## WILD par(type_param_list) EQ
##
program: Let WILD LPAR Type Ident RPAR COLON Ident EQ With
##
## Ends in an error in state: 1263.
##
## non_fun_decl -> WILD par(type_param_list) type_annotation(type_expr) EQ . expr [ Type Module Let In End EOF Directive Contract Attr ]
##
## The known suffix of the stack is as follows:
## WILD par(type_param_list) type_annotation(type_expr) EQ
##

Ill-formed value declaration.
At this point, an expression is expected.

interactive_expr: Lang With
##
## Ends in an error in state: 120.
##
## code_inj -> Lang . expr RBRACKET [ With Verbatim VBAR UIdent Type To Then TIMES String SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Lxor Lsr Lsl Lor Let Lang Land LT LPAR LE LBRACKET LBRACE Int In Ident GT End Else EQ EOF EIdent Downto Done Do Directive Contract CONS COMMA COLON CARET Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## Lang
##

Ill-formed code injection.
At this point, the code is expected as an expression whose value is a
verbatim string.

interactive_expr: LPAR With
##
## Ends in an error in state: 122.
##
## par(__anonymous_2) -> LPAR . Contract address_cast RPAR [ With VBAR Type To Then TIMES SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or NE Module Mod MINUS Lxor Lsr Lsl Lor Let Land LT LE In GT End Else EQ EOF Downto Done Do Directive Contract CONS COMMA COLON CARET BOOL_OR BOOL_AND Attr ]
## par(expr) -> LPAR . expr RPAR [ With Verbatim VBAR UIdent Type To Then TIMES String SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Lxor Lsr Lsl Lor Let Lang Land LT LPAR LE LBRACKET LBRACE Int In Ident GT End Else EQ EOF EIdent Downto Done Do Directive DOT Contract CONS COMMA COLON CARET Bytes Begin BOOL_OR BOOL_AND Attr ]
## par(typed_expr) -> LPAR . typed_expr RPAR [ With Verbatim VBAR UIdent Type To Then TIMES String SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Lxor Lsr Lsl Lor Let Lang Land LT LPAR LE LBRACKET LBRACE Int In Ident GT End Else EQ EOF EIdent Downto Done Do Directive Contract CONS COMMA COLON CARET Bytes Begin BOOL_OR BOOL_AND Attr ]
## unit -> LPAR . RPAR [ With Verbatim VBAR UIdent Type To Then TIMES String SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Lxor Lsr Lsl Lor Let Lang Land LT LPAR LE LBRACKET LBRACE Int In Ident GT End Else EQ EOF EIdent Downto Done Do Directive Contract CONS COMMA COLON CARET Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## LPAR
##

Ill-formed expression.
At this point, one of the following is expected:
  * an expression, if defining a parenthesised expression;
  * a closing parenthesis ')' if defining the unit value '()'.

interactive_expr: Match UIdent With LBRACKET With
##
## Ends in an error in state: 324.
##
## list_of(cons_pattern_level) -> LBRACKET . option(sep_or_term_list(cons_pattern_level,SEMI)) RBRACKET [ SEMI RPAR RBRACKET RBRACE In CONS COMMA COLON ARROW ]
##
## The known suffix of the stack is as follows:
## LBRACKET
##

Ill-formed list of patterns.
At this point, one of the following is expected:
  * a list element as a pattern;
  * a closing bracket ']' if matching the empty list.

interactive_expr: Match UIdent With UIdent COMMA With
##
## Ends in an error in state: 371.
##
## tuple(cons_pattern_level) -> cons_pattern_level COMMA . nsepseq(cons_pattern_level,COMMA) [ RPAR In COLON ARROW ]
##
## The known suffix of the stack is as follows:
## cons_pattern_level COMMA
##
interactive_expr: Match UIdent With UIdent COMMA UIdent COMMA With
##
## Ends in an error in state: 374.
##
## nsepseq(cons_pattern_level,COMMA) -> cons_pattern_level COMMA . nsepseq(cons_pattern_level,COMMA) [ RPAR In COLON ARROW ]
##
## The known suffix of the stack is as follows:
## cons_pattern_level COMMA
##
program: Let Ident COMMA With
##
## Ends in an error in state: 164.
##
## tuple(core_irrefutable) -> var_pattern COMMA . nsepseq(core_irrefutable,COMMA) [ SEMI RPAR RBRACE LPAR EQ COLON ]
##
## The known suffix of the stack is as follows:
## var_pattern COMMA
##
program: Let Ident COMMA Ident COMMA With
##
## Ends in an error in state: 166.
##
## nsepseq(core_irrefutable,COMMA) -> var_pattern COMMA . nsepseq(core_irrefutable,COMMA) [ SEMI RPAR RBRACE LPAR EQ COLON ]
##
## The known suffix of the stack is as follows:
## var_pattern COMMA
##
program: Let WILD COMMA WILD COMMA With
##
## Ends in an error in state: 154.
##
## nsepseq(core_irrefutable,COMMA) -> WILD COMMA . nsepseq(core_irrefutable,COMMA) [ SEMI RPAR RBRACE LPAR EQ COLON ]
##
## The known suffix of the stack is as follows:
## WILD COMMA
##
program: Let WILD COMMA LPAR RPAR COMMA With
##
## Ends in an error in state: 168.
##
## nsepseq(core_irrefutable,COMMA) -> unit COMMA . nsepseq(core_irrefutable,COMMA) [ SEMI RPAR RBRACE LPAR EQ COLON ]
##
## The known suffix of the stack is as follows:
## unit COMMA
##
program: Let WILD COMMA LBRACE Ident RBRACE COMMA With
##
## Ends in an error in state: 170.
##
## nsepseq(core_irrefutable,COMMA) -> record_pattern(irrefutable) COMMA . nsepseq(core_irrefutable,COMMA) [ SEMI RPAR RBRACE LPAR EQ COLON ]
##
## The known suffix of the stack is as follows:
## record_pattern(irrefutable) COMMA
##
program: Let WILD COMMA LPAR UIdent COLON Ident RPAR COMMA With
##
## Ends in an error in state: 172.
##
## nsepseq(core_irrefutable,COMMA) -> par(typed_irrefutable) COMMA . nsepseq(core_irrefutable,COMMA) [ SEMI RPAR RBRACE LPAR EQ COLON ]
##
## The known suffix of the stack is as follows:
## par(typed_irrefutable) COMMA
##
program: Let WILD COMMA LPAR WILD RPAR COMMA With
##
## Ends in an error in state: 175.
##
## nsepseq(core_irrefutable,COMMA) -> par(irrefutable) COMMA . nsepseq(core_irrefutable,COMMA) [ SEMI RPAR RBRACE LPAR EQ COLON ]
##
## The known suffix of the stack is as follows:
## par(irrefutable) COMMA
##
program: Let WILD COMMA UIdent COMMA With
##
## Ends in an error in state: 181.
##
## nsepseq(core_irrefutable,COMMA) -> ctor_irrefutable COMMA . nsepseq(core_irrefutable,COMMA) [ SEMI RPAR RBRACE LPAR EQ COLON ]
##
## The known suffix of the stack is as follows:
## ctor_irrefutable COMMA
##
program: Let LPAR RPAR COMMA With
##
## Ends in an error in state: 190.
##
## tuple(core_irrefutable) -> unit COMMA . nsepseq(core_irrefutable,COMMA) [ SEMI RPAR RBRACE LPAR EQ COLON ]
##
## The known suffix of the stack is as follows:
## unit COMMA
##
program: Let LBRACE Ident RBRACE COMMA With
##
## Ends in an error in state: 194.
##
## tuple(core_irrefutable) -> record_pattern(irrefutable) COMMA . nsepseq(core_irrefutable,COMMA) [ SEMI RPAR RBRACE LPAR EQ COLON ]
##
## The known suffix of the stack is as follows:
## record_pattern(irrefutable) COMMA
##
program: Let LPAR UIdent COLON Ident RPAR COMMA With
##
## Ends in an error in state: 197.
##
## tuple(core_irrefutable) -> par(typed_irrefutable) COMMA . nsepseq(core_irrefutable,COMMA) [ SEMI RPAR RBRACE LPAR EQ COLON ]
##
## The known suffix of the stack is as follows:
## par(typed_irrefutable) COMMA
##
program: Let LPAR WILD RPAR COMMA With
##
## Ends in an error in state: 200.
##
## tuple(core_irrefutable) -> par(irrefutable) COMMA . nsepseq(core_irrefutable,COMMA) [ SEMI RPAR RBRACE LPAR EQ COLON ]
##
## The known suffix of the stack is as follows:
## par(irrefutable) COMMA
##
program: Let UIdent COMMA With
##
## Ends in an error in state: 203.
##
## tuple(core_irrefutable) -> ctor_irrefutable COMMA . nsepseq(core_irrefutable,COMMA) [ SEMI RPAR RBRACE LPAR EQ COLON ]
##
## The known suffix of the stack is as follows:
## ctor_irrefutable COMMA
##
program: Let WILD COMMA With
##
## Ends in an error in state: 152.
##
## tuple(core_irrefutable) -> WILD COMMA . nsepseq(core_irrefutable,COMMA) [ SEMI RPAR RBRACE LPAR EQ COLON ]
##
## The known suffix of the stack is as follows:
## WILD COMMA
##

Ill-formed tuple of patterns.
At this point, another component is expected as a pattern.

interactive_expr: LBRACKET With
##
## Ends in an error in state: 145.
##
## list_of(expr) -> LBRACKET . option(sep_or_term_list(expr,SEMI)) RBRACKET [ With Verbatim VBAR UIdent Type To Then TIMES String SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Lxor Lsr Lsl Lor Let Lang Land LT LPAR LE LBRACKET LBRACE Int In Ident GT End Else EQ EOF EIdent Downto Done Do Directive Contract CONS COMMA COLON CARET Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## LBRACKET
##

Ill-formed list of expressions.
At this point, one of the following is expected:
  * a list element as an expression;
  * a closing bracket ']' if defining the empty list.

interactive_expr: LBRACE Ident EQ With
##
## Ends in an error in state: 1195.
##
## field_assignment -> gen_ident EQ . expr [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## gen_ident EQ
##

Ill-formed record expression.
At this point, an expression is expected to be assigned to the field.

interactive_expr: If UIdent Then Attr Fun LPAR Type Ident RPAR With
##
## Ends in an error in state: 1151.
##
## fun_expr(closed_expr) -> nseq(Attr) Fun par(type_param_list) . nseq(core_irrefutable) ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> nseq(Attr) Fun par(type_param_list) . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW closed_expr [ Else ]
## fun_expr(expr) -> nseq(Attr) Fun par(type_param_list) . nseq(core_irrefutable) ARROW expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(expr) -> nseq(Attr) Fun par(type_param_list) . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun par(type_param_list)
##
interactive_expr: Begin Match UIdent With UIdent ARROW Fun LPAR Type Ident RPAR With
##
## Ends in an error in state: 937.
##
## fun_expr(base_cond) -> Fun par(type_param_list) . nseq(core_irrefutable) ARROW base_cond [ VBAR ]
## fun_expr(base_cond) -> Fun par(type_param_list) . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW base_cond [ VBAR ]
## fun_expr(last_expr) -> Fun par(type_param_list) . nseq(core_irrefutable) ARROW last_expr [ End Done ]
## fun_expr(last_expr) -> Fun par(type_param_list) . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW last_expr [ End Done ]
##
## The known suffix of the stack is as follows:
## Fun par(type_param_list)
##
interactive_expr: Match UIdent With UIdent ARROW Attr Fun LPAR Type Ident RPAR With
##
## Ends in an error in state: 911.
##
## fun_expr(base_cond) -> nseq(Attr) Fun par(type_param_list) . nseq(core_irrefutable) ARROW base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(base_cond) -> nseq(Attr) Fun par(type_param_list) . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun par(type_param_list)
##
interactive_expr: If UIdent Then Match UIdent With UIdent ARROW Attr Fun LPAR Type Ident RPAR With
##
## Ends in an error in state: 840.
##
## fun_expr(base_cond) -> nseq(Attr) Fun par(type_param_list) . nseq(core_irrefutable) ARROW base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(base_cond) -> nseq(Attr) Fun par(type_param_list) . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(base_if_then_else) -> nseq(Attr) Fun par(type_param_list) . nseq(core_irrefutable) ARROW base_if_then_else [ Else ]
## fun_expr(base_if_then_else) -> nseq(Attr) Fun par(type_param_list) . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun par(type_param_list)
##
interactive_expr: Attr Fun LPAR Type Ident RPAR With
##
## Ends in an error in state: 616.
##
## fun_expr(expr) -> nseq(Attr) Fun par(type_param_list) . nseq(core_irrefutable) ARROW expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(expr) -> nseq(Attr) Fun par(type_param_list) . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun par(type_param_list)
##
interactive_expr: Match UIdent With UIdent ARROW If UIdent Then Attr Fun LPAR Type Ident RPAR With
##
## Ends in an error in state: 751.
##
## fun_expr(base_cond) -> nseq(Attr) Fun par(type_param_list) . nseq(core_irrefutable) ARROW base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(base_cond) -> nseq(Attr) Fun par(type_param_list) . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(closed_expr) -> nseq(Attr) Fun par(type_param_list) . nseq(core_irrefutable) ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> nseq(Attr) Fun par(type_param_list) . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun par(type_param_list)
##
interactive_expr: Fun LPAR Type Ident RPAR With
##
## Ends in an error in state: 290.
##
## fun_expr(expr) -> Fun par(type_param_list) . nseq(core_irrefutable) ARROW expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(expr) -> Fun par(type_param_list) . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun par(type_param_list)
##
interactive_expr: Match UIdent With UIdent ARROW If UIdent Then Fun LPAR Type Ident RPAR With
##
## Ends in an error in state: 697.
##
## fun_expr(base_cond) -> Fun par(type_param_list) . nseq(core_irrefutable) ARROW base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(base_cond) -> Fun par(type_param_list) . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(closed_expr) -> Fun par(type_param_list) . nseq(core_irrefutable) ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> Fun par(type_param_list) . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Fun par(type_param_list)
##
interactive_expr: If UIdent Then Match UIdent With UIdent ARROW Fun LPAR Type Ident RPAR With
##
## Ends in an error in state: 803.
##
## fun_expr(base_cond) -> Fun par(type_param_list) . nseq(core_irrefutable) ARROW base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(base_cond) -> Fun par(type_param_list) . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(base_if_then_else) -> Fun par(type_param_list) . nseq(core_irrefutable) ARROW base_if_then_else [ Else ]
## fun_expr(base_if_then_else) -> Fun par(type_param_list) . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## Fun par(type_param_list)
##
interactive_expr: Match UIdent With UIdent ARROW Fun LPAR Type Ident RPAR With
##
## Ends in an error in state: 888.
##
## fun_expr(base_cond) -> Fun par(type_param_list) . nseq(core_irrefutable) ARROW base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(base_cond) -> Fun par(type_param_list) . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun par(type_param_list)
##
interactive_expr: Begin Fun LPAR Type Ident RPAR With
##
## Ends in an error in state: 1016.
##
## fun_expr(last_expr) -> Fun par(type_param_list) . nseq(core_irrefutable) ARROW last_expr [ End Done ]
## fun_expr(last_expr) -> Fun par(type_param_list) . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW last_expr [ End Done ]
##
## The known suffix of the stack is as follows:
## Fun par(type_param_list)
##
interactive_expr: If UIdent Then Fun LPAR Type Ident RPAR With
##
## Ends in an error in state: 1128.
##
## fun_expr(closed_expr) -> Fun par(type_param_list) . nseq(core_irrefutable) ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> Fun par(type_param_list) . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW closed_expr [ Else ]
## fun_expr(expr) -> Fun par(type_param_list) . nseq(core_irrefutable) ARROW expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(expr) -> Fun par(type_param_list) . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun par(type_param_list)
##
interactive_expr: Begin If UIdent Then Fun LPAR Type Ident RPAR With
##
## Ends in an error in state: 965.
##
## fun_expr(closed_expr) -> Fun par(type_param_list) . nseq(core_irrefutable) ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> Fun par(type_param_list) . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Fun par(type_param_list)
##
interactive_expr: Begin If UIdent Then Attr Fun LPAR Type Ident RPAR With
##
## Ends in an error in state: 988.
##
## fun_expr(closed_expr) -> nseq(Attr) Fun par(type_param_list) . nseq(core_irrefutable) ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> nseq(Attr) Fun par(type_param_list) . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun par(type_param_list)
##
interactive_expr: Begin Attr Fun LPAR Type Ident RPAR With
##
## Ends in an error in state: 1031.
##
## fun_expr(last_expr) -> nseq(Attr) Fun par(type_param_list) . nseq(core_irrefutable) ARROW last_expr [ End Done ]
## fun_expr(last_expr) -> nseq(Attr) Fun par(type_param_list) . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW last_expr [ End Done ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun par(type_param_list)
##
interactive_expr: Begin Match UIdent With UIdent ARROW Attr Fun LPAR Type Ident RPAR With
##
## Ends in an error in state: 1062.
##
## fun_expr(base_cond) -> nseq(Attr) Fun par(type_param_list) . nseq(core_irrefutable) ARROW base_cond [ VBAR ]
## fun_expr(base_cond) -> nseq(Attr) Fun par(type_param_list) . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW base_cond [ VBAR ]
## fun_expr(last_expr) -> nseq(Attr) Fun par(type_param_list) . nseq(core_irrefutable) ARROW last_expr [ End Done ]
## fun_expr(last_expr) -> nseq(Attr) Fun par(type_param_list) . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW last_expr [ End Done ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun par(type_param_list)
##

Ill-formed functional expression.
At this point, parameters are expected as irrefutable patterns,
e.g. variables.

interactive_expr: If UIdent Then Attr Fun With
##
## Ends in an error in state: 1150.
##
## fun_expr(closed_expr) -> nseq(Attr) Fun . nseq(core_irrefutable) ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> nseq(Attr) Fun . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> nseq(Attr) Fun . par(type_param_list) nseq(core_irrefutable) ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> nseq(Attr) Fun . par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW closed_expr [ Else ]
## fun_expr(expr) -> nseq(Attr) Fun . nseq(core_irrefutable) ARROW expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(expr) -> nseq(Attr) Fun . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(expr) -> nseq(Attr) Fun . par(type_param_list) nseq(core_irrefutable) ARROW expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(expr) -> nseq(Attr) Fun . par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun
##
interactive_expr: Begin Match UIdent With UIdent ARROW Attr Fun With
##
## Ends in an error in state: 1061.
##
## fun_expr(base_cond) -> nseq(Attr) Fun . nseq(core_irrefutable) ARROW base_cond [ VBAR ]
## fun_expr(base_cond) -> nseq(Attr) Fun . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW base_cond [ VBAR ]
## fun_expr(base_cond) -> nseq(Attr) Fun . par(type_param_list) nseq(core_irrefutable) ARROW base_cond [ VBAR ]
## fun_expr(base_cond) -> nseq(Attr) Fun . par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW base_cond [ VBAR ]
## fun_expr(last_expr) -> nseq(Attr) Fun . nseq(core_irrefutable) ARROW last_expr [ End Done ]
## fun_expr(last_expr) -> nseq(Attr) Fun . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW last_expr [ End Done ]
## fun_expr(last_expr) -> nseq(Attr) Fun . par(type_param_list) nseq(core_irrefutable) ARROW last_expr [ End Done ]
## fun_expr(last_expr) -> nseq(Attr) Fun . par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW last_expr [ End Done ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun
##
interactive_expr: Begin Attr Fun With
##
## Ends in an error in state: 1030.
##
## fun_expr(last_expr) -> nseq(Attr) Fun . nseq(core_irrefutable) ARROW last_expr [ End Done ]
## fun_expr(last_expr) -> nseq(Attr) Fun . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW last_expr [ End Done ]
## fun_expr(last_expr) -> nseq(Attr) Fun . par(type_param_list) nseq(core_irrefutable) ARROW last_expr [ End Done ]
## fun_expr(last_expr) -> nseq(Attr) Fun . par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW last_expr [ End Done ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun
##
interactive_expr: Begin If UIdent Then Attr Fun With
##
## Ends in an error in state: 987.
##
## fun_expr(closed_expr) -> nseq(Attr) Fun . nseq(core_irrefutable) ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> nseq(Attr) Fun . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> nseq(Attr) Fun . par(type_param_list) nseq(core_irrefutable) ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> nseq(Attr) Fun . par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun
##
interactive_expr: Match UIdent With UIdent ARROW Attr Fun With
##
## Ends in an error in state: 910.
##
## fun_expr(base_cond) -> nseq(Attr) Fun . nseq(core_irrefutable) ARROW base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(base_cond) -> nseq(Attr) Fun . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(base_cond) -> nseq(Attr) Fun . par(type_param_list) nseq(core_irrefutable) ARROW base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(base_cond) -> nseq(Attr) Fun . par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun
##
interactive_expr: If UIdent Then Match UIdent With UIdent ARROW Attr Fun With
##
## Ends in an error in state: 839.
##
## fun_expr(base_cond) -> nseq(Attr) Fun . nseq(core_irrefutable) ARROW base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(base_cond) -> nseq(Attr) Fun . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(base_cond) -> nseq(Attr) Fun . par(type_param_list) nseq(core_irrefutable) ARROW base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(base_cond) -> nseq(Attr) Fun . par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(base_if_then_else) -> nseq(Attr) Fun . nseq(core_irrefutable) ARROW base_if_then_else [ Else ]
## fun_expr(base_if_then_else) -> nseq(Attr) Fun . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW base_if_then_else [ Else ]
## fun_expr(base_if_then_else) -> nseq(Attr) Fun . par(type_param_list) nseq(core_irrefutable) ARROW base_if_then_else [ Else ]
## fun_expr(base_if_then_else) -> nseq(Attr) Fun . par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun
##
interactive_expr: Attr Fun With
##
## Ends in an error in state: 615.
##
## fun_expr(expr) -> nseq(Attr) Fun . nseq(core_irrefutable) ARROW expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(expr) -> nseq(Attr) Fun . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(expr) -> nseq(Attr) Fun . par(type_param_list) nseq(core_irrefutable) ARROW expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(expr) -> nseq(Attr) Fun . par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun
##
interactive_expr: If UIdent Then Fun With
##
## Ends in an error in state: 1127.
##
## fun_expr(closed_expr) -> Fun . nseq(core_irrefutable) ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> Fun . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> Fun . par(type_param_list) nseq(core_irrefutable) ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> Fun . par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW closed_expr [ Else ]
## fun_expr(expr) -> Fun . nseq(core_irrefutable) ARROW expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(expr) -> Fun . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(expr) -> Fun . par(type_param_list) nseq(core_irrefutable) ARROW expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(expr) -> Fun . par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun
##
interactive_expr: Begin Fun With
##
## Ends in an error in state: 1015.
##
## fun_expr(last_expr) -> Fun . nseq(core_irrefutable) ARROW last_expr [ End Done ]
## fun_expr(last_expr) -> Fun . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW last_expr [ End Done ]
## fun_expr(last_expr) -> Fun . par(type_param_list) nseq(core_irrefutable) ARROW last_expr [ End Done ]
## fun_expr(last_expr) -> Fun . par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW last_expr [ End Done ]
##
## The known suffix of the stack is as follows:
## Fun
##
interactive_expr: Begin If UIdent Then Fun With
##
## Ends in an error in state: 964.
##
## fun_expr(closed_expr) -> Fun . nseq(core_irrefutable) ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> Fun . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> Fun . par(type_param_list) nseq(core_irrefutable) ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> Fun . par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Fun
##
interactive_expr: Begin Match UIdent With UIdent ARROW Fun With
##
## Ends in an error in state: 936.
##
## fun_expr(base_cond) -> Fun . nseq(core_irrefutable) ARROW base_cond [ VBAR ]
## fun_expr(base_cond) -> Fun . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW base_cond [ VBAR ]
## fun_expr(base_cond) -> Fun . par(type_param_list) nseq(core_irrefutable) ARROW base_cond [ VBAR ]
## fun_expr(base_cond) -> Fun . par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW base_cond [ VBAR ]
## fun_expr(last_expr) -> Fun . nseq(core_irrefutable) ARROW last_expr [ End Done ]
## fun_expr(last_expr) -> Fun . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW last_expr [ End Done ]
## fun_expr(last_expr) -> Fun . par(type_param_list) nseq(core_irrefutable) ARROW last_expr [ End Done ]
## fun_expr(last_expr) -> Fun . par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW last_expr [ End Done ]
##
## The known suffix of the stack is as follows:
## Fun
##
interactive_expr: Match UIdent With UIdent ARROW Fun With
##
## Ends in an error in state: 887.
##
## fun_expr(base_cond) -> Fun . nseq(core_irrefutable) ARROW base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(base_cond) -> Fun . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(base_cond) -> Fun . par(type_param_list) nseq(core_irrefutable) ARROW base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(base_cond) -> Fun . par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun
##
interactive_expr: If UIdent Then Match UIdent With UIdent ARROW Fun With
##
## Ends in an error in state: 802.
##
## fun_expr(base_cond) -> Fun . nseq(core_irrefutable) ARROW base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(base_cond) -> Fun . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(base_cond) -> Fun . par(type_param_list) nseq(core_irrefutable) ARROW base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(base_cond) -> Fun . par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(base_if_then_else) -> Fun . nseq(core_irrefutable) ARROW base_if_then_else [ Else ]
## fun_expr(base_if_then_else) -> Fun . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW base_if_then_else [ Else ]
## fun_expr(base_if_then_else) -> Fun . par(type_param_list) nseq(core_irrefutable) ARROW base_if_then_else [ Else ]
## fun_expr(base_if_then_else) -> Fun . par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## Fun
##
interactive_expr: Fun With
##
## Ends in an error in state: 281.
##
## fun_expr(expr) -> Fun . nseq(core_irrefutable) ARROW expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(expr) -> Fun . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(expr) -> Fun . par(type_param_list) nseq(core_irrefutable) ARROW expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(expr) -> Fun . par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun
##
interactive_expr: Match UIdent With UIdent ARROW If UIdent Then Fun With
##
## Ends in an error in state: 696.
##
## fun_expr(base_cond) -> Fun . nseq(core_irrefutable) ARROW base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(base_cond) -> Fun . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(base_cond) -> Fun . par(type_param_list) nseq(core_irrefutable) ARROW base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(base_cond) -> Fun . par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(closed_expr) -> Fun . nseq(core_irrefutable) ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> Fun . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> Fun . par(type_param_list) nseq(core_irrefutable) ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> Fun . par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Fun
##
interactive_expr: Match UIdent With UIdent ARROW If UIdent Then Attr Fun With
##
## Ends in an error in state: 750.
##
## fun_expr(base_cond) -> nseq(Attr) Fun . nseq(core_irrefutable) ARROW base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(base_cond) -> nseq(Attr) Fun . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(base_cond) -> nseq(Attr) Fun . par(type_param_list) nseq(core_irrefutable) ARROW base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(base_cond) -> nseq(Attr) Fun . par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(closed_expr) -> nseq(Attr) Fun . nseq(core_irrefutable) ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> nseq(Attr) Fun . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> nseq(Attr) Fun . par(type_param_list) nseq(core_irrefutable) ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> nseq(Attr) Fun . par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun
##

Ill-formed functional expression.
At this point, one of the following is expected:
  * parameters as irrefutable patterns, e.g. variables;
  * bound type parameters between parentheses, like '(type a b)'.

interactive_expr: If UIdent Then Match With
##
## Ends in an error in state: 1115.
##
## try_or_match_expr(base_cond) -> Match . expr With option(VBAR) cases(base_cond) [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## try_or_match_expr(base_if_then_else) -> Match . expr With option(VBAR) cases(base_if_then_else) [ Else ]
##
## The known suffix of the stack is as follows:
## Match
##
interactive_expr: Begin Match With
##
## Ends in an error in state: 649.
##
## try_or_match_expr(last_expr) -> Match . expr With option(VBAR) cases(last_expr) [ End Done ]
##
## The known suffix of the stack is as follows:
## Match
##
interactive_expr: Match With
##
## Ends in an error in state: 143.
##
## try_or_match_expr(base_cond) -> Match . expr With option(VBAR) cases(base_cond) [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## Match
##
interactive_expr: Begin If UIdent Then Match With
##
## Ends in an error in state: 680.
##
## try_or_match_expr(base_if_then_else) -> Match . expr With option(VBAR) cases(base_if_then_else) [ Else ]
##
## The known suffix of the stack is as follows:
## Match
##

Ill-formed pattern matching expression.
At this point, the subject expression is expected.

interactive_expr: Module UIdent EQ Struct Directive End In With
##
## Ends in an error in state: 443.
##
## local_module_decl(expr) -> module_decl In . expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## module_decl In
##
interactive_expr: If UIdent Then Module UIdent EQ Struct Directive End In With
##
## Ends in an error in state: 1140.
##
## local_module_decl(closed_expr) -> module_decl In . closed_expr [ Else ]
## local_module_decl(expr) -> module_decl In . expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## module_decl In
##
interactive_expr: Begin If UIdent Then Module UIdent EQ Struct Directive End In With
##
## Ends in an error in state: 977.
##
## local_module_decl(closed_expr) -> module_decl In . closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## module_decl In
##
interactive_expr: Match UIdent With UIdent ARROW Module UIdent EQ Struct Directive End In With
##
## Ends in an error in state: 900.
##
## local_module_decl(base_cond) -> module_decl In . base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## module_decl In
##
interactive_expr: If UIdent Then Match UIdent With UIdent ARROW Module UIdent EQ Struct Directive End In With
##
## Ends in an error in state: 815.
##
## local_module_decl(base_cond) -> module_decl In . base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## local_module_decl(base_if_then_else) -> module_decl In . base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## module_decl In
##
interactive_expr: Match UIdent With UIdent ARROW If UIdent Then Module UIdent EQ Struct Directive End In With
##
## Ends in an error in state: 710.
##
## local_module_decl(base_cond) -> module_decl In . base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## local_module_decl(closed_expr) -> module_decl In . closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## module_decl In
##

Ill-formed local module declaration.
At this point, an expression is expected.

interactive_expr: Module UIdent EQ UIdent In With
##
## Ends in an error in state: 445.
##
## local_module_alias(expr) -> module_alias In . expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## module_alias In
##
interactive_expr: If UIdent Then Module UIdent EQ UIdent In With
##
## Ends in an error in state: 1142.
##
## local_module_alias(closed_expr) -> module_alias In . closed_expr [ Else ]
## local_module_alias(expr) -> module_alias In . expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## module_alias In
##
interactive_expr: Begin If UIdent Then Module UIdent EQ UIdent In With
##
## Ends in an error in state: 979.
##
## local_module_alias(closed_expr) -> module_alias In . closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## module_alias In
##
interactive_expr: Match UIdent With UIdent ARROW If UIdent Then Module UIdent EQ UIdent In With
##
## Ends in an error in state: 712.
##
## local_module_alias(base_cond) -> module_alias In . base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## local_module_alias(closed_expr) -> module_alias In . closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## module_alias In
##
interactive_expr: If UIdent Then Match UIdent With UIdent ARROW Module UIdent EQ UIdent In With
##
## Ends in an error in state: 817.
##
## local_module_alias(base_cond) -> module_alias In . base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## local_module_alias(base_if_then_else) -> module_alias In . base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## module_alias In
##
interactive_expr: Match UIdent With UIdent ARROW Module UIdent EQ UIdent In With
##
## Ends in an error in state: 902.
##
## local_module_alias(base_cond) -> module_alias In . base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## module_alias In
##

Ill-formed local module alias declaration.
At this point, an expression is expected.

program: Let Ident LPAR With
##
## Ends in an error in state: 267.
##
## par(irrefutable) -> LPAR . tuple(core_irrefutable) RPAR [ WILD UIdent LPAR LBRACE Ident EQ EIdent COLON Attr ARROW ]
## par(irrefutable) -> LPAR . WILD RPAR [ WILD UIdent LPAR LBRACE Ident EQ EIdent COLON Attr ARROW ]
## par(irrefutable) -> LPAR . var_pattern RPAR [ WILD UIdent LPAR LBRACE Ident EQ EIdent COLON Attr ARROW ]
## par(irrefutable) -> LPAR . unit RPAR [ WILD UIdent LPAR LBRACE Ident EQ EIdent COLON Attr ARROW ]
## par(irrefutable) -> LPAR . record_pattern(irrefutable) RPAR [ WILD UIdent LPAR LBRACE Ident EQ EIdent COLON Attr ARROW ]
## par(irrefutable) -> LPAR . par(typed_irrefutable) RPAR [ WILD UIdent LPAR LBRACE Ident EQ EIdent COLON Attr ARROW ]
## par(irrefutable) -> LPAR . par(irrefutable) RPAR [ WILD UIdent LPAR LBRACE Ident EQ EIdent COLON Attr ARROW ]
## par(irrefutable) -> LPAR . ctor_irrefutable RPAR [ WILD UIdent LPAR LBRACE Ident EQ EIdent COLON Attr ARROW ]
## par(non_const_ctor_irrefutable) -> LPAR . non_const_ctor_irrefutable RPAR [ WILD UIdent LPAR LBRACE Ident EQ EIdent COLON Attr ARROW ]
## par(type_param_list) -> LPAR . type_param_list RPAR [ WILD UIdent LPAR LBRACE Ident EQ EIdent COLON Attr ]
## par(typed_irrefutable) -> LPAR . typed_irrefutable RPAR [ WILD UIdent LPAR LBRACE Ident EQ EIdent COLON Attr ARROW ]
## unit -> LPAR . RPAR [ WILD UIdent LPAR LBRACE Ident EQ EIdent COLON Attr ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR
##

Ill-formed value declaration.
At this point, one of the following is expected:
  * the keyword 'type' followed by type parameters and a closing
    parenthesis ')';
  * a closing parenthesis ')' if matching the unit pattern;
  * a parameter as an irrefutable pattern followed by a closing
    parenthesis ')'.

program: Let Ident COLON LPAR With
##
## Ends in an error in state: 37.
##
## par(tuple(type_expr)) -> LPAR . tuple(type_expr) RPAR [ Ident EIdent ]
## par(type_expr) -> LPAR . type_expr RPAR [ VBAR Type TIMES SEMI RPAR RBRACE Module Let In Ident End EQ EOF EIdent Directive Contract COMMA Attr ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR
##

Ill-formed parenthesised expression.
At this point, an expression is expected.
Note: Tuples of expressions do not require in general to be
parenthesised, but parentheses improve readability.

program: Let Ident LPAR Type Ident RPAR With
##
## Ends in an error in state: 1215.
##
## fun_decl -> var_pattern par(type_param_list) . parameters EQ expr [ Type Module Let In End EOF Directive Contract Attr ]
## fun_decl -> var_pattern par(type_param_list) . parameters type_annotation(type_expr) EQ expr [ Type Module Let In End EOF Directive Contract Attr ]
## non_fun_decl -> var_pattern par(type_param_list) . EQ expr [ Type Module Let In End EOF Directive Contract Attr ]
## non_fun_decl -> var_pattern par(type_param_list) . type_annotation(type_expr) EQ expr [ Type Module Let In End EOF Directive Contract Attr ]
##
## The known suffix of the stack is as follows:
## var_pattern par(type_param_list)
##

Ill-formed polymorphic function declaration.
At this point, one of the following is expected:
  * parameters as irrefutable patterns, e.g. variables;
  * the assignment symbol '=' followed by the body as an expression;
  * a type annotation starting with a colon ':' for the body.

program: Let Ident LPAR Type Ident RPAR Ident EQ With
##
## Ends in an error in state: 1222.
##
## fun_decl -> var_pattern par(type_param_list) parameters EQ . expr [ Type Module Let In End EOF Directive Contract Attr ]
##
## The known suffix of the stack is as follows:
## var_pattern par(type_param_list) parameters EQ
##
program: Let Ident LPAR Type Ident RPAR Ident COLON Ident EQ With
##
## Ends in an error in state: 1225.
##
## fun_decl -> var_pattern par(type_param_list) parameters type_annotation(type_expr) EQ . expr [ Type Module Let In End EOF Directive Contract Attr ]
##
## The known suffix of the stack is as follows:
## var_pattern par(type_param_list) parameters type_annotation(type_expr) EQ
##

Ill-formed function declaration.
At this point, the body of the function is expected as an expression.

interactive_expr: Fun WILD With
##
## Ends in an error in state: 251.
##
## nseq(core_irrefutable) -> WILD . seq(core_irrefutable) [ EQ COLON ARROW ]
##
## The known suffix of the stack is as follows:
## WILD
##
interactive_expr: Fun WILD WILD With
##
## Ends in an error in state: 252.
##
## seq(core_irrefutable) -> WILD . seq(core_irrefutable) [ EQ COLON ARROW ]
##
## The known suffix of the stack is as follows:
## WILD
##
interactive_expr: Fun WILD LPAR RPAR With
##
## Ends in an error in state: 254.
##
## seq(core_irrefutable) -> unit . seq(core_irrefutable) [ EQ COLON ARROW ]
##
## The known suffix of the stack is as follows:
## unit
##
interactive_expr: Fun WILD LBRACE Ident RBRACE With
##
## Ends in an error in state: 256.
##
## seq(core_irrefutable) -> record_pattern(irrefutable) . seq(core_irrefutable) [ EQ COLON ARROW ]
##
## The known suffix of the stack is as follows:
## record_pattern(irrefutable)
##
interactive_expr: Fun WILD LPAR UIdent COLON Ident RPAR With
##
## Ends in an error in state: 258.
##
## seq(core_irrefutable) -> par(typed_irrefutable) . seq(core_irrefutable) [ EQ COLON ARROW ]
##
## The known suffix of the stack is as follows:
## par(typed_irrefutable)
##
interactive_expr: Fun WILD LPAR WILD RPAR With
##
## Ends in an error in state: 260.
##
## seq(core_irrefutable) -> par(irrefutable) . seq(core_irrefutable) [ EQ COLON ARROW ]
##
## The known suffix of the stack is as follows:
## par(irrefutable)
##
interactive_expr: Fun WILD UIdent With
##
## Ends in an error in state: 262.
##
## seq(core_irrefutable) -> ctor_irrefutable . seq(core_irrefutable) [ EQ COLON ARROW ]
##
## The known suffix of the stack is as follows:
## ctor_irrefutable
##
interactive_expr: Fun LPAR RPAR With
##
## Ends in an error in state: 284.
##
## nseq(core_irrefutable) -> unit . seq(core_irrefutable) [ EQ COLON ARROW ]
##
## The known suffix of the stack is as follows:
## unit
##
interactive_expr: Fun LBRACE Ident RBRACE With
##
## Ends in an error in state: 286.
##
## nseq(core_irrefutable) -> record_pattern(irrefutable) . seq(core_irrefutable) [ EQ COLON ARROW ]
##
## The known suffix of the stack is as follows:
## record_pattern(irrefutable)
##
interactive_expr: Fun LPAR UIdent COLON Ident RPAR With
##
## Ends in an error in state: 288.
##
## nseq(core_irrefutable) -> par(typed_irrefutable) . seq(core_irrefutable) [ EQ COLON ARROW ]
##
## The known suffix of the stack is as follows:
## par(typed_irrefutable)
##
interactive_expr: Fun LPAR WILD RPAR With
##
## Ends in an error in state: 291.
##
## nseq(core_irrefutable) -> par(irrefutable) . seq(core_irrefutable) [ EQ COLON ARROW ]
##
## The known suffix of the stack is as follows:
## par(irrefutable)
##
interactive_expr: Fun UIdent With
##
## Ends in an error in state: 623.
##
## nseq(core_irrefutable) -> ctor_irrefutable . seq(core_irrefutable) [ EQ COLON ARROW ]
##
## The known suffix of the stack is as follows:
## ctor_irrefutable
##

Ill-formed function parameters.
At this point, one of the following is expected:
  * another parameter as an irrefutable pattern, e.g a variable;
  * a type annotation starting with a colon ':' for the body;
  * an arrow '->' followed by the function body;
  * the assignment symbol '=' followed by an expression.

interactive_expr: Match UIdent With VBAR With
##
## Ends in an error in state: 1250.
##
## try_or_match_expr(base_cond) -> Match expr With option(VBAR) . cases(base_cond) [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## Match expr With option(VBAR)
##
interactive_expr: Match UIdent With UIdent ARROW UIdent VBAR With
##
## Ends in an error in state: 1254.
##
## cases(base_cond) -> cases(base_cond) VBAR . case_clause(base_cond) [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## cases(base_cond) VBAR
##
interactive_expr: Begin Match UIdent With UIdent ARROW UIdent VBAR With
##
## Ends in an error in state: 655.
##
## cases(base_cond) -> cases(base_cond) VBAR . case_clause(base_cond) [ VBAR ]
## cases(last_expr) -> cases(base_cond) VBAR . case_clause(last_expr) [ End Done ]
##
## The known suffix of the stack is as follows:
## cases(base_cond) VBAR
##
interactive_expr: If UIdent Then Match UIdent With UIdent ARROW UIdent VBAR With
##
## Ends in an error in state: 686.
##
## cases(base_cond) -> cases(base_cond) VBAR . case_clause(base_cond) [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## cases(base_if_then_else) -> cases(base_cond) VBAR . case_clause(base_if_then_else) [ Else ]
##
## The known suffix of the stack is as follows:
## cases(base_cond) VBAR
##
interactive_expr: If UIdent Then Match UIdent With VBAR With
##
## Ends in an error in state: 1118.
##
## try_or_match_expr(base_cond) -> Match expr With option(VBAR) . cases(base_cond) [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## try_or_match_expr(base_if_then_else) -> Match expr With option(VBAR) . cases(base_if_then_else) [ Else ]
##
## The known suffix of the stack is as follows:
## Match expr With option(VBAR)
##
interactive_expr: Begin Match UIdent With VBAR With
##
## Ends in an error in state: 652.
##
## try_or_match_expr(last_expr) -> Match expr With option(VBAR) . cases(last_expr) [ End Done ]
##
## The known suffix of the stack is as follows:
## Match expr With option(VBAR)
##
interactive_expr: Begin If UIdent Then Match UIdent With VBAR With
##
## Ends in an error in state: 683.
##
## try_or_match_expr(base_if_then_else) -> Match expr With option(VBAR) . cases(base_if_then_else) [ Else ]
##
## The known suffix of the stack is as follows:
## Match expr With option(VBAR)
##

Ill-formed pattern matching expression.
At this point, a case is expected to start with a pattern.

interactive_expr: Match UIdent With UIdent CONS With
##
## Ends in an error in state: 355.
##
## cons_pattern_level -> core_pattern CONS . cons_pattern_level [ SEMI RPAR RBRACKET In COMMA COLON ARROW ]
##
## The known suffix of the stack is as follows:
## core_pattern CONS
##

Ill-formed list pattern.
At this point, a pattern that matches as list is expected.

interactive_expr: Match UIdent With LBRACKET UIdent SEMI With
##
## Ends in an error in state: 358.
##
## nsepseq(cons_pattern_level,SEMI) -> cons_pattern_level SEMI . nsepseq(cons_pattern_level,SEMI) [ RBRACKET ]
## nseq(__anonymous_0(cons_pattern_level,SEMI)) -> cons_pattern_level SEMI . seq(__anonymous_0(cons_pattern_level,SEMI)) [ RBRACKET ]
##
## The known suffix of the stack is as follows:
## cons_pattern_level SEMI
##
interactive_expr: Match UIdent With LBRACKET UIdent SEMI UIdent SEMI With
##
## Ends in an error in state: 362.
##
## nsepseq(cons_pattern_level,SEMI) -> cons_pattern_level SEMI . nsepseq(cons_pattern_level,SEMI) [ RBRACKET ]
## seq(__anonymous_0(cons_pattern_level,SEMI)) -> cons_pattern_level SEMI . seq(__anonymous_0(cons_pattern_level,SEMI)) [ RBRACKET ]
##
## The known suffix of the stack is as follows:
## cons_pattern_level SEMI
##

Ill-formed list of patterns.
At this point, one of the following is expected:
  * a list element as a pattern;
  * a closing bracket ']' if the list is complete.

interactive_expr: If UIdent Then Match UIdent With UIdent ARROW Attr With
##
## Ends in an error in state: 809.
##
## fun_expr(base_cond) -> nseq(Attr) . Fun nseq(core_irrefutable) ARROW base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(base_cond) -> nseq(Attr) . Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(base_cond) -> nseq(Attr) . Fun par(type_param_list) nseq(core_irrefutable) ARROW base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(base_cond) -> nseq(Attr) . Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(base_if_then_else) -> nseq(Attr) . Fun nseq(core_irrefutable) ARROW base_if_then_else [ Else ]
## fun_expr(base_if_then_else) -> nseq(Attr) . Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW base_if_then_else [ Else ]
## fun_expr(base_if_then_else) -> nseq(Attr) . Fun par(type_param_list) nseq(core_irrefutable) ARROW base_if_then_else [ Else ]
## fun_expr(base_if_then_else) -> nseq(Attr) . Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW base_if_then_else [ Else ]
## let_in_expr(base_cond) -> nseq(Attr) . Let let_binding In base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## let_in_expr(base_cond) -> nseq(Attr) . Let Rec let_binding In base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## let_in_expr(base_if_then_else) -> nseq(Attr) . Let let_binding In base_if_then_else [ Else ]
## let_in_expr(base_if_then_else) -> nseq(Attr) . Let Rec let_binding In base_if_then_else [ Else ]
## let_mut_in_expr(base_cond) -> nseq(Attr) . Let Mut let_mut_binding In base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## let_mut_in_expr(base_if_then_else) -> nseq(Attr) . Let Mut let_mut_binding In base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 41, spurious reduction of production seq(Attr) ->
## In state 44, spurious reduction of production nseq(Attr) -> Attr seq(Attr)
##
interactive_expr: Match UIdent With UIdent ARROW Attr With
##
## Ends in an error in state: 894.
##
## fun_expr(base_cond) -> nseq(Attr) . Fun nseq(core_irrefutable) ARROW base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(base_cond) -> nseq(Attr) . Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(base_cond) -> nseq(Attr) . Fun par(type_param_list) nseq(core_irrefutable) ARROW base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(base_cond) -> nseq(Attr) . Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## let_in_expr(base_cond) -> nseq(Attr) . Let let_binding In base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## let_in_expr(base_cond) -> nseq(Attr) . Let Rec let_binding In base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## let_mut_in_expr(base_cond) -> nseq(Attr) . Let Mut let_mut_binding In base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 41, spurious reduction of production seq(Attr) ->
## In state 44, spurious reduction of production nseq(Attr) -> Attr seq(Attr)
##
interactive_expr: Begin Match UIdent With UIdent ARROW Attr With
##
## Ends in an error in state: 942.
##
## fun_expr(base_cond) -> nseq(Attr) . Fun nseq(core_irrefutable) ARROW base_cond [ VBAR ]
## fun_expr(base_cond) -> nseq(Attr) . Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW base_cond [ VBAR ]
## fun_expr(base_cond) -> nseq(Attr) . Fun par(type_param_list) nseq(core_irrefutable) ARROW base_cond [ VBAR ]
## fun_expr(base_cond) -> nseq(Attr) . Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW base_cond [ VBAR ]
## fun_expr(last_expr) -> nseq(Attr) . Fun nseq(core_irrefutable) ARROW last_expr [ End Done ]
## fun_expr(last_expr) -> nseq(Attr) . Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW last_expr [ End Done ]
## fun_expr(last_expr) -> nseq(Attr) . Fun par(type_param_list) nseq(core_irrefutable) ARROW last_expr [ End Done ]
## fun_expr(last_expr) -> nseq(Attr) . Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW last_expr [ End Done ]
## let_in_expr(base_cond) -> nseq(Attr) . Let let_binding In base_cond [ VBAR ]
## let_in_expr(base_cond) -> nseq(Attr) . Let Rec let_binding In base_cond [ VBAR ]
## let_in_sequence -> nseq(Attr) . Let let_binding In series [ End Done ]
## let_in_sequence -> nseq(Attr) . Let Rec let_binding In series [ End Done ]
## let_mut_in_expr(base_cond) -> nseq(Attr) . Let Mut let_mut_binding In base_cond [ VBAR ]
##
## The known suffix of the stack is as follows:
## nseq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 41, spurious reduction of production seq(Attr) ->
## In state 44, spurious reduction of production nseq(Attr) -> Attr seq(Attr)
##
interactive_expr: Begin If UIdent Then Attr With
##
## Ends in an error in state: 971.
##
## fun_expr(closed_expr) -> nseq(Attr) . Fun nseq(core_irrefutable) ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> nseq(Attr) . Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> nseq(Attr) . Fun par(type_param_list) nseq(core_irrefutable) ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> nseq(Attr) . Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW closed_expr [ Else ]
## let_in_expr(closed_expr) -> nseq(Attr) . Let let_binding In closed_expr [ Else ]
## let_in_expr(closed_expr) -> nseq(Attr) . Let Rec let_binding In closed_expr [ Else ]
## let_mut_in_expr(closed_expr) -> nseq(Attr) . Let Mut let_mut_binding In closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 41, spurious reduction of production seq(Attr) ->
## In state 44, spurious reduction of production nseq(Attr) -> Attr seq(Attr)
##
interactive_expr: Begin Attr With
##
## Ends in an error in state: 1019.
##
## fun_expr(last_expr) -> nseq(Attr) . Fun nseq(core_irrefutable) ARROW last_expr [ End Done ]
## fun_expr(last_expr) -> nseq(Attr) . Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW last_expr [ End Done ]
## fun_expr(last_expr) -> nseq(Attr) . Fun par(type_param_list) nseq(core_irrefutable) ARROW last_expr [ End Done ]
## fun_expr(last_expr) -> nseq(Attr) . Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW last_expr [ End Done ]
## let_in_sequence -> nseq(Attr) . Let let_binding In series [ End Done ]
## let_in_sequence -> nseq(Attr) . Let Rec let_binding In series [ End Done ]
##
## The known suffix of the stack is as follows:
## nseq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 41, spurious reduction of production seq(Attr) ->
## In state 44, spurious reduction of production nseq(Attr) -> Attr seq(Attr)
##
interactive_expr: If UIdent Then Attr With
##
## Ends in an error in state: 1134.
##
## fun_expr(closed_expr) -> nseq(Attr) . Fun nseq(core_irrefutable) ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> nseq(Attr) . Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> nseq(Attr) . Fun par(type_param_list) nseq(core_irrefutable) ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> nseq(Attr) . Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW closed_expr [ Else ]
## fun_expr(expr) -> nseq(Attr) . Fun nseq(core_irrefutable) ARROW expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(expr) -> nseq(Attr) . Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(expr) -> nseq(Attr) . Fun par(type_param_list) nseq(core_irrefutable) ARROW expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(expr) -> nseq(Attr) . Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## let_in_expr(closed_expr) -> nseq(Attr) . Let let_binding In closed_expr [ Else ]
## let_in_expr(closed_expr) -> nseq(Attr) . Let Rec let_binding In closed_expr [ Else ]
## let_in_expr(expr) -> nseq(Attr) . Let let_binding In expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## let_in_expr(expr) -> nseq(Attr) . Let Rec let_binding In expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## let_mut_in_expr(closed_expr) -> nseq(Attr) . Let Mut let_mut_binding In closed_expr [ Else ]
## let_mut_in_expr(expr) -> nseq(Attr) . Let Mut let_mut_binding In expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 41, spurious reduction of production seq(Attr) ->
## In state 44, spurious reduction of production nseq(Attr) -> Attr seq(Attr)
##
program: Attr With
##
## Ends in an error in state: 1323.
##
## let_decl -> nseq(Attr) . Let let_binding [ Type Module Let End EOF Directive Contract Attr ]
## let_decl -> nseq(Attr) . Let Rec let_binding [ Type Module Let End EOF Directive Contract Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 41, spurious reduction of production seq(Attr) ->
## In state 44, spurious reduction of production nseq(Attr) -> Attr seq(Attr)
##
interactive_expr: Match UIdent With UIdent ARROW If UIdent Then Attr With
##
## Ends in an error in state: 704.
##
## fun_expr(base_cond) -> nseq(Attr) . Fun nseq(core_irrefutable) ARROW base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(base_cond) -> nseq(Attr) . Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(base_cond) -> nseq(Attr) . Fun par(type_param_list) nseq(core_irrefutable) ARROW base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(base_cond) -> nseq(Attr) . Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(closed_expr) -> nseq(Attr) . Fun nseq(core_irrefutable) ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> nseq(Attr) . Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> nseq(Attr) . Fun par(type_param_list) nseq(core_irrefutable) ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> nseq(Attr) . Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW closed_expr [ Else ]
## let_in_expr(base_cond) -> nseq(Attr) . Let let_binding In base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## let_in_expr(base_cond) -> nseq(Attr) . Let Rec let_binding In base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## let_in_expr(closed_expr) -> nseq(Attr) . Let let_binding In closed_expr [ Else ]
## let_in_expr(closed_expr) -> nseq(Attr) . Let Rec let_binding In closed_expr [ Else ]
## let_mut_in_expr(base_cond) -> nseq(Attr) . Let Mut let_mut_binding In base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## let_mut_in_expr(closed_expr) -> nseq(Attr) . Let Mut let_mut_binding In closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 41, spurious reduction of production seq(Attr) ->
## In state 44, spurious reduction of production nseq(Attr) -> Attr seq(Attr)
##
interactive_expr: Attr With
##
## Ends in an error in state: 418.
##
## fun_expr(expr) -> nseq(Attr) . Fun nseq(core_irrefutable) ARROW expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(expr) -> nseq(Attr) . Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(expr) -> nseq(Attr) . Fun par(type_param_list) nseq(core_irrefutable) ARROW expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(expr) -> nseq(Attr) . Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## let_in_expr(expr) -> nseq(Attr) . Let let_binding In expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## let_in_expr(expr) -> nseq(Attr) . Let Rec let_binding In expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## let_mut_in_expr(expr) -> nseq(Attr) . Let Mut let_mut_binding In expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 41, spurious reduction of production seq(Attr) ->
## In state 44, spurious reduction of production nseq(Attr) -> Attr seq(Attr)
##

Ill-formed attributed expression.
At this point, if the attributes are complete, one of the following is
expected:
  * a functional expression starting with the keyword 'fun';
  * a local value declaration starting with the keyword 'let'.

interactive_expr: Fun Ident With
##
## Ends in an error in state: 282.
##
## nseq(core_irrefutable) -> var_pattern . seq(core_irrefutable) [ EQ COLON ARROW ]
##
## The known suffix of the stack is as follows:
## var_pattern
##
interactive_expr: Fun Ident Ident With
##
## Ends in an error in state: 253.
##
## seq(core_irrefutable) -> var_pattern . seq(core_irrefutable) [ EQ COLON ARROW ]
##
## The known suffix of the stack is as follows:
## var_pattern
##

Ill-formed functional expression.
At this point, one of the following is expected:
  * a parameter as an irrefutable pattern, e.g. a variable;
  * a colon ':' followed by the type of the body;
  * an arrow '->' followed by the body as an expression.

interactive_expr: Match UIdent With UIdent ARROW If UIdent Then Type Ident EQ Ident In With
##
## Ends in an error in state: 702.
##
## local_type_decl(base_cond) -> type_decl In . base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## local_type_decl(closed_expr) -> type_decl In . closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## type_decl In
##
interactive_expr: If UIdent Then Type Ident EQ Ident In With
##
## Ends in an error in state: 1133.
##
## local_type_decl(closed_expr) -> type_decl In . closed_expr [ Else ]
## local_type_decl(expr) -> type_decl In . expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## type_decl In
##
#
#interactive_expr: Match UIdent With UIdent ARROW If UIdent Then Type Ident EQ Ident In With
interactive_expr: If UIdent Then Match UIdent With UIdent ARROW Type Ident EQ Ident In With
##
## Ends in an error in state: 808.
##
## local_type_decl(base_cond) -> type_decl In . base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## local_type_decl(base_if_then_else) -> type_decl In . base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## type_decl In
##
interactive_expr: Type Ident EQ Ident In With
##
## Ends in an error in state: 413.
##
## local_type_decl(expr) -> type_decl In . expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## type_decl In
##
interactive_expr: Match UIdent With UIdent ARROW Type Ident EQ Ident In With
##
## Ends in an error in state: 893.
##
## local_type_decl(base_cond) -> type_decl In . base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## type_decl In
##
interactive_expr: Begin If UIdent Then Type Ident EQ Ident In With
##
## Ends in an error in state: 970.
##
## local_type_decl(closed_expr) -> type_decl In . closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## type_decl In
##

Ill-formed local type declaration.
At this point, an expression is expected.

interactive_expr: LBRACE Ident With Ident EQ With
##
## Ends in an error in state: 278.
##
## field_path_assignment -> path EQ . expr [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## path EQ
##

Ill-formed record update.
At this point, the expression assigned to the field is expected.

interactive_expr: LBRACKET UIdent SEMI With
##
## Ends in an error in state: 1241.
##
## nsepseq(expr,SEMI) -> expr SEMI . nsepseq(expr,SEMI) [ RBRACKET ]
## nseq(__anonymous_0(expr,SEMI)) -> expr SEMI . seq(__anonymous_0(expr,SEMI)) [ RBRACKET ]
##
## The known suffix of the stack is as follows:
## expr SEMI
##
interactive_expr: LBRACKET UIdent SEMI UIdent SEMI With
##
## Ends in an error in state: 1245.
##
## nsepseq(expr,SEMI) -> expr SEMI . nsepseq(expr,SEMI) [ RBRACKET ]
## seq(__anonymous_0(expr,SEMI)) -> expr SEMI . seq(__anonymous_0(expr,SEMI)) [ RBRACKET ]
##
## The known suffix of the stack is as follows:
## expr SEMI
##

Ill-formed list of expressions.
At this point, one of the following is expected:
  * a list element as an expression;
  * a closing bracket ']' if the list is complete.

program: Let Ident COLON UIdent Of Attr With
##
## Ends in an error in state: 69.
##
## record_type -> nseq(Attr) . LBRACE sep_or_term_list(field_decl,SEMI) RBRACE [ VBAR Type TIMES SEMI RPAR RBRACE Module Let In Ident End EQ EOF EIdent Directive Contract COMMA Attr ARROW ]
##
## The known suffix of the stack is as follows:
## nseq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 41, spurious reduction of production seq(Attr) ->
## In state 44, spurious reduction of production nseq(Attr) -> Attr seq(Attr)
##

Ill-formed record type.
At this point, if the attribute is complete, an opening brace '{' is
expected.

program: Type QUOTE Ident Ident With
##
## Ends in an error in state: 25.
##
## type_decl -> Type quoted_type_params gen_ident . EQ type_expr [ Type Module Let In End EOF Directive Contract Attr ]
##
## The known suffix of the stack is as follows:
## Type quoted_type_params gen_ident
##
program: Type Ident With
##
## Ends in an error in state: 111.
##
## type_decl -> Type gen_ident . EQ type_expr [ Type Module Let In End EOF Directive Contract Attr ]
##
## The known suffix of the stack is as follows:
## Type gen_ident
##

Ill-formed type declaration.
At this point, the assignment symbol '=' is expected, followed by a
type expression.

program: Type QUOTE Ident Ident EQ With
##
## Ends in an error in state: 26.
##
## type_decl -> Type quoted_type_params gen_ident EQ . type_expr [ Type Module Let In End EOF Directive Contract Attr ]
##
## The known suffix of the stack is as follows:
## Type quoted_type_params gen_ident EQ
##
program: Type Ident EQ With
##
## Ends in an error in state: 112.
##
## type_decl -> Type gen_ident EQ . type_expr [ Type Module Let In End EOF Directive Contract Attr ]
##
## The known suffix of the stack is as follows:
## Type gen_ident EQ
##

Ill-formed type declaration.
At this point, a type expression is expected.

program: Type Ident EQ VBAR Attr With
##
## Ends in an error in state: 54.
##
## variant(fun_type_level) -> nseq(Attr) . UIdent [ VBAR Type SEMI RPAR RBRACE Module Let In End EQ EOF Directive Contract COMMA Attr ]
## variant(fun_type_level) -> nseq(Attr) . UIdent of_type(fun_type_level) [ VBAR Type SEMI RPAR RBRACE Module Let In End EQ EOF Directive Contract COMMA Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 41, spurious reduction of production seq(Attr) ->
## In state 44, spurious reduction of production nseq(Attr) -> Attr seq(Attr)
##
interactive_expr: Fun Ident COLON VBAR Attr With
##
## Ends in an error in state: 302.
##
## variant(prod_type_level) -> nseq(Attr) . UIdent [ VBAR ARROW ]
## variant(prod_type_level) -> nseq(Attr) . UIdent of_type(prod_type_level) [ VBAR ARROW ]
##
## The known suffix of the stack is as follows:
## nseq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 41, spurious reduction of production seq(Attr) ->
## In state 44, spurious reduction of production nseq(Attr) -> Attr seq(Attr)
##

Ill-formed variant type.
At this point, if the attribute of the variant is complete, one of the
following is expected:
  * another attribute;
  * the data constructor of the variant.

program: Let Ident COLON Attr With
##
## Ends in an error in state: 77.
##
## record_type -> nseq(Attr) . LBRACE sep_or_term_list(field_decl,SEMI) RBRACE [ Type TIMES SEMI RPAR RBRACE Module Let In Ident End EQ EOF EIdent Directive Contract COMMA Attr ARROW ]
## sum_type(fun_type_level) -> nseq(Attr) . VBAR nsepseq(variant(fun_type_level),VBAR) [ Type SEMI RPAR RBRACE Module Let In End EQ EOF Directive Contract COMMA Attr ]
## variant(fun_type_level) -> nseq(Attr) . UIdent [ VBAR Type SEMI RPAR RBRACE Module Let In End EQ EOF Directive Contract COMMA Attr ]
## variant(fun_type_level) -> nseq(Attr) . UIdent of_type(fun_type_level) [ VBAR Type SEMI RPAR RBRACE Module Let In End EQ EOF Directive Contract COMMA Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 41, spurious reduction of production seq(Attr) ->
## In state 44, spurious reduction of production nseq(Attr) -> Attr seq(Attr)
##
interactive_expr: Fun Ident COLON Attr With
##
## Ends in an error in state: 310.
##
## record_type -> nseq(Attr) . LBRACE sep_or_term_list(field_decl,SEMI) RBRACE [ TIMES Ident EIdent ARROW ]
## sum_type(prod_type_level) -> nseq(Attr) . VBAR nsepseq(variant(prod_type_level),VBAR) [ ARROW ]
## variant(prod_type_level) -> nseq(Attr) . UIdent [ VBAR ARROW ]
## variant(prod_type_level) -> nseq(Attr) . UIdent of_type(prod_type_level) [ VBAR ARROW ]
##
## The known suffix of the stack is as follows:
## nseq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 41, spurious reduction of production seq(Attr) ->
## In state 44, spurious reduction of production nseq(Attr) -> Attr seq(Attr)
##

Ill-formed attributed variant type or record type.
At this point, if the attributes are complete, one of the following is
expected:
  * an opening brace '{' followed by field declarations, if defining a
    record type;
  * a variant starting with a value constructor, if defining a sum
    type (the attributes then apply to the variant, not the type);
  * a vertical bar followed by a variant (the attributes then apply to
    the sum type, not the variant).

interactive_expr: If UIdent Then Attr Fun Ident COLON Ident DOT
##
## Ends in an error in state: 1158.
##
## fun_expr(closed_expr) -> nseq(Attr) Fun nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW closed_expr [ Else ]
## fun_expr(expr) -> nseq(Attr) Fun nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun nseq(core_irrefutable) type_annotation(lambda_app_type)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 84, spurious reduction of production prod_type_level -> core_type
## In state 309, spurious reduction of production lambda_app_type -> prod_type_level
## In state 314, spurious reduction of production type_annotation(lambda_app_type) -> COLON lambda_app_type
##
interactive_expr: If UIdent Then Attr Fun LPAR Type Ident RPAR Ident COLON Ident DOT
##
## Ends in an error in state: 1154.
##
## fun_expr(closed_expr) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW closed_expr [ Else ]
## fun_expr(expr) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 84, spurious reduction of production prod_type_level -> core_type
## In state 309, spurious reduction of production lambda_app_type -> prod_type_level
## In state 314, spurious reduction of production type_annotation(lambda_app_type) -> COLON lambda_app_type
##
interactive_expr: Begin Match UIdent With UIdent ARROW Attr Fun Ident COLON Ident DOT
##
## Ends in an error in state: 1069.
##
## fun_expr(base_cond) -> nseq(Attr) Fun nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW base_cond [ VBAR ]
## fun_expr(last_expr) -> nseq(Attr) Fun nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW last_expr [ End Done ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun nseq(core_irrefutable) type_annotation(lambda_app_type)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 84, spurious reduction of production prod_type_level -> core_type
## In state 309, spurious reduction of production lambda_app_type -> prod_type_level
## In state 314, spurious reduction of production type_annotation(lambda_app_type) -> COLON lambda_app_type
##
interactive_expr: Begin Match UIdent With UIdent ARROW Attr Fun LPAR Type Ident RPAR Ident COLON Ident DOT
##
## Ends in an error in state: 1065.
##
## fun_expr(base_cond) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW base_cond [ VBAR ]
## fun_expr(last_expr) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW last_expr [ End Done ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 84, spurious reduction of production prod_type_level -> core_type
## In state 309, spurious reduction of production lambda_app_type -> prod_type_level
## In state 314, spurious reduction of production type_annotation(lambda_app_type) -> COLON lambda_app_type
##
interactive_expr: Begin Attr Fun LPAR Type Ident RPAR Ident COLON Ident DOT
##
## Ends in an error in state: 1035.
##
## fun_expr(last_expr) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW last_expr [ End Done ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 84, spurious reduction of production prod_type_level -> core_type
## In state 309, spurious reduction of production lambda_app_type -> prod_type_level
## In state 314, spurious reduction of production type_annotation(lambda_app_type) -> COLON lambda_app_type
##
interactive_expr: Begin If UIdent Then Attr Fun Ident COLON Ident DOT
##
## Ends in an error in state: 995.
##
## fun_expr(closed_expr) -> nseq(Attr) Fun nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun nseq(core_irrefutable) type_annotation(lambda_app_type)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 84, spurious reduction of production prod_type_level -> core_type
## In state 309, spurious reduction of production lambda_app_type -> prod_type_level
## In state 314, spurious reduction of production type_annotation(lambda_app_type) -> COLON lambda_app_type
##
interactive_expr: Begin If UIdent Then Attr Fun LPAR Type Ident RPAR Ident COLON Ident DOT
##
## Ends in an error in state: 991.
##
## fun_expr(closed_expr) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 84, spurious reduction of production prod_type_level -> core_type
## In state 309, spurious reduction of production lambda_app_type -> prod_type_level
## In state 314, spurious reduction of production type_annotation(lambda_app_type) -> COLON lambda_app_type
##
interactive_expr: Match UIdent With UIdent ARROW Attr Fun Ident COLON Ident DOT
##
## Ends in an error in state: 918.
##
## fun_expr(base_cond) -> nseq(Attr) Fun nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun nseq(core_irrefutable) type_annotation(lambda_app_type)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 84, spurious reduction of production prod_type_level -> core_type
## In state 309, spurious reduction of production lambda_app_type -> prod_type_level
## In state 314, spurious reduction of production type_annotation(lambda_app_type) -> COLON lambda_app_type
##
interactive_expr: Match UIdent With UIdent ARROW Attr Fun LPAR Type Ident RPAR Ident COLON Ident DOT
##
## Ends in an error in state: 914.
##
## fun_expr(base_cond) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 84, spurious reduction of production prod_type_level -> core_type
## In state 309, spurious reduction of production lambda_app_type -> prod_type_level
## In state 314, spurious reduction of production type_annotation(lambda_app_type) -> COLON lambda_app_type
##
interactive_expr: If UIdent Then Match UIdent With UIdent ARROW Attr Fun Ident COLON Ident DOT
##
## Ends in an error in state: 850.
##
## fun_expr(base_cond) -> nseq(Attr) Fun nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(base_if_then_else) -> nseq(Attr) Fun nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun nseq(core_irrefutable) type_annotation(lambda_app_type)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 84, spurious reduction of production prod_type_level -> core_type
## In state 309, spurious reduction of production lambda_app_type -> prod_type_level
## In state 314, spurious reduction of production type_annotation(lambda_app_type) -> COLON lambda_app_type
##
interactive_expr: If UIdent Then Match UIdent With UIdent ARROW Attr Fun LPAR Type Ident RPAR Ident COLON Ident DOT
##
## Ends in an error in state: 844.
##
## fun_expr(base_cond) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(base_if_then_else) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 84, spurious reduction of production prod_type_level -> core_type
## In state 309, spurious reduction of production lambda_app_type -> prod_type_level
## In state 314, spurious reduction of production type_annotation(lambda_app_type) -> COLON lambda_app_type
##
interactive_expr: If UIdent Then Match UIdent With UIdent ARROW Fun LPAR Type Ident RPAR Ident COLON Ident DOT
##
## Ends in an error in state: 855.
##
## fun_expr(base_cond) -> Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(base_if_then_else) -> Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 84, spurious reduction of production prod_type_level -> core_type
## In state 309, spurious reduction of production lambda_app_type -> prod_type_level
## In state 314, spurious reduction of production type_annotation(lambda_app_type) -> COLON lambda_app_type
##
interactive_expr: If UIdent Then Match UIdent With UIdent ARROW Fun Ident COLON Ident DOT
##
## Ends in an error in state: 861.
##
## fun_expr(base_cond) -> Fun nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(base_if_then_else) -> Fun nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable) type_annotation(lambda_app_type)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 84, spurious reduction of production prod_type_level -> core_type
## In state 309, spurious reduction of production lambda_app_type -> prod_type_level
## In state 314, spurious reduction of production type_annotation(lambda_app_type) -> COLON lambda_app_type
##
interactive_expr: Match UIdent With UIdent ARROW Fun LPAR Type Ident RPAR Ident COLON Ident DOT
##
## Ends in an error in state: 920.
##
## fun_expr(base_cond) -> Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 84, spurious reduction of production prod_type_level -> core_type
## In state 309, spurious reduction of production lambda_app_type -> prod_type_level
## In state 314, spurious reduction of production type_annotation(lambda_app_type) -> COLON lambda_app_type
##
interactive_expr: Match UIdent With UIdent ARROW Fun Ident COLON Ident DOT
##
## Ends in an error in state: 924.
##
## fun_expr(base_cond) -> Fun nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable) type_annotation(lambda_app_type)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 84, spurious reduction of production prod_type_level -> core_type
## In state 309, spurious reduction of production lambda_app_type -> prod_type_level
## In state 314, spurious reduction of production type_annotation(lambda_app_type) -> COLON lambda_app_type
##
interactive_expr: Begin If UIdent Then Fun LPAR Type Ident RPAR Ident COLON Ident DOT
##
## Ends in an error in state: 997.
##
## fun_expr(closed_expr) -> Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 84, spurious reduction of production prod_type_level -> core_type
## In state 309, spurious reduction of production lambda_app_type -> prod_type_level
## In state 314, spurious reduction of production type_annotation(lambda_app_type) -> COLON lambda_app_type
##
interactive_expr: Begin If UIdent Then Fun Ident COLON Ident DOT
##
## Ends in an error in state: 1001.
##
## fun_expr(closed_expr) -> Fun nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable) type_annotation(lambda_app_type)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 84, spurious reduction of production prod_type_level -> core_type
## In state 309, spurious reduction of production lambda_app_type -> prod_type_level
## In state 314, spurious reduction of production type_annotation(lambda_app_type) -> COLON lambda_app_type
##
interactive_expr: Begin Fun LPAR Type Ident RPAR Ident COLON Ident DOT
##
## Ends in an error in state: 1045.
##
## fun_expr(last_expr) -> Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW last_expr [ End Done ]
##
## The known suffix of the stack is as follows:
## Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 84, spurious reduction of production prod_type_level -> core_type
## In state 309, spurious reduction of production lambda_app_type -> prod_type_level
## In state 314, spurious reduction of production type_annotation(lambda_app_type) -> COLON lambda_app_type
##
interactive_expr: Begin Fun Ident COLON Ident DOT
##
## Ends in an error in state: 1051.
##
## fun_expr(last_expr) -> Fun nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW last_expr [ End Done ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable) type_annotation(lambda_app_type)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 84, spurious reduction of production prod_type_level -> core_type
## In state 309, spurious reduction of production lambda_app_type -> prod_type_level
## In state 314, spurious reduction of production type_annotation(lambda_app_type) -> COLON lambda_app_type
##
interactive_expr: Begin Match UIdent With UIdent ARROW Fun LPAR Type Ident RPAR Ident COLON Ident DOT
##
## Ends in an error in state: 1071.
##
## fun_expr(base_cond) -> Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW base_cond [ VBAR ]
## fun_expr(last_expr) -> Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW last_expr [ End Done ]
##
## The known suffix of the stack is as follows:
## Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 84, spurious reduction of production prod_type_level -> core_type
## In state 309, spurious reduction of production lambda_app_type -> prod_type_level
## In state 314, spurious reduction of production type_annotation(lambda_app_type) -> COLON lambda_app_type
##
interactive_expr: Begin Match UIdent With UIdent ARROW Fun Ident COLON Ident DOT
##
## Ends in an error in state: 1075.
##
## fun_expr(base_cond) -> Fun nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW base_cond [ VBAR ]
## fun_expr(last_expr) -> Fun nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW last_expr [ End Done ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable) type_annotation(lambda_app_type)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 84, spurious reduction of production prod_type_level -> core_type
## In state 309, spurious reduction of production lambda_app_type -> prod_type_level
## In state 314, spurious reduction of production type_annotation(lambda_app_type) -> COLON lambda_app_type
##
interactive_expr: Fun LPAR Type Ident RPAR Ident COLON Ident DOT
##
## Ends in an error in state: 1099.
##
## fun_expr(expr) -> Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 84, spurious reduction of production prod_type_level -> core_type
## In state 309, spurious reduction of production lambda_app_type -> prod_type_level
## In state 314, spurious reduction of production type_annotation(lambda_app_type) -> COLON lambda_app_type
##
interactive_expr: Fun Ident COLON Ident DOT
##
## Ends in an error in state: 1105.
##
## fun_expr(expr) -> Fun nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable) type_annotation(lambda_app_type)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 84, spurious reduction of production prod_type_level -> core_type
## In state 309, spurious reduction of production lambda_app_type -> prod_type_level
## In state 314, spurious reduction of production type_annotation(lambda_app_type) -> COLON lambda_app_type
##
interactive_expr: If UIdent Then Fun LPAR Type Ident RPAR Ident COLON Ident DOT
##
## Ends in an error in state: 1160.
##
## fun_expr(closed_expr) -> Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW closed_expr [ Else ]
## fun_expr(expr) -> Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 84, spurious reduction of production prod_type_level -> core_type
## In state 309, spurious reduction of production lambda_app_type -> prod_type_level
## In state 314, spurious reduction of production type_annotation(lambda_app_type) -> COLON lambda_app_type
##
interactive_expr: If UIdent Then Fun Ident COLON Ident DOT
##
## Ends in an error in state: 1164.
##
## fun_expr(closed_expr) -> Fun nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW closed_expr [ Else ]
## fun_expr(expr) -> Fun nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable) type_annotation(lambda_app_type)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 84, spurious reduction of production prod_type_level -> core_type
## In state 309, spurious reduction of production lambda_app_type -> prod_type_level
## In state 314, spurious reduction of production type_annotation(lambda_app_type) -> COLON lambda_app_type
##
interactive_expr: Match UIdent With UIdent ARROW If UIdent Then Fun Ident COLON Ident DOT
##
## Ends in an error in state: 780.
##
## fun_expr(base_cond) -> Fun nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(closed_expr) -> Fun nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable) type_annotation(lambda_app_type)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 84, spurious reduction of production prod_type_level -> core_type
## In state 309, spurious reduction of production lambda_app_type -> prod_type_level
## In state 314, spurious reduction of production type_annotation(lambda_app_type) -> COLON lambda_app_type
##
interactive_expr: Match UIdent With UIdent ARROW If UIdent Then Fun LPAR Type Ident RPAR Ident COLON Ident DOT
##
## Ends in an error in state: 772.
##
## fun_expr(base_cond) -> Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(closed_expr) -> Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 84, spurious reduction of production prod_type_level -> core_type
## In state 309, spurious reduction of production lambda_app_type -> prod_type_level
## In state 314, spurious reduction of production type_annotation(lambda_app_type) -> COLON lambda_app_type
##
interactive_expr: Attr Fun Ident COLON Ident DOT
##
## Ends in an error in state: 628.
##
## fun_expr(expr) -> nseq(Attr) Fun nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun nseq(core_irrefutable) type_annotation(lambda_app_type)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 84, spurious reduction of production prod_type_level -> core_type
## In state 309, spurious reduction of production lambda_app_type -> prod_type_level
## In state 314, spurious reduction of production type_annotation(lambda_app_type) -> COLON lambda_app_type
##
interactive_expr: Match UIdent With UIdent ARROW If UIdent Then Attr Fun LPAR Type Ident RPAR Ident COLON Ident DOT
##
## Ends in an error in state: 756.
##
## fun_expr(base_cond) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(closed_expr) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 84, spurious reduction of production prod_type_level -> core_type
## In state 309, spurious reduction of production lambda_app_type -> prod_type_level
## In state 314, spurious reduction of production type_annotation(lambda_app_type) -> COLON lambda_app_type
##
interactive_expr: Match UIdent With UIdent ARROW If UIdent Then Attr Fun Ident COLON Ident DOT
##
## Ends in an error in state: 764.
##
## fun_expr(base_cond) -> nseq(Attr) Fun nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(closed_expr) -> nseq(Attr) Fun nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun nseq(core_irrefutable) type_annotation(lambda_app_type)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 84, spurious reduction of production prod_type_level -> core_type
## In state 309, spurious reduction of production lambda_app_type -> prod_type_level
## In state 314, spurious reduction of production type_annotation(lambda_app_type) -> COLON lambda_app_type
##
interactive_expr: Attr Fun LPAR Type Ident RPAR Ident COLON Ident DOT
##
## Ends in an error in state: 620.
##
## fun_expr(expr) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 84, spurious reduction of production prod_type_level -> core_type
## In state 309, spurious reduction of production lambda_app_type -> prod_type_level
## In state 314, spurious reduction of production type_annotation(lambda_app_type) -> COLON lambda_app_type
##
interactive_expr: Begin Attr Fun Ident COLON Ident DOT
##
## Ends in an error in state: 1041.
##
## fun_expr(last_expr) -> nseq(Attr) Fun nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW last_expr [ End Done ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun nseq(core_irrefutable) type_annotation(lambda_app_type)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 84, spurious reduction of production prod_type_level -> core_type
## In state 309, spurious reduction of production lambda_app_type -> prod_type_level
## In state 314, spurious reduction of production type_annotation(lambda_app_type) -> COLON lambda_app_type
##

Ill-formed functional expression.
At this point, if the type of the body is complete, an arrow '->' is
expected, followed by the body as an expression.

program: Let LPAR UIdent COLON Ident With
##
## Ends in an error in state: 231.
##
## par(typed_irrefutable) -> LPAR typed_irrefutable . RPAR [ WILD UIdent SEMI RPAR RBRACE LPAR LBRACE Ident EQ EIdent COMMA COLON Attr ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR typed_irrefutable
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 84, spurious reduction of production prod_type_level -> core_type
## In state 65, spurious reduction of production fun_type_level -> prod_type_level
## In state 83, spurious reduction of production type_expr -> fun_type_level
## In state 215, spurious reduction of production type_annotation(type_expr) -> COLON type_expr
## In state 249, spurious reduction of production typed_irrefutable -> ctor_irrefutable type_annotation(type_expr)
##

Ill-formed typed pattern.
At this point, if the type annotation is complete, then a closing
parenthesis ')' is expected.

interactive_expr: Verbatim With
##
## Ends in an error in state: 1361.
##
## interactive_expr -> expr . EOF [ # ]
##
## The known suffix of the stack is as follows:
## expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 408, spurious reduction of production call_expr_level -> core_expr
## In state 428, spurious reduction of production unary_expr_level -> call_expr_level
## In state 386, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 417, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 423, spurious reduction of production add_expr_level -> mult_expr_level
## In state 470, spurious reduction of production cons_expr_level -> add_expr_level
## In state 457, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 494, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 501, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 510, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 455, spurious reduction of production tuple_expr_level -> disj_expr_level
## In state 414, spurious reduction of production ass_expr_level -> tuple_expr_level
## In state 525, spurious reduction of production base_expr(expr) -> ass_expr_level
## In state 523, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 524, spurious reduction of production expr -> base_cond__open(expr)
##

Ill-formed expression.
At this point, if the expression is complete, the end of the input is
expected.

program: Let WILD LPAR With
##
## Ends in an error in state: 133.
##
## par(type_param_list) -> LPAR . type_param_list RPAR [ EQ COLON ]
##
## The known suffix of the stack is as follows:
## LPAR
##

Ill-formed value declaration.
At this point, the keyword 'type' is expected, followed by type
parameters and a closing parenthesis ')'.

interactive_expr: Fun LBRACE Ident EQ UIdent With
##
## Ends in an error in state: 202.
##
## field_pattern(irrefutable) -> gen_ident EQ ctor_irrefutable . [ SEMI RBRACE ]
## tuple(core_irrefutable) -> ctor_irrefutable . COMMA nsepseq(core_irrefutable,COMMA) [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## gen_ident EQ ctor_irrefutable
##
program: Let LBRACE Ident EQ WILD With
##
## Ends in an error in state: 162.
##
## field_pattern(irrefutable) -> gen_ident EQ WILD . [ SEMI RBRACE ]
## tuple(core_irrefutable) -> WILD . COMMA nsepseq(core_irrefutable,COMMA) [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## gen_ident EQ WILD
##
program: Let LBRACE Ident EQ Ident With
##
## Ends in an error in state: 163.
##
## field_pattern(irrefutable) -> gen_ident EQ var_pattern . [ SEMI RBRACE ]
## tuple(core_irrefutable) -> var_pattern . COMMA nsepseq(core_irrefutable,COMMA) [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## gen_ident EQ var_pattern
##
program: Let LBRACE Ident EQ LPAR RPAR With
##
## Ends in an error in state: 189.
##
## field_pattern(irrefutable) -> gen_ident EQ unit . [ SEMI RBRACE ]
## tuple(core_irrefutable) -> unit . COMMA nsepseq(core_irrefutable,COMMA) [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## gen_ident EQ unit
##
program: Let LBRACE Ident EQ LBRACE Ident RBRACE With
##
## Ends in an error in state: 193.
##
## field_pattern(irrefutable) -> gen_ident EQ record_pattern(irrefutable) . [ SEMI RBRACE ]
## tuple(core_irrefutable) -> record_pattern(irrefutable) . COMMA nsepseq(core_irrefutable,COMMA) [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## gen_ident EQ record_pattern(irrefutable)
##
program: Let LBRACE Ident EQ LPAR UIdent COLON Ident RPAR With
##
## Ends in an error in state: 196.
##
## field_pattern(irrefutable) -> gen_ident EQ par(typed_irrefutable) . [ SEMI RBRACE ]
## tuple(core_irrefutable) -> par(typed_irrefutable) . COMMA nsepseq(core_irrefutable,COMMA) [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## gen_ident EQ par(typed_irrefutable)
##
program: Let LBRACE Ident EQ LPAR WILD RPAR With
##
## Ends in an error in state: 199.
##
## field_pattern(irrefutable) -> gen_ident EQ par(irrefutable) . [ SEMI RBRACE ]
## tuple(core_irrefutable) -> par(irrefutable) . COMMA nsepseq(core_irrefutable,COMMA) [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## gen_ident EQ par(irrefutable)
##

Ill-formed record pattern.
At this point, one of the following is expected:
  * a comma ',' followed by a tuple component as a pattern, if the
    field is a tuple;
  * a semicolon ';' if the field is punned (that is, a variable with
    the same name is implicitly the pattern);
  * a closing brace '}' if the record pattern is complete.

program: Let LPAR Ident With
##
## Ends in an error in state: 225.
##
## par(irrefutable) -> LPAR var_pattern . RPAR [ WILD UIdent SEMI RPAR RBRACE LPAR LBRACE Ident EQ EIdent COMMA COLON Attr ARROW ]
## tuple(core_irrefutable) -> var_pattern . COMMA nsepseq(core_irrefutable,COMMA) [ RPAR COLON ]
## typed_irrefutable -> var_pattern . type_annotation(type_expr) [ RPAR ]
##
## The known suffix of the stack is as follows:
## LPAR var_pattern
##
program: Let LPAR LPAR RPAR With
##
## Ends in an error in state: 228.
##
## par(irrefutable) -> LPAR unit . RPAR [ WILD UIdent SEMI RPAR RBRACE LPAR LBRACE Ident EQ EIdent COMMA COLON Attr ARROW ]
## tuple(core_irrefutable) -> unit . COMMA nsepseq(core_irrefutable,COMMA) [ RPAR COLON ]
## typed_irrefutable -> unit . type_annotation(type_expr) [ RPAR ]
##
## The known suffix of the stack is as follows:
## LPAR unit
##
program: Let LPAR WILD WILD
##
## Ends in an error in state: 150.
##
## par(irrefutable) -> LPAR WILD . RPAR [ WILD UIdent SEMI RPAR RBRACE LPAR LBRACE Ident EQ EIdent COMMA COLON Attr ARROW ]
## tuple(core_irrefutable) -> WILD . COMMA nsepseq(core_irrefutable,COMMA) [ RPAR COLON ]
## typed_irrefutable -> WILD . type_annotation(type_expr) [ RPAR ]
##
## The known suffix of the stack is as follows:
## LPAR WILD
##
program: Let LPAR LBRACE Ident RBRACE With
##
## Ends in an error in state: 236.
##
## par(irrefutable) -> LPAR record_pattern(irrefutable) . RPAR [ WILD UIdent SEMI RPAR RBRACE LPAR LBRACE Ident EQ EIdent COMMA COLON Attr ARROW ]
## tuple(core_irrefutable) -> record_pattern(irrefutable) . COMMA nsepseq(core_irrefutable,COMMA) [ RPAR COLON ]
## typed_irrefutable -> record_pattern(irrefutable) . type_annotation(type_expr) [ RPAR ]
##
## The known suffix of the stack is as follows:
## LPAR record_pattern(irrefutable)
##
program: Let LPAR LPAR UIdent COLON Ident RPAR With
##
## Ends in an error in state: 239.
##
## par(irrefutable) -> LPAR par(typed_irrefutable) . RPAR [ WILD UIdent SEMI RPAR RBRACE LPAR LBRACE Ident EQ EIdent COMMA COLON Attr ARROW ]
## tuple(core_irrefutable) -> par(typed_irrefutable) . COMMA nsepseq(core_irrefutable,COMMA) [ RPAR COLON ]
## typed_irrefutable -> par(typed_irrefutable) . type_annotation(type_expr) [ RPAR ]
##
## The known suffix of the stack is as follows:
## LPAR par(typed_irrefutable)
##
program: Let LPAR LPAR WILD RPAR With
##
## Ends in an error in state: 242.
##
## par(irrefutable) -> LPAR par(irrefutable) . RPAR [ WILD UIdent SEMI RPAR RBRACE LPAR LBRACE Ident EQ EIdent COMMA COLON Attr ARROW ]
## tuple(core_irrefutable) -> par(irrefutable) . COMMA nsepseq(core_irrefutable,COMMA) [ RPAR COLON ]
## typed_irrefutable -> par(irrefutable) . type_annotation(type_expr) [ RPAR ]
##
## The known suffix of the stack is as follows:
## LPAR par(irrefutable)
##
program: Let LPAR UIdent With
##
## Ends in an error in state: 247.
##
## par(irrefutable) -> LPAR ctor_irrefutable . RPAR [ WILD UIdent SEMI RPAR RBRACE LPAR LBRACE Ident EQ EIdent COMMA COLON Attr ARROW ]
## tuple(core_irrefutable) -> ctor_irrefutable . COMMA nsepseq(core_irrefutable,COMMA) [ RPAR COLON ]
## typed_irrefutable -> ctor_irrefutable . type_annotation(type_expr) [ RPAR ]
##
## The known suffix of the stack is as follows:
## LPAR ctor_irrefutable
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 217, spurious reduction of production const_ctor_pattern -> UIdent
## In state 183, spurious reduction of production ctor_irrefutable -> const_ctor_pattern
##

Ill-formed pattern.
At this point, one of the following is expected:
  * a closing parenthesis ')', if the pattern is complete;
  * a comma ',' followed by another component as a pattern, if
    defining a tuple pattern;
  * a type annotation starting with ':'.

program: Let Ident With
##
## Ends in an error in state: 250.
##
## fun_decl -> var_pattern . parameters EQ expr [ Type Module Let In End EOF Directive Contract Attr ]
## fun_decl -> var_pattern . parameters type_annotation(type_expr) EQ expr [ Type Module Let In End EOF Directive Contract Attr ]
## fun_decl -> var_pattern . par(type_param_list) parameters EQ expr [ Type Module Let In End EOF Directive Contract Attr ]
## fun_decl -> var_pattern . par(type_param_list) parameters type_annotation(type_expr) EQ expr [ Type Module Let In End EOF Directive Contract Attr ]
## non_fun_decl -> var_pattern . EQ expr [ Type Module Let In End EOF Directive Contract Attr ]
## non_fun_decl -> var_pattern . type_annotation(type_expr) EQ expr [ Type Module Let In End EOF Directive Contract Attr ]
## non_fun_decl -> var_pattern . par(type_param_list) EQ expr [ Type Module Let In End EOF Directive Contract Attr ]
## non_fun_decl -> var_pattern . par(type_param_list) type_annotation(type_expr) EQ expr [ Type Module Let In End EOF Directive Contract Attr ]
## tuple(core_irrefutable) -> var_pattern . COMMA nsepseq(core_irrefutable,COMMA) [ LPAR EQ COLON ]
##
## The known suffix of the stack is as follows:
## var_pattern
##

Ill-formed value declaration.
At this point, one of the following is expected:
  * parameters as irrefutable patterns, e.g. variables, if defining a
    function;
  * the assignment symbol '=' followed by an expression;
  * a type annotation starting with a colon ':';
  * a comma ',' followed by another tuple component, if defining a
    tuple.

program: Contract UIdent EQ Struct Let Entry Ident ZWSP
##
## Ends in an error in state: 1283.
##
## entry_decl -> Let Entry var_pattern . parameters EQ expr [ Let End Attr ]
## entry_decl -> Let Entry var_pattern . parameters type_annotation(type_expr) EQ expr [ Let End Attr ]
##
## The known suffix of the stack is as follows:
## Let Entry var_pattern
##
program: Contract UIdent EQ Struct Attr Let Entry Ident ZWSP
##
## Ends in an error in state: 1307.
##
## entry_decl -> nseq(Attr) Let Entry var_pattern . parameters EQ expr [ Let End Attr ]
## entry_decl -> nseq(Attr) Let Entry var_pattern . parameters type_annotation(type_expr) EQ expr [ Let End Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let Entry var_pattern
##

Ill-formed entrypoint declaration.
At this point, parameters are expected, e.g. variables.

program: Let LPAR RPAR LPAR Type Ident RPAR With
##
## Ends in an error in state: 531.
##
## non_fun_decl -> unit par(type_param_list) . EQ expr [ Type Module Let In End EOF Directive Contract Attr ]
## non_fun_decl -> unit par(type_param_list) . type_annotation(type_expr) EQ expr [ Type Module Let In End EOF Directive Contract Attr ]
##
## The known suffix of the stack is as follows:
## unit par(type_param_list)
##
program: Let WILD COMMA Ident LPAR Type Ident RPAR With
##
## Ends in an error in state: 543.
##
## non_fun_decl -> tuple(core_irrefutable) par(type_param_list) . EQ expr [ Type Module Let In End EOF Directive Contract Attr ]
## non_fun_decl -> tuple(core_irrefutable) par(type_param_list) . type_annotation(type_expr) EQ expr [ Type Module Let In End EOF Directive Contract Attr ]
##
## The known suffix of the stack is as follows:
## tuple(core_irrefutable) par(type_param_list)
##
program: Let LBRACE Ident RBRACE LPAR Type Ident RPAR With
##
## Ends in an error in state: 555.
##
## non_fun_decl -> record_pattern(irrefutable) par(type_param_list) . EQ expr [ Type Module Let In End EOF Directive Contract Attr ]
## non_fun_decl -> record_pattern(irrefutable) par(type_param_list) . type_annotation(type_expr) EQ expr [ Type Module Let In End EOF Directive Contract Attr ]
##
## The known suffix of the stack is as follows:
## record_pattern(irrefutable) par(type_param_list)
##
program: Let LPAR UIdent COLON Ident RPAR LPAR Type Ident RPAR With
##
## Ends in an error in state: 567.
##
## non_fun_decl -> par(typed_irrefutable) par(type_param_list) . EQ expr [ Type Module Let In End EOF Directive Contract Attr ]
## non_fun_decl -> par(typed_irrefutable) par(type_param_list) . type_annotation(type_expr) EQ expr [ Type Module Let In End EOF Directive Contract Attr ]
##
## The known suffix of the stack is as follows:
## par(typed_irrefutable) par(type_param_list)
##
program: Let LPAR WILD RPAR LPAR Type Ident RPAR With
##
## Ends in an error in state: 579.
##
## non_fun_decl -> par(irrefutable) par(type_param_list) . EQ expr [ Type Module Let In End EOF Directive Contract Attr ]
## non_fun_decl -> par(irrefutable) par(type_param_list) . type_annotation(type_expr) EQ expr [ Type Module Let In End EOF Directive Contract Attr ]
##
## The known suffix of the stack is as follows:
## par(irrefutable) par(type_param_list)
##
program: Let UIdent LPAR Type Ident RPAR With
##
## Ends in an error in state: 596.
##
## non_fun_decl -> ctor_irrefutable par(type_param_list) . EQ expr [ Type Module Let In End EOF Directive Contract Attr ]
## non_fun_decl -> ctor_irrefutable par(type_param_list) . type_annotation(type_expr) EQ expr [ Type Module Let In End EOF Directive Contract Attr ]
##
## The known suffix of the stack is as follows:
## ctor_irrefutable par(type_param_list)
##
program: Let WILD LPAR Type Ident RPAR With
##
## Ends in an error in state: 1259.
##
## non_fun_decl -> WILD par(type_param_list) . EQ expr [ Type Module Let In End EOF Directive Contract Attr ]
## non_fun_decl -> WILD par(type_param_list) . type_annotation(type_expr) EQ expr [ Type Module Let In End EOF Directive Contract Attr ]
##
## The known suffix of the stack is as follows:
## WILD par(type_param_list)
##
interactive_expr: Let Mut Ident ZWSP
##
## Ends in an error in state: 603.
##
## let_mut_binding -> var_pattern . EQ expr [ In ]
## let_mut_binding -> var_pattern . type_annotation(type_expr) EQ expr [ In ]
##
## The known suffix of the stack is as follows:
## var_pattern
##

Ill-formed value declaration.
At this point, one of the following is expected:
  * the assignment symbol '=' followed by an expression;
  * a type annotation starting with a colon ':'.

program: Let Ident LPAR Type Ident RPAR WILD ARROW
##
## Ends in an error in state: 1221.
##
## fun_decl -> var_pattern par(type_param_list) parameters . EQ expr [ Type Module Let In End EOF Directive Contract Attr ]
## fun_decl -> var_pattern par(type_param_list) parameters . type_annotation(type_expr) EQ expr [ Type Module Let In End EOF Directive Contract Attr ]
##
## The known suffix of the stack is as follows:
## var_pattern par(type_param_list) parameters
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 251, spurious reduction of production seq(core_irrefutable) ->
## In state 266, spurious reduction of production nseq(core_irrefutable) -> WILD seq(core_irrefutable)
## In state 1227, spurious reduction of production parameters -> nseq(core_irrefutable)
##
program: Let Ident WILD ARROW
##
## Ends in an error in state: 1209.
##
## fun_decl -> var_pattern parameters . EQ expr [ Type Module Let In End EOF Directive Contract Attr ]
## fun_decl -> var_pattern parameters . type_annotation(type_expr) EQ expr [ Type Module Let In End EOF Directive Contract Attr ]
##
## The known suffix of the stack is as follows:
## var_pattern parameters
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 251, spurious reduction of production seq(core_irrefutable) ->
## In state 266, spurious reduction of production nseq(core_irrefutable) -> WILD seq(core_irrefutable)
## In state 1227, spurious reduction of production parameters -> nseq(core_irrefutable)
##

Ill-formed function declaration.
At this point, if there are no more parameters, one of the following
is expected:
  * the assignment symbol '=' followed by an expression;
  * a type annotation starting with a colon ':'.

program: Let WILD COMMA Ident With
##
## Ends in an error in state: 537.
##
## non_fun_decl -> tuple(core_irrefutable) . EQ expr [ Type Module Let In End EOF Directive Contract Attr ]
## non_fun_decl -> tuple(core_irrefutable) . type_annotation(type_expr) EQ expr [ Type Module Let In End EOF Directive Contract Attr ]
## non_fun_decl -> tuple(core_irrefutable) . par(type_param_list) EQ expr [ Type Module Let In End EOF Directive Contract Attr ]
## non_fun_decl -> tuple(core_irrefutable) . par(type_param_list) type_annotation(type_expr) EQ expr [ Type Module Let In End EOF Directive Contract Attr ]
##
## The known suffix of the stack is as follows:
## tuple(core_irrefutable)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 165, spurious reduction of production nsepseq(core_irrefutable,COMMA) -> var_pattern
## In state 213, spurious reduction of production tuple(core_irrefutable) -> WILD COMMA nsepseq(core_irrefutable,COMMA)
##

Ill-formed tuple declaration.
At this point, if there are no more components, one of the following
is expected:
  * the assignment symbol '=' followed by an expression;
  * a type annotation starting with a colon ':';
  * bound type parameters between parentheses, like '(type a b)'.

program: Let LBRACE Ident RBRACE With
##
## Ends in an error in state: 549.
##
## non_fun_decl -> record_pattern(irrefutable) . EQ expr [ Type Module Let In End EOF Directive Contract Attr ]
## non_fun_decl -> record_pattern(irrefutable) . type_annotation(type_expr) EQ expr [ Type Module Let In End EOF Directive Contract Attr ]
## non_fun_decl -> record_pattern(irrefutable) . par(type_param_list) EQ expr [ Type Module Let In End EOF Directive Contract Attr ]
## non_fun_decl -> record_pattern(irrefutable) . par(type_param_list) type_annotation(type_expr) EQ expr [ Type Module Let In End EOF Directive Contract Attr ]
## tuple(core_irrefutable) -> record_pattern(irrefutable) . COMMA nsepseq(core_irrefutable,COMMA) [ LPAR EQ COLON ]
##
## The known suffix of the stack is as follows:
## record_pattern(irrefutable)
##
program: Let LPAR UIdent COLON Ident RPAR With
##
## Ends in an error in state: 561.
##
## non_fun_decl -> par(typed_irrefutable) . EQ expr [ Type Module Let In End EOF Directive Contract Attr ]
## non_fun_decl -> par(typed_irrefutable) . type_annotation(type_expr) EQ expr [ Type Module Let In End EOF Directive Contract Attr ]
## non_fun_decl -> par(typed_irrefutable) . par(type_param_list) EQ expr [ Type Module Let In End EOF Directive Contract Attr ]
## non_fun_decl -> par(typed_irrefutable) . par(type_param_list) type_annotation(type_expr) EQ expr [ Type Module Let In End EOF Directive Contract Attr ]
## tuple(core_irrefutable) -> par(typed_irrefutable) . COMMA nsepseq(core_irrefutable,COMMA) [ LPAR EQ COLON ]
##
## The known suffix of the stack is as follows:
## par(typed_irrefutable)
##
program: Let LPAR WILD RPAR With
##
## Ends in an error in state: 573.
##
## non_fun_decl -> par(irrefutable) . EQ expr [ Type Module Let In End EOF Directive Contract Attr ]
## non_fun_decl -> par(irrefutable) . type_annotation(type_expr) EQ expr [ Type Module Let In End EOF Directive Contract Attr ]
## non_fun_decl -> par(irrefutable) . par(type_param_list) EQ expr [ Type Module Let In End EOF Directive Contract Attr ]
## non_fun_decl -> par(irrefutable) . par(type_param_list) type_annotation(type_expr) EQ expr [ Type Module Let In End EOF Directive Contract Attr ]
## tuple(core_irrefutable) -> par(irrefutable) . COMMA nsepseq(core_irrefutable,COMMA) [ LPAR EQ COLON ]
##
## The known suffix of the stack is as follows:
## par(irrefutable)
##
program: Let UIdent With
##
## Ends in an error in state: 590.
##
## non_fun_decl -> ctor_irrefutable . EQ expr [ Type Module Let In End EOF Directive Contract Attr ]
## non_fun_decl -> ctor_irrefutable . type_annotation(type_expr) EQ expr [ Type Module Let In End EOF Directive Contract Attr ]
## non_fun_decl -> ctor_irrefutable . par(type_param_list) EQ expr [ Type Module Let In End EOF Directive Contract Attr ]
## non_fun_decl -> ctor_irrefutable . par(type_param_list) type_annotation(type_expr) EQ expr [ Type Module Let In End EOF Directive Contract Attr ]
## tuple(core_irrefutable) -> ctor_irrefutable . COMMA nsepseq(core_irrefutable,COMMA) [ LPAR EQ COLON ]
##
## The known suffix of the stack is as follows:
## ctor_irrefutable
##

Ill-formed tuple declaration.
At this point, one of the following is expected:
  * a comma ',' followed by another component as a pattern;
  * the assignment symbol '=' followed by an expression;
  * a type annotation starting with a colon ':';
  * bound type parameters between parentheses, like '(type a b)'.

interactive_expr: Attr Fun LPAR Type Ident RPAR WILD EQ
##
## Ends in an error in state: 617.
##
## fun_expr(expr) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) . ARROW expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(expr) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 251, spurious reduction of production seq(core_irrefutable) ->
## In state 266, spurious reduction of production nseq(core_irrefutable) -> WILD seq(core_irrefutable)
##
interactive_expr: Attr Fun WILD EQ
##
## Ends in an error in state: 625.
##
## fun_expr(expr) -> nseq(Attr) Fun nseq(core_irrefutable) . ARROW expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(expr) -> nseq(Attr) Fun nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun nseq(core_irrefutable)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 251, spurious reduction of production seq(core_irrefutable) ->
## In state 266, spurious reduction of production nseq(core_irrefutable) -> WILD seq(core_irrefutable)
##
interactive_expr: Begin Attr Fun LPAR Type Ident RPAR WILD EQ
##
## Ends in an error in state: 1032.
##
## fun_expr(last_expr) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) . ARROW last_expr [ End Done ]
## fun_expr(last_expr) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW last_expr [ End Done ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 251, spurious reduction of production seq(core_irrefutable) ->
## In state 266, spurious reduction of production nseq(core_irrefutable) -> WILD seq(core_irrefutable)
##
interactive_expr: Begin Attr Fun WILD EQ
##
## Ends in an error in state: 1038.
##
## fun_expr(last_expr) -> nseq(Attr) Fun nseq(core_irrefutable) . ARROW last_expr [ End Done ]
## fun_expr(last_expr) -> nseq(Attr) Fun nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW last_expr [ End Done ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun nseq(core_irrefutable)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 251, spurious reduction of production seq(core_irrefutable) ->
## In state 266, spurious reduction of production nseq(core_irrefutable) -> WILD seq(core_irrefutable)
##
interactive_expr: Begin Fun LPAR Type Ident RPAR WILD EQ
##
## Ends in an error in state: 1017.
##
## fun_expr(last_expr) -> Fun par(type_param_list) nseq(core_irrefutable) . ARROW last_expr [ End Done ]
## fun_expr(last_expr) -> Fun par(type_param_list) nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW last_expr [ End Done ]
##
## The known suffix of the stack is as follows:
## Fun par(type_param_list) nseq(core_irrefutable)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 251, spurious reduction of production seq(core_irrefutable) ->
## In state 266, spurious reduction of production nseq(core_irrefutable) -> WILD seq(core_irrefutable)
##
interactive_expr: Begin Fun WILD EQ
##
## Ends in an error in state: 1048.
##
## fun_expr(last_expr) -> Fun nseq(core_irrefutable) . ARROW last_expr [ End Done ]
## fun_expr(last_expr) -> Fun nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW last_expr [ End Done ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 251, spurious reduction of production seq(core_irrefutable) ->
## In state 266, spurious reduction of production nseq(core_irrefutable) -> WILD seq(core_irrefutable)
##
interactive_expr: Begin If Verbatim Then Attr Fun LPAR Type Ident RPAR WILD EQ
##
## Ends in an error in state: 989.
##
## fun_expr(closed_expr) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) . ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 251, spurious reduction of production seq(core_irrefutable) ->
## In state 266, spurious reduction of production nseq(core_irrefutable) -> WILD seq(core_irrefutable)
##
interactive_expr: Begin If Verbatim Then Attr Fun WILD EQ
##
## Ends in an error in state: 993.
##
## fun_expr(closed_expr) -> nseq(Attr) Fun nseq(core_irrefutable) . ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> nseq(Attr) Fun nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun nseq(core_irrefutable)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 251, spurious reduction of production seq(core_irrefutable) ->
## In state 266, spurious reduction of production nseq(core_irrefutable) -> WILD seq(core_irrefutable)
##
interactive_expr: Begin If Verbatim Then Fun LPAR Type Ident RPAR WILD EQ
##
## Ends in an error in state: 966.
##
## fun_expr(closed_expr) -> Fun par(type_param_list) nseq(core_irrefutable) . ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> Fun par(type_param_list) nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Fun par(type_param_list) nseq(core_irrefutable)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 251, spurious reduction of production seq(core_irrefutable) ->
## In state 266, spurious reduction of production nseq(core_irrefutable) -> WILD seq(core_irrefutable)
##
interactive_expr: Begin If Verbatim Then Fun WILD EQ
##
## Ends in an error in state: 999.
##
## fun_expr(closed_expr) -> Fun nseq(core_irrefutable) . ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> Fun nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 251, spurious reduction of production seq(core_irrefutable) ->
## In state 266, spurious reduction of production nseq(core_irrefutable) -> WILD seq(core_irrefutable)
##
interactive_expr: Begin Match Verbatim With WILD ARROW Attr Fun LPAR Type Ident RPAR WILD EQ
##
## Ends in an error in state: 1063.
##
## fun_expr(base_cond) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) . ARROW base_cond [ VBAR ]
## fun_expr(base_cond) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW base_cond [ VBAR ]
## fun_expr(last_expr) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) . ARROW last_expr [ End Done ]
## fun_expr(last_expr) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW last_expr [ End Done ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 251, spurious reduction of production seq(core_irrefutable) ->
## In state 266, spurious reduction of production nseq(core_irrefutable) -> WILD seq(core_irrefutable)
##
interactive_expr: Begin Match Verbatim With WILD ARROW Attr Fun WILD EQ
##
## Ends in an error in state: 1067.
##
## fun_expr(base_cond) -> nseq(Attr) Fun nseq(core_irrefutable) . ARROW base_cond [ VBAR ]
## fun_expr(base_cond) -> nseq(Attr) Fun nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW base_cond [ VBAR ]
## fun_expr(last_expr) -> nseq(Attr) Fun nseq(core_irrefutable) . ARROW last_expr [ End Done ]
## fun_expr(last_expr) -> nseq(Attr) Fun nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW last_expr [ End Done ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun nseq(core_irrefutable)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 251, spurious reduction of production seq(core_irrefutable) ->
## In state 266, spurious reduction of production nseq(core_irrefutable) -> WILD seq(core_irrefutable)
##
interactive_expr: Begin Match Verbatim With WILD ARROW Fun LPAR Type Ident RPAR WILD EQ
##
## Ends in an error in state: 938.
##
## fun_expr(base_cond) -> Fun par(type_param_list) nseq(core_irrefutable) . ARROW base_cond [ VBAR ]
## fun_expr(base_cond) -> Fun par(type_param_list) nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW base_cond [ VBAR ]
## fun_expr(last_expr) -> Fun par(type_param_list) nseq(core_irrefutable) . ARROW last_expr [ End Done ]
## fun_expr(last_expr) -> Fun par(type_param_list) nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW last_expr [ End Done ]
##
## The known suffix of the stack is as follows:
## Fun par(type_param_list) nseq(core_irrefutable)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 251, spurious reduction of production seq(core_irrefutable) ->
## In state 266, spurious reduction of production nseq(core_irrefutable) -> WILD seq(core_irrefutable)
##
interactive_expr: Begin Match Verbatim With WILD ARROW Fun WILD EQ
##
## Ends in an error in state: 1073.
##
## fun_expr(base_cond) -> Fun nseq(core_irrefutable) . ARROW base_cond [ VBAR ]
## fun_expr(base_cond) -> Fun nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW base_cond [ VBAR ]
## fun_expr(last_expr) -> Fun nseq(core_irrefutable) . ARROW last_expr [ End Done ]
## fun_expr(last_expr) -> Fun nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW last_expr [ End Done ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 251, spurious reduction of production seq(core_irrefutable) ->
## In state 266, spurious reduction of production nseq(core_irrefutable) -> WILD seq(core_irrefutable)
##
interactive_expr: Fun LPAR Type Ident RPAR WILD EQ
##
## Ends in an error in state: 293.
##
## fun_expr(expr) -> Fun par(type_param_list) nseq(core_irrefutable) . ARROW expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(expr) -> Fun par(type_param_list) nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun par(type_param_list) nseq(core_irrefutable)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 251, spurious reduction of production seq(core_irrefutable) ->
## In state 266, spurious reduction of production nseq(core_irrefutable) -> WILD seq(core_irrefutable)
##
interactive_expr: Fun WILD EQ
##
## Ends in an error in state: 1102.
##
## fun_expr(expr) -> Fun nseq(core_irrefutable) . ARROW expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(expr) -> Fun nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 251, spurious reduction of production seq(core_irrefutable) ->
## In state 266, spurious reduction of production nseq(core_irrefutable) -> WILD seq(core_irrefutable)
##
interactive_expr: If Verbatim Then Attr Fun LPAR Type Ident RPAR WILD EQ
##
## Ends in an error in state: 1152.
##
## fun_expr(closed_expr) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) . ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW closed_expr [ Else ]
## fun_expr(expr) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) . ARROW expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(expr) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 251, spurious reduction of production seq(core_irrefutable) ->
## In state 266, spurious reduction of production nseq(core_irrefutable) -> WILD seq(core_irrefutable)
##
interactive_expr: If Verbatim Then Attr Fun WILD EQ
##
## Ends in an error in state: 1156.
##
## fun_expr(closed_expr) -> nseq(Attr) Fun nseq(core_irrefutable) . ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> nseq(Attr) Fun nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW closed_expr [ Else ]
## fun_expr(expr) -> nseq(Attr) Fun nseq(core_irrefutable) . ARROW expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(expr) -> nseq(Attr) Fun nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun nseq(core_irrefutable)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 251, spurious reduction of production seq(core_irrefutable) ->
## In state 266, spurious reduction of production nseq(core_irrefutable) -> WILD seq(core_irrefutable)
##
interactive_expr: If Verbatim Then Fun LPAR Type Ident RPAR WILD EQ
##
## Ends in an error in state: 1129.
##
## fun_expr(closed_expr) -> Fun par(type_param_list) nseq(core_irrefutable) . ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> Fun par(type_param_list) nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW closed_expr [ Else ]
## fun_expr(expr) -> Fun par(type_param_list) nseq(core_irrefutable) . ARROW expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(expr) -> Fun par(type_param_list) nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun par(type_param_list) nseq(core_irrefutable)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 251, spurious reduction of production seq(core_irrefutable) ->
## In state 266, spurious reduction of production nseq(core_irrefutable) -> WILD seq(core_irrefutable)
##
interactive_expr: If Verbatim Then Fun WILD EQ
##
## Ends in an error in state: 1162.
##
## fun_expr(closed_expr) -> Fun nseq(core_irrefutable) . ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> Fun nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW closed_expr [ Else ]
## fun_expr(expr) -> Fun nseq(core_irrefutable) . ARROW expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(expr) -> Fun nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW expr [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 251, spurious reduction of production seq(core_irrefutable) ->
## In state 266, spurious reduction of production nseq(core_irrefutable) -> WILD seq(core_irrefutable)
##
interactive_expr: If Verbatim Then Match Verbatim With WILD ARROW Attr Fun LPAR Type Ident RPAR WILD EQ
##
## Ends in an error in state: 841.
##
## fun_expr(base_cond) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) . ARROW base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(base_cond) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(base_if_then_else) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) . ARROW base_if_then_else [ Else ]
## fun_expr(base_if_then_else) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 251, spurious reduction of production seq(core_irrefutable) ->
## In state 266, spurious reduction of production nseq(core_irrefutable) -> WILD seq(core_irrefutable)
##
interactive_expr: If Verbatim Then Match Verbatim With WILD ARROW Attr Fun WILD EQ
##
## Ends in an error in state: 847.
##
## fun_expr(base_cond) -> nseq(Attr) Fun nseq(core_irrefutable) . ARROW base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(base_cond) -> nseq(Attr) Fun nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(base_if_then_else) -> nseq(Attr) Fun nseq(core_irrefutable) . ARROW base_if_then_else [ Else ]
## fun_expr(base_if_then_else) -> nseq(Attr) Fun nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun nseq(core_irrefutable)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 251, spurious reduction of production seq(core_irrefutable) ->
## In state 266, spurious reduction of production nseq(core_irrefutable) -> WILD seq(core_irrefutable)
##
interactive_expr: If Verbatim Then Match Verbatim With WILD ARROW Fun LPAR Type Ident RPAR WILD EQ
##
## Ends in an error in state: 804.
##
## fun_expr(base_cond) -> Fun par(type_param_list) nseq(core_irrefutable) . ARROW base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(base_cond) -> Fun par(type_param_list) nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(base_if_then_else) -> Fun par(type_param_list) nseq(core_irrefutable) . ARROW base_if_then_else [ Else ]
## fun_expr(base_if_then_else) -> Fun par(type_param_list) nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## Fun par(type_param_list) nseq(core_irrefutable)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 251, spurious reduction of production seq(core_irrefutable) ->
## In state 266, spurious reduction of production nseq(core_irrefutable) -> WILD seq(core_irrefutable)
##
interactive_expr: If Verbatim Then Match Verbatim With WILD ARROW Fun WILD EQ
##
## Ends in an error in state: 858.
##
## fun_expr(base_cond) -> Fun nseq(core_irrefutable) . ARROW base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(base_cond) -> Fun nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(base_if_then_else) -> Fun nseq(core_irrefutable) . ARROW base_if_then_else [ Else ]
## fun_expr(base_if_then_else) -> Fun nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 251, spurious reduction of production seq(core_irrefutable) ->
## In state 266, spurious reduction of production nseq(core_irrefutable) -> WILD seq(core_irrefutable)
##
interactive_expr: Match Verbatim With WILD ARROW Attr Fun LPAR Type Ident RPAR WILD EQ
##
## Ends in an error in state: 912.
##
## fun_expr(base_cond) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) . ARROW base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(base_cond) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 251, spurious reduction of production seq(core_irrefutable) ->
## In state 266, spurious reduction of production nseq(core_irrefutable) -> WILD seq(core_irrefutable)
##
interactive_expr: Match Verbatim With WILD ARROW Attr Fun WILD EQ
##
## Ends in an error in state: 916.
##
## fun_expr(base_cond) -> nseq(Attr) Fun nseq(core_irrefutable) . ARROW base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(base_cond) -> nseq(Attr) Fun nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun nseq(core_irrefutable)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 251, spurious reduction of production seq(core_irrefutable) ->
## In state 266, spurious reduction of production nseq(core_irrefutable) -> WILD seq(core_irrefutable)
##
interactive_expr: Match Verbatim With WILD ARROW Fun LPAR Type Ident RPAR WILD EQ
##
## Ends in an error in state: 889.
##
## fun_expr(base_cond) -> Fun par(type_param_list) nseq(core_irrefutable) . ARROW base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(base_cond) -> Fun par(type_param_list) nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun par(type_param_list) nseq(core_irrefutable)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 251, spurious reduction of production seq(core_irrefutable) ->
## In state 266, spurious reduction of production nseq(core_irrefutable) -> WILD seq(core_irrefutable)
##
interactive_expr: Match Verbatim With WILD ARROW Fun WILD EQ
##
## Ends in an error in state: 922.
##
## fun_expr(base_cond) -> Fun nseq(core_irrefutable) . ARROW base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(base_cond) -> Fun nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 251, spurious reduction of production seq(core_irrefutable) ->
## In state 266, spurious reduction of production nseq(core_irrefutable) -> WILD seq(core_irrefutable)
##
interactive_expr: Match Verbatim With WILD ARROW If Verbatim Then Attr Fun LPAR Type Ident RPAR WILD EQ
##
## Ends in an error in state: 752.
##
## fun_expr(base_cond) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) . ARROW base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(base_cond) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(closed_expr) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) . ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 251, spurious reduction of production seq(core_irrefutable) ->
## In state 266, spurious reduction of production nseq(core_irrefutable) -> WILD seq(core_irrefutable)
##
interactive_expr: Match Verbatim With WILD ARROW If Verbatim Then Attr Fun WILD EQ
##
## Ends in an error in state: 760.
##
## fun_expr(base_cond) -> nseq(Attr) Fun nseq(core_irrefutable) . ARROW base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(base_cond) -> nseq(Attr) Fun nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(closed_expr) -> nseq(Attr) Fun nseq(core_irrefutable) . ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> nseq(Attr) Fun nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun nseq(core_irrefutable)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 251, spurious reduction of production seq(core_irrefutable) ->
## In state 266, spurious reduction of production nseq(core_irrefutable) -> WILD seq(core_irrefutable)
##
interactive_expr: Match Verbatim With WILD ARROW If Verbatim Then Fun LPAR Type Ident RPAR WILD EQ
##
## Ends in an error in state: 698.
##
## fun_expr(base_cond) -> Fun par(type_param_list) nseq(core_irrefutable) . ARROW base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(base_cond) -> Fun par(type_param_list) nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(closed_expr) -> Fun par(type_param_list) nseq(core_irrefutable) . ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> Fun par(type_param_list) nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Fun par(type_param_list) nseq(core_irrefutable)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 251, spurious reduction of production seq(core_irrefutable) ->
## In state 266, spurious reduction of production nseq(core_irrefutable) -> WILD seq(core_irrefutable)
##
interactive_expr: Match Verbatim With WILD ARROW If Verbatim Then Fun WILD EQ
##
## Ends in an error in state: 776.
##
## fun_expr(base_cond) -> Fun nseq(core_irrefutable) . ARROW base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(base_cond) -> Fun nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW base_cond [ With VBAR Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## fun_expr(closed_expr) -> Fun nseq(core_irrefutable) . ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> Fun nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 251, spurious reduction of production seq(core_irrefutable) ->
## In state 266, spurious reduction of production nseq(core_irrefutable) -> WILD seq(core_irrefutable)
##

Ill-formed functional expression.
At this point, if there are no more parameters, one of the following
is expected:
  * an arrow '->', followed by the body as an expression;
  * a type annotation for the body, starting with a colon ':'.

interactive_expr: Bytes GT ZWSP ZWSP
##
## Ends in an error in state: 487.
##
## ge -> GT ZWSP . EQ [ Verbatim UIdent String Originate Not Nat Mutez MINUS Lang LPAR LBRACKET LBRACE Int Ident EIdent Bytes Begin ]
##
## The known suffix of the stack is as follows:
## GT ZWSP
##

This syntax error should not happen. Please report to the developpers.

interactive_expr: LBRACE LPAR ZWSP
##
## Ends in an error in state: 8.
##
## par(expr) -> LPAR . expr RPAR [ DOT ]
##
## The known suffix of the stack is as follows:
## LPAR
##

Ill-formed parenthesised expression.
At this point, an expressions is expected.

interactive_expr: LBRACE LPAR Bytes ZWSP
##
## Ends in an error in state: 1352.
##
## par(expr) -> LPAR expr . RPAR [ DOT ]
##
## The known suffix of the stack is as follows:
## LPAR expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 408, spurious reduction of production call_expr_level -> core_expr
## In state 428, spurious reduction of production unary_expr_level -> call_expr_level
## In state 386, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 417, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 423, spurious reduction of production add_expr_level -> mult_expr_level
## In state 470, spurious reduction of production cons_expr_level -> add_expr_level
## In state 457, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 494, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 501, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 510, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 455, spurious reduction of production tuple_expr_level -> disj_expr_level
## In state 414, spurious reduction of production ass_expr_level -> tuple_expr_level
## In state 525, spurious reduction of production base_expr(expr) -> ass_expr_level
## In state 523, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 524, spurious reduction of production expr -> base_cond__open(expr)
##

Ill-formed parenthesised expression.
At this point, a closing parenthesis ')' is expected.

interactive_expr: LPAR Bytes RPAR DOT ZWSP
##
## Ends in an error in state: 394.
##
## projection -> par(expr) DOT . nsepseq(selection,DOT) [ With Verbatim VBAR UIdent Type To Then TIMES String SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Lxor Lsr Lsl Lor Let Lang Land LT LPAR LE LBRACKET LBRACE Int In Ident GT End Else EQ EOF EIdent Downto Done Do Directive Contract CONS COMMA COLON CARET Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## par(expr) DOT
##

Ill-formed selection in an expression.
At this point, one of the following is expected:
  * the name of a record field;
  * the index of a component in a tuple, '0' denoting the first
    component;
  * the name of an entrypoint in a contract;
  * the name of a view in a contract.

interactive_expr: LBRACE LPAR Bytes RPAR ZWSP
##
## Ends in an error in state: 1181.
##
## projection -> par(expr) . DOT nsepseq(selection,DOT) [ With Verbatim VBAR UIdent Type To Then TIMES String SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Lxor Lsr Lsl Lor Let Lang Land LT LPAR LE LBRACKET LBRACE Int In Ident GT End Else EQ EOF EIdent Downto Done Do Directive Contract CONS COMMA COLON CARET Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## par(expr)
##

Ill-formed selection in an expression.
At this point, the selection operator '.' is expected.

interactive_expr: Originate ZWSP
##
## Ends in an error in state: 116.
##
## call_expr -> Originate . UIdent arguments [ With VBAR Type To Then TIMES SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or NE Module Mod MINUS Lxor Lsr Lsl Lor Let Land LT LE In GT End Else EQ EOF Downto Done Do Directive Contract CONS COMMA COLON CARET BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## Originate
##

Ill-formed origination.
At this point, the name of the contract is expected.

interactive_expr: Originate UIdent ZWSP
##
## Ends in an error in state: 117.
##
## call_expr -> Originate UIdent . arguments [ With VBAR Type To Then TIMES SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or NE Module Mod MINUS Lxor Lsr Lsl Lor Let Land LT LE In GT End Else EQ EOF Downto Done Do Directive Contract CONS COMMA COLON CARET BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## Originate UIdent
##

Ill-formed origination.
At this point, the arguments are expected.

interactive_expr: Try ZWSP
##
## Ends in an error in state: 114.
##
## try_or_match_expr(base_cond) -> Try . expr With option(VBAR) cases(base_cond) [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## Try
##
interactive_expr: Begin Try ZWSP
##
## Ends in an error in state: 382.
##
## try_or_match_expr(last_expr) -> Try . expr With option(VBAR) cases(last_expr) [ End Done ]
##
## The known suffix of the stack is as follows:
## Try
##
interactive_expr: Begin If Bytes Then Try ZWSP
##
## Ends in an error in state: 667.
##
## try_or_match_expr(base_if_then_else) -> Try . expr With option(VBAR) cases(base_if_then_else) [ Else ]
##
## The known suffix of the stack is as follows:
## Try
##
interactive_expr: If Bytes Then Try ZWSP
##
## Ends in an error in state: 1110.
##
## try_or_match_expr(base_cond) -> Try . expr With option(VBAR) cases(base_cond) [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## try_or_match_expr(base_if_then_else) -> Try . expr With option(VBAR) cases(base_if_then_else) [ Else ]
##
## The known suffix of the stack is as follows:
## Try
##

Ill-formed exception handler.
At this point, the subjet expression that might fail is expected as an
expression.

interactive_expr: Begin If Bytes Then Try Bytes ZWSP
##
## Ends in an error in state: 668.
##
## try_or_match_expr(base_if_then_else) -> Try expr . With option(VBAR) cases(base_if_then_else) [ Else ]
##
## The known suffix of the stack is as follows:
## Try expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 408, spurious reduction of production call_expr_level -> core_expr
## In state 428, spurious reduction of production unary_expr_level -> call_expr_level
## In state 386, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 417, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 423, spurious reduction of production add_expr_level -> mult_expr_level
## In state 470, spurious reduction of production cons_expr_level -> add_expr_level
## In state 457, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 494, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 501, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 510, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 455, spurious reduction of production tuple_expr_level -> disj_expr_level
## In state 414, spurious reduction of production ass_expr_level -> tuple_expr_level
## In state 525, spurious reduction of production base_expr(expr) -> ass_expr_level
## In state 523, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 524, spurious reduction of production expr -> base_cond__open(expr)
##
interactive_expr: Begin Try Bytes ZWSP
##
## Ends in an error in state: 643.
##
## try_or_match_expr(last_expr) -> Try expr . With option(VBAR) cases(last_expr) [ End Done ]
##
## The known suffix of the stack is as follows:
## Try expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 408, spurious reduction of production call_expr_level -> core_expr
## In state 428, spurious reduction of production unary_expr_level -> call_expr_level
## In state 386, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 417, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 423, spurious reduction of production add_expr_level -> mult_expr_level
## In state 470, spurious reduction of production cons_expr_level -> add_expr_level
## In state 457, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 494, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 501, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 510, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 455, spurious reduction of production tuple_expr_level -> disj_expr_level
## In state 414, spurious reduction of production ass_expr_level -> tuple_expr_level
## In state 525, spurious reduction of production base_expr(expr) -> ass_expr_level
## In state 523, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 524, spurious reduction of production expr -> base_cond__open(expr)
##
interactive_expr: If Bytes Then Try Bytes ZWSP
##
## Ends in an error in state: 1111.
##
## try_or_match_expr(base_cond) -> Try expr . With option(VBAR) cases(base_cond) [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## try_or_match_expr(base_if_then_else) -> Try expr . With option(VBAR) cases(base_if_then_else) [ Else ]
##
## The known suffix of the stack is as follows:
## Try expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 408, spurious reduction of production call_expr_level -> core_expr
## In state 428, spurious reduction of production unary_expr_level -> call_expr_level
## In state 386, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 417, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 423, spurious reduction of production add_expr_level -> mult_expr_level
## In state 470, spurious reduction of production cons_expr_level -> add_expr_level
## In state 457, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 494, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 501, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 510, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 455, spurious reduction of production tuple_expr_level -> disj_expr_level
## In state 414, spurious reduction of production ass_expr_level -> tuple_expr_level
## In state 525, spurious reduction of production base_expr(expr) -> ass_expr_level
## In state 523, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 524, spurious reduction of production expr -> base_cond__open(expr)
##
interactive_expr: Try Bytes ZWSP
##
## Ends in an error in state: 1348.
##
## try_or_match_expr(base_cond) -> Try expr . With option(VBAR) cases(base_cond) [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## Try expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 408, spurious reduction of production call_expr_level -> core_expr
## In state 428, spurious reduction of production unary_expr_level -> call_expr_level
## In state 386, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 417, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 423, spurious reduction of production add_expr_level -> mult_expr_level
## In state 470, spurious reduction of production cons_expr_level -> add_expr_level
## In state 457, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 494, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 501, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 510, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 455, spurious reduction of production tuple_expr_level -> disj_expr_level
## In state 414, spurious reduction of production ass_expr_level -> tuple_expr_level
## In state 525, spurious reduction of production base_expr(expr) -> ass_expr_level
## In state 523, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 524, spurious reduction of production expr -> base_cond__open(expr)
##

Ill-formed exception handler.
At this point, if the subjet expression is complete, the keyword
'with' is expected.

interactive_expr: Begin If Bytes Then Try Bytes With ZWSP
##
## Ends in an error in state: 669.
##
## try_or_match_expr(base_if_then_else) -> Try expr With . option(VBAR) cases(base_if_then_else) [ Else ]
##
## The known suffix of the stack is as follows:
## Try expr With
##
interactive_expr: Begin Try Bytes With ZWSP
##
## Ends in an error in state: 644.
##
## try_or_match_expr(last_expr) -> Try expr With . option(VBAR) cases(last_expr) [ End Done ]
##
## The known suffix of the stack is as follows:
## Try expr With
##
interactive_expr: If Bytes Then Try Bytes With ZWSP
##
## Ends in an error in state: 1112.
##
## try_or_match_expr(base_cond) -> Try expr With . option(VBAR) cases(base_cond) [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## try_or_match_expr(base_if_then_else) -> Try expr With . option(VBAR) cases(base_if_then_else) [ Else ]
##
## The known suffix of the stack is as follows:
## Try expr With
##
interactive_expr: Try Bytes With ZWSP
##
## Ends in an error in state: 1349.
##
## try_or_match_expr(base_cond) -> Try expr With . option(VBAR) cases(base_cond) [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## Try expr With
##

Ill-formed exception handler.
At this point, one of the following is expected:
  * a case starting with a pattern;
  * a vertical bar '|' followed by a case.

interactive_expr: Begin If Bytes Then Try Bytes With VBAR ZWSP
##
## Ends in an error in state: 670.
##
## try_or_match_expr(base_if_then_else) -> Try expr With option(VBAR) . cases(base_if_then_else) [ Else ]
##
## The known suffix of the stack is as follows:
## Try expr With option(VBAR)
##
interactive_expr: If Bytes Then Try Bytes With VBAR ZWSP
##
## Ends in an error in state: 1113.
##
## try_or_match_expr(base_cond) -> Try expr With option(VBAR) . cases(base_cond) [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
## try_or_match_expr(base_if_then_else) -> Try expr With option(VBAR) . cases(base_if_then_else) [ Else ]
##
## The known suffix of the stack is as follows:
## Try expr With option(VBAR)
##
interactive_expr: Try Bytes With VBAR ZWSP
##
## Ends in an error in state: 1350.
##
## try_or_match_expr(base_cond) -> Try expr With option(VBAR) . cases(base_cond) [ With Type To Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Downto Do Directive Contract COLON Attr ]
##
## The known suffix of the stack is as follows:
## Try expr With option(VBAR)
##

Ill-formed exception handler.
At this point, a case is expected to start with a pattern.

interactive_expr: Begin Try Bytes With VBAR ZWSP
##
## Ends in an error in state: 646.
##
## try_or_match_expr(last_expr) -> Try expr With option(VBAR) . cases(last_expr) [ End Done ]
##
## The known suffix of the stack is as follows:
## Try expr With option(VBAR)
##

Ill-formed exception handler.
At this point, a case starting with a pattern is expected.

program: Contract ZWSP
##
## Ends in an error in state: 1269.
##
## contract_decl -> Contract . UIdent EQ Struct End [ Type Module Let End EOF Directive Contract Attr ]
## contract_decl -> Contract . UIdent EQ Struct nseq(contract) End [ Type Module Let End EOF Directive Contract Attr ]
##
## The known suffix of the stack is as follows:
## Contract
##

Ill-formed contract declaration.
At this point, the name of the contract is expected.

program: Contract UIdent ZWSP
##
## Ends in an error in state: 1270.
##
## contract_decl -> Contract UIdent . EQ Struct End [ Type Module Let End EOF Directive Contract Attr ]
## contract_decl -> Contract UIdent . EQ Struct nseq(contract) End [ Type Module Let End EOF Directive Contract Attr ]
##
## The known suffix of the stack is as follows:
## Contract UIdent
##

Ill-formed contract declaration.
At this point, the assignment operator '=' is expected.

program: Contract UIdent EQ ZWSP
##
## Ends in an error in state: 1271.
##
## contract_decl -> Contract UIdent EQ . Struct End [ Type Module Let End EOF Directive Contract Attr ]
## contract_decl -> Contract UIdent EQ . Struct nseq(contract) End [ Type Module Let End EOF Directive Contract Attr ]
##
## The known suffix of the stack is as follows:
## Contract UIdent EQ
##

Ill-formed contract declaration.
At this point, the keyword 'struct' is expected.

program: Contract UIdent EQ Struct ZWSP
##
## Ends in an error in state: 1272.
##
## contract_decl -> Contract UIdent EQ Struct . End [ Type Module Let End EOF Directive Contract Attr ]
## contract_decl -> Contract UIdent EQ Struct . nseq(contract) End [ Type Module Let End EOF Directive Contract Attr ]
##
## The known suffix of the stack is as follows:
## Contract UIdent EQ Struct
##

Ill-formed contract declaration.
At this point, one of the following is expected:
  * attributes;
  * an entry point declaration;
  * a view declaration;
  * a value declaration.
Note: All those declaration start with the keyword 'let'.

program: Contract UIdent EQ Struct Attr ZWSP
##
## Ends in an error in state: 1294.
##
## entry_decl -> nseq(Attr) . Let Entry var_pattern parameters EQ expr [ Let End Attr ]
## entry_decl -> nseq(Attr) . Let Entry var_pattern parameters type_annotation(type_expr) EQ expr [ Let End Attr ]
## let_decl -> nseq(Attr) . Let let_binding [ Let End Attr ]
## let_decl -> nseq(Attr) . Let Rec let_binding [ Let End Attr ]
## view_decl -> nseq(Attr) . Let View var_pattern parameters EQ expr [ Let End Attr ]
## view_decl -> nseq(Attr) . Let View var_pattern parameters type_annotation(type_expr) EQ expr [ Let End Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 41, spurious reduction of production seq(Attr) ->
## In state 44, spurious reduction of production nseq(Attr) -> Attr seq(Attr)
##

Ill-formed contract declaration.
At this point, one of the following is expected:
  * an entry point declaration;
  * a view declaration;
  * a value declaration.
Note: All those declaration start with the keyword 'let'.

program: Contract UIdent EQ Struct Let ZWSP
##
## Ends in an error in state: 1273.
##
## entry_decl -> Let . Entry var_pattern parameters EQ expr [ Let End Attr ]
## entry_decl -> Let . Entry var_pattern parameters type_annotation(type_expr) EQ expr [ Let End Attr ]
## let_decl -> Let . let_binding [ Let End Attr ]
## let_decl -> Let . Rec let_binding [ Let End Attr ]
## view_decl -> Let . View var_pattern parameters EQ expr [ Let End Attr ]
## view_decl -> Let . View var_pattern parameters type_annotation(type_expr) EQ expr [ Let End Attr ]
##
## The known suffix of the stack is as follows:
## Let
##
program: Contract UIdent EQ Struct Attr Let ZWSP
##
## Ends in an error in state: 1295.
##
## entry_decl -> nseq(Attr) Let . Entry var_pattern parameters EQ expr [ Let End Attr ]
## entry_decl -> nseq(Attr) Let . Entry var_pattern parameters type_annotation(type_expr) EQ expr [ Let End Attr ]
## let_decl -> nseq(Attr) Let . let_binding [ Let End Attr ]
## let_decl -> nseq(Attr) Let . Rec let_binding [ Let End Attr ]
## view_decl -> nseq(Attr) Let . View var_pattern parameters EQ expr [ Let End Attr ]
## view_decl -> nseq(Attr) Let . View var_pattern parameters type_annotation(type_expr) EQ expr [ Let End Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let
##

Ill-formed contract declaration.
At this point, one of the following is expected:
  * the keyword 'entry' if declaring an entrypoint;
  * the keyword 'view' if declaring a view;
  * the keyword 'rec' if declaring a recursive function;
  * a pattern, e.g. an identifier, if declaration a non-recursive
    function.

program: Contract UIdent EQ Struct Let View ZWSP
##
## Ends in an error in state: 1274.
##
## view_decl -> Let View . var_pattern parameters EQ expr [ Let End Attr ]
## view_decl -> Let View . var_pattern parameters type_annotation(type_expr) EQ expr [ Let End Attr ]
##
## The known suffix of the stack is as follows:
## Let View
##
program: Contract UIdent EQ Struct Attr Let View ZWSP
##
## Ends in an error in state: 1296.
##
## view_decl -> nseq(Attr) Let View . var_pattern parameters EQ expr [ Let End Attr ]
## view_decl -> nseq(Attr) Let View . var_pattern parameters type_annotation(type_expr) EQ expr [ Let End Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let View
##

Ill-formed view declaration.
At this point, the name of the view is expected.

program: Contract UIdent EQ Struct Let Entry ZWSP
##
## Ends in an error in state: 1282.
##
## entry_decl -> Let Entry . var_pattern parameters EQ expr [ Let End Attr ]
## entry_decl -> Let Entry . var_pattern parameters type_annotation(type_expr) EQ expr [ Let End Attr ]
##
## The known suffix of the stack is as follows:
## Let Entry
##
program: Contract UIdent EQ Struct Attr Let Entry ZWSP
##
## Ends in an error in state: 1306.
##
## entry_decl -> nseq(Attr) Let Entry . var_pattern parameters EQ expr [ Let End Attr ]
## entry_decl -> nseq(Attr) Let Entry . var_pattern parameters type_annotation(type_expr) EQ expr [ Let End Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let Entry
##

Ill-formed entrypoint declaration.
At this point, the name of the entrypoint is expected.

program: Contract UIdent EQ Struct Let WILD EQ Bytes ZWSP
##
## Ends in an error in state: 1317.
##
## nseq(contract) -> contract . seq(contract) [ End ]
##
## The known suffix of the stack is as follows:
## contract
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 408, spurious reduction of production call_expr_level -> core_expr
## In state 428, spurious reduction of production unary_expr_level -> call_expr_level
## In state 386, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 417, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 423, spurious reduction of production add_expr_level -> mult_expr_level
## In state 470, spurious reduction of production cons_expr_level -> add_expr_level
## In state 457, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 494, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 501, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 510, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 455, spurious reduction of production tuple_expr_level -> disj_expr_level
## In state 414, spurious reduction of production ass_expr_level -> tuple_expr_level
## In state 525, spurious reduction of production base_expr(expr) -> ass_expr_level
## In state 523, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 524, spurious reduction of production expr -> base_cond__open(expr)
## In state 1255, spurious reduction of production non_fun_decl -> WILD EQ expr
## In state 585, spurious reduction of production let_binding -> non_fun_decl
## In state 1267, spurious reduction of production let_decl -> Let let_binding
## In state 1315, spurious reduction of production contract -> let_decl
##
program: Contract UIdent EQ Struct Let WILD EQ Bytes Let WILD EQ Bytes ZWSP
##
## Ends in an error in state: 1319.
##
## seq(contract) -> contract . seq(contract) [ End ]
##
## The known suffix of the stack is as follows:
## contract
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 408, spurious reduction of production call_expr_level -> core_expr
## In state 428, spurious reduction of production unary_expr_level -> call_expr_level
## In state 386, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 417, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 423, spurious reduction of production add_expr_level -> mult_expr_level
## In state 470, spurious reduction of production cons_expr_level -> add_expr_level
## In state 457, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 494, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 501, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 510, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 455, spurious reduction of production tuple_expr_level -> disj_expr_level
## In state 414, spurious reduction of production ass_expr_level -> tuple_expr_level
## In state 525, spurious reduction of production base_expr(expr) -> ass_expr_level
## In state 523, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 524, spurious reduction of production expr -> base_cond__open(expr)
## In state 1255, spurious reduction of production non_fun_decl -> WILD EQ expr
## In state 585, spurious reduction of production let_binding -> non_fun_decl
## In state 1267, spurious reduction of production let_decl -> Let let_binding
## In state 1315, spurious reduction of production contract -> let_decl
##

Ill-formed contract declaration.
At this point, if the declaration is complete, one of the following is
expected:
  * another declaration (value, function, entrypoint, view);
  * the keyword 'end' if the contract is complete.

program: Contract UIdent EQ Struct Let View Ident ZWSP
##
## Ends in an error in state: 1275.
##
## view_decl -> Let View var_pattern . parameters EQ expr [ Let End Attr ]
## view_decl -> Let View var_pattern . parameters type_annotation(type_expr) EQ expr [ Let End Attr ]
##
## The known suffix of the stack is as follows:
## Let View var_pattern
##
program: Contract UIdent EQ Struct Attr Let View Ident ZWSP
##
## Ends in an error in state: 1297.
##
## view_decl -> nseq(Attr) Let View var_pattern . parameters EQ expr [ Let End Attr ]
## view_decl -> nseq(Attr) Let View var_pattern . parameters type_annotation(type_expr) EQ expr [ Let End Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let View var_pattern
##

Ill-formed view declaration.
At this point, parameters are expected, e.g. variables.

program: Contract UIdent EQ Struct Let View Ident UIdent ARROW
##
## Ends in an error in state: 1276.
##
## view_decl -> Let View var_pattern parameters . EQ expr [ Let End Attr ]
## view_decl -> Let View var_pattern parameters . type_annotation(type_expr) EQ expr [ Let End Attr ]
##
## The known suffix of the stack is as follows:
## Let View var_pattern parameters
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 623, spurious reduction of production seq(core_irrefutable) ->
## In state 624, spurious reduction of production nseq(core_irrefutable) -> ctor_irrefutable seq(core_irrefutable)
## In state 1227, spurious reduction of production parameters -> nseq(core_irrefutable)
##
program: Contract UIdent EQ Struct Attr Let View Ident UIdent ARROW
##
## Ends in an error in state: 1298.
##
## view_decl -> nseq(Attr) Let View var_pattern parameters . EQ expr [ Let End Attr ]
## view_decl -> nseq(Attr) Let View var_pattern parameters . type_annotation(type_expr) EQ expr [ Let End Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let View var_pattern parameters
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 623, spurious reduction of production seq(core_irrefutable) ->
## In state 624, spurious reduction of production nseq(core_irrefutable) -> ctor_irrefutable seq(core_irrefutable)
## In state 1227, spurious reduction of production parameters -> nseq(core_irrefutable)
##

Ill-formed view declaration.
At this point, if the parameter is complete, one of the following is
expected:
  * another parameter;
  * the assignment symbol '=' if there are no more parameters;
  * a type annotation starting with a colon ':'.

program: Contract UIdent EQ Struct Let View Ident UIdent COLON UIdent ARROW
##
## Ends in an error in state: 1279.
##
## view_decl -> Let View var_pattern parameters type_annotation(type_expr) . EQ expr [ Let End Attr ]
##
## The known suffix of the stack is as follows:
## Let View var_pattern parameters type_annotation(type_expr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 38, spurious reduction of production variant(fun_type_level) -> UIdent
## In state 52, spurious reduction of production nsepseq(variant(fun_type_level),VBAR) -> variant(fun_type_level)
## In state 80, spurious reduction of production sum_type(fun_type_level) -> nsepseq(variant(fun_type_level),VBAR)
## In state 63, spurious reduction of production type_expr -> sum_type(fun_type_level)
## In state 215, spurious reduction of production type_annotation(type_expr) -> COLON type_expr
##
program: Contract UIdent EQ Struct Attr Let View Ident UIdent COLON UIdent ARROW
##
## Ends in an error in state: 1301.
##
## view_decl -> nseq(Attr) Let View var_pattern parameters type_annotation(type_expr) . EQ expr [ Let End Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let View var_pattern parameters type_annotation(type_expr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 38, spurious reduction of production variant(fun_type_level) -> UIdent
## In state 52, spurious reduction of production nsepseq(variant(fun_type_level),VBAR) -> variant(fun_type_level)
## In state 80, spurious reduction of production sum_type(fun_type_level) -> nsepseq(variant(fun_type_level),VBAR)
## In state 63, spurious reduction of production type_expr -> sum_type(fun_type_level)
## In state 215, spurious reduction of production type_annotation(type_expr) -> COLON type_expr
##

Ill-formed view declaration.
At this point, the type annotation is complete, the assignment symbol
'=' is expected.

program: Contract UIdent EQ Struct Let View Ident UIdent COLON Ident EQ ZWSP
##
## Ends in an error in state: 1280.
##
## view_decl -> Let View var_pattern parameters type_annotation(type_expr) EQ . expr [ Let End Attr ]
##
## The known suffix of the stack is as follows:
## Let View var_pattern parameters type_annotation(type_expr) EQ
##
program: Contract UIdent EQ Struct Let View Ident UIdent EQ ZWSP
##
## Ends in an error in state: 1277.
##
## view_decl -> Let View var_pattern parameters EQ . expr [ Let End Attr ]
##
## The known suffix of the stack is as follows:
## Let View var_pattern parameters EQ
##
program: Contract UIdent EQ Struct Attr Let View Ident UIdent EQ ZWSP
##
## Ends in an error in state: 1299.
##
## view_decl -> nseq(Attr) Let View var_pattern parameters EQ . expr [ Let End Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let View var_pattern parameters EQ
##
program: Contract UIdent EQ Struct Attr Let View Ident UIdent COLON Ident EQ ZWSP
##
## Ends in an error in state: 1302.
##
## view_decl -> nseq(Attr) Let View var_pattern parameters type_annotation(type_expr) EQ . expr [ Let End Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let View var_pattern parameters type_annotation(type_expr) EQ
##

Ill-formed view declaration.
At this point, the body of the view is expected.

program: Contract UIdent EQ Struct Let Entry Ident UIdent ARROW
##
## Ends in an error in state: 1284.
##
## entry_decl -> Let Entry var_pattern parameters . EQ expr [ Let End Attr ]
## entry_decl -> Let Entry var_pattern parameters . type_annotation(type_expr) EQ expr [ Let End Attr ]
##
## The known suffix of the stack is as follows:
## Let Entry var_pattern parameters
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 623, spurious reduction of production seq(core_irrefutable) ->
## In state 624, spurious reduction of production nseq(core_irrefutable) -> ctor_irrefutable seq(core_irrefutable)
## In state 1227, spurious reduction of production parameters -> nseq(core_irrefutable)
##
program: Contract UIdent EQ Struct Attr Let Entry Ident UIdent ARROW
##
## Ends in an error in state: 1308.
##
## entry_decl -> nseq(Attr) Let Entry var_pattern parameters . EQ expr [ Let End Attr ]
## entry_decl -> nseq(Attr) Let Entry var_pattern parameters . type_annotation(type_expr) EQ expr [ Let End Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let Entry var_pattern parameters
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 623, spurious reduction of production seq(core_irrefutable) ->
## In state 624, spurious reduction of production nseq(core_irrefutable) -> ctor_irrefutable seq(core_irrefutable)
## In state 1227, spurious reduction of production parameters -> nseq(core_irrefutable)
##

Ill-formed entrypoint declaration.
At this point, if the parameter is complete, one of the following is
expected:
  * another parameter;
  * a type annotation starting with a colon ':'.

program: Contract UIdent EQ Struct Let Entry Ident UIdent EQ ZWSP
##
## Ends in an error in state: 1285.
##
## entry_decl -> Let Entry var_pattern parameters EQ . expr [ Let End Attr ]
##
## The known suffix of the stack is as follows:
## Let Entry var_pattern parameters EQ
##
program: Contract UIdent EQ Struct Let Entry Ident UIdent COLON Ident EQ ZWSP
##
## Ends in an error in state: 1288.
##
## entry_decl -> Let Entry var_pattern parameters type_annotation(type_expr) EQ . expr [ Let End Attr ]
##
## The known suffix of the stack is as follows:
## Let Entry var_pattern parameters type_annotation(type_expr) EQ
##
program: Contract UIdent EQ Struct Attr Let Entry Ident UIdent EQ ZWSP
##
## Ends in an error in state: 1309.
##
## entry_decl -> nseq(Attr) Let Entry var_pattern parameters EQ . expr [ Let End Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let Entry var_pattern parameters EQ
##
program: Contract UIdent EQ Struct Attr Let Entry Ident UIdent COLON Ident EQ ZWSP
##
## Ends in an error in state: 1312.
##
## entry_decl -> nseq(Attr) Let Entry var_pattern parameters type_annotation(type_expr) EQ . expr [ Let End Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let Entry var_pattern parameters type_annotation(type_expr) EQ
##

Ill-formed entrypoint declaration.
At this point, the body of the entrypoint is expected.

program: Contract UIdent EQ Struct Attr Let Entry Ident UIdent COLON UIdent ARROW
##
## Ends in an error in state: 1311.
##
## entry_decl -> nseq(Attr) Let Entry var_pattern parameters type_annotation(type_expr) . EQ expr [ Let End Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let Entry var_pattern parameters type_annotation(type_expr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 38, spurious reduction of production variant(fun_type_level) -> UIdent
## In state 52, spurious reduction of production nsepseq(variant(fun_type_level),VBAR) -> variant(fun_type_level)
## In state 80, spurious reduction of production sum_type(fun_type_level) -> nsepseq(variant(fun_type_level),VBAR)
## In state 63, spurious reduction of production type_expr -> sum_type(fun_type_level)
## In state 215, spurious reduction of production type_annotation(type_expr) -> COLON type_expr
##
program: Contract UIdent EQ Struct Let Entry Ident UIdent COLON UIdent ARROW
##
## Ends in an error in state: 1287.
##
## entry_decl -> Let Entry var_pattern parameters type_annotation(type_expr) . EQ expr [ Let End Attr ]
##
## The known suffix of the stack is as follows:
## Let Entry var_pattern parameters type_annotation(type_expr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 38, spurious reduction of production variant(fun_type_level) -> UIdent
## In state 52, spurious reduction of production nsepseq(variant(fun_type_level),VBAR) -> variant(fun_type_level)
## In state 80, spurious reduction of production sum_type(fun_type_level) -> nsepseq(variant(fun_type_level),VBAR)
## In state 63, spurious reduction of production type_expr -> sum_type(fun_type_level)
## In state 215, spurious reduction of production type_annotation(type_expr) -> COLON type_expr
##

Ill-formed entrypoint declaration.
At this point, the type annotation is complete, the assignment symbol
'=' is expected.

interactive_expr: Bytes LPAR ZWSP
##
## Ends in an error in state: 409.
##
## par(expr) -> LPAR . expr RPAR [ With Verbatim VBAR UIdent Type To Then TIMES String SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Lxor Lsr Lsl Lor Let Lang Land LT LPAR LE LBRACKET LBRACE Int In Ident GT End Else EQ EOF EIdent Downto Done Do Directive DOT Contract CONS COMMA COLON CARET Bytes Begin BOOL_OR BOOL_AND Attr ]
## par(typed_expr) -> LPAR . typed_expr RPAR [ With Verbatim VBAR UIdent Type To Then TIMES String SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Lxor Lsr Lsl Lor Let Lang Land LT LPAR LE LBRACKET LBRACE Int In Ident GT End Else EQ EOF EIdent Downto Done Do Directive Contract CONS COMMA COLON CARET Bytes Begin BOOL_OR BOOL_AND Attr ]
## unit -> LPAR . RPAR [ With Verbatim VBAR UIdent Type To Then TIMES String SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Lxor Lsr Lsl Lor Let Lang Land LT LPAR LE LBRACKET LBRACE Int In Ident GT End Else EQ EOF EIdent Downto Done Do Directive Contract CONS COMMA COLON CARET Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## LPAR
##

Ill-formed expression.
At this point, one of following is expected:
  * an expression is expected, if defining a parenthesised expression.
  * a closing parenthesis ')' if defining the unit value.

interactive_expr: LPAR Contract ZWSP
##
## Ends in an error in state: 1336.
##
## par(__anonymous_2) -> LPAR Contract . address_cast RPAR [ With VBAR Type To Then TIMES SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or NE Module Mod MINUS Lxor Lsr Lsl Lor Let Land LT LE In GT End Else EQ EOF Downto Done Do Directive Contract CONS COMMA COLON CARET BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## LPAR Contract
##

Ill-formed casting of a contract from an address.
At this point, an address is expected as an expression.

interactive_expr: LPAR Contract Ident ZWSP
##
## Ends in an error in state: 1337.
##
## address_cast -> core_expr . COLON Type Of UIdent [ RPAR ]
##
## The known suffix of the stack is as follows:
## core_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 404, spurious reduction of production core_expr -> gen_ident
##

Ill-formed casting of a contract from an address.
At this point, an address is expected.

interactive_expr: LPAR Contract Ident COLON ZWSP
##
## Ends in an error in state: 1338.
##
## address_cast -> core_expr COLON . Type Of UIdent [ RPAR ]
##
## The known suffix of the stack is as follows:
## core_expr COLON
##

Ill-formed casting of a contract from an address.
At this point, the keywords 'type' and 'of' are expected.

interactive_expr: LPAR Contract Ident COLON Type ZWSP
##
## Ends in an error in state: 1339.
##
## address_cast -> core_expr COLON Type . Of UIdent [ RPAR ]
##
## The known suffix of the stack is as follows:
## core_expr COLON Type
##

Ill-formed casting of a contract from an address.
At this point, the keyword 'of' is expected, followed by a contract
name.

interactive_expr: LPAR Contract Ident COLON Type Of ZWSP
##
## Ends in an error in state: 1340.
##
## address_cast -> core_expr COLON Type Of . UIdent [ RPAR ]
##
## The known suffix of the stack is as follows:
## core_expr COLON Type Of
##

Ill-formed casting of a contract from an address.
At this point, a contract name is expected.

interactive_expr: LPAR Contract Ident COLON Type Of UIdent ZWSP
##
## Ends in an error in state: 1342.
##
## par(__anonymous_2) -> LPAR Contract address_cast . RPAR [ With VBAR Type To Then TIMES SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or NE Module Mod MINUS Lxor Lsr Lsl Lor Let Land LT LE In GT End Else EQ EOF Downto Done Do Directive Contract CONS COMMA COLON CARET BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## LPAR Contract address_cast
##

Ill-formed casting of a contract from an address.
At this point, a closing parenthesis ')' is expected.
