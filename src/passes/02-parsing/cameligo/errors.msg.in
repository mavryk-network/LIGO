interactive_expr: Begin Fun WILD ARROW Bytes SEMI
##
## Ends in an error in state: 983.
##
## sequence -> Begin series . End [ With Verbatim VBAR UIdent Type Then TIMES String SLASH SEMI RPAR RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Lxor Lsr Lsl Lor Let Lang Land LT LPAR LE LBRACKET LBRACE Int In Ident GT GE End Else EQ EOF Directive CONS COMMA COLON CARET Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## Begin series
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 329, spurious reduction of production call_expr_level -> core_expr
## In state 338, spurious reduction of production unary_expr_level -> call_expr_level
## In state 319, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 348, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 354, spurious reduction of production add_expr_level -> mult_expr_level
## In state 395, spurious reduction of production cons_expr_level -> add_expr_level
## In state 382, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 417, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 424, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 431, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 923, spurious reduction of production seq_expr -> disj_expr_level
## In state 844, spurious reduction of production last_expr -> seq_expr
## In state 947, spurious reduction of production fun_expr(last_expr) -> Fun nseq(core_irrefutable) ARROW last_expr
## In state 922, spurious reduction of production last_expr -> fun_expr(last_expr)
## In state 921, spurious reduction of production series -> last_expr
##

Ill-formed sequence of expressions.
At this point, if the expression is complete, one of the following is
expected:
  * a semicolon ';' followed by another expression;
  * the keyword 'end' if the sequence is complete.

interactive_expr: Begin Match UIdent With UIdent ARROW If With
##
## Ends in an error in state: 602.
##
## if_then(base_cond) -> If . expr Then base_cond [ VBAR ]
## if_then_else(base_cond) -> If . expr Then closed_expr Else base_cond [ VBAR ]
## if_then_else(seq_expr) -> If . expr Then closed_expr Else seq_expr [ SEMI End ]
##
## The known suffix of the stack is as follows:
## If
##
interactive_expr: If With
##
## Ends in an error in state: 277.
##
## if_then(expr) -> If . expr Then expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## if_then_else(expr) -> If . expr Then closed_expr Else expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## If
##
interactive_expr: If UIdent Then If With
##
## Ends in an error in state: 1006.
##
## if_then(expr) -> If . expr Then expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## if_then_else(closed_expr) -> If . expr Then closed_expr Else closed_expr [ Else ]
## if_then_else(expr) -> If . expr Then closed_expr Else expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## If
##
interactive_expr: Begin If UIdent Then If With
##
## Ends in an error in state: 864.
##
## if_then_else(closed_expr) -> If . expr Then closed_expr Else closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## If
##
interactive_expr: Begin If With
##
## Ends in an error in state: 857.
##
## if_then_else(seq_expr) -> If . expr Then closed_expr Else seq_expr [ SEMI End ]
##
## The known suffix of the stack is as follows:
## If
##
interactive_expr: Match UIdent With UIdent ARROW If With
##
## Ends in an error in state: 794.
##
## if_then(base_cond) -> If . expr Then base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## if_then_else(base_cond) -> If . expr Then closed_expr Else base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## If
##
interactive_expr: Match UIdent With UIdent ARROW If UIdent Then If With
##
## Ends in an error in state: 622.
##
## if_then(base_cond) -> If . expr Then base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## if_then_else(base_cond) -> If . expr Then closed_expr Else base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## if_then_else(closed_expr) -> If . expr Then closed_expr Else closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## If
##
interactive_expr: If UIdent Then Match UIdent With UIdent ARROW If With
##
## Ends in an error in state: 615.
##
## if_then(base_cond) -> If . expr Then base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## if_then_else(base_cond) -> If . expr Then closed_expr Else base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## if_then_else(base_if_then_else) -> If . expr Then closed_expr Else base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## If
##

Ill-formed conditional expression.
At this point, the condition is expected as an expression.

interactive_expr: If UIdent Then UIdent Else With
##
## Ends in an error in state: 1053.
##
## if_then_else(expr) -> If expr Then closed_expr Else . expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## If expr Then closed_expr Else
##
interactive_expr: Begin If UIdent Then If UIdent Then UIdent Else With
##
## Ends in an error in state: 903.
##
## if_then_else(closed_expr) -> If expr Then closed_expr Else . closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## If expr Then closed_expr Else
##
interactive_expr: Match UIdent With UIdent ARROW If UIdent Then UIdent Else With
##
## Ends in an error in state: 798.
##
## if_then_else(base_cond) -> If expr Then closed_expr Else . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## If expr Then closed_expr Else
##
interactive_expr: If UIdent Then Match UIdent With UIdent ARROW If UIdent Then UIdent Else With
##
## Ends in an error in state: 717.
##
## if_then_else(base_cond) -> If expr Then closed_expr Else . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## if_then_else(base_if_then_else) -> If expr Then closed_expr Else . base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## If expr Then closed_expr Else
##
interactive_expr: Match UIdent With UIdent ARROW If UIdent Then If UIdent Then UIdent Else With
##
## Ends in an error in state: 706.
##
## if_then_else(base_cond) -> If expr Then closed_expr Else . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## if_then_else(closed_expr) -> If expr Then closed_expr Else . closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## If expr Then closed_expr Else
##
interactive_expr: Begin Match UIdent With UIdent ARROW If UIdent Then UIdent Else With
##
## Ends in an error in state: 789.
##
## if_then_else(base_cond) -> If expr Then closed_expr Else . base_cond [ VBAR ]
## if_then_else(seq_expr) -> If expr Then closed_expr Else . seq_expr [ SEMI End ]
##
## The known suffix of the stack is as follows:
## If expr Then closed_expr Else
##
interactive_expr: If UIdent Then If UIdent Then UIdent Else With
##
## Ends in an error in state: 1046.
##
## if_then_else(closed_expr) -> If expr Then closed_expr Else . closed_expr [ Else ]
## if_then_else(expr) -> If expr Then closed_expr Else . expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## If expr Then closed_expr Else
##
interactive_expr: Begin If Verbatim Then Verbatim Else With
##
## Ends in an error in state: 907.
##
## if_then_else(seq_expr) -> If expr Then closed_expr Else . seq_expr [ SEMI End ]
##
## The known suffix of the stack is as follows:
## If expr Then closed_expr Else
##

Ill-formed conditional expression.
At this point, the expression of the 'else' branch is expected.

interactive_expr: If UIdent Then Attr Fun Ident COLON Ident ARROW With
##
## Ends in an error in state: 1037.
##
## fun_expr(closed_expr) -> nseq(Attr) Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . closed_expr [ Else ]
## fun_expr(expr) -> nseq(Attr) Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW
##
interactive_expr: If UIdent Then Attr Fun Ident ARROW With
##
## Ends in an error in state: 1035.
##
## fun_expr(closed_expr) -> nseq(Attr) Fun nseq(core_irrefutable) ARROW . closed_expr [ Else ]
## fun_expr(expr) -> nseq(Attr) Fun nseq(core_irrefutable) ARROW . expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun nseq(core_irrefutable) ARROW
##
interactive_expr: If UIdent Then Attr Fun LPAR Type Ident RPAR Ident COLON Ident ARROW With
##
## Ends in an error in state: 1033.
##
## fun_expr(closed_expr) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . closed_expr [ Else ]
## fun_expr(expr) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW
##
interactive_expr: If UIdent Then Attr Fun LPAR Type Ident RPAR Ident ARROW With
##
## Ends in an error in state: 1031.
##
## fun_expr(closed_expr) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) ARROW . closed_expr [ Else ]
## fun_expr(expr) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) ARROW . expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) ARROW
##
interactive_expr: Begin Match UIdent With UIdent ARROW Attr Fun Ident COLON Ident ARROW With
##
## Ends in an error in state: 967.
##
## fun_expr(base_cond) -> nseq(Attr) Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . base_cond [ VBAR ]
## fun_expr(last_expr) -> nseq(Attr) Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . last_expr [ End ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW
##
interactive_expr: Begin Match UIdent With UIdent ARROW Attr Fun Ident ARROW With
##
## Ends in an error in state: 965.
##
## fun_expr(base_cond) -> nseq(Attr) Fun nseq(core_irrefutable) ARROW . base_cond [ VBAR ]
## fun_expr(last_expr) -> nseq(Attr) Fun nseq(core_irrefutable) ARROW . last_expr [ End ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun nseq(core_irrefutable) ARROW
##
interactive_expr: Begin Match UIdent With UIdent ARROW Attr Fun LPAR Type Ident RPAR Ident COLON Ident ARROW With
##
## Ends in an error in state: 963.
##
## fun_expr(base_cond) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . base_cond [ VBAR ]
## fun_expr(last_expr) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . last_expr [ End ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW
##
interactive_expr: Begin Match UIdent With UIdent ARROW Attr Fun LPAR Type Ident RPAR Ident ARROW With
##
## Ends in an error in state: 961.
##
## fun_expr(base_cond) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) ARROW . base_cond [ VBAR ]
## fun_expr(last_expr) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) ARROW . last_expr [ End ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) ARROW
##
interactive_expr: Begin Attr Fun Ident COLON Ident ARROW With
##
## Ends in an error in state: 939.
##
## fun_expr(last_expr) -> nseq(Attr) Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . last_expr [ End ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW
##
interactive_expr: Begin Attr Fun Ident ARROW With
##
## Ends in an error in state: 936.
##
## fun_expr(last_expr) -> nseq(Attr) Fun nseq(core_irrefutable) ARROW . last_expr [ End ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun nseq(core_irrefutable) ARROW
##
interactive_expr: Begin Attr Fun LPAR Type Ident RPAR Ident COLON Ident ARROW With
##
## Ends in an error in state: 933.
##
## fun_expr(last_expr) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . last_expr [ End ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW
##
interactive_expr: Begin Attr Fun LPAR Type Ident RPAR Ident ARROW With
##
## Ends in an error in state: 930.
##
## fun_expr(last_expr) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) ARROW . last_expr [ End ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) ARROW
##
interactive_expr: Begin If UIdent Then Attr Fun Ident COLON Ident ARROW With
##
## Ends in an error in state: 895.
##
## fun_expr(closed_expr) -> nseq(Attr) Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW
##
interactive_expr: Begin If UIdent Then Attr Fun Ident ARROW With
##
## Ends in an error in state: 893.
##
## fun_expr(closed_expr) -> nseq(Attr) Fun nseq(core_irrefutable) ARROW . closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun nseq(core_irrefutable) ARROW
##
interactive_expr: Begin If UIdent Then Attr Fun LPAR Type Ident RPAR Ident COLON Ident ARROW With
##
## Ends in an error in state: 891.
##
## fun_expr(closed_expr) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW
##
interactive_expr: Begin If UIdent Then Attr Fun LPAR Type Ident RPAR Ident ARROW With
##
## Ends in an error in state: 889.
##
## fun_expr(closed_expr) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) ARROW . closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) ARROW
##
interactive_expr: Match UIdent With UIdent ARROW Attr Fun Ident COLON Ident ARROW With
##
## Ends in an error in state: 827.
##
## fun_expr(base_cond) -> nseq(Attr) Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW
##
interactive_expr: Match UIdent With UIdent ARROW Attr Fun Ident ARROW With
##
## Ends in an error in state: 825.
##
## fun_expr(base_cond) -> nseq(Attr) Fun nseq(core_irrefutable) ARROW . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun nseq(core_irrefutable) ARROW
##
interactive_expr: Match UIdent With UIdent ARROW Attr Fun LPAR Type Ident RPAR Ident COLON Ident ARROW With
##
## Ends in an error in state: 823.
##
## fun_expr(base_cond) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW
##
interactive_expr: Match UIdent With UIdent ARROW Attr Fun LPAR Type Ident RPAR Ident ARROW With
##
## Ends in an error in state: 821.
##
## fun_expr(base_cond) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) ARROW . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) ARROW
##
interactive_expr: If UIdent Then Match UIdent With UIdent ARROW Attr Fun Ident COLON Ident ARROW With
##
## Ends in an error in state: 761.
##
## fun_expr(base_cond) -> nseq(Attr) Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_if_then_else) -> nseq(Attr) Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW
##
interactive_expr: If UIdent Then Match UIdent With UIdent ARROW Attr Fun Ident ARROW With
##
## Ends in an error in state: 758.
##
## fun_expr(base_cond) -> nseq(Attr) Fun nseq(core_irrefutable) ARROW . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_if_then_else) -> nseq(Attr) Fun nseq(core_irrefutable) ARROW . base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun nseq(core_irrefutable) ARROW
##
interactive_expr: If UIdent Then Match UIdent With UIdent ARROW Attr Fun LPAR Type Ident RPAR Ident COLON Ident ARROW With
##
## Ends in an error in state: 755.
##
## fun_expr(base_cond) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_if_then_else) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW
##
interactive_expr: If UIdent Then Match UIdent With UIdent ARROW Attr Fun LPAR Type Ident RPAR Ident ARROW With
##
## Ends in an error in state: 752.
##
## fun_expr(base_cond) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) ARROW . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_if_then_else) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) ARROW . base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) ARROW
##
interactive_expr: Attr Fun LPAR Type Ident RPAR Ident ARROW With
##
## Ends in an error in state: 519.
##
## fun_expr(expr) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) ARROW . expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) ARROW
##
interactive_expr: Attr Fun LPAR Type Ident RPAR Ident COLON Ident ARROW With
##
## Ends in an error in state: 522.
##
## fun_expr(expr) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW
##
interactive_expr: Attr Fun Ident ARROW With
##
## Ends in an error in state: 527.
##
## fun_expr(expr) -> nseq(Attr) Fun nseq(core_irrefutable) ARROW . expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun nseq(core_irrefutable) ARROW
##
interactive_expr: Attr Fun Ident COLON Ident ARROW With
##
## Ends in an error in state: 530.
##
## fun_expr(expr) -> nseq(Attr) Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW
##
interactive_expr: Match UIdent With UIdent ARROW If UIdent Then Attr Fun LPAR Type Ident RPAR Ident ARROW With
##
## Ends in an error in state: 674.
##
## fun_expr(base_cond) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) ARROW . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(closed_expr) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) ARROW . closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) ARROW
##
interactive_expr: Match UIdent With UIdent ARROW If UIdent Then Attr Fun LPAR Type Ident RPAR Ident COLON Ident ARROW With
##
## Ends in an error in state: 678.
##
## fun_expr(base_cond) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(closed_expr) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW
##
interactive_expr: Match UIdent With UIdent ARROW If UIdent Then Attr Fun Ident ARROW With
##
## Ends in an error in state: 682.
##
## fun_expr(base_cond) -> nseq(Attr) Fun nseq(core_irrefutable) ARROW . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(closed_expr) -> nseq(Attr) Fun nseq(core_irrefutable) ARROW . closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun nseq(core_irrefutable) ARROW
##
interactive_expr: Match UIdent With UIdent ARROW If UIdent Then Attr Fun Ident COLON Ident ARROW With
##
## Ends in an error in state: 686.
##
## fun_expr(base_cond) -> nseq(Attr) Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(closed_expr) -> nseq(Attr) Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW
##
interactive_expr: Begin Match Verbatim With WILD ARROW Fun WILD ARROW With
##
## Ends in an error in state: 971.
##
## fun_expr(base_cond) -> Fun nseq(core_irrefutable) ARROW . base_cond [ VBAR ]
## fun_expr(last_expr) -> Fun nseq(core_irrefutable) ARROW . last_expr [ End ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable) ARROW
##
interactive_expr: Fun Ident ARROW With
##
## Ends in an error in state: 990.
##
## fun_expr(expr) -> Fun nseq(core_irrefutable) ARROW . expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable) ARROW
##
interactive_expr: Match UIdent With UIdent ARROW If UIdent Then Fun Ident ARROW With
##
## Ends in an error in state: 698.
##
## fun_expr(base_cond) -> Fun nseq(core_irrefutable) ARROW . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(closed_expr) -> Fun nseq(core_irrefutable) ARROW . closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable) ARROW
##
interactive_expr: If UIdent Then Match UIdent With UIdent ARROW Fun Ident ARROW With
##
## Ends in an error in state: 769.
##
## fun_expr(base_cond) -> Fun nseq(core_irrefutable) ARROW . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_if_then_else) -> Fun nseq(core_irrefutable) ARROW . base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable) ARROW
##
interactive_expr: Match UIdent With UIdent ARROW Fun Ident ARROW With
##
## Ends in an error in state: 831.
##
## fun_expr(base_cond) -> Fun nseq(core_irrefutable) ARROW . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable) ARROW
##
interactive_expr: Begin If UIdent Then Fun Ident ARROW With
##
## Ends in an error in state: 899.
##
## fun_expr(closed_expr) -> Fun nseq(core_irrefutable) ARROW . closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable) ARROW
##
interactive_expr: Begin Fun Ident ARROW With
##
## Ends in an error in state: 946.
##
## fun_expr(last_expr) -> Fun nseq(core_irrefutable) ARROW . last_expr [ End ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable) ARROW
##
interactive_expr: If UIdent Then Fun Ident ARROW With
##
## Ends in an error in state: 1041.
##
## fun_expr(closed_expr) -> Fun nseq(core_irrefutable) ARROW . closed_expr [ Else ]
## fun_expr(expr) -> Fun nseq(core_irrefutable) ARROW . expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable) ARROW
##
interactive_expr: Fun LPAR Type Ident RPAR Ident ARROW With
##
## Ends in an error in state: 313.
##
## fun_expr(expr) -> Fun par(type_param_list) nseq(core_irrefutable) ARROW . expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun par(type_param_list) nseq(core_irrefutable) ARROW
##
interactive_expr: Match UIdent With UIdent ARROW If UIdent Then Fun LPAR Type Ident RPAR Ident ARROW With
##
## Ends in an error in state: 628.
##
## fun_expr(base_cond) -> Fun par(type_param_list) nseq(core_irrefutable) ARROW . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(closed_expr) -> Fun par(type_param_list) nseq(core_irrefutable) ARROW . closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Fun par(type_param_list) nseq(core_irrefutable) ARROW
##
interactive_expr: Match UIdent With UIdent ARROW If UIdent Then Fun LPAR Type Ident RPAR Ident COLON Ident ARROW With
##
## Ends in an error in state: 694.
##
## fun_expr(base_cond) -> Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(closed_expr) -> Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW
##
interactive_expr: Match UIdent With UIdent ARROW If UIdent Then Fun Ident COLON Ident ARROW With
##
## Ends in an error in state: 702.
##
## fun_expr(base_cond) -> Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(closed_expr) -> Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW
##
interactive_expr: If UIdent Then Match UIdent With UIdent ARROW Fun LPAR Type Ident RPAR Ident ARROW With
##
## Ends in an error in state: 721.
##
## fun_expr(base_cond) -> Fun par(type_param_list) nseq(core_irrefutable) ARROW . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_if_then_else) -> Fun par(type_param_list) nseq(core_irrefutable) ARROW . base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## Fun par(type_param_list) nseq(core_irrefutable) ARROW
##
interactive_expr: If UIdent Then Match UIdent With UIdent ARROW Fun LPAR Type Ident RPAR Ident COLON Ident ARROW With
##
## Ends in an error in state: 766.
##
## fun_expr(base_cond) -> Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_if_then_else) -> Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW
##
interactive_expr: If UIdent Then Match UIdent With UIdent ARROW Fun Ident COLON Ident ARROW With
##
## Ends in an error in state: 772.
##
## fun_expr(base_cond) -> Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_if_then_else) -> Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW
##
interactive_expr: Match UIdent With UIdent ARROW Fun LPAR Type Ident RPAR Ident ARROW With
##
## Ends in an error in state: 802.
##
## fun_expr(base_cond) -> Fun par(type_param_list) nseq(core_irrefutable) ARROW . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun par(type_param_list) nseq(core_irrefutable) ARROW
##
interactive_expr: Match UIdent With UIdent ARROW Fun LPAR Type Ident RPAR Ident COLON Ident ARROW With
##
## Ends in an error in state: 829.
##
## fun_expr(base_cond) -> Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW
##
interactive_expr: Match UIdent With UIdent ARROW Fun Ident COLON Ident ARROW With
##
## Ends in an error in state: 833.
##
## fun_expr(base_cond) -> Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW
##
interactive_expr: Begin Match UIdent With UIdent ARROW Fun LPAR Type Ident RPAR Ident ARROW With
##
## Ends in an error in state: 842.
##
## fun_expr(base_cond) -> Fun par(type_param_list) nseq(core_irrefutable) ARROW . base_cond [ VBAR ]
## fun_expr(last_expr) -> Fun par(type_param_list) nseq(core_irrefutable) ARROW . last_expr [ End ]
##
## The known suffix of the stack is as follows:
## Fun par(type_param_list) nseq(core_irrefutable) ARROW
##
interactive_expr: Begin If UIdent Then Fun LPAR Type Ident RPAR Ident ARROW With
##
## Ends in an error in state: 870.
##
## fun_expr(closed_expr) -> Fun par(type_param_list) nseq(core_irrefutable) ARROW . closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Fun par(type_param_list) nseq(core_irrefutable) ARROW
##
interactive_expr: Begin If UIdent Then Fun LPAR Type Ident RPAR Ident COLON Ident ARROW With
##
## Ends in an error in state: 897.
##
## fun_expr(closed_expr) -> Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW
##
interactive_expr: Begin If UIdent Then Fun Ident COLON Ident ARROW With
##
## Ends in an error in state: 901.
##
## fun_expr(closed_expr) -> Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW
##
interactive_expr: Begin Fun LPAR Type Ident RPAR Ident ARROW With
##
## Ends in an error in state: 912.
##
## fun_expr(last_expr) -> Fun par(type_param_list) nseq(core_irrefutable) ARROW . last_expr [ End ]
##
## The known suffix of the stack is as follows:
## Fun par(type_param_list) nseq(core_irrefutable) ARROW
##
interactive_expr: Begin Fun LPAR Type Ident RPAR Ident COLON Ident ARROW With
##
## Ends in an error in state: 943.
##
## fun_expr(last_expr) -> Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . last_expr [ End ]
##
## The known suffix of the stack is as follows:
## Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW
##
interactive_expr: Begin Fun Ident COLON Ident ARROW With
##
## Ends in an error in state: 949.
##
## fun_expr(last_expr) -> Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . last_expr [ End ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW
##
interactive_expr: Begin Match UIdent With UIdent ARROW Fun LPAR Type Ident RPAR Ident COLON Ident ARROW With
##
## Ends in an error in state: 969.
##
## fun_expr(base_cond) -> Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . base_cond [ VBAR ]
## fun_expr(last_expr) -> Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . last_expr [ End ]
##
## The known suffix of the stack is as follows:
## Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW
##
interactive_expr: Begin Match UIdent With UIdent ARROW Fun Ident COLON Ident ARROW With
##
## Ends in an error in state: 973.
##
## fun_expr(base_cond) -> Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . base_cond [ VBAR ]
## fun_expr(last_expr) -> Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . last_expr [ End ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW
##
interactive_expr: Fun LPAR Type Ident RPAR Ident COLON Ident ARROW With
##
## Ends in an error in state: 987.
##
## fun_expr(expr) -> Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW
##
interactive_expr: Fun Ident COLON Ident ARROW With
##
## Ends in an error in state: 993.
##
## fun_expr(expr) -> Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW
##
interactive_expr: If UIdent Then Fun LPAR Type Ident RPAR Ident ARROW With
##
## Ends in an error in state: 1012.
##
## fun_expr(closed_expr) -> Fun par(type_param_list) nseq(core_irrefutable) ARROW . closed_expr [ Else ]
## fun_expr(expr) -> Fun par(type_param_list) nseq(core_irrefutable) ARROW . expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun par(type_param_list) nseq(core_irrefutable) ARROW
##
interactive_expr: If UIdent Then Fun LPAR Type Ident RPAR Ident COLON Ident ARROW With
##
## Ends in an error in state: 1039.
##
## fun_expr(closed_expr) -> Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . closed_expr [ Else ]
## fun_expr(expr) -> Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW
##
interactive_expr: If UIdent Then Fun Ident COLON Ident ARROW With
##
## Ends in an error in state: 1043.
##
## fun_expr(closed_expr) -> Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . closed_expr [ Else ]
## fun_expr(expr) -> Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW
##

Ill-formed functional expression.
At this point, the body of the function is expected as an expression.

interactive_expr: If Verbatim Then Match Verbatim With WILD ARROW With
##
## Ends in an error in state: 610.
##
## case_clause(base_cond) -> pattern ARROW . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## case_clause(base_if_then_else) -> pattern ARROW . base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## pattern ARROW
##
interactive_expr: Begin Match UIdent With UIdent ARROW With
##
## Ends in an error in state: 597.
##
## case_clause(base_cond) -> pattern ARROW . base_cond [ VBAR ]
## case_clause(last_expr) -> pattern ARROW . last_expr [ End ]
##
## The known suffix of the stack is as follows:
## pattern ARROW
##
interactive_expr: Match UIdent With UIdent ARROW With
##
## Ends in an error in state: 1129.
##
## case_clause(base_cond) -> pattern ARROW . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## pattern ARROW
##

Ill-formed pattern matching.
At this point, the right-hand side of the current clause is expected
as an expression.

interactive_expr: Begin With
##
## Ends in an error in state: 315.
##
## sequence -> Begin . End [ With Verbatim VBAR UIdent Type Then TIMES String SLASH SEMI RPAR RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Lxor Lsr Lsl Lor Let Lang Land LT LPAR LE LBRACKET LBRACE Int In Ident GT GE End Else EQ EOF Directive CONS COMMA COLON CARET Bytes Begin BOOL_OR BOOL_AND Attr ]
## sequence -> Begin . series End [ With Verbatim VBAR UIdent Type Then TIMES String SLASH SEMI RPAR RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Lxor Lsr Lsl Lor Let Lang Land LT LPAR LE LBRACKET LBRACE Int In Ident GT GE End Else EQ EOF Directive CONS COMMA COLON CARET Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## Begin
##

Ill-formed sequence of expressions.
At this point, one of the following is expected:
  * an expression of type 'unit';
  * the keyword 'end' if the sequence is empty.

interactive_expr: Begin If Verbatim Then With
##
## Ends in an error in state: 859.
##
## if_then_else(seq_expr) -> If expr Then . closed_expr Else seq_expr [ SEMI End ]
##
## The known suffix of the stack is as follows:
## If expr Then
##
interactive_expr: If Verbatim Then With
##
## Ends in an error in state: 996.
##
## if_then(expr) -> If expr Then . expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## if_then_else(expr) -> If expr Then . closed_expr Else expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## If expr Then
##
interactive_expr: Match Verbatim With WILD ARROW If Verbatim Then With
##
## Ends in an error in state: 796.
##
## if_then(base_cond) -> If expr Then . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## if_then_else(base_cond) -> If expr Then . closed_expr Else base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## If expr Then
##
interactive_expr: Begin Match UIdent With UIdent ARROW If UIdent Then With
##
## Ends in an error in state: 604.
##
## if_then(base_cond) -> If expr Then . base_cond [ VBAR ]
## if_then_else(base_cond) -> If expr Then . closed_expr Else base_cond [ VBAR ]
## if_then_else(seq_expr) -> If expr Then . closed_expr Else seq_expr [ SEMI End ]
##
## The known suffix of the stack is as follows:
## If expr Then
##
interactive_expr: If UIdent Then Match UIdent With UIdent ARROW If UIdent Then With
##
## Ends in an error in state: 617.
##
## if_then(base_cond) -> If expr Then . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## if_then_else(base_cond) -> If expr Then . closed_expr Else base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## if_then_else(base_if_then_else) -> If expr Then . closed_expr Else base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## If expr Then
##
interactive_expr: Match UIdent With UIdent ARROW If UIdent Then If UIdent Then With
##
## Ends in an error in state: 624.
##
## if_then(base_cond) -> If expr Then . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## if_then_else(base_cond) -> If expr Then . closed_expr Else base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## if_then_else(closed_expr) -> If expr Then . closed_expr Else closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## If expr Then
##
interactive_expr: Begin If UIdent Then If UIdent Then With
##
## Ends in an error in state: 866.
##
## if_then_else(closed_expr) -> If expr Then . closed_expr Else closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## If expr Then
##
interactive_expr: If UIdent Then If UIdent Then With
##
## Ends in an error in state: 1008.
##
## if_then(expr) -> If expr Then . expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## if_then_else(closed_expr) -> If expr Then . closed_expr Else closed_expr [ Else ]
## if_then_else(expr) -> If expr Then . closed_expr Else expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## If expr Then
##

Ill-formed conditional expression.
At this point, the 'then' branch is expected as an expression.

interactive_expr: Begin Attr Let Rec Ident EQ UIdent In With
##
## Ends in an error in state: 918.
##
## let_in_sequence -> nseq(Attr) Let Rec let_binding In . series [ End ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let Rec let_binding In
##
interactive_expr: Begin If UIdent Then Attr Let Rec Ident EQ UIdent In With
##
## Ends in an error in state: 878.
##
## let_in_expr(closed_expr) -> nseq(Attr) Let Rec let_binding In . closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let Rec let_binding In
##
interactive_expr: Begin If UIdent Then Let Rec Ident EQ UIdent In With
##
## Ends in an error in state: 863.
##
## let_in_expr(closed_expr) -> Let Rec let_binding In . closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Let Rec let_binding In
##
interactive_expr: Begin Attr Let Ident EQ UIdent In With
##
## Ends in an error in state: 925.
##
## let_in_sequence -> nseq(Attr) Let let_binding In . series [ End ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let let_binding In
##
interactive_expr: Begin Let Ident EQ UIdent In With
##
## Ends in an error in state: 953.
##
## let_in_sequence -> Let let_binding In . series [ End ]
##
## The known suffix of the stack is as follows:
## Let let_binding In
##
interactive_expr: Begin Match UIdent With UIdent ARROW Attr Let Ident EQ UIdent In With
##
## Ends in an error in state: 957.
##
## let_in_expr(base_cond) -> nseq(Attr) Let let_binding In . base_cond [ VBAR ]
## let_in_sequence -> nseq(Attr) Let let_binding In . series [ End ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let let_binding In
##
interactive_expr: Begin Match UIdent With UIdent ARROW Let Ident EQ UIdent In With
##
## Ends in an error in state: 975.
##
## let_in_expr(base_cond) -> Let let_binding In . base_cond [ VBAR ]
## let_in_sequence -> Let let_binding In . series [ End ]
##
## The known suffix of the stack is as follows:
## Let let_binding In
##
interactive_expr: If UIdent Then Let Rec Ident EQ UIdent In With
##
## Ends in an error in state: 1005.
##
## let_in_expr(closed_expr) -> Let Rec let_binding In . closed_expr [ Else ]
## let_in_expr(expr) -> Let Rec let_binding In . expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let Rec let_binding In
##
interactive_expr: If UIdent Then Attr Let Rec Ident EQ UIdent In With
##
## Ends in an error in state: 1020.
##
## let_in_expr(closed_expr) -> nseq(Attr) Let Rec let_binding In . closed_expr [ Else ]
## let_in_expr(expr) -> nseq(Attr) Let Rec let_binding In . expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let Rec let_binding In
##
interactive_expr: If UIdent Then Attr Let Ident EQ UIdent In With
##
## Ends in an error in state: 1027.
##
## let_in_expr(closed_expr) -> nseq(Attr) Let let_binding In . closed_expr [ Else ]
## let_in_expr(expr) -> nseq(Attr) Let let_binding In . expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let let_binding In
##
interactive_expr: If UIdent Then Let Ident EQ UIdent In With
##
## Ends in an error in state: 1050.
##
## let_in_expr(closed_expr) -> Let let_binding In . closed_expr [ Else ]
## let_in_expr(expr) -> Let let_binding In . expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let let_binding In
##
interactive_expr: Let Ident EQ UIdent In With
##
## Ends in an error in state: 1111.
##
## let_in_expr(expr) -> Let let_binding In . expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let let_binding In
##
interactive_expr: Begin If UIdent Then Attr Let Ident EQ UIdent In With
##
## Ends in an error in state: 885.
##
## let_in_expr(closed_expr) -> nseq(Attr) Let let_binding In . closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let let_binding In
##
interactive_expr: Begin If UIdent Then Let Ident EQ UIdent In With
##
## Ends in an error in state: 905.
##
## let_in_expr(closed_expr) -> Let let_binding In . closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Let let_binding In
##
interactive_expr: Match Verbatim With WILD ARROW Let WILD EQ Bytes In With
##
## Ends in an error in state: 835.
##
## let_in_expr(base_cond) -> Let let_binding In . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let let_binding In
##
interactive_expr: Let Rec Ident EQ UIdent In With
##
## Ends in an error in state: 1109.
##
## let_in_expr(expr) -> Let Rec let_binding In . expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let Rec let_binding In
##
interactive_expr: Attr Let Rec Ident EQ UIdent In With
##
## Ends in an error in state: 499.
##
## let_in_expr(expr) -> nseq(Attr) Let Rec let_binding In . expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let Rec let_binding In
##
interactive_expr: Attr Let Ident EQ UIdent In With
##
## Ends in an error in state: 514.
##
## let_in_expr(expr) -> nseq(Attr) Let let_binding In . expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let let_binding In
##
interactive_expr: Begin Match UIdent With UIdent ARROW Let Rec Ident EQ UIdent In With
##
## Ends in an error in state: 601.
##
## let_in_expr(base_cond) -> Let Rec let_binding In . base_cond [ VBAR ]
## let_in_sequence -> Let Rec let_binding In . series [ End ]
##
## The known suffix of the stack is as follows:
## Let Rec let_binding In
##
interactive_expr: If UIdent Then Match UIdent With UIdent ARROW Let Rec Ident EQ UIdent In With
##
## Ends in an error in state: 614.
##
## let_in_expr(base_cond) -> Let Rec let_binding In . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## let_in_expr(base_if_then_else) -> Let Rec let_binding In . base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## Let Rec let_binding In
##
interactive_expr: Match UIdent With UIdent ARROW If UIdent Then Let Rec Ident EQ UIdent In With
##
## Ends in an error in state: 621.
##
## let_in_expr(base_cond) -> Let Rec let_binding In . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## let_in_expr(closed_expr) -> Let Rec let_binding In . closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Let Rec let_binding In
##
interactive_expr: Match UIdent With UIdent ARROW If UIdent Then Attr Let Rec Ident EQ UIdent In With
##
## Ends in an error in state: 636.
##
## let_in_expr(base_cond) -> nseq(Attr) Let Rec let_binding In . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## let_in_expr(closed_expr) -> nseq(Attr) Let Rec let_binding In . closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let Rec let_binding In
##
interactive_expr: Match UIdent With UIdent ARROW If UIdent Then Attr Let Ident EQ UIdent In With
##
## Ends in an error in state: 668.
##
## let_in_expr(base_cond) -> nseq(Attr) Let let_binding In . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## let_in_expr(closed_expr) -> nseq(Attr) Let let_binding In . closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let let_binding In
##
interactive_expr: Match UIdent With UIdent ARROW If UIdent Then Let Ident EQ UIdent In With
##
## Ends in an error in state: 713.
##
## let_in_expr(base_cond) -> Let let_binding In . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## let_in_expr(closed_expr) -> Let let_binding In . closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Let let_binding In
##
interactive_expr: If UIdent Then Match UIdent With UIdent ARROW Attr Let Rec Ident EQ UIdent In With
##
## Ends in an error in state: 729.
##
## let_in_expr(base_cond) -> nseq(Attr) Let Rec let_binding In . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## let_in_expr(base_if_then_else) -> nseq(Attr) Let Rec let_binding In . base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let Rec let_binding In
##
interactive_expr: If UIdent Then Match UIdent With UIdent ARROW Attr Let Ident EQ UIdent In With
##
## Ends in an error in state: 747.
##
## let_in_expr(base_cond) -> nseq(Attr) Let let_binding In . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## let_in_expr(base_if_then_else) -> nseq(Attr) Let let_binding In . base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let let_binding In
##
interactive_expr: If UIdent Then Match UIdent With UIdent ARROW Let Ident EQ UIdent In With
##
## Ends in an error in state: 777.
##
## let_in_expr(base_cond) -> Let let_binding In . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## let_in_expr(base_if_then_else) -> Let let_binding In . base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## Let let_binding In
##
interactive_expr: Match UIdent With UIdent ARROW Let Rec Ident EQ UIdent In With
##
## Ends in an error in state: 793.
##
## let_in_expr(base_cond) -> Let Rec let_binding In . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let Rec let_binding In
##
interactive_expr: Match UIdent With UIdent ARROW Attr Let Rec Ident EQ UIdent In With
##
## Ends in an error in state: 810.
##
## let_in_expr(base_cond) -> nseq(Attr) Let Rec let_binding In . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let Rec let_binding In
##
interactive_expr: Match UIdent With UIdent ARROW Attr Let Ident EQ UIdent In With
##
## Ends in an error in state: 817.
##
## let_in_expr(base_cond) -> nseq(Attr) Let let_binding In . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let let_binding In
##
interactive_expr: Begin Match UIdent With UIdent ARROW Attr Let Rec Ident EQ UIdent In With
##
## Ends in an error in state: 849.
##
## let_in_expr(base_cond) -> nseq(Attr) Let Rec let_binding In . base_cond [ VBAR ]
## let_in_sequence -> nseq(Attr) Let Rec let_binding In . series [ End ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let Rec let_binding In
##
interactive_expr: Begin Let Rec Ident EQ UIdent In With
##
## Ends in an error in state: 856.
##
## let_in_sequence -> Let Rec let_binding In . series [ End ]
##
## The known suffix of the stack is as follows:
## Let Rec let_binding In
##

Ill-formed local value declaration.
At this point, an expression is expected.

interactive_expr: With
##
## Ends in an error in state: 1176.
##
## interactive_expr' -> . interactive_expr [ # ]
##
## The known suffix of the stack is as follows:
##
##

Ill-formed expression.
At this point, an expression is expected.

contract: With
##
## Ends in an error in state: 0.
##
## contract' -> . contract [ # ]
##
## The known suffix of the stack is as follows:
##
##

Ill-formed contract.
At this point, a declaration is expected.

interactive_expr: Match Verbatim With WILD ARROW If Verbatim Then If Verbatim Then Verbatim WILD
##
## Ends in an error in state: 705.
##
## if_then_else(base_cond) -> If expr Then closed_expr . Else base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## if_then_else(closed_expr) -> If expr Then closed_expr . Else closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## If expr Then closed_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 329, spurious reduction of production call_expr_level -> core_expr
## In state 338, spurious reduction of production unary_expr_level -> call_expr_level
## In state 319, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 348, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 354, spurious reduction of production add_expr_level -> mult_expr_level
## In state 395, spurious reduction of production cons_expr_level -> add_expr_level
## In state 382, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 417, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 424, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 431, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 655, spurious reduction of production base_expr(closed_expr) -> disj_expr_level
## In state 659, spurious reduction of production base_if_then_else__open(closed_expr) -> base_expr(closed_expr)
## In state 658, spurious reduction of production closed_expr -> base_if_then_else__open(closed_expr)
##
interactive_expr: Begin If Verbatim Then If Verbatim Then Verbatim COMMA Bytes With
##
## Ends in an error in state: 902.
##
## if_then_else(closed_expr) -> If expr Then closed_expr . Else closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## If expr Then closed_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 329, spurious reduction of production call_expr_level -> core_expr
## In state 338, spurious reduction of production unary_expr_level -> call_expr_level
## In state 319, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 348, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 354, spurious reduction of production add_expr_level -> mult_expr_level
## In state 395, spurious reduction of production cons_expr_level -> add_expr_level
## In state 382, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 417, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 424, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 431, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 428, spurious reduction of production nsepseq(disj_expr_level,COMMA) -> disj_expr_level
## In state 427, spurious reduction of production tuple(disj_expr_level) -> disj_expr_level COMMA nsepseq(disj_expr_level,COMMA)
## In state 347, spurious reduction of production tuple_expr -> tuple(disj_expr_level)
## In state 873, spurious reduction of production base_expr(closed_expr) -> tuple_expr
## In state 659, spurious reduction of production base_if_then_else__open(closed_expr) -> base_expr(closed_expr)
## In state 658, spurious reduction of production closed_expr -> base_if_then_else__open(closed_expr)
##
interactive_expr: Begin If Verbatim Then Verbatim With
##
## Ends in an error in state: 906.
##
## if_then_else(seq_expr) -> If expr Then closed_expr . Else seq_expr [ SEMI End ]
##
## The known suffix of the stack is as follows:
## If expr Then closed_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 329, spurious reduction of production call_expr_level -> core_expr
## In state 338, spurious reduction of production unary_expr_level -> call_expr_level
## In state 319, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 348, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 354, spurious reduction of production add_expr_level -> mult_expr_level
## In state 395, spurious reduction of production cons_expr_level -> add_expr_level
## In state 382, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 417, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 424, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 431, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 883, spurious reduction of production base_expr(closed_expr) -> disj_expr_level
## In state 659, spurious reduction of production base_if_then_else__open(closed_expr) -> base_expr(closed_expr)
## In state 658, spurious reduction of production closed_expr -> base_if_then_else__open(closed_expr)
##
interactive_expr: If Verbatim Then If Verbatim Then Verbatim VBAR
##
## Ends in an error in state: 1045.
##
## if_then_else(closed_expr) -> If expr Then closed_expr . Else closed_expr [ Else ]
## if_then_else(expr) -> If expr Then closed_expr . Else expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## If expr Then closed_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 329, spurious reduction of production call_expr_level -> core_expr
## In state 338, spurious reduction of production unary_expr_level -> call_expr_level
## In state 319, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 348, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 354, spurious reduction of production add_expr_level -> mult_expr_level
## In state 395, spurious reduction of production cons_expr_level -> add_expr_level
## In state 382, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 417, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 424, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 431, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 1025, spurious reduction of production base_expr(closed_expr) -> disj_expr_level
## In state 659, spurious reduction of production base_if_then_else__open(closed_expr) -> base_expr(closed_expr)
## In state 658, spurious reduction of production closed_expr -> base_if_then_else__open(closed_expr)
##
interactive_expr: If Verbatim Then Verbatim VBAR
##
## Ends in an error in state: 1052.
##
## if_then_else(expr) -> If expr Then closed_expr . Else expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## If expr Then closed_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 329, spurious reduction of production call_expr_level -> core_expr
## In state 338, spurious reduction of production unary_expr_level -> call_expr_level
## In state 319, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 348, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 354, spurious reduction of production add_expr_level -> mult_expr_level
## In state 395, spurious reduction of production cons_expr_level -> add_expr_level
## In state 382, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 417, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 424, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 431, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 1025, spurious reduction of production base_expr(closed_expr) -> disj_expr_level
## In state 659, spurious reduction of production base_if_then_else__open(closed_expr) -> base_expr(closed_expr)
## In state 658, spurious reduction of production closed_expr -> base_if_then_else__open(closed_expr)
##
interactive_expr: If Verbatim Then Match Verbatim With WILD ARROW If Verbatim Then Verbatim WILD
##
## Ends in an error in state: 716.
##
## if_then_else(base_cond) -> If expr Then closed_expr . Else base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## if_then_else(base_if_then_else) -> If expr Then closed_expr . Else base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## If expr Then closed_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 329, spurious reduction of production call_expr_level -> core_expr
## In state 338, spurious reduction of production unary_expr_level -> call_expr_level
## In state 319, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 348, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 354, spurious reduction of production add_expr_level -> mult_expr_level
## In state 395, spurious reduction of production cons_expr_level -> add_expr_level
## In state 382, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 417, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 424, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 431, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 655, spurious reduction of production base_expr(closed_expr) -> disj_expr_level
## In state 659, spurious reduction of production base_if_then_else__open(closed_expr) -> base_expr(closed_expr)
## In state 658, spurious reduction of production closed_expr -> base_if_then_else__open(closed_expr)
##
interactive_expr: Begin Match Verbatim With WILD ARROW If Verbatim Then Verbatim WILD
##
## Ends in an error in state: 788.
##
## if_then_else(base_cond) -> If expr Then closed_expr . Else base_cond [ VBAR ]
## if_then_else(seq_expr) -> If expr Then closed_expr . Else seq_expr [ SEMI End ]
##
## The known suffix of the stack is as follows:
## If expr Then closed_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 329, spurious reduction of production call_expr_level -> core_expr
## In state 338, spurious reduction of production unary_expr_level -> call_expr_level
## In state 319, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 348, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 354, spurious reduction of production add_expr_level -> mult_expr_level
## In state 395, spurious reduction of production cons_expr_level -> add_expr_level
## In state 382, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 417, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 424, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 431, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 655, spurious reduction of production base_expr(closed_expr) -> disj_expr_level
## In state 659, spurious reduction of production base_if_then_else__open(closed_expr) -> base_expr(closed_expr)
## In state 658, spurious reduction of production closed_expr -> base_if_then_else__open(closed_expr)
##
interactive_expr: Match Verbatim With WILD ARROW If Verbatim Then Verbatim WILD
##
## Ends in an error in state: 797.
##
## if_then_else(base_cond) -> If expr Then closed_expr . Else base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## If expr Then closed_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 329, spurious reduction of production call_expr_level -> core_expr
## In state 338, spurious reduction of production unary_expr_level -> call_expr_level
## In state 319, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 348, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 354, spurious reduction of production add_expr_level -> mult_expr_level
## In state 395, spurious reduction of production cons_expr_level -> add_expr_level
## In state 382, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 417, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 424, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 431, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 655, spurious reduction of production base_expr(closed_expr) -> disj_expr_level
## In state 659, spurious reduction of production base_if_then_else__open(closed_expr) -> base_expr(closed_expr)
## In state 658, spurious reduction of production closed_expr -> base_if_then_else__open(closed_expr)
##

Ill-formed complete conditional expression.
At this point, if the expression of the branch 'then' is complete, the
keyword 'else' is expected, followed by an expression.

interactive_expr: Begin If Verbatim Then If Verbatim With
##
## Ends in an error in state: 865.
##
## if_then_else(closed_expr) -> If expr . Then closed_expr Else closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## If expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 329, spurious reduction of production call_expr_level -> core_expr
## In state 338, spurious reduction of production unary_expr_level -> call_expr_level
## In state 319, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 348, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 354, spurious reduction of production add_expr_level -> mult_expr_level
## In state 395, spurious reduction of production cons_expr_level -> add_expr_level
## In state 382, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 417, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 424, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 431, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 380, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 437, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 438, spurious reduction of production expr -> base_cond__open(expr)
##
interactive_expr: Begin If Verbatim With
##
## Ends in an error in state: 858.
##
## if_then_else(seq_expr) -> If expr . Then closed_expr Else seq_expr [ SEMI End ]
##
## The known suffix of the stack is as follows:
## If expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 329, spurious reduction of production call_expr_level -> core_expr
## In state 338, spurious reduction of production unary_expr_level -> call_expr_level
## In state 319, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 348, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 354, spurious reduction of production add_expr_level -> mult_expr_level
## In state 395, spurious reduction of production cons_expr_level -> add_expr_level
## In state 382, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 417, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 424, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 431, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 380, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 437, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 438, spurious reduction of production expr -> base_cond__open(expr)
##
interactive_expr: Begin Match Verbatim With WILD ARROW If Verbatim With
##
## Ends in an error in state: 603.
##
## if_then(base_cond) -> If expr . Then base_cond [ VBAR ]
## if_then_else(base_cond) -> If expr . Then closed_expr Else base_cond [ VBAR ]
## if_then_else(seq_expr) -> If expr . Then closed_expr Else seq_expr [ SEMI End ]
##
## The known suffix of the stack is as follows:
## If expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 329, spurious reduction of production call_expr_level -> core_expr
## In state 338, spurious reduction of production unary_expr_level -> call_expr_level
## In state 319, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 348, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 354, spurious reduction of production add_expr_level -> mult_expr_level
## In state 395, spurious reduction of production cons_expr_level -> add_expr_level
## In state 382, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 417, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 424, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 431, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 380, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 437, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 438, spurious reduction of production expr -> base_cond__open(expr)
##
interactive_expr: If Verbatim Then If Verbatim With
##
## Ends in an error in state: 1007.
##
## if_then(expr) -> If expr . Then expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## if_then_else(closed_expr) -> If expr . Then closed_expr Else closed_expr [ Else ]
## if_then_else(expr) -> If expr . Then closed_expr Else expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## If expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 329, spurious reduction of production call_expr_level -> core_expr
## In state 338, spurious reduction of production unary_expr_level -> call_expr_level
## In state 319, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 348, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 354, spurious reduction of production add_expr_level -> mult_expr_level
## In state 395, spurious reduction of production cons_expr_level -> add_expr_level
## In state 382, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 417, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 424, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 431, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 380, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 437, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 438, spurious reduction of production expr -> base_cond__open(expr)
##
interactive_expr: If Verbatim Then Match Verbatim With WILD ARROW If Verbatim With
##
## Ends in an error in state: 616.
##
## if_then(base_cond) -> If expr . Then base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## if_then_else(base_cond) -> If expr . Then closed_expr Else base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## if_then_else(base_if_then_else) -> If expr . Then closed_expr Else base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## If expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 329, spurious reduction of production call_expr_level -> core_expr
## In state 338, spurious reduction of production unary_expr_level -> call_expr_level
## In state 319, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 348, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 354, spurious reduction of production add_expr_level -> mult_expr_level
## In state 395, spurious reduction of production cons_expr_level -> add_expr_level
## In state 382, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 417, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 424, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 431, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 380, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 437, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 438, spurious reduction of production expr -> base_cond__open(expr)
##
interactive_expr: If Verbatim With
##
## Ends in an error in state: 995.
##
## if_then(expr) -> If expr . Then expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## if_then_else(expr) -> If expr . Then closed_expr Else expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## If expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 329, spurious reduction of production call_expr_level -> core_expr
## In state 338, spurious reduction of production unary_expr_level -> call_expr_level
## In state 319, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 348, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 354, spurious reduction of production add_expr_level -> mult_expr_level
## In state 395, spurious reduction of production cons_expr_level -> add_expr_level
## In state 382, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 417, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 424, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 431, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 380, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 437, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 438, spurious reduction of production expr -> base_cond__open(expr)
##
interactive_expr: Match Verbatim With WILD ARROW If Verbatim Then If Verbatim With
##
## Ends in an error in state: 623.
##
## if_then(base_cond) -> If expr . Then base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## if_then_else(base_cond) -> If expr . Then closed_expr Else base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## if_then_else(closed_expr) -> If expr . Then closed_expr Else closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## If expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 329, spurious reduction of production call_expr_level -> core_expr
## In state 338, spurious reduction of production unary_expr_level -> call_expr_level
## In state 319, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 348, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 354, spurious reduction of production add_expr_level -> mult_expr_level
## In state 395, spurious reduction of production cons_expr_level -> add_expr_level
## In state 382, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 417, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 424, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 431, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 380, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 437, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 438, spurious reduction of production expr -> base_cond__open(expr)
##
interactive_expr: Match Verbatim With WILD ARROW If Verbatim With
##
## Ends in an error in state: 795.
##
## if_then(base_cond) -> If expr . Then base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## if_then_else(base_cond) -> If expr . Then closed_expr Else base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## If expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 329, spurious reduction of production call_expr_level -> core_expr
## In state 338, spurious reduction of production unary_expr_level -> call_expr_level
## In state 319, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 348, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 354, spurious reduction of production add_expr_level -> mult_expr_level
## In state 395, spurious reduction of production cons_expr_level -> add_expr_level
## In state 382, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 417, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 424, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 431, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 380, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 437, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 438, spurious reduction of production expr -> base_cond__open(expr)
##

Ill-formed conditional expression.
At this point, if the condition is complete, the keyword 'then' is
expected, followed by an expression.

interactive_expr: Match UIdent With UIdent ARROW If UIdent Then Attr Let Rec Ident EQ UIdent With
##
## Ends in an error in state: 635.
##
## let_in_expr(base_cond) -> nseq(Attr) Let Rec let_binding . In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## let_in_expr(closed_expr) -> nseq(Attr) Let Rec let_binding . In closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let Rec let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 124, spurious reduction of production constant_constr_expr -> UIdent
## In state 337, spurious reduction of production constr_expr -> constant_constr_expr
## In state 336, spurious reduction of production call_expr_level -> constr_expr
## In state 338, spurious reduction of production unary_expr_level -> call_expr_level
## In state 319, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 348, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 354, spurious reduction of production add_expr_level -> mult_expr_level
## In state 395, spurious reduction of production cons_expr_level -> add_expr_level
## In state 382, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 417, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 424, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 431, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 380, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 437, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 438, spurious reduction of production expr -> base_cond__open(expr)
## In state 1085, spurious reduction of production let_binding -> var_pattern EQ expr
##
interactive_expr: Match UIdent With UIdent ARROW If UIdent Then Attr Let Ident EQ UIdent With
##
## Ends in an error in state: 667.
##
## let_in_expr(base_cond) -> nseq(Attr) Let let_binding . In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## let_in_expr(closed_expr) -> nseq(Attr) Let let_binding . In closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 124, spurious reduction of production constant_constr_expr -> UIdent
## In state 337, spurious reduction of production constr_expr -> constant_constr_expr
## In state 336, spurious reduction of production call_expr_level -> constr_expr
## In state 338, spurious reduction of production unary_expr_level -> call_expr_level
## In state 319, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 348, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 354, spurious reduction of production add_expr_level -> mult_expr_level
## In state 395, spurious reduction of production cons_expr_level -> add_expr_level
## In state 382, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 417, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 424, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 431, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 380, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 437, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 438, spurious reduction of production expr -> base_cond__open(expr)
## In state 1085, spurious reduction of production let_binding -> var_pattern EQ expr
##
interactive_expr: Begin If UIdent Then Attr Let Ident EQ UIdent With
##
## Ends in an error in state: 884.
##
## let_in_expr(closed_expr) -> nseq(Attr) Let let_binding . In closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 124, spurious reduction of production constant_constr_expr -> UIdent
## In state 337, spurious reduction of production constr_expr -> constant_constr_expr
## In state 336, spurious reduction of production call_expr_level -> constr_expr
## In state 338, spurious reduction of production unary_expr_level -> call_expr_level
## In state 319, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 348, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 354, spurious reduction of production add_expr_level -> mult_expr_level
## In state 395, spurious reduction of production cons_expr_level -> add_expr_level
## In state 382, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 417, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 424, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 431, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 380, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 437, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 438, spurious reduction of production expr -> base_cond__open(expr)
## In state 1085, spurious reduction of production let_binding -> var_pattern EQ expr
##
interactive_expr: Begin Attr Let Rec Ident EQ UIdent With
##
## Ends in an error in state: 917.
##
## let_in_sequence -> nseq(Attr) Let Rec let_binding . In series [ End ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let Rec let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 124, spurious reduction of production constant_constr_expr -> UIdent
## In state 337, spurious reduction of production constr_expr -> constant_constr_expr
## In state 336, spurious reduction of production call_expr_level -> constr_expr
## In state 338, spurious reduction of production unary_expr_level -> call_expr_level
## In state 319, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 348, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 354, spurious reduction of production add_expr_level -> mult_expr_level
## In state 395, spurious reduction of production cons_expr_level -> add_expr_level
## In state 382, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 417, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 424, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 431, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 380, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 437, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 438, spurious reduction of production expr -> base_cond__open(expr)
## In state 1085, spurious reduction of production let_binding -> var_pattern EQ expr
##
interactive_expr: Begin Attr Let Ident EQ UIdent With
##
## Ends in an error in state: 924.
##
## let_in_sequence -> nseq(Attr) Let let_binding . In series [ End ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 124, spurious reduction of production constant_constr_expr -> UIdent
## In state 337, spurious reduction of production constr_expr -> constant_constr_expr
## In state 336, spurious reduction of production call_expr_level -> constr_expr
## In state 338, spurious reduction of production unary_expr_level -> call_expr_level
## In state 319, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 348, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 354, spurious reduction of production add_expr_level -> mult_expr_level
## In state 395, spurious reduction of production cons_expr_level -> add_expr_level
## In state 382, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 417, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 424, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 431, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 380, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 437, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 438, spurious reduction of production expr -> base_cond__open(expr)
## In state 1085, spurious reduction of production let_binding -> var_pattern EQ expr
##
interactive_expr: Begin Match UIdent With UIdent ARROW Attr Let Ident EQ UIdent With
##
## Ends in an error in state: 956.
##
## let_in_expr(base_cond) -> nseq(Attr) Let let_binding . In base_cond [ VBAR ]
## let_in_sequence -> nseq(Attr) Let let_binding . In series [ End ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 124, spurious reduction of production constant_constr_expr -> UIdent
## In state 337, spurious reduction of production constr_expr -> constant_constr_expr
## In state 336, spurious reduction of production call_expr_level -> constr_expr
## In state 338, spurious reduction of production unary_expr_level -> call_expr_level
## In state 319, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 348, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 354, spurious reduction of production add_expr_level -> mult_expr_level
## In state 395, spurious reduction of production cons_expr_level -> add_expr_level
## In state 382, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 417, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 424, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 431, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 380, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 437, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 438, spurious reduction of production expr -> base_cond__open(expr)
## In state 1085, spurious reduction of production let_binding -> var_pattern EQ expr
##
interactive_expr: Match UIdent With UIdent ARROW Attr Let Rec Ident EQ UIdent With
##
## Ends in an error in state: 809.
##
## let_in_expr(base_cond) -> nseq(Attr) Let Rec let_binding . In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let Rec let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 124, spurious reduction of production constant_constr_expr -> UIdent
## In state 337, spurious reduction of production constr_expr -> constant_constr_expr
## In state 336, spurious reduction of production call_expr_level -> constr_expr
## In state 338, spurious reduction of production unary_expr_level -> call_expr_level
## In state 319, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 348, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 354, spurious reduction of production add_expr_level -> mult_expr_level
## In state 395, spurious reduction of production cons_expr_level -> add_expr_level
## In state 382, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 417, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 424, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 431, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 380, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 437, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 438, spurious reduction of production expr -> base_cond__open(expr)
## In state 1085, spurious reduction of production let_binding -> var_pattern EQ expr
##
interactive_expr: If UIdent Then Match UIdent With UIdent ARROW Attr Let Rec Ident EQ UIdent With
##
## Ends in an error in state: 728.
##
## let_in_expr(base_cond) -> nseq(Attr) Let Rec let_binding . In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## let_in_expr(base_if_then_else) -> nseq(Attr) Let Rec let_binding . In base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let Rec let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 124, spurious reduction of production constant_constr_expr -> UIdent
## In state 337, spurious reduction of production constr_expr -> constant_constr_expr
## In state 336, spurious reduction of production call_expr_level -> constr_expr
## In state 338, spurious reduction of production unary_expr_level -> call_expr_level
## In state 319, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 348, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 354, spurious reduction of production add_expr_level -> mult_expr_level
## In state 395, spurious reduction of production cons_expr_level -> add_expr_level
## In state 382, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 417, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 424, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 431, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 380, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 437, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 438, spurious reduction of production expr -> base_cond__open(expr)
## In state 1085, spurious reduction of production let_binding -> var_pattern EQ expr
##
interactive_expr: If UIdent Then Match UIdent With UIdent ARROW Attr Let Ident EQ UIdent With
##
## Ends in an error in state: 746.
##
## let_in_expr(base_cond) -> nseq(Attr) Let let_binding . In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## let_in_expr(base_if_then_else) -> nseq(Attr) Let let_binding . In base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 124, spurious reduction of production constant_constr_expr -> UIdent
## In state 337, spurious reduction of production constr_expr -> constant_constr_expr
## In state 336, spurious reduction of production call_expr_level -> constr_expr
## In state 338, spurious reduction of production unary_expr_level -> call_expr_level
## In state 319, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 348, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 354, spurious reduction of production add_expr_level -> mult_expr_level
## In state 395, spurious reduction of production cons_expr_level -> add_expr_level
## In state 382, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 417, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 424, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 431, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 380, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 437, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 438, spurious reduction of production expr -> base_cond__open(expr)
## In state 1085, spurious reduction of production let_binding -> var_pattern EQ expr
##
interactive_expr: Match UIdent With UIdent ARROW Attr Let Ident EQ UIdent With
##
## Ends in an error in state: 816.
##
## let_in_expr(base_cond) -> nseq(Attr) Let let_binding . In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 124, spurious reduction of production constant_constr_expr -> UIdent
## In state 337, spurious reduction of production constr_expr -> constant_constr_expr
## In state 336, spurious reduction of production call_expr_level -> constr_expr
## In state 338, spurious reduction of production unary_expr_level -> call_expr_level
## In state 319, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 348, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 354, spurious reduction of production add_expr_level -> mult_expr_level
## In state 395, spurious reduction of production cons_expr_level -> add_expr_level
## In state 382, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 417, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 424, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 431, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 380, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 437, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 438, spurious reduction of production expr -> base_cond__open(expr)
## In state 1085, spurious reduction of production let_binding -> var_pattern EQ expr
##
interactive_expr: Begin Match UIdent With UIdent ARROW Attr Let Rec Ident EQ UIdent With
##
## Ends in an error in state: 848.
##
## let_in_expr(base_cond) -> nseq(Attr) Let Rec let_binding . In base_cond [ VBAR ]
## let_in_sequence -> nseq(Attr) Let Rec let_binding . In series [ End ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let Rec let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 124, spurious reduction of production constant_constr_expr -> UIdent
## In state 337, spurious reduction of production constr_expr -> constant_constr_expr
## In state 336, spurious reduction of production call_expr_level -> constr_expr
## In state 338, spurious reduction of production unary_expr_level -> call_expr_level
## In state 319, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 348, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 354, spurious reduction of production add_expr_level -> mult_expr_level
## In state 395, spurious reduction of production cons_expr_level -> add_expr_level
## In state 382, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 417, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 424, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 431, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 380, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 437, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 438, spurious reduction of production expr -> base_cond__open(expr)
## In state 1085, spurious reduction of production let_binding -> var_pattern EQ expr
##
interactive_expr: Begin If UIdent Then Attr Let Rec Ident EQ UIdent With
##
## Ends in an error in state: 877.
##
## let_in_expr(closed_expr) -> nseq(Attr) Let Rec let_binding . In closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let Rec let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 124, spurious reduction of production constant_constr_expr -> UIdent
## In state 337, spurious reduction of production constr_expr -> constant_constr_expr
## In state 336, spurious reduction of production call_expr_level -> constr_expr
## In state 338, spurious reduction of production unary_expr_level -> call_expr_level
## In state 319, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 348, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 354, spurious reduction of production add_expr_level -> mult_expr_level
## In state 395, spurious reduction of production cons_expr_level -> add_expr_level
## In state 382, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 417, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 424, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 431, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 380, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 437, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 438, spurious reduction of production expr -> base_cond__open(expr)
## In state 1085, spurious reduction of production let_binding -> var_pattern EQ expr
##
interactive_expr: Begin If Verbatim Then Let Rec WILD EQ Bytes With
##
## Ends in an error in state: 862.
##
## let_in_expr(closed_expr) -> Let Rec let_binding . In closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Let Rec let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 329, spurious reduction of production call_expr_level -> core_expr
## In state 338, spurious reduction of production unary_expr_level -> call_expr_level
## In state 319, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 348, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 354, spurious reduction of production add_expr_level -> mult_expr_level
## In state 395, spurious reduction of production cons_expr_level -> add_expr_level
## In state 382, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 417, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 424, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 431, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 380, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 437, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 438, spurious reduction of production expr -> base_cond__open(expr)
## In state 1142, spurious reduction of production let_binding -> WILD EQ expr
##
interactive_expr: Begin Let Rec WILD EQ Bytes With
##
## Ends in an error in state: 855.
##
## let_in_sequence -> Let Rec let_binding . In series [ End ]
##
## The known suffix of the stack is as follows:
## Let Rec let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 329, spurious reduction of production call_expr_level -> core_expr
## In state 338, spurious reduction of production unary_expr_level -> call_expr_level
## In state 319, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 348, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 354, spurious reduction of production add_expr_level -> mult_expr_level
## In state 395, spurious reduction of production cons_expr_level -> add_expr_level
## In state 382, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 417, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 424, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 431, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 380, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 437, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 438, spurious reduction of production expr -> base_cond__open(expr)
## In state 1142, spurious reduction of production let_binding -> WILD EQ expr
##
interactive_expr: Begin Match Verbatim With WILD ARROW Let Rec WILD EQ Bytes With
##
## Ends in an error in state: 600.
##
## let_in_expr(base_cond) -> Let Rec let_binding . In base_cond [ VBAR ]
## let_in_sequence -> Let Rec let_binding . In series [ End ]
##
## The known suffix of the stack is as follows:
## Let Rec let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 329, spurious reduction of production call_expr_level -> core_expr
## In state 338, spurious reduction of production unary_expr_level -> call_expr_level
## In state 319, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 348, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 354, spurious reduction of production add_expr_level -> mult_expr_level
## In state 395, spurious reduction of production cons_expr_level -> add_expr_level
## In state 382, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 417, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 424, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 431, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 380, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 437, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 438, spurious reduction of production expr -> base_cond__open(expr)
## In state 1142, spurious reduction of production let_binding -> WILD EQ expr
##
interactive_expr: If Verbatim Then Let Rec WILD EQ Bytes With
##
## Ends in an error in state: 1004.
##
## let_in_expr(closed_expr) -> Let Rec let_binding . In closed_expr [ Else ]
## let_in_expr(expr) -> Let Rec let_binding . In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let Rec let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 329, spurious reduction of production call_expr_level -> core_expr
## In state 338, spurious reduction of production unary_expr_level -> call_expr_level
## In state 319, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 348, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 354, spurious reduction of production add_expr_level -> mult_expr_level
## In state 395, spurious reduction of production cons_expr_level -> add_expr_level
## In state 382, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 417, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 424, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 431, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 380, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 437, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 438, spurious reduction of production expr -> base_cond__open(expr)
## In state 1142, spurious reduction of production let_binding -> WILD EQ expr
##
interactive_expr: If Verbatim Then Match Verbatim With WILD ARROW Let Rec WILD EQ Bytes With
##
## Ends in an error in state: 613.
##
## let_in_expr(base_cond) -> Let Rec let_binding . In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## let_in_expr(base_if_then_else) -> Let Rec let_binding . In base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## Let Rec let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 329, spurious reduction of production call_expr_level -> core_expr
## In state 338, spurious reduction of production unary_expr_level -> call_expr_level
## In state 319, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 348, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 354, spurious reduction of production add_expr_level -> mult_expr_level
## In state 395, spurious reduction of production cons_expr_level -> add_expr_level
## In state 382, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 417, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 424, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 431, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 380, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 437, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 438, spurious reduction of production expr -> base_cond__open(expr)
## In state 1142, spurious reduction of production let_binding -> WILD EQ expr
##
interactive_expr: Let Rec WILD EQ Bytes With
##
## Ends in an error in state: 1108.
##
## let_in_expr(expr) -> Let Rec let_binding . In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let Rec let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 329, spurious reduction of production call_expr_level -> core_expr
## In state 338, spurious reduction of production unary_expr_level -> call_expr_level
## In state 319, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 348, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 354, spurious reduction of production add_expr_level -> mult_expr_level
## In state 395, spurious reduction of production cons_expr_level -> add_expr_level
## In state 382, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 417, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 424, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 431, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 380, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 437, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 438, spurious reduction of production expr -> base_cond__open(expr)
## In state 1142, spurious reduction of production let_binding -> WILD EQ expr
##
interactive_expr: Match Verbatim With WILD ARROW If Verbatim Then Let Rec WILD EQ Bytes With
##
## Ends in an error in state: 620.
##
## let_in_expr(base_cond) -> Let Rec let_binding . In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## let_in_expr(closed_expr) -> Let Rec let_binding . In closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Let Rec let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 329, spurious reduction of production call_expr_level -> core_expr
## In state 338, spurious reduction of production unary_expr_level -> call_expr_level
## In state 319, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 348, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 354, spurious reduction of production add_expr_level -> mult_expr_level
## In state 395, spurious reduction of production cons_expr_level -> add_expr_level
## In state 382, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 417, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 424, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 431, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 380, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 437, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 438, spurious reduction of production expr -> base_cond__open(expr)
## In state 1142, spurious reduction of production let_binding -> WILD EQ expr
##
interactive_expr: Match Verbatim With WILD ARROW Let Rec WILD EQ Bytes With
##
## Ends in an error in state: 792.
##
## let_in_expr(base_cond) -> Let Rec let_binding . In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let Rec let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 329, spurious reduction of production call_expr_level -> core_expr
## In state 338, spurious reduction of production unary_expr_level -> call_expr_level
## In state 319, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 348, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 354, spurious reduction of production add_expr_level -> mult_expr_level
## In state 395, spurious reduction of production cons_expr_level -> add_expr_level
## In state 382, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 417, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 424, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 431, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 380, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 437, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 438, spurious reduction of production expr -> base_cond__open(expr)
## In state 1142, spurious reduction of production let_binding -> WILD EQ expr
##
interactive_expr: Begin If Verbatim Then Let WILD EQ Bytes With
##
## Ends in an error in state: 904.
##
## let_in_expr(closed_expr) -> Let let_binding . In closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Let let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 329, spurious reduction of production call_expr_level -> core_expr
## In state 338, spurious reduction of production unary_expr_level -> call_expr_level
## In state 319, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 348, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 354, spurious reduction of production add_expr_level -> mult_expr_level
## In state 395, spurious reduction of production cons_expr_level -> add_expr_level
## In state 382, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 417, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 424, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 431, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 380, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 437, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 438, spurious reduction of production expr -> base_cond__open(expr)
## In state 1142, spurious reduction of production let_binding -> WILD EQ expr
##
interactive_expr: Begin Let WILD EQ Bytes With
##
## Ends in an error in state: 952.
##
## let_in_sequence -> Let let_binding . In series [ End ]
##
## The known suffix of the stack is as follows:
## Let let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 329, spurious reduction of production call_expr_level -> core_expr
## In state 338, spurious reduction of production unary_expr_level -> call_expr_level
## In state 319, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 348, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 354, spurious reduction of production add_expr_level -> mult_expr_level
## In state 395, spurious reduction of production cons_expr_level -> add_expr_level
## In state 382, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 417, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 424, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 431, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 380, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 437, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 438, spurious reduction of production expr -> base_cond__open(expr)
## In state 1142, spurious reduction of production let_binding -> WILD EQ expr
##
interactive_expr: Begin Match Verbatim With WILD ARROW Let WILD EQ Bytes With
##
## Ends in an error in state: 974.
##
## let_in_expr(base_cond) -> Let let_binding . In base_cond [ VBAR ]
## let_in_sequence -> Let let_binding . In series [ End ]
##
## The known suffix of the stack is as follows:
## Let let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 329, spurious reduction of production call_expr_level -> core_expr
## In state 338, spurious reduction of production unary_expr_level -> call_expr_level
## In state 319, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 348, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 354, spurious reduction of production add_expr_level -> mult_expr_level
## In state 395, spurious reduction of production cons_expr_level -> add_expr_level
## In state 382, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 417, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 424, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 431, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 380, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 437, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 438, spurious reduction of production expr -> base_cond__open(expr)
## In state 1142, spurious reduction of production let_binding -> WILD EQ expr
##
interactive_expr: If Verbatim Then Match Verbatim With WILD ARROW Let WILD EQ Bytes With
##
## Ends in an error in state: 776.
##
## let_in_expr(base_cond) -> Let let_binding . In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## let_in_expr(base_if_then_else) -> Let let_binding . In base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## Let let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 329, spurious reduction of production call_expr_level -> core_expr
## In state 338, spurious reduction of production unary_expr_level -> call_expr_level
## In state 319, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 348, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 354, spurious reduction of production add_expr_level -> mult_expr_level
## In state 395, spurious reduction of production cons_expr_level -> add_expr_level
## In state 382, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 417, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 424, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 431, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 380, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 437, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 438, spurious reduction of production expr -> base_cond__open(expr)
## In state 1142, spurious reduction of production let_binding -> WILD EQ expr
##
interactive_expr: If Verbatim Then Let WILD EQ Bytes With
##
## Ends in an error in state: 1049.
##
## let_in_expr(closed_expr) -> Let let_binding . In closed_expr [ Else ]
## let_in_expr(expr) -> Let let_binding . In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 329, spurious reduction of production call_expr_level -> core_expr
## In state 338, spurious reduction of production unary_expr_level -> call_expr_level
## In state 319, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 348, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 354, spurious reduction of production add_expr_level -> mult_expr_level
## In state 395, spurious reduction of production cons_expr_level -> add_expr_level
## In state 382, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 417, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 424, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 431, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 380, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 437, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 438, spurious reduction of production expr -> base_cond__open(expr)
## In state 1142, spurious reduction of production let_binding -> WILD EQ expr
##
interactive_expr: Let WILD EQ Bytes With
##
## Ends in an error in state: 1110.
##
## let_in_expr(expr) -> Let let_binding . In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 329, spurious reduction of production call_expr_level -> core_expr
## In state 338, spurious reduction of production unary_expr_level -> call_expr_level
## In state 319, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 348, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 354, spurious reduction of production add_expr_level -> mult_expr_level
## In state 395, spurious reduction of production cons_expr_level -> add_expr_level
## In state 382, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 417, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 424, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 431, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 380, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 437, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 438, spurious reduction of production expr -> base_cond__open(expr)
## In state 1142, spurious reduction of production let_binding -> WILD EQ expr
##
interactive_expr: Match Verbatim With WILD ARROW If Verbatim Then Let WILD EQ Bytes With
##
## Ends in an error in state: 712.
##
## let_in_expr(base_cond) -> Let let_binding . In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## let_in_expr(closed_expr) -> Let let_binding . In closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Let let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 329, spurious reduction of production call_expr_level -> core_expr
## In state 338, spurious reduction of production unary_expr_level -> call_expr_level
## In state 319, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 348, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 354, spurious reduction of production add_expr_level -> mult_expr_level
## In state 395, spurious reduction of production cons_expr_level -> add_expr_level
## In state 382, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 417, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 424, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 431, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 380, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 437, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 438, spurious reduction of production expr -> base_cond__open(expr)
## In state 1142, spurious reduction of production let_binding -> WILD EQ expr
##
interactive_expr: Match Verbatim With WILD ARROW Let WILD EQ Bytes With
##
## Ends in an error in state: 834.
##
## let_in_expr(base_cond) -> Let let_binding . In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 329, spurious reduction of production call_expr_level -> core_expr
## In state 338, spurious reduction of production unary_expr_level -> call_expr_level
## In state 319, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 348, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 354, spurious reduction of production add_expr_level -> mult_expr_level
## In state 395, spurious reduction of production cons_expr_level -> add_expr_level
## In state 382, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 417, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 424, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 431, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 380, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 437, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 438, spurious reduction of production expr -> base_cond__open(expr)
## In state 1142, spurious reduction of production let_binding -> WILD EQ expr
##
interactive_expr: Attr Let Ident EQ UIdent With
##
## Ends in an error in state: 513.
##
## let_in_expr(expr) -> nseq(Attr) Let let_binding . In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 124, spurious reduction of production constant_constr_expr -> UIdent
## In state 337, spurious reduction of production constr_expr -> constant_constr_expr
## In state 336, spurious reduction of production call_expr_level -> constr_expr
## In state 338, spurious reduction of production unary_expr_level -> call_expr_level
## In state 319, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 348, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 354, spurious reduction of production add_expr_level -> mult_expr_level
## In state 395, spurious reduction of production cons_expr_level -> add_expr_level
## In state 382, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 417, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 424, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 431, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 380, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 437, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 438, spurious reduction of production expr -> base_cond__open(expr)
## In state 1085, spurious reduction of production let_binding -> var_pattern EQ expr
##
interactive_expr: If UIdent Then Attr Let Rec Ident EQ UIdent With
##
## Ends in an error in state: 1019.
##
## let_in_expr(closed_expr) -> nseq(Attr) Let Rec let_binding . In closed_expr [ Else ]
## let_in_expr(expr) -> nseq(Attr) Let Rec let_binding . In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let Rec let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 124, spurious reduction of production constant_constr_expr -> UIdent
## In state 337, spurious reduction of production constr_expr -> constant_constr_expr
## In state 336, spurious reduction of production call_expr_level -> constr_expr
## In state 338, spurious reduction of production unary_expr_level -> call_expr_level
## In state 319, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 348, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 354, spurious reduction of production add_expr_level -> mult_expr_level
## In state 395, spurious reduction of production cons_expr_level -> add_expr_level
## In state 382, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 417, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 424, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 431, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 380, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 437, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 438, spurious reduction of production expr -> base_cond__open(expr)
## In state 1085, spurious reduction of production let_binding -> var_pattern EQ expr
##
interactive_expr: If UIdent Then Attr Let Ident EQ UIdent With
##
## Ends in an error in state: 1026.
##
## let_in_expr(closed_expr) -> nseq(Attr) Let let_binding . In closed_expr [ Else ]
## let_in_expr(expr) -> nseq(Attr) Let let_binding . In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 124, spurious reduction of production constant_constr_expr -> UIdent
## In state 337, spurious reduction of production constr_expr -> constant_constr_expr
## In state 336, spurious reduction of production call_expr_level -> constr_expr
## In state 338, spurious reduction of production unary_expr_level -> call_expr_level
## In state 319, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 348, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 354, spurious reduction of production add_expr_level -> mult_expr_level
## In state 395, spurious reduction of production cons_expr_level -> add_expr_level
## In state 382, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 417, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 424, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 431, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 380, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 437, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 438, spurious reduction of production expr -> base_cond__open(expr)
## In state 1085, spurious reduction of production let_binding -> var_pattern EQ expr
##
interactive_expr: Attr Let Rec Ident EQ UIdent With
##
## Ends in an error in state: 498.
##
## let_in_expr(expr) -> nseq(Attr) Let Rec let_binding . In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let Rec let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 124, spurious reduction of production constant_constr_expr -> UIdent
## In state 337, spurious reduction of production constr_expr -> constant_constr_expr
## In state 336, spurious reduction of production call_expr_level -> constr_expr
## In state 338, spurious reduction of production unary_expr_level -> call_expr_level
## In state 319, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 348, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 354, spurious reduction of production add_expr_level -> mult_expr_level
## In state 395, spurious reduction of production cons_expr_level -> add_expr_level
## In state 382, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 417, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 424, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 431, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 380, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 437, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 438, spurious reduction of production expr -> base_cond__open(expr)
## In state 1085, spurious reduction of production let_binding -> var_pattern EQ expr
##

Ill-formed local value declaration.
At this point, if the expression of the left-hand side is complete,
the keyword 'in' is expected, followed by an expression.

interactive_expr: Begin Match UIdent With UIdent ARROW Let Rec With
##
## Ends in an error in state: 599.
##
## let_in_expr(base_cond) -> Let Rec . let_binding In base_cond [ VBAR ]
## let_in_sequence -> Let Rec . let_binding In series [ End ]
##
## The known suffix of the stack is as follows:
## Let Rec
##
interactive_expr: If UIdent Then Attr Let Rec With
##
## Ends in an error in state: 1018.
##
## let_in_expr(closed_expr) -> nseq(Attr) Let Rec . let_binding In closed_expr [ Else ]
## let_in_expr(expr) -> nseq(Attr) Let Rec . let_binding In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let Rec
##
contract: Attr Let Rec With
##
## Ends in an error in state: 1160.
##
## let_declaration -> nseq(Attr) Let Rec . let_binding [ Type Module Let End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let Rec
##
interactive_expr: If UIdent Then Let Rec With
##
## Ends in an error in state: 1003.
##
## let_in_expr(closed_expr) -> Let Rec . let_binding In closed_expr [ Else ]
## let_in_expr(expr) -> Let Rec . let_binding In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let Rec
##
interactive_expr: Begin Attr Let Rec With
##
## Ends in an error in state: 916.
##
## let_in_sequence -> nseq(Attr) Let Rec . let_binding In series [ End ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let Rec
##
interactive_expr: Begin If UIdent Then Attr Let Rec With
##
## Ends in an error in state: 876.
##
## let_in_expr(closed_expr) -> nseq(Attr) Let Rec . let_binding In closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let Rec
##
interactive_expr: Begin If UIdent Then Let Rec With
##
## Ends in an error in state: 861.
##
## let_in_expr(closed_expr) -> Let Rec . let_binding In closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Let Rec
##
interactive_expr: Begin Let Rec With
##
## Ends in an error in state: 854.
##
## let_in_sequence -> Let Rec . let_binding In series [ End ]
##
## The known suffix of the stack is as follows:
## Let Rec
##
interactive_expr: Begin Match UIdent With UIdent ARROW Attr Let Rec With
##
## Ends in an error in state: 847.
##
## let_in_expr(base_cond) -> nseq(Attr) Let Rec . let_binding In base_cond [ VBAR ]
## let_in_sequence -> nseq(Attr) Let Rec . let_binding In series [ End ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let Rec
##
interactive_expr: Match UIdent With UIdent ARROW Attr Let Rec With
##
## Ends in an error in state: 808.
##
## let_in_expr(base_cond) -> nseq(Attr) Let Rec . let_binding In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let Rec
##
interactive_expr: Match UIdent With UIdent ARROW Let Rec With
##
## Ends in an error in state: 791.
##
## let_in_expr(base_cond) -> Let Rec . let_binding In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let Rec
##
interactive_expr: If UIdent Then Match UIdent With UIdent ARROW Attr Let Rec With
##
## Ends in an error in state: 727.
##
## let_in_expr(base_cond) -> nseq(Attr) Let Rec . let_binding In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## let_in_expr(base_if_then_else) -> nseq(Attr) Let Rec . let_binding In base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let Rec
##
interactive_expr: Match UIdent With UIdent ARROW If UIdent Then Attr Let Rec With
##
## Ends in an error in state: 634.
##
## let_in_expr(base_cond) -> nseq(Attr) Let Rec . let_binding In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## let_in_expr(closed_expr) -> nseq(Attr) Let Rec . let_binding In closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let Rec
##
contract: Let Rec With
##
## Ends in an error in state: 1152.
##
## let_declaration -> Let Rec . let_binding [ Type Module Let End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## Let Rec
##
interactive_expr: Let Rec With
##
## Ends in an error in state: 152.
##
## let_in_expr(expr) -> Let Rec . let_binding In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let Rec
##
interactive_expr: Attr Let Rec With
##
## Ends in an error in state: 351.
##
## let_in_expr(expr) -> nseq(Attr) Let Rec . let_binding In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let Rec
##
interactive_expr: If UIdent Then Match UIdent With UIdent ARROW Let Rec With
##
## Ends in an error in state: 612.
##
## let_in_expr(base_cond) -> Let Rec . let_binding In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## let_in_expr(base_if_then_else) -> Let Rec . let_binding In base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## Let Rec
##
interactive_expr: Match UIdent With UIdent ARROW If UIdent Then Let Rec With
##
## Ends in an error in state: 619.
##
## let_in_expr(base_cond) -> Let Rec . let_binding In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## let_in_expr(closed_expr) -> Let Rec . let_binding In closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Let Rec
##

Ill-formed recursive value declaration.
At this point, a pattern is expected, e.g. an identifier.

contract: Attr Let With
##
## Ends in an error in state: 1159.
##
## let_declaration -> nseq(Attr) Let . let_binding [ Type Module Let End EOF Directive Attr ]
## let_declaration -> nseq(Attr) Let . Rec let_binding [ Type Module Let End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let
##
interactive_expr: If UIdent Then Attr Let With
##
## Ends in an error in state: 1017.
##
## let_in_expr(closed_expr) -> nseq(Attr) Let . let_binding In closed_expr [ Else ]
## let_in_expr(closed_expr) -> nseq(Attr) Let . Rec let_binding In closed_expr [ Else ]
## let_in_expr(expr) -> nseq(Attr) Let . let_binding In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## let_in_expr(expr) -> nseq(Attr) Let . Rec let_binding In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let
##
interactive_expr: If UIdent Then Let With
##
## Ends in an error in state: 1002.
##
## let_in_expr(closed_expr) -> Let . let_binding In closed_expr [ Else ]
## let_in_expr(closed_expr) -> Let . Rec let_binding In closed_expr [ Else ]
## let_in_expr(expr) -> Let . let_binding In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## let_in_expr(expr) -> Let . Rec let_binding In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let
##
interactive_expr: Begin Attr Let With
##
## Ends in an error in state: 915.
##
## let_in_sequence -> nseq(Attr) Let . let_binding In series [ End ]
## let_in_sequence -> nseq(Attr) Let . Rec let_binding In series [ End ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let
##
interactive_expr: Begin If UIdent Then Attr Let With
##
## Ends in an error in state: 875.
##
## let_in_expr(closed_expr) -> nseq(Attr) Let . let_binding In closed_expr [ Else ]
## let_in_expr(closed_expr) -> nseq(Attr) Let . Rec let_binding In closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let
##
interactive_expr: Begin If UIdent Then Let With
##
## Ends in an error in state: 860.
##
## let_in_expr(closed_expr) -> Let . let_binding In closed_expr [ Else ]
## let_in_expr(closed_expr) -> Let . Rec let_binding In closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Let
##
interactive_expr: Begin Let With
##
## Ends in an error in state: 853.
##
## let_in_sequence -> Let . let_binding In series [ End ]
## let_in_sequence -> Let . Rec let_binding In series [ End ]
##
## The known suffix of the stack is as follows:
## Let
##
interactive_expr: Begin Match UIdent With UIdent ARROW Attr Let With
##
## Ends in an error in state: 846.
##
## let_in_expr(base_cond) -> nseq(Attr) Let . let_binding In base_cond [ VBAR ]
## let_in_expr(base_cond) -> nseq(Attr) Let . Rec let_binding In base_cond [ VBAR ]
## let_in_sequence -> nseq(Attr) Let . let_binding In series [ End ]
## let_in_sequence -> nseq(Attr) Let . Rec let_binding In series [ End ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let
##
interactive_expr: Match UIdent With UIdent ARROW Attr Let With
##
## Ends in an error in state: 807.
##
## let_in_expr(base_cond) -> nseq(Attr) Let . let_binding In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## let_in_expr(base_cond) -> nseq(Attr) Let . Rec let_binding In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let
##
interactive_expr: If UIdent Then Match UIdent With UIdent ARROW Attr Let With
##
## Ends in an error in state: 726.
##
## let_in_expr(base_cond) -> nseq(Attr) Let . let_binding In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## let_in_expr(base_cond) -> nseq(Attr) Let . Rec let_binding In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## let_in_expr(base_if_then_else) -> nseq(Attr) Let . let_binding In base_if_then_else [ Else ]
## let_in_expr(base_if_then_else) -> nseq(Attr) Let . Rec let_binding In base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let
##
interactive_expr: Match UIdent With UIdent ARROW Let With
##
## Ends in an error in state: 790.
##
## let_in_expr(base_cond) -> Let . let_binding In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## let_in_expr(base_cond) -> Let . Rec let_binding In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let
##
interactive_expr: Match UIdent With UIdent ARROW If UIdent Then Attr Let With
##
## Ends in an error in state: 633.
##
## let_in_expr(base_cond) -> nseq(Attr) Let . let_binding In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## let_in_expr(base_cond) -> nseq(Attr) Let . Rec let_binding In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## let_in_expr(closed_expr) -> nseq(Attr) Let . let_binding In closed_expr [ Else ]
## let_in_expr(closed_expr) -> nseq(Attr) Let . Rec let_binding In closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let
##
interactive_expr: Match UIdent With UIdent ARROW If UIdent Then Let With
##
## Ends in an error in state: 618.
##
## let_in_expr(base_cond) -> Let . let_binding In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## let_in_expr(base_cond) -> Let . Rec let_binding In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## let_in_expr(closed_expr) -> Let . let_binding In closed_expr [ Else ]
## let_in_expr(closed_expr) -> Let . Rec let_binding In closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Let
##
interactive_expr: Let With
##
## Ends in an error in state: 150.
##
## let_in_expr(expr) -> Let . let_binding In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## let_in_expr(expr) -> Let . Rec let_binding In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let
##
contract: Let With
##
## Ends in an error in state: 111.
##
## let_declaration -> Let . let_binding [ Type Module Let End EOF Directive Attr ]
## let_declaration -> Let . Rec let_binding [ Type Module Let End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## Let
##
interactive_expr: Attr Let With
##
## Ends in an error in state: 350.
##
## let_in_expr(expr) -> nseq(Attr) Let . let_binding In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## let_in_expr(expr) -> nseq(Attr) Let . Rec let_binding In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let
##
interactive_expr: Begin Match UIdent With UIdent ARROW Let With
##
## Ends in an error in state: 598.
##
## let_in_expr(base_cond) -> Let . let_binding In base_cond [ VBAR ]
## let_in_expr(base_cond) -> Let . Rec let_binding In base_cond [ VBAR ]
## let_in_sequence -> Let . let_binding In series [ End ]
## let_in_sequence -> Let . Rec let_binding In series [ End ]
##
## The known suffix of the stack is as follows:
## Let
##
interactive_expr: If UIdent Then Match UIdent With UIdent ARROW Let With
##
## Ends in an error in state: 611.
##
## let_in_expr(base_cond) -> Let . let_binding In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## let_in_expr(base_cond) -> Let . Rec let_binding In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## let_in_expr(base_if_then_else) -> Let . let_binding In base_if_then_else [ Else ]
## let_in_expr(base_if_then_else) -> Let . Rec let_binding In base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## Let
##

Ill-formed value declaration.
At this point, one of the following is expected:
  * a pattern, e.g. an identifier;
  * the keyword 'rec' if defining a recursive function.

interactive_expr: Begin If Verbatim Then Match Verbatim Type
##
## Ends in an error in state: 606.
##
## match_expr(base_if_then_else) -> Match expr . With option(VBAR) cases(base_if_then_else) [ Else ]
##
## The known suffix of the stack is as follows:
## Match expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 329, spurious reduction of production call_expr_level -> core_expr
## In state 338, spurious reduction of production unary_expr_level -> call_expr_level
## In state 319, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 348, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 354, spurious reduction of production add_expr_level -> mult_expr_level
## In state 395, spurious reduction of production cons_expr_level -> add_expr_level
## In state 382, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 417, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 424, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 431, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 380, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 437, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 438, spurious reduction of production expr -> base_cond__open(expr)
##
interactive_expr: Begin Match Verbatim Type
##
## Ends in an error in state: 533.
##
## match_expr(last_expr) -> Match expr . With option(VBAR) cases(last_expr) [ End ]
##
## The known suffix of the stack is as follows:
## Match expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 329, spurious reduction of production call_expr_level -> core_expr
## In state 338, spurious reduction of production unary_expr_level -> call_expr_level
## In state 319, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 348, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 354, spurious reduction of production add_expr_level -> mult_expr_level
## In state 395, spurious reduction of production cons_expr_level -> add_expr_level
## In state 382, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 417, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 424, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 431, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 380, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 437, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 438, spurious reduction of production expr -> base_cond__open(expr)
##
interactive_expr: Match Verbatim Type
##
## Ends in an error in state: 1125.
##
## match_expr(base_cond) -> Match expr . With option(VBAR) cases(base_cond) [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Match expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 329, spurious reduction of production call_expr_level -> core_expr
## In state 338, spurious reduction of production unary_expr_level -> call_expr_level
## In state 319, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 348, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 354, spurious reduction of production add_expr_level -> mult_expr_level
## In state 395, spurious reduction of production cons_expr_level -> add_expr_level
## In state 382, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 417, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 424, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 431, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 380, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 437, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 438, spurious reduction of production expr -> base_cond__open(expr)
##
interactive_expr: If Verbatim Then Match Verbatim Type
##
## Ends in an error in state: 998.
##
## match_expr(base_cond) -> Match expr . With option(VBAR) cases(base_cond) [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## match_expr(base_if_then_else) -> Match expr . With option(VBAR) cases(base_if_then_else) [ Else ]
##
## The known suffix of the stack is as follows:
## Match expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 329, spurious reduction of production call_expr_level -> core_expr
## In state 338, spurious reduction of production unary_expr_level -> call_expr_level
## In state 319, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 348, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 354, spurious reduction of production add_expr_level -> mult_expr_level
## In state 395, spurious reduction of production cons_expr_level -> add_expr_level
## In state 382, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 417, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 424, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 431, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 380, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 437, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 438, spurious reduction of production expr -> base_cond__open(expr)
##

Ill-formed pattern matching.
At this point, if the expression is complete, then the keyword 'with'
is expected, followed by matching cases.

interactive_expr: Begin Match Verbatim With WILD ARROW Verbatim With
##
## Ends in an error in state: 978.
##
## cases(base_cond) -> cases(base_cond) . VBAR case_clause(base_cond) [ VBAR ]
## cases(last_expr) -> cases(base_cond) . VBAR case_clause(last_expr) [ End ]
##
## The known suffix of the stack is as follows:
## cases(base_cond)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 329, spurious reduction of production call_expr_level -> core_expr
## In state 338, spurious reduction of production unary_expr_level -> call_expr_level
## In state 319, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 348, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 354, spurious reduction of production add_expr_level -> mult_expr_level
## In state 395, spurious reduction of production cons_expr_level -> add_expr_level
## In state 382, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 417, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 424, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 431, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 838, spurious reduction of production base_expr(base_cond) -> disj_expr_level
## In state 660, spurious reduction of production base_cond__open(base_cond) -> base_expr(base_cond)
## In state 661, spurious reduction of production base_cond -> base_cond__open(base_cond)
## In state 780, spurious reduction of production case_clause(base_cond) -> pattern ARROW base_cond
## In state 787, spurious reduction of production cases(base_cond) -> case_clause(base_cond)
##
interactive_expr: Begin If Verbatim Then Match Verbatim With WILD ARROW Bytes With
##
## Ends in an error in state: 782.
##
## cases(base_cond) -> cases(base_cond) . VBAR case_clause(base_cond) [ VBAR ]
## cases(base_if_then_else) -> cases(base_cond) . VBAR case_clause(base_if_then_else) [ Else ]
##
## The known suffix of the stack is as follows:
## cases(base_cond)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 329, spurious reduction of production call_expr_level -> core_expr
## In state 338, spurious reduction of production unary_expr_level -> call_expr_level
## In state 319, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 348, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 354, spurious reduction of production add_expr_level -> mult_expr_level
## In state 395, spurious reduction of production cons_expr_level -> add_expr_level
## In state 382, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 417, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 424, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 431, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 740, spurious reduction of production base_expr(base_cond) -> disj_expr_level
## In state 660, spurious reduction of production base_cond__open(base_cond) -> base_expr(base_cond)
## In state 661, spurious reduction of production base_cond -> base_cond__open(base_cond)
## In state 780, spurious reduction of production case_clause(base_cond) -> pattern ARROW base_cond
## In state 787, spurious reduction of production cases(base_cond) -> case_clause(base_cond)
##

Ill-formed pattern matching.
At this point, if the case is complete, a vertical bar '|' is
expected, followed by another case starting with a pattern.

interactive_expr: Match Verbatim With WILD CONS Bytes SEMI
##
## Ends in an error in state: 1128.
##
## case_clause(base_cond) -> pattern . ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## pattern
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 573, spurious reduction of production cons_pattern_level -> core_pattern
## In state 575, spurious reduction of production cons_pattern_level -> core_pattern CONS cons_pattern_level
## In state 589, spurious reduction of production pattern -> cons_pattern_level
##
interactive_expr: Begin Match Verbatim With WILD RPAR
##
## Ends in an error in state: 596.
##
## case_clause(base_cond) -> pattern . ARROW base_cond [ VBAR ]
## case_clause(last_expr) -> pattern . ARROW last_expr [ End ]
##
## The known suffix of the stack is as follows:
## pattern
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 573, spurious reduction of production cons_pattern_level -> core_pattern
## In state 589, spurious reduction of production pattern -> cons_pattern_level
##
interactive_expr: If Verbatim Then Match Verbatim With WILD RPAR
##
## Ends in an error in state: 609.
##
## case_clause(base_cond) -> pattern . ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## case_clause(base_if_then_else) -> pattern . ARROW base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## pattern
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 573, spurious reduction of production cons_pattern_level -> core_pattern
## In state 589, spurious reduction of production pattern -> cons_pattern_level
##

Ill-formed pattern matching.
At this point, if the pattern is complete, an arrow '->' is expected,
followed by an expression.

interactive_expr: Begin If Verbatim Then Match Verbatim With With
##
## Ends in an error in state: 607.
##
## match_expr(base_if_then_else) -> Match expr With . option(VBAR) cases(base_if_then_else) [ Else ]
##
## The known suffix of the stack is as follows:
## Match expr With
##
interactive_expr: Begin Match Verbatim With With
##
## Ends in an error in state: 534.
##
## match_expr(last_expr) -> Match expr With . option(VBAR) cases(last_expr) [ End ]
##
## The known suffix of the stack is as follows:
## Match expr With
##
interactive_expr: If Verbatim Then Match Verbatim With With
##
## Ends in an error in state: 999.
##
## match_expr(base_cond) -> Match expr With . option(VBAR) cases(base_cond) [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## match_expr(base_if_then_else) -> Match expr With . option(VBAR) cases(base_if_then_else) [ Else ]
##
## The known suffix of the stack is as follows:
## Match expr With
##
interactive_expr: Match Verbatim With With
##
## Ends in an error in state: 1126.
##
## match_expr(base_cond) -> Match expr With . option(VBAR) cases(base_cond) [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Match expr With
##

Ill-formed pattern matching.
At this point, the first case is expected to start with a pattern or a
vertical bar.

interactive_expr: Begin UIdent SEMI With
##
## Ends in an error in state: 852.
##
## series -> seq_expr SEMI . series [ End ]
##
## The known suffix of the stack is as follows:
## seq_expr SEMI
##

Ill-formed sequence of expressions.
At this point, an expression of type 'unit' is expected.
Note: The last expression in a sequence cannot be terminated by a
semicolon ';'.

interactive_expr: Begin Verbatim With
##
## Ends in an error in state: 851.
##
## last_expr -> seq_expr . [ End ]
## series -> seq_expr . SEMI series [ End ]
##
## The known suffix of the stack is as follows:
## seq_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 329, spurious reduction of production call_expr_level -> core_expr
## In state 338, spurious reduction of production unary_expr_level -> call_expr_level
## In state 319, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 348, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 354, spurious reduction of production add_expr_level -> mult_expr_level
## In state 395, spurious reduction of production cons_expr_level -> add_expr_level
## In state 382, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 417, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 424, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 431, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 923, spurious reduction of production seq_expr -> disj_expr_level
##

Ill-formed sequence of expressions.
At this point, if the expression is complete, one of the following is
expected:
  * a semicolon ';' followed by another expression;
  * the keyword 'end' if the sequence is complete.

interactive_expr: UIdent DOT With
##
## Ends in an error in state: 126.
##
## module_access_e -> UIdent DOT . module_var_e [ With Verbatim VBAR UIdent Type Then TIMES String SLASH SEMI RPAR RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Lxor Lsr Lsl Lor Let Lang Land LT LPAR LE LBRACKET LBRACE Int In Ident GT GE End Else EQ EOF Directive CONS COMMA COLON CARET Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## UIdent DOT
##

Ill-formed selection of a value from a module.
At this point, the qualified name of a value is expected.

contract: Type Ident EQ UIdent DOT With
##
## Ends in an error in state: 20.
##
## module_access_t -> UIdent DOT . module_var_t [ VBAR Type TIMES SEMI RPAR RBRACE Module Let In Ident End EQ EOF Directive COMMA Attr ARROW ]
##
## The known suffix of the stack is as follows:
## UIdent DOT
##

Ill-formed selection of a type in a module.
At this point, the qualified name of a type is expected.

interactive_expr: UIdent DOT Ident DOT With
##
## Ends in an error in state: 130.
##
## projection -> Ident DOT . nsepseq(selection,DOT) [ With Verbatim VBAR UIdent Type Then TIMES String SLASH SEMI RPAR RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Lxor Lsr Lsl Lor Let Lang Land LT LPAR LE LBRACKET LBRACE Int In Ident GT GE End Else EQ EOF Directive CONS COMMA COLON CARET Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## Ident DOT
##
interactive_expr: Ident DOT Int DOT With
##
## Ends in an error in state: 134.
##
## nsepseq(selection,DOT) -> selection DOT . nsepseq(selection,DOT) [ With Verbatim VBAR UIdent Type Then TIMES String SLASH SEMI RPAR RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Lxor Lsr Lsl Lor Let Lang Land LT LPAR LE LBRACKET LBRACE Int In Ident GT GE End Else EQ EOF Directive CONS COMMA COLON CARET Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## selection DOT
##

Ill-formed selection in a record or a tuple.
At this point, one of the following is expected:
  * the name of a record field;
  * the index of a component in a tuple, '0' denoting the first
    component.

interactive_expr: LBRACE Ident DOT Ident Verbatim
##
## Ends in an error in state: 1058.
##
## update_record -> LBRACE path . With sep_or_term_list(field_path_assignment,SEMI) RBRACE [ With Verbatim VBAR UIdent Type Then TIMES String SLASH SEMI RPAR RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Lxor Lsr Lsl Lor Let Lang Land LT LPAR LE LBRACKET LBRACE Int In Ident GT GE End Else EQ EOF Directive CONS COMMA COLON CARET Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## LBRACE path
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 133, spurious reduction of production nsepseq(selection,DOT) -> selection
## In state 136, spurious reduction of production projection -> Ident DOT nsepseq(selection,DOT)
## In state 1057, spurious reduction of production path -> projection
##

Ill-formed record update.
At this point, if the record is fully qualified, then the keyword
'with' is expected, followed by field updates (assignments) separated
by semicolons ';'.

interactive_expr: LBRACE Ident EQ Bytes SEMI Ident EQ Bytes SEMI With
##
## Ends in an error in state: 1083.
##
## nsepseq(field_assignment,SEMI) -> field_assignment SEMI . nsepseq(field_assignment,SEMI) [ RBRACE ]
## seq(__anonymous_0(field_assignment,SEMI)) -> field_assignment SEMI . seq(__anonymous_0(field_assignment,SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_assignment SEMI
##
interactive_expr: LBRACE Ident EQ Bytes SEMI With
##
## Ends in an error in state: 1078.
##
## nsepseq(field_assignment,SEMI) -> field_assignment SEMI . nsepseq(field_assignment,SEMI) [ RBRACE ]
## nseq(__anonymous_0(field_assignment,SEMI)) -> field_assignment SEMI . seq(__anonymous_0(field_assignment,SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_assignment SEMI
##

Ill-formed record expression.
At this point, one of the following is expected:
  * more field assignments separated by semicolons ';';
  * a closing brace '}' if the record is complete.

interactive_expr: LBRACE Ident EQ Bytes SEMI Ident EQ Bytes With
##
## Ends in an error in state: 1082.
##
## nsepseq(field_assignment,SEMI) -> field_assignment . [ RBRACE ]
## nsepseq(field_assignment,SEMI) -> field_assignment . SEMI nsepseq(field_assignment,SEMI) [ RBRACE ]
## seq(__anonymous_0(field_assignment,SEMI)) -> field_assignment . SEMI seq(__anonymous_0(field_assignment,SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_assignment
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 329, spurious reduction of production call_expr_level -> core_expr
## In state 338, spurious reduction of production unary_expr_level -> call_expr_level
## In state 319, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 348, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 354, spurious reduction of production add_expr_level -> mult_expr_level
## In state 395, spurious reduction of production cons_expr_level -> add_expr_level
## In state 382, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 417, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 424, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 431, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 380, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 437, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 438, spurious reduction of production expr -> base_cond__open(expr)
## In state 1054, spurious reduction of production field_assignment -> Ident EQ expr
##
interactive_expr: LBRACE Ident EQ Bytes With
##
## Ends in an error in state: 1077.
##
## nsepseq(field_assignment,SEMI) -> field_assignment . [ RBRACE ]
## nsepseq(field_assignment,SEMI) -> field_assignment . SEMI nsepseq(field_assignment,SEMI) [ RBRACE ]
## nseq(__anonymous_0(field_assignment,SEMI)) -> field_assignment . SEMI seq(__anonymous_0(field_assignment,SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_assignment
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 329, spurious reduction of production call_expr_level -> core_expr
## In state 338, spurious reduction of production unary_expr_level -> call_expr_level
## In state 319, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 348, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 354, spurious reduction of production add_expr_level -> mult_expr_level
## In state 395, spurious reduction of production cons_expr_level -> add_expr_level
## In state 382, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 417, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 424, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 431, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 380, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 437, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 438, spurious reduction of production expr -> base_cond__open(expr)
## In state 1054, spurious reduction of production field_assignment -> Ident EQ expr
##

Ill-formed record expression.
At this point, if the expression assigned to the field is complete,
one of the following is expected:
  * a semicolon ';' followed by another field assignment;
  * a closing brace '}' if the record is complete.

interactive_expr: LBRACE Ident With Ident EQ Bytes SEMI Ident EQ Bytes With
##
## Ends in an error in state: 1072.
##
## nsepseq(field_path_assignment,SEMI) -> field_path_assignment . [ RBRACE ]
## nsepseq(field_path_assignment,SEMI) -> field_path_assignment . SEMI nsepseq(field_path_assignment,SEMI) [ RBRACE ]
## seq(__anonymous_0(field_path_assignment,SEMI)) -> field_path_assignment . SEMI seq(__anonymous_0(field_path_assignment,SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_path_assignment
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 329, spurious reduction of production call_expr_level -> core_expr
## In state 338, spurious reduction of production unary_expr_level -> call_expr_level
## In state 319, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 348, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 354, spurious reduction of production add_expr_level -> mult_expr_level
## In state 395, spurious reduction of production cons_expr_level -> add_expr_level
## In state 382, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 417, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 424, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 431, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 380, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 437, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 438, spurious reduction of production expr -> base_cond__open(expr)
## In state 1065, spurious reduction of production field_path_assignment -> path EQ expr
##
interactive_expr: LBRACE Ident With Ident EQ Bytes With
##
## Ends in an error in state: 1068.
##
## nsepseq(field_path_assignment,SEMI) -> field_path_assignment . [ RBRACE ]
## nsepseq(field_path_assignment,SEMI) -> field_path_assignment . SEMI nsepseq(field_path_assignment,SEMI) [ RBRACE ]
## nseq(__anonymous_0(field_path_assignment,SEMI)) -> field_path_assignment . SEMI seq(__anonymous_0(field_path_assignment,SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_path_assignment
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 329, spurious reduction of production call_expr_level -> core_expr
## In state 338, spurious reduction of production unary_expr_level -> call_expr_level
## In state 319, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 348, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 354, spurious reduction of production add_expr_level -> mult_expr_level
## In state 395, spurious reduction of production cons_expr_level -> add_expr_level
## In state 382, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 417, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 424, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 431, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 380, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 437, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 438, spurious reduction of production expr -> base_cond__open(expr)
## In state 1065, spurious reduction of production field_path_assignment -> path EQ expr
##

Ill-formed record update.
At this point, if the expression assigned to the field (update) is
complete, one of the following is expected:
  * a semicolon ';' followed by another field assignment;
  * a closing brace '}' if the update is complete.

interactive_expr: LBRACE Ident EQ Bytes SEMI Ident With
##
## Ends in an error in state: 1079.
##
## field_assignment -> Ident . EQ expr [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## Ident
##

Ill-formed assignment to a field in a record.
At this point, the assignment symbol '=' is expected, followed by an
expression.

interactive_expr: LBRACE Ident WILD
##
## Ends in an error in state: 274.
##
## field_assignment -> Ident . EQ expr [ SEMI RBRACE ]
## path -> Ident . [ With ]
## projection -> Ident . DOT nsepseq(selection,DOT) [ With ]
##
## The known suffix of the stack is as follows:
## Ident
##

Ill-formed record expression or record update.
At this point, one of the following is expected:
  * the assignment symbol '=' followed by an expression, if defining
    a record (as opposed to a record update);
  * the keyword 'with' followed by field updates (assignments);
  * the selection symbol '.' if the record to update is not fully
    qualified.

interactive_expr: LBRACE Ident With Ident DOT Ident With
##
## Ends in an error in state: 1063.
##
## field_path_assignment -> path . EQ expr [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## path
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 133, spurious reduction of production nsepseq(selection,DOT) -> selection
## In state 136, spurious reduction of production projection -> Ident DOT nsepseq(selection,DOT)
## In state 1057, spurious reduction of production path -> projection
##

Ill-formed record update.
At this point, the assignment symbol '=' is expected, followed by an
expression (update).

interactive_expr: LBRACE Ident With Ident EQ Bytes SEMI Ident EQ Bytes SEMI With
##
## Ends in an error in state: 1073.
##
## nsepseq(field_path_assignment,SEMI) -> field_path_assignment SEMI . nsepseq(field_path_assignment,SEMI) [ RBRACE ]
## seq(__anonymous_0(field_path_assignment,SEMI)) -> field_path_assignment SEMI . seq(__anonymous_0(field_path_assignment,SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_path_assignment SEMI
##
interactive_expr: LBRACE Ident With Ident EQ Bytes SEMI With
##
## Ends in an error in state: 1069.
##
## nsepseq(field_path_assignment,SEMI) -> field_path_assignment SEMI . nsepseq(field_path_assignment,SEMI) [ RBRACE ]
## nseq(__anonymous_0(field_path_assignment,SEMI)) -> field_path_assignment SEMI . seq(__anonymous_0(field_path_assignment,SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_path_assignment SEMI
##

Ill-formed record update.
At this point, one of the following is expected:
  * more field assignments (updates) separated by semicolons ';';
  * a closing brace '}' if the update is complete.

interactive_expr: LBRACE Ident With Ident With
##
## Ends in an error in state: 1060.
##
## path -> Ident . [ EQ ]
## projection -> Ident . DOT nsepseq(selection,DOT) [ EQ ]
##
## The known suffix of the stack is as follows:
## Ident
##

Ill-formed record update.
At this point, one of the following is expected:
  * the assignment symbol '=' if the field to update is fully
    qualified;
  * the selection symbol '.' to further qualify the field to update.

interactive_expr: LBRACE Ident With With
##
## Ends in an error in state: 1059.
##
## update_record -> LBRACE path With . sep_or_term_list(field_path_assignment,SEMI) RBRACE [ With Verbatim VBAR UIdent Type Then TIMES String SLASH SEMI RPAR RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Lxor Lsr Lsl Lor Let Lang Land LT LPAR LE LBRACKET LBRACE Int In Ident GT GE End Else EQ EOF Directive CONS COMMA COLON CARET Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## LBRACE path With
##

Ill-formed record update.
At this point, assignments to fields (updates) are expected, separated
by semicolons ';' and each starting with fully qualified field names.

interactive_expr: LBRACE With
##
## Ends in an error in state: 273.
##
## record_expr -> LBRACE . sep_or_term_list(field_assignment,SEMI) RBRACE [ With Verbatim VBAR UIdent Type Then TIMES String SLASH SEMI RPAR RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Lxor Lsr Lsl Lor Let Lang Land LT LPAR LE LBRACKET LBRACE Int In Ident GT GE End Else EQ EOF Directive CONS COMMA COLON CARET Bytes Begin BOOL_OR BOOL_AND Attr ]
## update_record -> LBRACE . path With sep_or_term_list(field_path_assignment,SEMI) RBRACE [ With Verbatim VBAR UIdent Type Then TIMES String SLASH SEMI RPAR RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Lxor Lsr Lsl Lor Let Lang Land LT LPAR LE LBRACKET LBRACE Int In Ident GT GE End Else EQ EOF Directive CONS COMMA COLON CARET Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## LBRACE
##

Ill-formed record expression or update.
At this point, one of the following is expected:
  * field assignments separated by semicolons ';', if defining a record;
  * the qualified name of the record to update, otherwise.

interactive_expr: LBRACKET Verbatim SEMI Verbatim With
##
## Ends in an error in state: 1121.
##
## nsepseq(expr,SEMI) -> expr . [ RBRACKET ]
## nsepseq(expr,SEMI) -> expr . SEMI nsepseq(expr,SEMI) [ RBRACKET ]
## seq(__anonymous_0(expr,SEMI)) -> expr . SEMI seq(__anonymous_0(expr,SEMI)) [ RBRACKET ]
##
## The known suffix of the stack is as follows:
## expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 329, spurious reduction of production call_expr_level -> core_expr
## In state 338, spurious reduction of production unary_expr_level -> call_expr_level
## In state 319, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 348, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 354, spurious reduction of production add_expr_level -> mult_expr_level
## In state 395, spurious reduction of production cons_expr_level -> add_expr_level
## In state 382, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 417, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 424, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 431, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 380, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 437, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 438, spurious reduction of production expr -> base_cond__open(expr)
##
interactive_expr: LBRACKET Verbatim With
##
## Ends in an error in state: 1117.
##
## nsepseq(expr,SEMI) -> expr . [ RBRACKET ]
## nsepseq(expr,SEMI) -> expr . SEMI nsepseq(expr,SEMI) [ RBRACKET ]
## nseq(__anonymous_0(expr,SEMI)) -> expr . SEMI seq(__anonymous_0(expr,SEMI)) [ RBRACKET ]
##
## The known suffix of the stack is as follows:
## expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 329, spurious reduction of production call_expr_level -> core_expr
## In state 338, spurious reduction of production unary_expr_level -> call_expr_level
## In state 319, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 348, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 354, spurious reduction of production add_expr_level -> mult_expr_level
## In state 395, spurious reduction of production cons_expr_level -> add_expr_level
## In state 382, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 417, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 424, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 431, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 380, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 437, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 438, spurious reduction of production expr -> base_cond__open(expr)
##

Ill-formed list of expressions.
At this point, if the list element is complete, one of the
following is expected:
  * a semicolon ';' followed by more elements as expressions;
  * a closing bracket ']' if the list is complete.

interactive_expr: LPAR Verbatim COLON Ident VBAR
##
## Ends in an error in state: 1132.
##
## par(typed_expr) -> LPAR typed_expr . RPAR [ With Verbatim VBAR UIdent Type Then TIMES String SLASH SEMI RPAR RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Lxor Lsr Lsl Lor Let Lang Land LT LPAR LE LBRACKET LBRACE Int In Ident GT GE End Else EQ EOF Directive CONS COMMA COLON CARET Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## LPAR typed_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 69, spurious reduction of production prod_type_level -> core_type
## In state 50, spurious reduction of production fun_type_level -> prod_type_level
## In state 68, spurious reduction of production type_expr -> fun_type_level
## In state 1137, spurious reduction of production typed_expr -> expr COLON type_expr
##

Ill-formed typed expression.
At this point, if the type annotation is complete, then a closing
parenthesis ')' is expected.

interactive_expr: LPAR Verbatim With
##
## Ends in an error in state: 1134.
##
## par(expr) -> LPAR expr . RPAR [ With Verbatim VBAR UIdent Type Then TIMES String SLASH SEMI RPAR RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Lxor Lsr Lsl Lor Let Lang Land LT LPAR LE LBRACKET LBRACE Int In Ident GT GE End Else EQ EOF Directive CONS COMMA COLON CARET Bytes Begin BOOL_OR BOOL_AND Attr ]
## typed_expr -> expr . COLON type_expr [ RPAR ]
##
## The known suffix of the stack is as follows:
## LPAR expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 329, spurious reduction of production call_expr_level -> core_expr
## In state 338, spurious reduction of production unary_expr_level -> call_expr_level
## In state 319, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 348, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 354, spurious reduction of production add_expr_level -> mult_expr_level
## In state 395, spurious reduction of production cons_expr_level -> add_expr_level
## In state 382, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 417, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 424, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 431, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 380, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 437, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 438, spurious reduction of production expr -> base_cond__open(expr)
##

Ill formed parenthesised expression.
At this point, if the expression is complete, one of the following is
expected:
  * a type annotation starting with a colon ':';
  * a closing parenthesis ')'.

interactive_expr: Lang Verbatim With
##
## Ends in an error in state: 1139.
##
## code_inj -> Lang expr . RBRACKET [ With Verbatim VBAR UIdent Type Then TIMES String SLASH SEMI RPAR RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Lxor Lsr Lsl Lor Let Lang Land LT LPAR LE LBRACKET LBRACE Int In Ident GT GE End Else EQ EOF Directive CONS COMMA COLON CARET Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## Lang expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 329, spurious reduction of production call_expr_level -> core_expr
## In state 338, spurious reduction of production unary_expr_level -> call_expr_level
## In state 319, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 348, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 354, spurious reduction of production add_expr_level -> mult_expr_level
## In state 395, spurious reduction of production cons_expr_level -> add_expr_level
## In state 382, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 417, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 424, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 431, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 380, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 437, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 438, spurious reduction of production expr -> base_cond__open(expr)
##

Ill-formed code injection.
At this point, a closing bracket ']' is expected.

interactive_expr: MINUS With
##
## Ends in an error in state: 148.
##
## unary_expr_level -> MINUS . call_expr_level [ With VBAR Type Then TIMES SLASH SEMI RPAR RBRACKET RBRACE PLUS Or NE Module Mod MINUS Lxor Lsr Lsl Lor Let Land LT LE In GT GE End Else EQ EOF Directive CONS COMMA COLON CARET BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## MINUS
##
interactive_expr: Not With
##
## Ends in an error in state: 144.
##
## unary_expr_level -> Not . call_expr_level [ With VBAR Type Then TIMES SLASH SEMI RPAR RBRACKET RBRACE PLUS Or NE Module Mod MINUS Lxor Lsr Lsl Lor Let Land LT LE In GT GE End Else EQ EOF Directive CONS COMMA COLON CARET BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## Not
##
interactive_expr: Verbatim BOOL_AND With
##
## Ends in an error in state: 403.
##
## bin_op(conj_expr_level,BOOL_AND,comp_expr_level) -> conj_expr_level BOOL_AND . comp_expr_level [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Or Module Let In End Else EOF Directive COMMA COLON BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## conj_expr_level BOOL_AND
##
interactive_expr: Verbatim BOOL_OR With
##
## Ends in an error in state: 434.
##
## bin_op(disj_expr_level,BOOL_OR,conj_expr_level) -> disj_expr_level BOOL_OR . conj_expr_level [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Or Module Let In End Else EOF Directive COMMA COLON BOOL_OR Attr ]
##
## The known suffix of the stack is as follows:
## disj_expr_level BOOL_OR
##
interactive_expr: Verbatim Or With
##
## Ends in an error in state: 381.
##
## bin_op(disj_expr_level,Or,conj_expr_level) -> disj_expr_level Or . conj_expr_level [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Or Module Let In End Else EOF Directive COMMA COLON BOOL_OR Attr ]
##
## The known suffix of the stack is as follows:
## disj_expr_level Or
##
interactive_expr: Verbatim CARET With
##
## Ends in an error in state: 383.
##
## bin_op(cons_expr_level,CARET,cat_expr_level) -> cons_expr_level CARET . cat_expr_level [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Or NE Module Let LT LE In GT GE End Else EQ EOF Directive COMMA COLON BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## cons_expr_level CARET
##
interactive_expr: Verbatim EQ With
##
## Ends in an error in state: 415.
##
## bin_op(comp_expr_level,EQ,cat_expr_level) -> comp_expr_level EQ . cat_expr_level [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Or NE Module Let LT LE In GT GE End Else EQ EOF Directive COMMA COLON BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## comp_expr_level EQ
##
interactive_expr: Verbatim GE With
##
## Ends in an error in state: 413.
##
## bin_op(comp_expr_level,GE,cat_expr_level) -> comp_expr_level GE . cat_expr_level [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Or NE Module Let LT LE In GT GE End Else EQ EOF Directive COMMA COLON BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## comp_expr_level GE
##
interactive_expr: Verbatim GT With
##
## Ends in an error in state: 411.
##
## bin_op(comp_expr_level,GT,cat_expr_level) -> comp_expr_level GT . cat_expr_level [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Or NE Module Let LT LE In GT GE End Else EQ EOF Directive COMMA COLON BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## comp_expr_level GT
##
interactive_expr: Verbatim LE With
##
## Ends in an error in state: 409.
##
## bin_op(comp_expr_level,LE,cat_expr_level) -> comp_expr_level LE . cat_expr_level [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Or NE Module Let LT LE In GT GE End Else EQ EOF Directive COMMA COLON BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## comp_expr_level LE
##
interactive_expr: Verbatim LT With
##
## Ends in an error in state: 407.
##
## bin_op(comp_expr_level,LT,cat_expr_level) -> comp_expr_level LT . cat_expr_level [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Or NE Module Let LT LE In GT GE End Else EQ EOF Directive COMMA COLON BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## comp_expr_level LT
##
interactive_expr: Verbatim NE With
##
## Ends in an error in state: 405.
##
## bin_op(comp_expr_level,NE,cat_expr_level) -> comp_expr_level NE . cat_expr_level [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Or NE Module Let LT LE In GT GE End Else EQ EOF Directive COMMA COLON BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## comp_expr_level NE
##
interactive_expr: Verbatim MINUS With
##
## Ends in an error in state: 398.
##
## bin_op(add_expr_level,MINUS,mult_expr_level) -> add_expr_level MINUS . mult_expr_level [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE PLUS Or NE Module MINUS Let LT LE In GT GE End Else EQ EOF Directive CONS COMMA COLON CARET BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## add_expr_level MINUS
##
interactive_expr: Verbatim Mod With
##
## Ends in an error in state: 359.
##
## bin_op(mult_expr_level,Mod,shift_expr_level) -> mult_expr_level Mod . shift_expr_level [ With VBAR Type Then TIMES SLASH SEMI RPAR RBRACKET RBRACE PLUS Or NE Module Mod MINUS Lxor Lor Let Land LT LE In GT GE End Else EQ EOF Directive CONS COMMA COLON CARET BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## mult_expr_level Mod
##
interactive_expr: Verbatim PLUS With
##
## Ends in an error in state: 396.
##
## bin_op(add_expr_level,PLUS,mult_expr_level) -> add_expr_level PLUS . mult_expr_level [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE PLUS Or NE Module MINUS Let LT LE In GT GE End Else EQ EOF Directive CONS COMMA COLON CARET BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## add_expr_level PLUS
##
interactive_expr: Verbatim SLASH With
##
## Ends in an error in state: 357.
##
## bin_op(mult_expr_level,SLASH,shift_expr_level) -> mult_expr_level SLASH . shift_expr_level [ With VBAR Type Then TIMES SLASH SEMI RPAR RBRACKET RBRACE PLUS Or NE Module Mod MINUS Lxor Lor Let Land LT LE In GT GE End Else EQ EOF Directive CONS COMMA COLON CARET BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## mult_expr_level SLASH
##
interactive_expr: Verbatim TIMES With
##
## Ends in an error in state: 355.
##
## bin_op(mult_expr_level,TIMES,shift_expr_level) -> mult_expr_level TIMES . shift_expr_level [ With VBAR Type Then TIMES SLASH SEMI RPAR RBRACKET RBRACE PLUS Or NE Module Mod MINUS Lxor Lor Let Land LT LE In GT GE End Else EQ EOF Directive CONS COMMA COLON CARET BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## mult_expr_level TIMES
##
interactive_expr: Verbatim Lsr With
##
## Ends in an error in state: 320.
##
## bin_op(unary_expr_level,Lsr,shift_expr_level) -> unary_expr_level Lsr . shift_expr_level [ With VBAR Type Then TIMES SLASH SEMI RPAR RBRACKET RBRACE PLUS Or NE Module Mod MINUS Lxor Lor Let Land LT LE In GT GE End Else EQ EOF Directive CONS COMMA COLON CARET BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## unary_expr_level Lsr
##
interactive_expr: Verbatim Lsl With
##
## Ends in an error in state: 342.
##
## bin_op(unary_expr_level,Lsl,shift_expr_level) -> unary_expr_level Lsl . shift_expr_level [ With VBAR Type Then TIMES SLASH SEMI RPAR RBRACKET RBRACE PLUS Or NE Module Mod MINUS Lxor Lor Let Land LT LE In GT GE End Else EQ EOF Directive CONS COMMA COLON CARET BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## unary_expr_level Lsl
##
interactive_expr: Verbatim Lxor With
##
## Ends in an error in state: 361.
##
## bin_op(mult_expr_level,Lxor,shift_expr_level) -> mult_expr_level Lxor . shift_expr_level [ With VBAR Type Then TIMES SLASH SEMI RPAR RBRACKET RBRACE PLUS Or NE Module Mod MINUS Lxor Lor Let Land LT LE In GT GE End Else EQ EOF Directive CONS COMMA COLON CARET BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## mult_expr_level Lxor
##
interactive_expr: Verbatim Lor With
##
## Ends in an error in state: 363.
##
## bin_op(mult_expr_level,Lor,shift_expr_level) -> mult_expr_level Lor . shift_expr_level [ With VBAR Type Then TIMES SLASH SEMI RPAR RBRACKET RBRACE PLUS Or NE Module Mod MINUS Lxor Lor Let Land LT LE In GT GE End Else EQ EOF Directive CONS COMMA COLON CARET BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## mult_expr_level Lor
##
interactive_expr: Verbatim Land With
##
## Ends in an error in state: 365.
##
## bin_op(mult_expr_level,Land,shift_expr_level) -> mult_expr_level Land . shift_expr_level [ With VBAR Type Then TIMES SLASH SEMI RPAR RBRACKET RBRACE PLUS Or NE Module Mod MINUS Lxor Lor Let Land LT LE In GT GE End Else EQ EOF Directive CONS COMMA COLON CARET BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## mult_expr_level Land
##

Ill-formed expression.
At this point, an expression is expected.
Hint: To check your understanding of the syntax, try and add
parentheses around what you think is the expression.

interactive_expr: Verbatim COMMA Verbatim COMMA With
##
## Ends in an error in state: 429.
##
## nsepseq(disj_expr_level,COMMA) -> disj_expr_level COMMA . nsepseq(disj_expr_level,COMMA) [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End Else EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## disj_expr_level COMMA
##
interactive_expr: Verbatim COMMA With
##
## Ends in an error in state: 426.
##
## tuple(disj_expr_level) -> disj_expr_level COMMA . nsepseq(disj_expr_level,COMMA) [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End Else EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## disj_expr_level COMMA
##

Ill-formed tuple of expressions.
At this point, another component is expected as an expression.
Hint: To check your understanding of the syntax, try and add
parentheses around what you think is the expression.

interactive_expr: Verbatim CONS With
##
## Ends in an error in state: 400.
##
## bin_op(add_expr_level,CONS,cons_expr_level) -> add_expr_level CONS . cons_expr_level [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Or NE Module Let LT LE In GT GE End Else EQ EOF Directive COMMA COLON CARET BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## add_expr_level CONS
##

Ill-formed list expression.
At this point, an expression of type list is expected.

interactive_expr: UIdent DOT UIdent With
##
## Ends in an error in state: 127.
##
## module_access_e -> UIdent . DOT module_var_e [ With Verbatim VBAR UIdent Type Then TIMES String SLASH SEMI RPAR RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Lxor Lsr Lsl Lor Let Lang Land LT LPAR LE LBRACKET LBRACE Int In Ident GT GE End Else EQ EOF Directive CONS COMMA COLON CARET Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## UIdent
##

Ill-formed selection of a value from a module.
At this point, the selection symbol '.' is expected, followed by the
qualified name of a value.

contract: Let Ident WILD COLON String VBAR
##
## Ends in an error in state: 1092.
##
## let_binding -> var_pattern parameters type_annotation(type_expr) . EQ expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## var_pattern parameters type_annotation(type_expr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 69, spurious reduction of production prod_type_level -> core_type
## In state 50, spurious reduction of production fun_type_level -> prod_type_level
## In state 68, spurious reduction of production type_expr -> fun_type_level
## In state 219, spurious reduction of production type_annotation(type_expr) -> COLON type_expr
##
contract: Let Ident LPAR Type Ident RPAR WILD COLON UIdent With
##
## Ends in an error in state: 1104.
##
## let_binding -> var_pattern par(type_param_list) parameters type_annotation(type_expr) . EQ expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## var_pattern par(type_param_list) parameters type_annotation(type_expr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 26, spurious reduction of production variant(fun_type_level) -> UIdent
## In state 37, spurious reduction of production nsepseq(variant(fun_type_level),VBAR) -> variant(fun_type_level)
## In state 66, spurious reduction of production sum_type(fun_type_level) -> nsepseq(variant(fun_type_level),VBAR)
## In state 48, spurious reduction of production type_expr -> sum_type(fun_type_level)
## In state 219, spurious reduction of production type_annotation(type_expr) -> COLON type_expr
##
contract: Let WILD COLON Ident VBAR
##
## Ends in an error in state: 1143.
##
## let_binding -> WILD type_annotation(type_expr) . EQ expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## WILD type_annotation(type_expr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 69, spurious reduction of production prod_type_level -> core_type
## In state 50, spurious reduction of production fun_type_level -> prod_type_level
## In state 68, spurious reduction of production type_expr -> fun_type_level
## In state 219, spurious reduction of production type_annotation(type_expr) -> COLON type_expr
##
contract: Let LPAR RPAR LPAR Type Ident RPAR COLON Ident With
##
## Ends in an error in state: 447.
##
## let_binding -> unit par(type_param_list) type_annotation(type_expr) . EQ expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## unit par(type_param_list) type_annotation(type_expr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 69, spurious reduction of production prod_type_level -> core_type
## In state 50, spurious reduction of production fun_type_level -> prod_type_level
## In state 68, spurious reduction of production type_expr -> fun_type_level
## In state 219, spurious reduction of production type_annotation(type_expr) -> COLON type_expr
##
contract: Let WILD COMMA Ident COLON Ident With
##
## Ends in an error in state: 453.
##
## let_binding -> tuple(core_irrefutable) type_annotation(type_expr) . EQ expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## tuple(core_irrefutable) type_annotation(type_expr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 69, spurious reduction of production prod_type_level -> core_type
## In state 50, spurious reduction of production fun_type_level -> prod_type_level
## In state 68, spurious reduction of production type_expr -> fun_type_level
## In state 219, spurious reduction of production type_annotation(type_expr) -> COLON type_expr
##
contract: Let WILD COMMA Ident LPAR Type Ident RPAR COLON Ident With
##
## Ends in an error in state: 459.
##
## let_binding -> tuple(core_irrefutable) par(type_param_list) type_annotation(type_expr) . EQ expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## tuple(core_irrefutable) par(type_param_list) type_annotation(type_expr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 69, spurious reduction of production prod_type_level -> core_type
## In state 50, spurious reduction of production fun_type_level -> prod_type_level
## In state 68, spurious reduction of production type_expr -> fun_type_level
## In state 219, spurious reduction of production type_annotation(type_expr) -> COLON type_expr
##
contract: Let LBRACE Ident RBRACE COLON Ident With
##
## Ends in an error in state: 465.
##
## let_binding -> record_pattern(irrefutable) type_annotation(type_expr) . EQ expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## record_pattern(irrefutable) type_annotation(type_expr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 69, spurious reduction of production prod_type_level -> core_type
## In state 50, spurious reduction of production fun_type_level -> prod_type_level
## In state 68, spurious reduction of production type_expr -> fun_type_level
## In state 219, spurious reduction of production type_annotation(type_expr) -> COLON type_expr
##
contract: Let LBRACE Ident RBRACE LPAR Type Ident RPAR COLON Ident With
##
## Ends in an error in state: 471.
##
## let_binding -> record_pattern(irrefutable) par(type_param_list) type_annotation(type_expr) . EQ expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## record_pattern(irrefutable) par(type_param_list) type_annotation(type_expr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 69, spurious reduction of production prod_type_level -> core_type
## In state 50, spurious reduction of production fun_type_level -> prod_type_level
## In state 68, spurious reduction of production type_expr -> fun_type_level
## In state 219, spurious reduction of production type_annotation(type_expr) -> COLON type_expr
##
contract: Let LPAR UIdent COLON Ident RPAR COLON Ident With
##
## Ends in an error in state: 477.
##
## let_binding -> par(typed_irrefutable) type_annotation(type_expr) . EQ expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## par(typed_irrefutable) type_annotation(type_expr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 69, spurious reduction of production prod_type_level -> core_type
## In state 50, spurious reduction of production fun_type_level -> prod_type_level
## In state 68, spurious reduction of production type_expr -> fun_type_level
## In state 219, spurious reduction of production type_annotation(type_expr) -> COLON type_expr
##
contract: Let LPAR UIdent COLON Ident RPAR LPAR Type Ident RPAR COLON Ident With
##
## Ends in an error in state: 483.
##
## let_binding -> par(typed_irrefutable) par(type_param_list) type_annotation(type_expr) . EQ expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## par(typed_irrefutable) par(type_param_list) type_annotation(type_expr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 69, spurious reduction of production prod_type_level -> core_type
## In state 50, spurious reduction of production fun_type_level -> prod_type_level
## In state 68, spurious reduction of production type_expr -> fun_type_level
## In state 219, spurious reduction of production type_annotation(type_expr) -> COLON type_expr
##
contract: Let LPAR WILD RPAR COLON Ident With
##
## Ends in an error in state: 489.
##
## let_binding -> par(irrefutable) type_annotation(type_expr) . EQ expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## par(irrefutable) type_annotation(type_expr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 69, spurious reduction of production prod_type_level -> core_type
## In state 50, spurious reduction of production fun_type_level -> prod_type_level
## In state 68, spurious reduction of production type_expr -> fun_type_level
## In state 219, spurious reduction of production type_annotation(type_expr) -> COLON type_expr
##
contract: Let LPAR WILD RPAR LPAR Type Ident RPAR COLON Ident With
##
## Ends in an error in state: 495.
##
## let_binding -> par(irrefutable) par(type_param_list) type_annotation(type_expr) . EQ expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## par(irrefutable) par(type_param_list) type_annotation(type_expr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 69, spurious reduction of production prod_type_level -> core_type
## In state 50, spurious reduction of production fun_type_level -> prod_type_level
## In state 68, spurious reduction of production type_expr -> fun_type_level
## In state 219, spurious reduction of production type_annotation(type_expr) -> COLON type_expr
##
contract: Let UIdent COLON Ident With
##
## Ends in an error in state: 504.
##
## let_binding -> constr_irrefutable type_annotation(type_expr) . EQ expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## constr_irrefutable type_annotation(type_expr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 69, spurious reduction of production prod_type_level -> core_type
## In state 50, spurious reduction of production fun_type_level -> prod_type_level
## In state 68, spurious reduction of production type_expr -> fun_type_level
## In state 219, spurious reduction of production type_annotation(type_expr) -> COLON type_expr
##
contract: Let UIdent LPAR Type Ident RPAR COLON Ident With
##
## Ends in an error in state: 510.
##
## let_binding -> constr_irrefutable par(type_param_list) type_annotation(type_expr) . EQ expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## constr_irrefutable par(type_param_list) type_annotation(type_expr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 69, spurious reduction of production prod_type_level -> core_type
## In state 50, spurious reduction of production fun_type_level -> prod_type_level
## In state 68, spurious reduction of production type_expr -> fun_type_level
## In state 219, spurious reduction of production type_annotation(type_expr) -> COLON type_expr
##
contract: Let Ident COLON Ident With
##
## Ends in an error in state: 1086.
##
## let_binding -> var_pattern type_annotation(type_expr) . EQ expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## var_pattern type_annotation(type_expr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 69, spurious reduction of production prod_type_level -> core_type
## In state 50, spurious reduction of production fun_type_level -> prod_type_level
## In state 68, spurious reduction of production type_expr -> fun_type_level
## In state 219, spurious reduction of production type_annotation(type_expr) -> COLON type_expr
##
contract: Let Ident LPAR Type Ident RPAR COLON Ident With
##
## Ends in an error in state: 1098.
##
## let_binding -> var_pattern par(type_param_list) type_annotation(type_expr) . EQ expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## var_pattern par(type_param_list) type_annotation(type_expr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 69, spurious reduction of production prod_type_level -> core_type
## In state 50, spurious reduction of production fun_type_level -> prod_type_level
## In state 68, spurious reduction of production type_expr -> fun_type_level
## In state 219, spurious reduction of production type_annotation(type_expr) -> COLON type_expr
##
contract: Let WILD LPAR Type Ident RPAR COLON Ident With
##
## Ends in an error in state: 1149.
##
## let_binding -> WILD par(type_param_list) type_annotation(type_expr) . EQ expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## WILD par(type_param_list) type_annotation(type_expr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 69, spurious reduction of production prod_type_level -> core_type
## In state 50, spurious reduction of production fun_type_level -> prod_type_level
## In state 68, spurious reduction of production type_expr -> fun_type_level
## In state 219, spurious reduction of production type_annotation(type_expr) -> COLON type_expr
##
contract: Let LPAR RPAR COLON Ident With
##
## Ends in an error in state: 441.
##
## let_binding -> unit type_annotation(type_expr) . EQ expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## unit type_annotation(type_expr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 69, spurious reduction of production prod_type_level -> core_type
## In state 50, spurious reduction of production fun_type_level -> prod_type_level
## In state 68, spurious reduction of production type_expr -> fun_type_level
## In state 219, spurious reduction of production type_annotation(type_expr) -> COLON type_expr
##

Ill-formed value declaration.
At this point, if the type annotation is complete, the assignment
symbol '=' is expected, followed by an expression.

contract: Let LBRACE Ident With
##
## Ends in an error in state: 160.
##
## field_pattern(irrefutable) -> Ident . [ SEMI RBRACE ]
## field_pattern(irrefutable) -> Ident . EQ tuple(core_irrefutable) [ SEMI RBRACE ]
## field_pattern(irrefutable) -> Ident . EQ WILD [ SEMI RBRACE ]
## field_pattern(irrefutable) -> Ident . EQ var_pattern [ SEMI RBRACE ]
## field_pattern(irrefutable) -> Ident . EQ unit [ SEMI RBRACE ]
## field_pattern(irrefutable) -> Ident . EQ record_pattern(irrefutable) [ SEMI RBRACE ]
## field_pattern(irrefutable) -> Ident . EQ par(typed_irrefutable) [ SEMI RBRACE ]
## field_pattern(irrefutable) -> Ident . EQ par(irrefutable) [ SEMI RBRACE ]
## field_pattern(irrefutable) -> Ident . EQ constr_irrefutable [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## Ident
##
interactive_expr: Match Verbatim With LBRACE Ident With
##
## Ends in an error in state: 545.
##
## field_pattern(core_pattern) -> Ident . [ SEMI RBRACE ]
## field_pattern(core_pattern) -> Ident . EQ core_pattern [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## Ident
##

Ill-formed record pattern.
At this point, one of the following is expected:
  * the assignment symbol '=' followed by a pattern;
  * a semicolon ';' if the field is punned (that is, a variable with
    the same name denotes implicitly the pattern);
  * a closing brace '}' if the record pattern is complete.

contract: Let LBRACE With
##
## Ends in an error in state: 159.
##
## record_pattern(irrefutable) -> LBRACE . sep_or_term_list(field_pattern(irrefutable),SEMI) RBRACE [ WILD UIdent SEMI RPAR RBRACE LPAR LBRACE Ident EQ COMMA COLON Attr ARROW ]
##
## The known suffix of the stack is as follows:
## LBRACE
##
interactive_expr: Match Verbatim With LBRACE With
##
## Ends in an error in state: 544.
##
## record_pattern(core_pattern) -> LBRACE . sep_or_term_list(field_pattern(core_pattern),SEMI) RBRACE [ SEMI RPAR RBRACKET RBRACE CONS COMMA COLON ARROW ]
##
## The known suffix of the stack is as follows:
## LBRACE
##

Ill-formed record pattern.
At this point, field patterns are expected, separated by semicolons ';'.

contract: Let LPAR UIdent UIdent With
##
## Ends in an error in state: 249.
##
## par(non_const_constr_irrefutable) -> LPAR non_const_constr_irrefutable . RPAR [ WILD UIdent SEMI RPAR RBRACE LPAR LBRACE Ident EQ COMMA COLON Attr ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR non_const_constr_irrefutable
##

Ill-formed parenthesised pattern.
At this point, if the enclosed pattern is complete, a closing
parenthesis ')' is expected.

interactive_expr: Match Verbatim With LPAR WILD With
##
## Ends in an error in state: 586.
##
## par(pattern) -> LPAR pattern . RPAR [ SEMI RPAR RBRACKET RBRACE CONS COMMA COLON ARROW ]
## typed_pattern -> pattern . type_annotation(type_expr) [ RPAR ]
##
## The known suffix of the stack is as follows:
## LPAR pattern
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 573, spurious reduction of production cons_pattern_level -> core_pattern
## In state 589, spurious reduction of production pattern -> cons_pattern_level
##
contract: Let LPAR WILD COMMA Ident With
##
## Ends in an error in state: 237.
##
## par(irrefutable) -> LPAR tuple(core_irrefutable) . RPAR [ WILD UIdent SEMI RPAR RBRACE LPAR LBRACE Ident EQ COMMA COLON Attr ARROW ]
## typed_irrefutable -> tuple(core_irrefutable) . type_annotation(type_expr) [ RPAR ]
##
## The known suffix of the stack is as follows:
## LPAR tuple(core_irrefutable)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 166, spurious reduction of production nsepseq(core_irrefutable,COMMA) -> var_pattern
## In state 217, spurious reduction of production tuple(core_irrefutable) -> WILD COMMA nsepseq(core_irrefutable,COMMA)
##

Ill-formed parenthesised pattern.
At this point, if the enclosed pattern is complete, one of the
following is expected:
  * a type annotation starting with a colon ':', followed by a closing
    parenthesis ')';
  * a closing parenthesis ')'.

contract: Let WILD With
##
## Ends in an error in state: 112.
##
## let_binding -> WILD . EQ expr [ Type Module Let In End EOF Directive Attr ]
## let_binding -> WILD . type_annotation(type_expr) EQ expr [ Type Module Let In End EOF Directive Attr ]
## let_binding -> WILD . par(type_param_list) EQ expr [ Type Module Let In End EOF Directive Attr ]
## let_binding -> WILD . par(type_param_list) type_annotation(type_expr) EQ expr [ Type Module Let In End EOF Directive Attr ]
## tuple(core_irrefutable) -> WILD . COMMA nsepseq(core_irrefutable,COMMA) [ LPAR EQ COLON ]
##
## The known suffix of the stack is as follows:
## WILD
##
contract: Let LPAR RPAR With
##
## Ends in an error in state: 352.
##
## let_binding -> unit . EQ expr [ Type Module Let In End EOF Directive Attr ]
## let_binding -> unit . type_annotation(type_expr) EQ expr [ Type Module Let In End EOF Directive Attr ]
## let_binding -> unit . par(type_param_list) EQ expr [ Type Module Let In End EOF Directive Attr ]
## let_binding -> unit . par(type_param_list) type_annotation(type_expr) EQ expr [ Type Module Let In End EOF Directive Attr ]
## tuple(core_irrefutable) -> unit . COMMA nsepseq(core_irrefutable,COMMA) [ LPAR EQ COLON ]
##
## The known suffix of the stack is as follows:
## unit
##

Ill-formed value declaration.
At this point, one of the following is expected:
  * a type annotation starting with a colon ':';
  * the assignment symbol '=' followed by an expression;
  * a comma ',' followed by another component as a pattern, if
    defining a tuple.

contract: Type Ident EQ LBRACE Ident COLON UIdent SEMI Ident COLON Ident VBAR
##
## Ends in an error in state: 80.
##
## nsepseq(field_decl,SEMI) -> field_decl . [ RBRACE ]
## nsepseq(field_decl,SEMI) -> field_decl . SEMI nsepseq(field_decl,SEMI) [ RBRACE ]
## seq(__anonymous_0(field_decl,SEMI)) -> field_decl . SEMI seq(__anonymous_0(field_decl,SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_decl
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 69, spurious reduction of production prod_type_level -> core_type
## In state 50, spurious reduction of production fun_type_level -> prod_type_level
## In state 68, spurious reduction of production type_expr -> fun_type_level
## In state 44, spurious reduction of production field_decl -> Ident COLON type_expr
##
contract: Type Ident EQ LBRACE Ident COLON Ident VBAR
##
## Ends in an error in state: 76.
##
## nsepseq(field_decl,SEMI) -> field_decl . [ RBRACE ]
## nsepseq(field_decl,SEMI) -> field_decl . SEMI nsepseq(field_decl,SEMI) [ RBRACE ]
## nseq(__anonymous_0(field_decl,SEMI)) -> field_decl . SEMI seq(__anonymous_0(field_decl,SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_decl
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 69, spurious reduction of production prod_type_level -> core_type
## In state 50, spurious reduction of production fun_type_level -> prod_type_level
## In state 68, spurious reduction of production type_expr -> fun_type_level
## In state 44, spurious reduction of production field_decl -> Ident COLON type_expr
##

Ill-formed record type.
At this point, if the field is complete, one of the following is
expected:
  * a semicolon ';' followed by another field declaration;
  * a closing brace '}' if the record type is complete.

contract: Type Ident EQ LBRACE With
##
## Ends in an error in state: 28.
##
## record_type -> LBRACE . sep_or_term_list(field_decl,SEMI) RBRACE [ VBAR Type TIMES SEMI RPAR RBRACE Module Let In Ident End EQ EOF Directive COMMA Attr ARROW ]
##
## The known suffix of the stack is as follows:
## LBRACE
##
contract: Let Ident COLON Attr LBRACE With
##
## Ends in an error in state: 55.
##
## record_type -> nseq(Attr) LBRACE . sep_or_term_list(field_decl,SEMI) RBRACE [ VBAR Type TIMES SEMI RPAR RBRACE Module Let In Ident End EQ EOF Directive COMMA Attr ARROW ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) LBRACE
##

Ill-formed record type.
At this point, field declarations are expected, separated by
semicolons ';'.

contract: Type Ident EQ LPAR String COMMA String VBAR
##
## Ends in an error in state: 89.
##
## nsepseq(type_expr,COMMA) -> type_expr . [ RPAR ]
## nsepseq(type_expr,COMMA) -> type_expr . COMMA nsepseq(type_expr,COMMA) [ RPAR ]
##
## The known suffix of the stack is as follows:
## type_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 69, spurious reduction of production prod_type_level -> core_type
## In state 50, spurious reduction of production fun_type_level -> prod_type_level
## In state 68, spurious reduction of production type_expr -> fun_type_level
##

Ill-formed argument to a type constructor.
At this point, if the tuple component is complete, one of the
following is expected:
  * a comma ',' followed by another component as a type expression;
  * a closing parenthesis ')' if the tuple is complete.

contract: Type Ident EQ LPAR String VBAR
##
## Ends in an error in state: 86.
##
## par(type_expr) -> LPAR type_expr . RPAR [ VBAR Type TIMES SEMI RPAR RBRACE Module Let In Ident End EQ EOF Directive COMMA Attr ARROW ]
## tuple(type_expr) -> type_expr . COMMA nsepseq(type_expr,COMMA) [ RPAR ]
##
## The known suffix of the stack is as follows:
## LPAR type_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 69, spurious reduction of production prod_type_level -> core_type
## In state 50, spurious reduction of production fun_type_level -> prod_type_level
## In state 68, spurious reduction of production type_expr -> fun_type_level
##

Ill-formed parenthesised type or argument to a type constructor.
At this point, one of the following is expected:
  * a closing parenthesis if the type is complete;
  * a comma ',' followed by another type expression, if defining the
    argument to a type constructor.

contract: Type Ident EQ String ARROW With
##
## Ends in an error in state: 51.
##
## fun_type_level -> prod_type_level ARROW . fun_type_level [ VBAR Type SEMI RPAR RBRACE Module Let In End EQ EOF Directive COMMA Attr ]
##
## The known suffix of the stack is as follows:
## prod_type_level ARROW
##

Ill-formed functional type.
At this point, a type expression is expected.
Note: If you want a sum type, enclose it between parentheses.

interactive_expr: Fun Ident COLON UIdent Of With
##
## Ends in an error in state: 295.
##
## of_type(prod_type_level) -> Of . prod_type_level [ VBAR ARROW ]
##
## The known suffix of the stack is as follows:
## Of
##
contract: Let Ident COLON UIdent Of With
##
## Ends in an error in state: 18.
##
## of_type(fun_type_level) -> Of . fun_type_level [ VBAR Type SEMI RPAR RBRACE Module Let In End EQ EOF Directive COMMA Attr ]
##
## The known suffix of the stack is as follows:
## Of
##

Ill-formed parameter of a variant.
At this point, a type expression is expected.
Note: If you want a sum type, enclose it between parentheses.

contract: Type Ident EQ String TIMES UIdent With
##
## Ends in an error in state: 19.
##
## module_access_t -> UIdent . DOT module_var_t [ VBAR Type TIMES SEMI RPAR RBRACE Module Let In Ident End EQ EOF Directive COMMA Attr ARROW ]
##
## The known suffix of the stack is as follows:
## UIdent
##

Ill-formed selection of a type in a module.
At this point, the selection symbol '.' is expected, followed by the
qualified name of a type.

contract: Type Ident EQ String TIMES String TIMES With
##
## Ends in an error in state: 73.
##
## nsepseq(core_type,TIMES) -> core_type TIMES . nsepseq(core_type,TIMES) [ VBAR Type SEMI RPAR RBRACE Module Let In End EQ EOF Directive COMMA Attr ARROW ]
##
## The known suffix of the stack is as follows:
## core_type TIMES
##
contract: Type Ident EQ String TIMES With
##
## Ends in an error in state: 70.
##
## prod_type_level -> core_type TIMES . nsepseq(core_type,TIMES) [ VBAR Type SEMI RPAR RBRACE Module Let In End EQ EOF Directive COMMA Attr ARROW ]
##
## The known suffix of the stack is as follows:
## core_type TIMES
##

Ill-formed product type.
At this point, a type expression is expected.
Hint: If you want a sum type, put it between parentheses.

interactive_expr: Fun Ident COLON UIdent VBAR With
##
## Ends in an error in state: 299.
##
## nsepseq(variant(prod_type_level),VBAR) -> variant(prod_type_level) VBAR . nsepseq(variant(prod_type_level),VBAR) [ ARROW ]
##
## The known suffix of the stack is as follows:
## variant(prod_type_level) VBAR
##
interactive_expr: Fun Ident COLON Attr VBAR With
##
## Ends in an error in state: 309.
##
## sum_type(prod_type_level) -> nseq(Attr) VBAR . nsepseq(variant(prod_type_level),VBAR) [ ARROW ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) VBAR
##
contract: Let Ident COLON Attr VBAR With
##
## Ends in an error in state: 64.
##
## sum_type(fun_type_level) -> nseq(Attr) VBAR . nsepseq(variant(fun_type_level),VBAR) [ Type SEMI RPAR RBRACE Module Let In End EQ EOF Directive COMMA Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) VBAR
##
contract: Type Ident EQ VBAR With
##
## Ends in an error in state: 16.
##
## sum_type(fun_type_level) -> VBAR . nsepseq(variant(fun_type_level),VBAR) [ Type SEMI RPAR RBRACE Module Let In End EQ EOF Directive COMMA Attr ]
##
## The known suffix of the stack is as follows:
## VBAR
##
contract: Type Ident EQ UIdent VBAR With
##
## Ends in an error in state: 38.
##
## nsepseq(variant(fun_type_level),VBAR) -> variant(fun_type_level) VBAR . nsepseq(variant(fun_type_level),VBAR) [ Type SEMI RPAR RBRACE Module Let In End EQ EOF Directive COMMA Attr ]
##
## The known suffix of the stack is as follows:
## variant(fun_type_level) VBAR
##
interactive_expr: Fun Ident COLON VBAR With
##
## Ends in an error in state: 293.
##
## sum_type(prod_type_level) -> VBAR . nsepseq(variant(prod_type_level),VBAR) [ ARROW ]
##
## The known suffix of the stack is as follows:
## VBAR
##

Ill-formed variant of sum type.
At this point, a variant starting with a data constructor is expected.

contract: Type With
##
## Ends in an error in state: 1.
##
## type_decl -> Type . Ident EQ type_expr [ Type Module Let In End EOF Directive Attr ]
## type_decl -> Type . quoted_type_params Ident EQ type_expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## Type
##

Ill-formed type declaration.
At this point, one of the following is expected:
  * the name of the type being defined;
  * a quoted type parameter, like 'a;
  * a tuple of quoted type parameters, like ('a, 'b).

interactive_expr: Type Ident EQ UIdent With
##
## Ends in an error in state: 344.
##
## local_type_decl(expr) -> type_decl . In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## type_decl
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 26, spurious reduction of production variant(fun_type_level) -> UIdent
## In state 37, spurious reduction of production nsepseq(variant(fun_type_level),VBAR) -> variant(fun_type_level)
## In state 66, spurious reduction of production sum_type(fun_type_level) -> nsepseq(variant(fun_type_level),VBAR)
## In state 48, spurious reduction of production type_expr -> sum_type(fun_type_level)
## In state 97, spurious reduction of production type_decl -> Type Ident EQ type_expr
##
interactive_expr: If Verbatim Then Match Verbatim With WILD ARROW Type Ident EQ UIdent With
##
## Ends in an error in state: 722.
##
## local_type_decl(base_cond) -> type_decl . In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## local_type_decl(base_if_then_else) -> type_decl . In base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## type_decl
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 26, spurious reduction of production variant(fun_type_level) -> UIdent
## In state 37, spurious reduction of production nsepseq(variant(fun_type_level),VBAR) -> variant(fun_type_level)
## In state 66, spurious reduction of production sum_type(fun_type_level) -> nsepseq(variant(fun_type_level),VBAR)
## In state 48, spurious reduction of production type_expr -> sum_type(fun_type_level)
## In state 97, spurious reduction of production type_decl -> Type Ident EQ type_expr
##
interactive_expr: Begin If Verbatim Then Type Ident EQ UIdent With
##
## Ends in an error in state: 871.
##
## local_type_decl(closed_expr) -> type_decl . In closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## type_decl
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 26, spurious reduction of production variant(fun_type_level) -> UIdent
## In state 37, spurious reduction of production nsepseq(variant(fun_type_level),VBAR) -> variant(fun_type_level)
## In state 66, spurious reduction of production sum_type(fun_type_level) -> nsepseq(variant(fun_type_level),VBAR)
## In state 48, spurious reduction of production type_expr -> sum_type(fun_type_level)
## In state 97, spurious reduction of production type_decl -> Type Ident EQ type_expr
##
interactive_expr: If Verbatim Then Type Ident EQ UIdent With
##
## Ends in an error in state: 1013.
##
## local_type_decl(closed_expr) -> type_decl . In closed_expr [ Else ]
## local_type_decl(expr) -> type_decl . In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## type_decl
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 26, spurious reduction of production variant(fun_type_level) -> UIdent
## In state 37, spurious reduction of production nsepseq(variant(fun_type_level),VBAR) -> variant(fun_type_level)
## In state 66, spurious reduction of production sum_type(fun_type_level) -> nsepseq(variant(fun_type_level),VBAR)
## In state 48, spurious reduction of production type_expr -> sum_type(fun_type_level)
## In state 97, spurious reduction of production type_decl -> Type Ident EQ type_expr
##
interactive_expr: Match Verbatim With WILD ARROW If Verbatim Then Type Ident EQ UIdent With
##
## Ends in an error in state: 629.
##
## local_type_decl(base_cond) -> type_decl . In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## local_type_decl(closed_expr) -> type_decl . In closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## type_decl
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 26, spurious reduction of production variant(fun_type_level) -> UIdent
## In state 37, spurious reduction of production nsepseq(variant(fun_type_level),VBAR) -> variant(fun_type_level)
## In state 66, spurious reduction of production sum_type(fun_type_level) -> nsepseq(variant(fun_type_level),VBAR)
## In state 48, spurious reduction of production type_expr -> sum_type(fun_type_level)
## In state 97, spurious reduction of production type_decl -> Type Ident EQ type_expr
##
interactive_expr: Match Verbatim With WILD ARROW Type Ident EQ UIdent With
##
## Ends in an error in state: 803.
##
## local_type_decl(base_cond) -> type_decl . In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## type_decl
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 26, spurious reduction of production variant(fun_type_level) -> UIdent
## In state 37, spurious reduction of production nsepseq(variant(fun_type_level),VBAR) -> variant(fun_type_level)
## In state 66, spurious reduction of production sum_type(fun_type_level) -> nsepseq(variant(fun_type_level),VBAR)
## In state 48, spurious reduction of production type_expr -> sum_type(fun_type_level)
## In state 97, spurious reduction of production type_decl -> Type Ident EQ type_expr
##

Ill-formed local type declaration.
At this point, if the type expression is complete, the keyword 'in' is
expected, followed by an expression.

contract: Type Ident EQ UIdent End
##
## Ends in an error in state: 1173.
##
## contract -> module_ . EOF [ # ]
##
## The known suffix of the stack is as follows:
## module_
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 26, spurious reduction of production variant(fun_type_level) -> UIdent
## In state 37, spurious reduction of production nsepseq(variant(fun_type_level),VBAR) -> variant(fun_type_level)
## In state 66, spurious reduction of production sum_type(fun_type_level) -> nsepseq(variant(fun_type_level),VBAR)
## In state 48, spurious reduction of production type_expr -> sum_type(fun_type_level)
## In state 97, spurious reduction of production type_decl -> Type Ident EQ type_expr
## In state 1156, spurious reduction of production declaration -> type_decl
## In state 1168, spurious reduction of production seq(declaration) ->
## In state 1169, spurious reduction of production nseq(declaration) -> declaration seq(declaration)
## In state 1157, spurious reduction of production module_ -> nseq(declaration)
##
contract: Directive With
##
## Ends in an error in state: 1168.
##
## nseq(declaration) -> declaration . seq(declaration) [ End EOF ]
##
## The known suffix of the stack is as follows:
## declaration
##
contract: Directive Directive With
##
## Ends in an error in state: 1170.
##
## seq(declaration) -> declaration . seq(declaration) [ End EOF ]
##
## The known suffix of the stack is as follows:
## declaration
##

Ill-formed contract.
At this point, if the declaration is complete, one the following is
expected:
  * another declaration;
  * the end of the file.

contract: Module UIdent EQ Struct Type Ident EQ UIdent EOF
##
## Ends in an error in state: 1165.
##
## module_decl -> Module UIdent EQ Struct module_ . End [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## Module UIdent EQ Struct module_
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 26, spurious reduction of production variant(fun_type_level) -> UIdent
## In state 37, spurious reduction of production nsepseq(variant(fun_type_level),VBAR) -> variant(fun_type_level)
## In state 66, spurious reduction of production sum_type(fun_type_level) -> nsepseq(variant(fun_type_level),VBAR)
## In state 48, spurious reduction of production type_expr -> sum_type(fun_type_level)
## In state 97, spurious reduction of production type_decl -> Type Ident EQ type_expr
## In state 1156, spurious reduction of production declaration -> type_decl
## In state 1168, spurious reduction of production seq(declaration) ->
## In state 1169, spurious reduction of production nseq(declaration) -> declaration seq(declaration)
## In state 1157, spurious reduction of production module_ -> nseq(declaration)
##

Ill-formed module declaration.
At this point, if the declaration is complete, one the following is
expected:
  * another declaration;
  * the end of the file.

contract: Module UIdent EQ With
##
## Ends in an error in state: 106.
##
## module_alias -> Module UIdent EQ . nsepseq(module_name,DOT) [ Type Module Let In End EOF Directive Attr ]
## module_decl -> Module UIdent EQ . Struct module_ End [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## Module UIdent EQ
##

Ill-formed module declaration or module alias declaration.
At this point, one of the following is expected:
  * the qualified name of a module being aliased;
  * the keyword 'struct' followed by declarations, if
    defining a module.

contract: Module UIdent With
##
## Ends in an error in state: 105.
##
## module_alias -> Module UIdent . EQ nsepseq(module_name,DOT) [ Type Module Let In End EOF Directive Attr ]
## module_decl -> Module UIdent . EQ Struct module_ End [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## Module UIdent
##

Ill-formed module declaration.
At this point, the assignment symbol '=' is expected to introduce
either the qualified name of a module being aliased, or a module
structure.

contract: Module With
##
## Ends in an error in state: 104.
##
## module_alias -> Module . UIdent EQ nsepseq(module_name,DOT) [ Type Module Let In End EOF Directive Attr ]
## module_decl -> Module . UIdent EQ Struct module_ End [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## Module
##

Ill-formed module declaration.
At this point, the name of the module being declared or aliased is
expected.

interactive_expr: Module UIdent EQ Struct Type Ident EQ UIdent End With
##
## Ends in an error in state: 367.
##
## local_module_decl(expr) -> module_decl . In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## module_decl
##
interactive_expr: Match Verbatim With WILD ARROW If Verbatim Then Module UIdent EQ Struct Type Ident EQ UIdent End With
##
## Ends in an error in state: 637.
##
## local_module_decl(base_cond) -> module_decl . In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## local_module_decl(closed_expr) -> module_decl . In closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## module_decl
##
interactive_expr: Match Verbatim With WILD ARROW Module UIdent EQ Struct Type Ident EQ UIdent End With
##
## Ends in an error in state: 811.
##
## local_module_decl(base_cond) -> module_decl . In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## module_decl
##
interactive_expr: If Verbatim Then Match Verbatim With WILD ARROW Module UIdent EQ Struct Type Ident EQ UIdent End With
##
## Ends in an error in state: 730.
##
## local_module_decl(base_cond) -> module_decl . In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## local_module_decl(base_if_then_else) -> module_decl . In base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## module_decl
##
interactive_expr: If Verbatim Then Module UIdent EQ Struct Type Ident EQ UIdent End With
##
## Ends in an error in state: 1021.
##
## local_module_decl(closed_expr) -> module_decl . In closed_expr [ Else ]
## local_module_decl(expr) -> module_decl . In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## module_decl
##
interactive_expr: Begin If Verbatim Then Module UIdent EQ Struct Type Ident EQ UIdent End With
##
## Ends in an error in state: 879.
##
## local_module_decl(closed_expr) -> module_decl . In closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## module_decl
##

Ill-formed local module declaration.
At this point, the keyword 'in' is expected, followed by an
expression.

interactive_expr: Module UIdent EQ UIdent Type
##
## Ends in an error in state: 369.
##
## local_module_alias(expr) -> module_alias . In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## module_alias
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 107, spurious reduction of production nsepseq(module_name,DOT) -> UIdent
## In state 1172, spurious reduction of production module_alias -> Module UIdent EQ nsepseq(module_name,DOT)
##
interactive_expr: Match Verbatim With WILD ARROW If Verbatim Then Module UIdent EQ UIdent Type
##
## Ends in an error in state: 639.
##
## local_module_alias(base_cond) -> module_alias . In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## local_module_alias(closed_expr) -> module_alias . In closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## module_alias
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 107, spurious reduction of production nsepseq(module_name,DOT) -> UIdent
## In state 1172, spurious reduction of production module_alias -> Module UIdent EQ nsepseq(module_name,DOT)
##
interactive_expr: If Verbatim Then Match Verbatim With WILD ARROW Module UIdent EQ UIdent Type
##
## Ends in an error in state: 732.
##
## local_module_alias(base_cond) -> module_alias . In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## local_module_alias(base_if_then_else) -> module_alias . In base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## module_alias
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 107, spurious reduction of production nsepseq(module_name,DOT) -> UIdent
## In state 1172, spurious reduction of production module_alias -> Module UIdent EQ nsepseq(module_name,DOT)
##
interactive_expr: Match Verbatim With WILD ARROW Module UIdent EQ UIdent Type
##
## Ends in an error in state: 813.
##
## local_module_alias(base_cond) -> module_alias . In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## module_alias
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 107, spurious reduction of production nsepseq(module_name,DOT) -> UIdent
## In state 1172, spurious reduction of production module_alias -> Module UIdent EQ nsepseq(module_name,DOT)
##
interactive_expr: Begin If Verbatim Then Module UIdent EQ UIdent Type
##
## Ends in an error in state: 881.
##
## local_module_alias(closed_expr) -> module_alias . In closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## module_alias
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 107, spurious reduction of production nsepseq(module_name,DOT) -> UIdent
## In state 1172, spurious reduction of production module_alias -> Module UIdent EQ nsepseq(module_name,DOT)
##
interactive_expr: If Verbatim Then Module UIdent EQ UIdent Type
##
## Ends in an error in state: 1023.
##
## local_module_alias(closed_expr) -> module_alias . In closed_expr [ Else ]
## local_module_alias(expr) -> module_alias . In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## module_alias
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 107, spurious reduction of production nsepseq(module_name,DOT) -> UIdent
## In state 1172, spurious reduction of production module_alias -> Module UIdent EQ nsepseq(module_name,DOT)
##

Ill-formed local module declaration.
At this point, if the module to be aliased is fully qualified, the
keyword 'in' is expected, followed by an expression.

contract: Module UIdent EQ UIdent DOT With
##
## Ends in an error in state: 108.
##
## nsepseq(module_name,DOT) -> UIdent DOT . nsepseq(module_name,DOT) [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## UIdent DOT
##

Ill-formed module qualification.
At this point, a module name is expected.

contract: Type QUOTE With
##
## Ends in an error in state: 2.
##
## type_var -> QUOTE . Ident [ VBAR Type TIMES SEMI RPAR RBRACE Module Let In Ident End EQ EOF Directive COMMA Attr ARROW ]
##
## The known suffix of the stack is as follows:
## QUOTE
##

Ill-formed quoted type parameter.
At this point, an identifier is expected.

contract: Type QUOTE Ident With
##
## Ends in an error in state: 99.
##
## type_decl -> Type quoted_type_params . Ident EQ type_expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## Type quoted_type_params
##

Ill-formed parametric type declaration.
At this point, the name of the type being defined is expected.

interactive_expr: Match Verbatim With LBRACE Ident SEMI Ident EQ Bytes With
##
## Ends in an error in state: 565.
##
## nsepseq(field_pattern(core_pattern),SEMI) -> field_pattern(core_pattern) . [ RBRACE ]
## nsepseq(field_pattern(core_pattern),SEMI) -> field_pattern(core_pattern) . SEMI nsepseq(field_pattern(core_pattern),SEMI) [ RBRACE ]
## seq(__anonymous_0(field_pattern(core_pattern),SEMI)) -> field_pattern(core_pattern) . SEMI seq(__anonymous_0(field_pattern(core_pattern),SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_pattern(core_pattern)
##
interactive_expr: Match Verbatim With LBRACE Ident EQ Bytes With
##
## Ends in an error in state: 561.
##
## nsepseq(field_pattern(core_pattern),SEMI) -> field_pattern(core_pattern) . [ RBRACE ]
## nsepseq(field_pattern(core_pattern),SEMI) -> field_pattern(core_pattern) . SEMI nsepseq(field_pattern(core_pattern),SEMI) [ RBRACE ]
## nseq(__anonymous_0(field_pattern(core_pattern),SEMI)) -> field_pattern(core_pattern) . SEMI seq(__anonymous_0(field_pattern(core_pattern),SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_pattern(core_pattern)
##
contract: Let LBRACE Ident EQ WILD COMMA Ident With
##
## Ends in an error in state: 209.
##
## nsepseq(field_pattern(irrefutable),SEMI) -> field_pattern(irrefutable) . [ RBRACE ]
## nsepseq(field_pattern(irrefutable),SEMI) -> field_pattern(irrefutable) . SEMI nsepseq(field_pattern(irrefutable),SEMI) [ RBRACE ]
## nseq(__anonymous_0(field_pattern(irrefutable),SEMI)) -> field_pattern(irrefutable) . SEMI seq(__anonymous_0(field_pattern(irrefutable),SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_pattern(irrefutable)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 166, spurious reduction of production nsepseq(core_irrefutable,COMMA) -> var_pattern
## In state 217, spurious reduction of production tuple(core_irrefutable) -> WILD COMMA nsepseq(core_irrefutable,COMMA)
## In state 192, spurious reduction of production field_pattern(irrefutable) -> Ident EQ tuple(core_irrefutable)
##
contract: Let LBRACE Ident SEMI Ident EQ WILD COMMA Ident With
##
## Ends in an error in state: 213.
##
## nsepseq(field_pattern(irrefutable),SEMI) -> field_pattern(irrefutable) . [ RBRACE ]
## nsepseq(field_pattern(irrefutable),SEMI) -> field_pattern(irrefutable) . SEMI nsepseq(field_pattern(irrefutable),SEMI) [ RBRACE ]
## seq(__anonymous_0(field_pattern(irrefutable),SEMI)) -> field_pattern(irrefutable) . SEMI seq(__anonymous_0(field_pattern(irrefutable),SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_pattern(irrefutable)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 166, spurious reduction of production nsepseq(core_irrefutable,COMMA) -> var_pattern
## In state 217, spurious reduction of production tuple(core_irrefutable) -> WILD COMMA nsepseq(core_irrefutable,COMMA)
## In state 192, spurious reduction of production field_pattern(irrefutable) -> Ident EQ tuple(core_irrefutable)
##

Ill-formed record pattern.
At this point, if the field pattern is complete, one of the following
is expected:
  * a semicolon ';' followed by another field pattern;
  * a closing brace '}' if the record pattern is complete.

interactive_expr: Fun LBRACE Ident SEMI With
##
## Ends in an error in state: 210.
##
## nsepseq(field_pattern(irrefutable),SEMI) -> field_pattern(irrefutable) SEMI . nsepseq(field_pattern(irrefutable),SEMI) [ RBRACE ]
## nseq(__anonymous_0(field_pattern(irrefutable),SEMI)) -> field_pattern(irrefutable) SEMI . seq(__anonymous_0(field_pattern(irrefutable),SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_pattern(irrefutable) SEMI
##
interactive_expr: Fun LBRACE Ident SEMI Ident SEMI With
##
## Ends in an error in state: 214.
##
## nsepseq(field_pattern(irrefutable),SEMI) -> field_pattern(irrefutable) SEMI . nsepseq(field_pattern(irrefutable),SEMI) [ RBRACE ]
## seq(__anonymous_0(field_pattern(irrefutable),SEMI)) -> field_pattern(irrefutable) SEMI . seq(__anonymous_0(field_pattern(irrefutable),SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_pattern(irrefutable) SEMI
##
interactive_expr: Match Verbatim With LBRACE Ident SEMI With
##
## Ends in an error in state: 562.
##
## nsepseq(field_pattern(core_pattern),SEMI) -> field_pattern(core_pattern) SEMI . nsepseq(field_pattern(core_pattern),SEMI) [ RBRACE ]
## nseq(__anonymous_0(field_pattern(core_pattern),SEMI)) -> field_pattern(core_pattern) SEMI . seq(__anonymous_0(field_pattern(core_pattern),SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_pattern(core_pattern) SEMI
##
interactive_expr: Match Verbatim With LBRACE Ident SEMI Ident SEMI With
##
## Ends in an error in state: 566.
##
## nsepseq(field_pattern(core_pattern),SEMI) -> field_pattern(core_pattern) SEMI . nsepseq(field_pattern(core_pattern),SEMI) [ RBRACE ]
## seq(__anonymous_0(field_pattern(core_pattern),SEMI)) -> field_pattern(core_pattern) SEMI . seq(__anonymous_0(field_pattern(core_pattern),SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_pattern(core_pattern) SEMI
##

Ill-formed record pattern.
At this point, if the field pattern is complete, one of the following
is expected:
  * another field pattern starting with a field name;
  * a closing brace '}' if the record pattern is complete.

contract: Let Ident LPAR Type With
##
## Ends in an error in state: 114.
##
## type_param_list -> Type . nseq(variable) [ RPAR ]
##
## The known suffix of the stack is as follows:
## Type
##

Ill-formed type parameter.
At this point, a type parameter without a quote is expected.

contract: Let Ident LPAR Type Ident With
##
## Ends in an error in state: 115.
##
## nseq(variable) -> Ident . seq(variable) [ RPAR ]
##
## The known suffix of the stack is as follows:
## Ident
##
contract: Let Ident LPAR Type Ident Ident With
##
## Ends in an error in state: 116.
##
## seq(variable) -> Ident . seq(variable) [ RPAR ]
##
## The known suffix of the stack is as follows:
## Ident
##

Ill-formed type parameters.
At this point, one of the following is expected:
  * a type parameter without a quote;
  * a closing parenthesis ')' if there are no more parameters.

interactive_expr: Match Verbatim With LBRACKET WILD SEMI WILD With
##
## Ends in an error in state: 580.
##
## nsepseq(cons_pattern_level,SEMI) -> cons_pattern_level . [ RBRACKET ]
## nsepseq(cons_pattern_level,SEMI) -> cons_pattern_level . SEMI nsepseq(cons_pattern_level,SEMI) [ RBRACKET ]
## seq(__anonymous_0(cons_pattern_level,SEMI)) -> cons_pattern_level . SEMI seq(__anonymous_0(cons_pattern_level,SEMI)) [ RBRACKET ]
##
## The known suffix of the stack is as follows:
## cons_pattern_level
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 573, spurious reduction of production cons_pattern_level -> core_pattern
##
interactive_expr: Match Verbatim With LBRACKET WILD With
##
## Ends in an error in state: 576.
##
## nsepseq(cons_pattern_level,SEMI) -> cons_pattern_level . [ RBRACKET ]
## nsepseq(cons_pattern_level,SEMI) -> cons_pattern_level . SEMI nsepseq(cons_pattern_level,SEMI) [ RBRACKET ]
## nseq(__anonymous_0(cons_pattern_level,SEMI)) -> cons_pattern_level . SEMI seq(__anonymous_0(cons_pattern_level,SEMI)) [ RBRACKET ]
##
## The known suffix of the stack is as follows:
## cons_pattern_level
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 573, spurious reduction of production cons_pattern_level -> core_pattern
##

Ill-formed list of patterns.
At this point, if the element as a pattern is complete, one of
the following is expected:
  * a semicolon ';' followed by another pattern;
  * a closing bracket ']' if the list is complete.

interactive_expr: Match Verbatim With LPAR WILD COLON UIdent With
##
## Ends in an error in state: 583.
##
## par(typed_pattern) -> LPAR typed_pattern . RPAR [ SEMI RPAR RBRACKET RBRACE CONS COMMA COLON ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR typed_pattern
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 26, spurious reduction of production variant(fun_type_level) -> UIdent
## In state 37, spurious reduction of production nsepseq(variant(fun_type_level),VBAR) -> variant(fun_type_level)
## In state 66, spurious reduction of production sum_type(fun_type_level) -> nsepseq(variant(fun_type_level),VBAR)
## In state 48, spurious reduction of production type_expr -> sum_type(fun_type_level)
## In state 219, spurious reduction of production type_annotation(type_expr) -> COLON type_expr
## In state 588, spurious reduction of production typed_pattern -> pattern type_annotation(type_expr)
##

Ill-formed parenthesised pattern.
At this point, if the type annotation is complete, a closing
parenthesis ')' is expected.

contract: Type LPAR With
##
## Ends in an error in state: 4.
##
## par(tuple(type_var)) -> LPAR . tuple(type_var) RPAR [ Ident ]
##
## The known suffix of the stack is as follows:
## LPAR
##
contract: Type LPAR QUOTE Ident COMMA QUOTE Ident COMMA With
##
## Ends in an error in state: 8.
##
## nsepseq(type_var,COMMA) -> type_var COMMA . nsepseq(type_var,COMMA) [ RPAR ]
##
## The known suffix of the stack is as follows:
## type_var COMMA
##
contract: Type LPAR QUOTE Ident COMMA With
##
## Ends in an error in state: 6.
##
## tuple(type_var) -> type_var COMMA . nsepseq(type_var,COMMA) [ RPAR ]
##
## The known suffix of the stack is as follows:
## type_var COMMA
##

Ill-formed parametric type declaration.
At this point, a quoted type parameter is expected, like 'a.

contract: Type LPAR QUOTE Ident With
##
## Ends in an error in state: 5.
##
## tuple(type_var) -> type_var . COMMA nsepseq(type_var,COMMA) [ RPAR ]
##
## The known suffix of the stack is as follows:
## type_var
##

Ill-formed parametric type declaration.
At this point, a comma ',' is expected, followed by another quoted
type parameter, like 'a.

contract: Type LPAR QUOTE Ident COMMA QUOTE Ident With
##
## Ends in an error in state: 7.
##
## nsepseq(type_var,COMMA) -> type_var . [ RPAR ]
## nsepseq(type_var,COMMA) -> type_var . COMMA nsepseq(type_var,COMMA) [ RPAR ]
##
## The known suffix of the stack is as follows:
## type_var
##

Ill-formed parametric type declaration.
At this point, one of the following is expected:
  * a comma ',' followed by another quoted type parameter, like 'a;
  * a closing parenthesis ')' if there are no more parameters.

interactive_expr: LPAR UIdent COLON LPAR Ident COMMA Ident RPAR With
##
## Ends in an error in state: 45.
##
## type_constr_app -> type_constr_arg . Ident [ VBAR Type TIMES SEMI RPAR RBRACE Module Let In Ident End EQ EOF Directive COMMA Attr ARROW ]
##
## The known suffix of the stack is as follows:
## type_constr_arg
##

Ill-formed type expression.
At this point, a type constructor is expected.
Note: A type constructor is the analogue of a function name at the
type level. For example, 'list', 'map' and 'set' are type
constructors. Contrary to function names, type constructors are
written after their arguments.

contract: Let Ident COLON LBRACE Attr Ident With
##
## Ends in an error in state: 60.
##
## field_decl -> nseq(Attr) Ident . COLON type_expr [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Ident
##
contract: Type Ident EQ LBRACE Ident With
##
## Ends in an error in state: 29.
##
## field_decl -> Ident . COLON type_expr [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## Ident
##

Ill-formed record type.
At this point, a type annotation for the field is expected, starting
with a colon ':'.

contract: Let Ident COLON LBRACE Ident COLON With
##
## Ends in an error in state: 30.
##
## field_decl -> Ident COLON . type_expr [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## Ident COLON
##
contract: Let Ident COLON LBRACE Attr Ident COLON With
##
## Ends in an error in state: 61.
##
## field_decl -> nseq(Attr) Ident COLON . type_expr [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Ident COLON
##

Ill-formed record type.
At this point, the type of the field is expected.

contract: Let Ident COLON LBRACE Attr With
##
## Ends in an error in state: 59.
##
## field_decl -> nseq(Attr) . Ident COLON type_expr [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## nseq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 33, spurious reduction of production seq(Attr) ->
## In state 36, spurious reduction of production nseq(Attr) -> Attr seq(Attr)
##

Ill-formed record type.
At this point, if the attribute is complete, a field name is expected.

contract: Let Ident COLON LBRACE Ident COLON Ident SEMI With
##
## Ends in an error in state: 77.
##
## nsepseq(field_decl,SEMI) -> field_decl SEMI . nsepseq(field_decl,SEMI) [ RBRACE ]
## nseq(__anonymous_0(field_decl,SEMI)) -> field_decl SEMI . seq(__anonymous_0(field_decl,SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_decl SEMI
##
contract: Let Ident COLON LBRACE Ident COLON Ident SEMI Ident COLON Ident SEMI With
##
## Ends in an error in state: 81.
##
## nsepseq(field_decl,SEMI) -> field_decl SEMI . nsepseq(field_decl,SEMI) [ RBRACE ]
## seq(__anonymous_0(field_decl,SEMI)) -> field_decl SEMI . seq(__anonymous_0(field_decl,SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_decl SEMI
##

Ill-formed record type.
At this point one of the following is expected:
  * a field declaration, starting with a field name;
  * a closing brace '}' if the record is complete.

contract: Let Ident COLON With
##
## Ends in an error in state: 218.
##
## type_annotation(type_expr) -> COLON . type_expr [ RPAR EQ ]
##
## The known suffix of the stack is as follows:
## COLON
##
interactive_expr: Fun Ident COLON With
##
## Ends in an error in state: 292.
##
## type_annotation(lambda_app_type) -> COLON . lambda_app_type [ ARROW ]
##
## The known suffix of the stack is as follows:
## COLON
##

Ill-formed type annotation.
At this point, a type expression is expected.
Note: If you want a functional type, enclose it between parentheses.

interactive_expr: LPAR UIdent COLON With
##
## Ends in an error in state: 1136.
##
## typed_expr -> expr COLON . type_expr [ RPAR ]
##
## The known suffix of the stack is as follows:
## expr COLON
##

Ill-formed typed expression.
At this point, a type expression is expected.

contract: Let Ident COLON LPAR Ident COMMA With
##
## Ends in an error in state: 88.
##
## tuple(type_expr) -> type_expr COMMA . nsepseq(type_expr,COMMA) [ RPAR ]
##
## The known suffix of the stack is as follows:
## type_expr COMMA
##
contract: Let Ident COLON LPAR Ident COMMA Ident COMMA With
##
## Ends in an error in state: 90.
##
## nsepseq(type_expr,COMMA) -> type_expr COMMA . nsepseq(type_expr,COMMA) [ RPAR ]
##
## The known suffix of the stack is as follows:
## type_expr COMMA
##

Ill-formed parametric type expression.
At this point, a type argument is expected as a type expression.

contract: Module UIdent EQ Struct With
##
## Ends in an error in state: 110.
##
## module_decl -> Module UIdent EQ Struct . module_ End [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## Module UIdent EQ Struct
##

Ill-formed module declaration.
At this point, declarations are expected.

contract: Let LPAR With
##
## Ends in an error in state: 153.
##
## par(irrefutable) -> LPAR . tuple(core_irrefutable) RPAR [ WILD UIdent SEMI RPAR RBRACE LPAR LBRACE Ident EQ COMMA COLON Attr ARROW ]
## par(irrefutable) -> LPAR . WILD RPAR [ WILD UIdent SEMI RPAR RBRACE LPAR LBRACE Ident EQ COMMA COLON Attr ARROW ]
## par(irrefutable) -> LPAR . var_pattern RPAR [ WILD UIdent SEMI RPAR RBRACE LPAR LBRACE Ident EQ COMMA COLON Attr ARROW ]
## par(irrefutable) -> LPAR . unit RPAR [ WILD UIdent SEMI RPAR RBRACE LPAR LBRACE Ident EQ COMMA COLON Attr ARROW ]
## par(irrefutable) -> LPAR . record_pattern(irrefutable) RPAR [ WILD UIdent SEMI RPAR RBRACE LPAR LBRACE Ident EQ COMMA COLON Attr ARROW ]
## par(irrefutable) -> LPAR . par(typed_irrefutable) RPAR [ WILD UIdent SEMI RPAR RBRACE LPAR LBRACE Ident EQ COMMA COLON Attr ARROW ]
## par(irrefutable) -> LPAR . par(irrefutable) RPAR [ WILD UIdent SEMI RPAR RBRACE LPAR LBRACE Ident EQ COMMA COLON Attr ARROW ]
## par(irrefutable) -> LPAR . constr_irrefutable RPAR [ WILD UIdent SEMI RPAR RBRACE LPAR LBRACE Ident EQ COMMA COLON Attr ARROW ]
## par(non_const_constr_irrefutable) -> LPAR . non_const_constr_irrefutable RPAR [ WILD UIdent SEMI RPAR RBRACE LPAR LBRACE Ident EQ COMMA COLON Attr ARROW ]
## par(typed_irrefutable) -> LPAR . typed_irrefutable RPAR [ WILD UIdent SEMI RPAR RBRACE LPAR LBRACE Ident EQ COMMA COLON Attr ARROW ]
## unit -> LPAR . RPAR [ WILD UIdent SEMI RPAR RBRACE LPAR LBRACE Ident EQ COMMA COLON Attr ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR
##
interactive_expr: Match UIdent With LPAR With
##
## Ends in an error in state: 542.
##
## par(pattern) -> LPAR . pattern RPAR [ SEMI RPAR RBRACKET RBRACE CONS COMMA COLON ARROW ]
## par(typed_pattern) -> LPAR . typed_pattern RPAR [ SEMI RPAR RBRACKET RBRACE CONS COMMA COLON ARROW ]
## unit -> LPAR . RPAR [ SEMI RPAR RBRACKET RBRACE CONS COMMA COLON ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR
##

Ill-formed pattern.
At this point, one of the following is expected:
  * a pattern followed by a closing parenthesis ')';
  * a closing parenthesis ')' if matching the unit value '()'.

contract: Let LBRACE Ident EQ With
##
## Ends in an error in state: 161.
##
## field_pattern(irrefutable) -> Ident EQ . tuple(core_irrefutable) [ SEMI RBRACE ]
## field_pattern(irrefutable) -> Ident EQ . WILD [ SEMI RBRACE ]
## field_pattern(irrefutable) -> Ident EQ . var_pattern [ SEMI RBRACE ]
## field_pattern(irrefutable) -> Ident EQ . unit [ SEMI RBRACE ]
## field_pattern(irrefutable) -> Ident EQ . record_pattern(irrefutable) [ SEMI RBRACE ]
## field_pattern(irrefutable) -> Ident EQ . par(typed_irrefutable) [ SEMI RBRACE ]
## field_pattern(irrefutable) -> Ident EQ . par(irrefutable) [ SEMI RBRACE ]
## field_pattern(irrefutable) -> Ident EQ . constr_irrefutable [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## Ident EQ
##

Ill-formed record pattern.
At this point, an irrefutable pattern matching the field is expected,
e.g. a variable.

interactive_expr: Match UIdent With LBRACE Ident EQ With
##
## Ends in an error in state: 546.
##
## field_pattern(core_pattern) -> Ident EQ . core_pattern [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## Ident EQ
##

Ill-formed record pattern.
At this point, a pattern matching the field is expected.

contract: Let Attr With
##
## Ends in an error in state: 177.
##
## var_pattern -> nseq(Attr) . Ident [ WILD UIdent SEMI RPAR RBRACKET RBRACE LPAR LBRACE Ident EQ CONS COMMA COLON Attr ARROW ]
##
## The known suffix of the stack is as follows:
## nseq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 33, spurious reduction of production seq(Attr) ->
## In state 36, spurious reduction of production nseq(Attr) -> Attr seq(Attr)
##

Ill-formed attributed variable in a pattern.
At this point, if the attribute is complete, an identifier is
expected.

contract: Let Ident COLON Ident EQ With
##
## Ends in an error in state: 1087.
##
## let_binding -> var_pattern type_annotation(type_expr) EQ . expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## var_pattern type_annotation(type_expr) EQ
##
contract: Let Ident EQ With
##
## Ends in an error in state: 272.
##
## let_binding -> var_pattern EQ . expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## var_pattern EQ
##
contract: Let Ident Ident EQ With
##
## Ends in an error in state: 1090.
##
## let_binding -> var_pattern parameters EQ . expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## var_pattern parameters EQ
##
contract: Let Ident Ident COLON Ident EQ With
##
## Ends in an error in state: 1093.
##
## let_binding -> var_pattern parameters type_annotation(type_expr) EQ . expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## var_pattern parameters type_annotation(type_expr) EQ
##
contract: Let WILD EQ With
##
## Ends in an error in state: 122.
##
## let_binding -> WILD EQ . expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## WILD EQ
##
contract: Let LPAR RPAR COLON Ident EQ With
##
## Ends in an error in state: 442.
##
## let_binding -> unit type_annotation(type_expr) EQ . expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## unit type_annotation(type_expr) EQ
##
contract: Let LPAR RPAR EQ With
##
## Ends in an error in state: 353.
##
## let_binding -> unit EQ . expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## unit EQ
##
contract: Let LPAR RPAR LPAR Type Ident RPAR EQ With
##
## Ends in an error in state: 445.
##
## let_binding -> unit par(type_param_list) EQ . expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## unit par(type_param_list) EQ
##
contract: Let LPAR RPAR LPAR Type Ident RPAR COLON Ident EQ With
##
## Ends in an error in state: 448.
##
## let_binding -> unit par(type_param_list) type_annotation(type_expr) EQ . expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## unit par(type_param_list) type_annotation(type_expr) EQ
##
contract: Let WILD COMMA Ident EQ With
##
## Ends in an error in state: 451.
##
## let_binding -> tuple(core_irrefutable) EQ . expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## tuple(core_irrefutable) EQ
##
contract: Let WILD COMMA Ident COLON Ident EQ With
##
## Ends in an error in state: 454.
##
## let_binding -> tuple(core_irrefutable) type_annotation(type_expr) EQ . expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## tuple(core_irrefutable) type_annotation(type_expr) EQ
##
contract: Let WILD COMMA Ident LPAR Type Ident RPAR EQ With
##
## Ends in an error in state: 457.
##
## let_binding -> tuple(core_irrefutable) par(type_param_list) EQ . expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## tuple(core_irrefutable) par(type_param_list) EQ
##
contract: Let WILD COMMA Ident LPAR Type Ident RPAR COLON Ident EQ With
##
## Ends in an error in state: 460.
##
## let_binding -> tuple(core_irrefutable) par(type_param_list) type_annotation(type_expr) EQ . expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## tuple(core_irrefutable) par(type_param_list) type_annotation(type_expr) EQ
##
contract: Let LBRACE Ident RBRACE EQ With
##
## Ends in an error in state: 463.
##
## let_binding -> record_pattern(irrefutable) EQ . expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## record_pattern(irrefutable) EQ
##
contract: Let LBRACE Ident RBRACE COLON Ident EQ With
##
## Ends in an error in state: 466.
##
## let_binding -> record_pattern(irrefutable) type_annotation(type_expr) EQ . expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## record_pattern(irrefutable) type_annotation(type_expr) EQ
##
contract: Let LBRACE Ident RBRACE LPAR Type Ident RPAR EQ With
##
## Ends in an error in state: 469.
##
## let_binding -> record_pattern(irrefutable) par(type_param_list) EQ . expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## record_pattern(irrefutable) par(type_param_list) EQ
##
contract: Let LBRACE Ident RBRACE LPAR Type Ident RPAR COLON Ident EQ With
##
## Ends in an error in state: 472.
##
## let_binding -> record_pattern(irrefutable) par(type_param_list) type_annotation(type_expr) EQ . expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## record_pattern(irrefutable) par(type_param_list) type_annotation(type_expr) EQ
##
contract: Let LPAR UIdent COLON Ident RPAR EQ With
##
## Ends in an error in state: 475.
##
## let_binding -> par(typed_irrefutable) EQ . expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## par(typed_irrefutable) EQ
##
contract: Let LPAR UIdent COLON Ident RPAR COLON Ident EQ With
##
## Ends in an error in state: 478.
##
## let_binding -> par(typed_irrefutable) type_annotation(type_expr) EQ . expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## par(typed_irrefutable) type_annotation(type_expr) EQ
##
contract: Let LPAR UIdent COLON Ident RPAR LPAR Type Ident RPAR EQ With
##
## Ends in an error in state: 481.
##
## let_binding -> par(typed_irrefutable) par(type_param_list) EQ . expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## par(typed_irrefutable) par(type_param_list) EQ
##
contract: Let LPAR UIdent COLON Ident RPAR LPAR Type Ident RPAR COLON Ident EQ With
##
## Ends in an error in state: 484.
##
## let_binding -> par(typed_irrefutable) par(type_param_list) type_annotation(type_expr) EQ . expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## par(typed_irrefutable) par(type_param_list) type_annotation(type_expr) EQ
##
contract: Let LPAR WILD RPAR EQ With
##
## Ends in an error in state: 487.
##
## let_binding -> par(irrefutable) EQ . expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## par(irrefutable) EQ
##
contract: Let LPAR WILD RPAR COLON Ident EQ With
##
## Ends in an error in state: 490.
##
## let_binding -> par(irrefutable) type_annotation(type_expr) EQ . expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## par(irrefutable) type_annotation(type_expr) EQ
##
contract: Let LPAR WILD RPAR LPAR Type Ident RPAR EQ With
##
## Ends in an error in state: 493.
##
## let_binding -> par(irrefutable) par(type_param_list) EQ . expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## par(irrefutable) par(type_param_list) EQ
##
contract: Let LPAR WILD RPAR LPAR Type Ident RPAR COLON Ident EQ With
##
## Ends in an error in state: 496.
##
## let_binding -> par(irrefutable) par(type_param_list) type_annotation(type_expr) EQ . expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## par(irrefutable) par(type_param_list) type_annotation(type_expr) EQ
##
contract: Let UIdent EQ With
##
## Ends in an error in state: 502.
##
## let_binding -> constr_irrefutable EQ . expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## constr_irrefutable EQ
##
contract: Let UIdent COLON Ident EQ With
##
## Ends in an error in state: 505.
##
## let_binding -> constr_irrefutable type_annotation(type_expr) EQ . expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## constr_irrefutable type_annotation(type_expr) EQ
##
contract: Let UIdent LPAR Type Ident RPAR EQ With
##
## Ends in an error in state: 508.
##
## let_binding -> constr_irrefutable par(type_param_list) EQ . expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## constr_irrefutable par(type_param_list) EQ
##
contract: Let UIdent LPAR Type Ident RPAR COLON Ident EQ With
##
## Ends in an error in state: 511.
##
## let_binding -> constr_irrefutable par(type_param_list) type_annotation(type_expr) EQ . expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## constr_irrefutable par(type_param_list) type_annotation(type_expr) EQ
##
contract: Let Ident LPAR Type Ident RPAR EQ With
##
## Ends in an error in state: 1096.
##
## let_binding -> var_pattern par(type_param_list) EQ . expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## var_pattern par(type_param_list) EQ
##
contract: Let Ident LPAR Type Ident RPAR COLON Ident EQ With
##
## Ends in an error in state: 1099.
##
## let_binding -> var_pattern par(type_param_list) type_annotation(type_expr) EQ . expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## var_pattern par(type_param_list) type_annotation(type_expr) EQ
##
contract: Let WILD COLON WILD EQ With
##
## Ends in an error in state: 1144.
##
## let_binding -> WILD type_annotation(type_expr) EQ . expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## WILD type_annotation(type_expr) EQ
##
contract: Let WILD LPAR Type Ident RPAR EQ With
##
## Ends in an error in state: 1147.
##
## let_binding -> WILD par(type_param_list) EQ . expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## WILD par(type_param_list) EQ
##
contract: Let WILD LPAR Type Ident RPAR COLON Ident EQ With
##
## Ends in an error in state: 1150.
##
## let_binding -> WILD par(type_param_list) type_annotation(type_expr) EQ . expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## WILD par(type_param_list) type_annotation(type_expr) EQ
##

Ill-formed value declaration.
At this point, an expression is expected.

interactive_expr: Lang With
##
## Ends in an error in state: 143.
##
## code_inj -> Lang . expr RBRACKET [ With Verbatim VBAR UIdent Type Then TIMES String SLASH SEMI RPAR RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Lxor Lsr Lsl Lor Let Lang Land LT LPAR LE LBRACKET LBRACE Int In Ident GT GE End Else EQ EOF Directive CONS COMMA COLON CARET Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## Lang
##

Ill-formed code injection.
At this point, the code is expected as an expression whose value is a
verbatim string.

interactive_expr: LPAR With
##
## Ends in an error in state: 145.
##
## par(expr) -> LPAR . expr RPAR [ With Verbatim VBAR UIdent Type Then TIMES String SLASH SEMI RPAR RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Lxor Lsr Lsl Lor Let Lang Land LT LPAR LE LBRACKET LBRACE Int In Ident GT GE End Else EQ EOF Directive CONS COMMA COLON CARET Bytes Begin BOOL_OR BOOL_AND Attr ]
## par(typed_expr) -> LPAR . typed_expr RPAR [ With Verbatim VBAR UIdent Type Then TIMES String SLASH SEMI RPAR RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Lxor Lsr Lsl Lor Let Lang Land LT LPAR LE LBRACKET LBRACE Int In Ident GT GE End Else EQ EOF Directive CONS COMMA COLON CARET Bytes Begin BOOL_OR BOOL_AND Attr ]
## unit -> LPAR . RPAR [ With Verbatim VBAR UIdent Type Then TIMES String SLASH SEMI RPAR RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Lxor Lsr Lsl Lor Let Lang Land LT LPAR LE LBRACKET LBRACE Int In Ident GT GE End Else EQ EOF Directive CONS COMMA COLON CARET Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## LPAR
##

Ill-formed expression.
At this point, one of the following is expected:
  * an expression, if defining a parenthesised expression;
  * a closing parenthesis ')' if defining the unit value '()'.

interactive_expr: Match UIdent With LBRACKET With
##
## Ends in an error in state: 543.
##
## list_of(cons_pattern_level) -> LBRACKET . option(sep_or_term_list(cons_pattern_level,SEMI)) RBRACKET [ SEMI RPAR RBRACKET RBRACE CONS COMMA COLON ARROW ]
##
## The known suffix of the stack is as follows:
## LBRACKET
##

Ill-formed list of patterns.
At this point, one of the following is expected:
  * a list element as a pattern;
  * a closing bracket ']' if matching the empty list.

interactive_expr: Match UIdent With UIdent COMMA With
##
## Ends in an error in state: 590.
##
## tuple(cons_pattern_level) -> cons_pattern_level COMMA . nsepseq(cons_pattern_level,COMMA) [ RPAR COLON ARROW ]
##
## The known suffix of the stack is as follows:
## cons_pattern_level COMMA
##
interactive_expr: Match UIdent With UIdent COMMA UIdent COMMA With
##
## Ends in an error in state: 593.
##
## nsepseq(cons_pattern_level,COMMA) -> cons_pattern_level COMMA . nsepseq(cons_pattern_level,COMMA) [ RPAR COLON ARROW ]
##
## The known suffix of the stack is as follows:
## cons_pattern_level COMMA
##
contract: Let Ident COMMA With
##
## Ends in an error in state: 165.
##
## tuple(core_irrefutable) -> var_pattern COMMA . nsepseq(core_irrefutable,COMMA) [ SEMI RPAR RBRACE LPAR EQ COLON ]
##
## The known suffix of the stack is as follows:
## var_pattern COMMA
##
contract: Let Ident COMMA Ident COMMA With
##
## Ends in an error in state: 167.
##
## nsepseq(core_irrefutable,COMMA) -> var_pattern COMMA . nsepseq(core_irrefutable,COMMA) [ SEMI RPAR RBRACE LPAR EQ COLON ]
##
## The known suffix of the stack is as follows:
## var_pattern COMMA
##
contract: Let WILD COMMA WILD COMMA With
##
## Ends in an error in state: 158.
##
## nsepseq(core_irrefutable,COMMA) -> WILD COMMA . nsepseq(core_irrefutable,COMMA) [ SEMI RPAR RBRACE LPAR EQ COLON ]
##
## The known suffix of the stack is as follows:
## WILD COMMA
##
contract: Let WILD COMMA LPAR RPAR COMMA With
##
## Ends in an error in state: 169.
##
## nsepseq(core_irrefutable,COMMA) -> unit COMMA . nsepseq(core_irrefutable,COMMA) [ SEMI RPAR RBRACE LPAR EQ COLON ]
##
## The known suffix of the stack is as follows:
## unit COMMA
##
contract: Let WILD COMMA LBRACE Ident RBRACE COMMA With
##
## Ends in an error in state: 171.
##
## nsepseq(core_irrefutable,COMMA) -> record_pattern(irrefutable) COMMA . nsepseq(core_irrefutable,COMMA) [ SEMI RPAR RBRACE LPAR EQ COLON ]
##
## The known suffix of the stack is as follows:
## record_pattern(irrefutable) COMMA
##
contract: Let WILD COMMA LPAR UIdent COLON Ident RPAR COMMA With
##
## Ends in an error in state: 173.
##
## nsepseq(core_irrefutable,COMMA) -> par(typed_irrefutable) COMMA . nsepseq(core_irrefutable,COMMA) [ SEMI RPAR RBRACE LPAR EQ COLON ]
##
## The known suffix of the stack is as follows:
## par(typed_irrefutable) COMMA
##
contract: Let WILD COMMA LPAR WILD RPAR COMMA With
##
## Ends in an error in state: 176.
##
## nsepseq(core_irrefutable,COMMA) -> par(irrefutable) COMMA . nsepseq(core_irrefutable,COMMA) [ SEMI RPAR RBRACE LPAR EQ COLON ]
##
## The known suffix of the stack is as follows:
## par(irrefutable) COMMA
##
contract: Let WILD COMMA UIdent COMMA With
##
## Ends in an error in state: 181.
##
## nsepseq(core_irrefutable,COMMA) -> constr_irrefutable COMMA . nsepseq(core_irrefutable,COMMA) [ SEMI RPAR RBRACE LPAR EQ COLON ]
##
## The known suffix of the stack is as follows:
## constr_irrefutable COMMA
##
contract: Let LPAR RPAR COMMA With
##
## Ends in an error in state: 190.
##
## tuple(core_irrefutable) -> unit COMMA . nsepseq(core_irrefutable,COMMA) [ SEMI RPAR RBRACE LPAR EQ COLON ]
##
## The known suffix of the stack is as follows:
## unit COMMA
##
contract: Let LBRACE Ident RBRACE COMMA With
##
## Ends in an error in state: 194.
##
## tuple(core_irrefutable) -> record_pattern(irrefutable) COMMA . nsepseq(core_irrefutable,COMMA) [ SEMI RPAR RBRACE LPAR EQ COLON ]
##
## The known suffix of the stack is as follows:
## record_pattern(irrefutable) COMMA
##
contract: Let LPAR UIdent COLON Ident RPAR COMMA With
##
## Ends in an error in state: 197.
##
## tuple(core_irrefutable) -> par(typed_irrefutable) COMMA . nsepseq(core_irrefutable,COMMA) [ SEMI RPAR RBRACE LPAR EQ COLON ]
##
## The known suffix of the stack is as follows:
## par(typed_irrefutable) COMMA
##
contract: Let LPAR WILD RPAR COMMA With
##
## Ends in an error in state: 200.
##
## tuple(core_irrefutable) -> par(irrefutable) COMMA . nsepseq(core_irrefutable,COMMA) [ SEMI RPAR RBRACE LPAR EQ COLON ]
##
## The known suffix of the stack is as follows:
## par(irrefutable) COMMA
##
contract: Let UIdent COMMA With
##
## Ends in an error in state: 203.
##
## tuple(core_irrefutable) -> constr_irrefutable COMMA . nsepseq(core_irrefutable,COMMA) [ SEMI RPAR RBRACE LPAR EQ COLON ]
##
## The known suffix of the stack is as follows:
## constr_irrefutable COMMA
##
contract: Let WILD COMMA With
##
## Ends in an error in state: 156.
##
## tuple(core_irrefutable) -> WILD COMMA . nsepseq(core_irrefutable,COMMA) [ SEMI RPAR RBRACE LPAR EQ COLON ]
##
## The known suffix of the stack is as follows:
## WILD COMMA
##

Ill-formed tuple of patterns.
At this point, another component is expected as a pattern.

interactive_expr: LBRACKET With
##
## Ends in an error in state: 149.
##
## list_of(expr) -> LBRACKET . option(sep_or_term_list(expr,SEMI)) RBRACKET [ With Verbatim VBAR UIdent Type Then TIMES String SLASH SEMI RPAR RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Lxor Lsr Lsl Lor Let Lang Land LT LPAR LE LBRACKET LBRACE Int In Ident GT GE End Else EQ EOF Directive CONS COMMA COLON CARET Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## LBRACKET
##

Ill-formed list of expressions.
At this point, one of the following is expected:
  * a list element as an expression;
  * a closing bracket ']' if defining the empty list.

interactive_expr: LBRACE Ident EQ With
##
## Ends in an error in state: 275.
##
## field_assignment -> Ident EQ . expr [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## Ident EQ
##

Ill-formed record expression.
At this point, an expression is expected to be assigned to the field.

interactive_expr: If UIdent Then Attr Fun LPAR Type Ident RPAR With
##
## Ends in an error in state: 1029.
##
## fun_expr(closed_expr) -> nseq(Attr) Fun par(type_param_list) . nseq(core_irrefutable) ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> nseq(Attr) Fun par(type_param_list) . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW closed_expr [ Else ]
## fun_expr(expr) -> nseq(Attr) Fun par(type_param_list) . nseq(core_irrefutable) ARROW expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(expr) -> nseq(Attr) Fun par(type_param_list) . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun par(type_param_list)
##
interactive_expr: Begin Match UIdent With UIdent ARROW Fun LPAR Type Ident RPAR With
##
## Ends in an error in state: 840.
##
## fun_expr(base_cond) -> Fun par(type_param_list) . nseq(core_irrefutable) ARROW base_cond [ VBAR ]
## fun_expr(base_cond) -> Fun par(type_param_list) . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW base_cond [ VBAR ]
## fun_expr(last_expr) -> Fun par(type_param_list) . nseq(core_irrefutable) ARROW last_expr [ End ]
## fun_expr(last_expr) -> Fun par(type_param_list) . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW last_expr [ End ]
##
## The known suffix of the stack is as follows:
## Fun par(type_param_list)
##
interactive_expr: Match UIdent With UIdent ARROW Attr Fun LPAR Type Ident RPAR With
##
## Ends in an error in state: 819.
##
## fun_expr(base_cond) -> nseq(Attr) Fun par(type_param_list) . nseq(core_irrefutable) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_cond) -> nseq(Attr) Fun par(type_param_list) . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun par(type_param_list)
##
interactive_expr: If UIdent Then Match UIdent With UIdent ARROW Attr Fun LPAR Type Ident RPAR With
##
## Ends in an error in state: 750.
##
## fun_expr(base_cond) -> nseq(Attr) Fun par(type_param_list) . nseq(core_irrefutable) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_cond) -> nseq(Attr) Fun par(type_param_list) . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_if_then_else) -> nseq(Attr) Fun par(type_param_list) . nseq(core_irrefutable) ARROW base_if_then_else [ Else ]
## fun_expr(base_if_then_else) -> nseq(Attr) Fun par(type_param_list) . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun par(type_param_list)
##
interactive_expr: Attr Fun LPAR Type Ident RPAR With
##
## Ends in an error in state: 517.
##
## fun_expr(expr) -> nseq(Attr) Fun par(type_param_list) . nseq(core_irrefutable) ARROW expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(expr) -> nseq(Attr) Fun par(type_param_list) . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun par(type_param_list)
##
interactive_expr: Match UIdent With UIdent ARROW If UIdent Then Attr Fun LPAR Type Ident RPAR With
##
## Ends in an error in state: 672.
##
## fun_expr(base_cond) -> nseq(Attr) Fun par(type_param_list) . nseq(core_irrefutable) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_cond) -> nseq(Attr) Fun par(type_param_list) . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(closed_expr) -> nseq(Attr) Fun par(type_param_list) . nseq(core_irrefutable) ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> nseq(Attr) Fun par(type_param_list) . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun par(type_param_list)
##
interactive_expr: Fun LPAR Type Ident RPAR With
##
## Ends in an error in state: 288.
##
## fun_expr(expr) -> Fun par(type_param_list) . nseq(core_irrefutable) ARROW expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(expr) -> Fun par(type_param_list) . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun par(type_param_list)
##
interactive_expr: Match UIdent With UIdent ARROW If UIdent Then Fun LPAR Type Ident RPAR With
##
## Ends in an error in state: 626.
##
## fun_expr(base_cond) -> Fun par(type_param_list) . nseq(core_irrefutable) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_cond) -> Fun par(type_param_list) . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(closed_expr) -> Fun par(type_param_list) . nseq(core_irrefutable) ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> Fun par(type_param_list) . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Fun par(type_param_list)
##
interactive_expr: If UIdent Then Match UIdent With UIdent ARROW Fun LPAR Type Ident RPAR With
##
## Ends in an error in state: 719.
##
## fun_expr(base_cond) -> Fun par(type_param_list) . nseq(core_irrefutable) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_cond) -> Fun par(type_param_list) . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_if_then_else) -> Fun par(type_param_list) . nseq(core_irrefutable) ARROW base_if_then_else [ Else ]
## fun_expr(base_if_then_else) -> Fun par(type_param_list) . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## Fun par(type_param_list)
##
interactive_expr: Match UIdent With UIdent ARROW Fun LPAR Type Ident RPAR With
##
## Ends in an error in state: 800.
##
## fun_expr(base_cond) -> Fun par(type_param_list) . nseq(core_irrefutable) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_cond) -> Fun par(type_param_list) . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun par(type_param_list)
##
interactive_expr: Begin Fun LPAR Type Ident RPAR With
##
## Ends in an error in state: 910.
##
## fun_expr(last_expr) -> Fun par(type_param_list) . nseq(core_irrefutable) ARROW last_expr [ End ]
## fun_expr(last_expr) -> Fun par(type_param_list) . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW last_expr [ End ]
##
## The known suffix of the stack is as follows:
## Fun par(type_param_list)
##
interactive_expr: If UIdent Then Fun LPAR Type Ident RPAR With
##
## Ends in an error in state: 1010.
##
## fun_expr(closed_expr) -> Fun par(type_param_list) . nseq(core_irrefutable) ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> Fun par(type_param_list) . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW closed_expr [ Else ]
## fun_expr(expr) -> Fun par(type_param_list) . nseq(core_irrefutable) ARROW expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(expr) -> Fun par(type_param_list) . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun par(type_param_list)
##
interactive_expr: Begin If UIdent Then Fun LPAR Type Ident RPAR With
##
## Ends in an error in state: 868.
##
## fun_expr(closed_expr) -> Fun par(type_param_list) . nseq(core_irrefutable) ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> Fun par(type_param_list) . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Fun par(type_param_list)
##
interactive_expr: Begin If UIdent Then Attr Fun LPAR Type Ident RPAR With
##
## Ends in an error in state: 887.
##
## fun_expr(closed_expr) -> nseq(Attr) Fun par(type_param_list) . nseq(core_irrefutable) ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> nseq(Attr) Fun par(type_param_list) . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun par(type_param_list)
##
interactive_expr: Begin Attr Fun LPAR Type Ident RPAR With
##
## Ends in an error in state: 928.
##
## fun_expr(last_expr) -> nseq(Attr) Fun par(type_param_list) . nseq(core_irrefutable) ARROW last_expr [ End ]
## fun_expr(last_expr) -> nseq(Attr) Fun par(type_param_list) . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW last_expr [ End ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun par(type_param_list)
##
interactive_expr: Begin Match UIdent With UIdent ARROW Attr Fun LPAR Type Ident RPAR With
##
## Ends in an error in state: 959.
##
## fun_expr(base_cond) -> nseq(Attr) Fun par(type_param_list) . nseq(core_irrefutable) ARROW base_cond [ VBAR ]
## fun_expr(base_cond) -> nseq(Attr) Fun par(type_param_list) . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW base_cond [ VBAR ]
## fun_expr(last_expr) -> nseq(Attr) Fun par(type_param_list) . nseq(core_irrefutable) ARROW last_expr [ End ]
## fun_expr(last_expr) -> nseq(Attr) Fun par(type_param_list) . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW last_expr [ End ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun par(type_param_list)
##

Ill-formed functional expression.
At this point, parameters are expected as irrefutable patterns,
e.g. variables.

interactive_expr: If UIdent Then Attr Fun With
##
## Ends in an error in state: 1028.
##
## fun_expr(closed_expr) -> nseq(Attr) Fun . nseq(core_irrefutable) ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> nseq(Attr) Fun . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> nseq(Attr) Fun . par(type_param_list) nseq(core_irrefutable) ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> nseq(Attr) Fun . par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW closed_expr [ Else ]
## fun_expr(expr) -> nseq(Attr) Fun . nseq(core_irrefutable) ARROW expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(expr) -> nseq(Attr) Fun . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(expr) -> nseq(Attr) Fun . par(type_param_list) nseq(core_irrefutable) ARROW expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(expr) -> nseq(Attr) Fun . par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun
##
interactive_expr: Begin Match UIdent With UIdent ARROW Attr Fun With
##
## Ends in an error in state: 958.
##
## fun_expr(base_cond) -> nseq(Attr) Fun . nseq(core_irrefutable) ARROW base_cond [ VBAR ]
## fun_expr(base_cond) -> nseq(Attr) Fun . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW base_cond [ VBAR ]
## fun_expr(base_cond) -> nseq(Attr) Fun . par(type_param_list) nseq(core_irrefutable) ARROW base_cond [ VBAR ]
## fun_expr(base_cond) -> nseq(Attr) Fun . par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW base_cond [ VBAR ]
## fun_expr(last_expr) -> nseq(Attr) Fun . nseq(core_irrefutable) ARROW last_expr [ End ]
## fun_expr(last_expr) -> nseq(Attr) Fun . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW last_expr [ End ]
## fun_expr(last_expr) -> nseq(Attr) Fun . par(type_param_list) nseq(core_irrefutable) ARROW last_expr [ End ]
## fun_expr(last_expr) -> nseq(Attr) Fun . par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW last_expr [ End ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun
##
interactive_expr: Begin Attr Fun With
##
## Ends in an error in state: 927.
##
## fun_expr(last_expr) -> nseq(Attr) Fun . nseq(core_irrefutable) ARROW last_expr [ End ]
## fun_expr(last_expr) -> nseq(Attr) Fun . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW last_expr [ End ]
## fun_expr(last_expr) -> nseq(Attr) Fun . par(type_param_list) nseq(core_irrefutable) ARROW last_expr [ End ]
## fun_expr(last_expr) -> nseq(Attr) Fun . par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW last_expr [ End ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun
##
interactive_expr: Begin If UIdent Then Attr Fun With
##
## Ends in an error in state: 886.
##
## fun_expr(closed_expr) -> nseq(Attr) Fun . nseq(core_irrefutable) ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> nseq(Attr) Fun . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> nseq(Attr) Fun . par(type_param_list) nseq(core_irrefutable) ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> nseq(Attr) Fun . par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun
##
interactive_expr: Match UIdent With UIdent ARROW Attr Fun With
##
## Ends in an error in state: 818.
##
## fun_expr(base_cond) -> nseq(Attr) Fun . nseq(core_irrefutable) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_cond) -> nseq(Attr) Fun . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_cond) -> nseq(Attr) Fun . par(type_param_list) nseq(core_irrefutable) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_cond) -> nseq(Attr) Fun . par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun
##
interactive_expr: If UIdent Then Match UIdent With UIdent ARROW Attr Fun With
##
## Ends in an error in state: 749.
##
## fun_expr(base_cond) -> nseq(Attr) Fun . nseq(core_irrefutable) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_cond) -> nseq(Attr) Fun . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_cond) -> nseq(Attr) Fun . par(type_param_list) nseq(core_irrefutable) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_cond) -> nseq(Attr) Fun . par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_if_then_else) -> nseq(Attr) Fun . nseq(core_irrefutable) ARROW base_if_then_else [ Else ]
## fun_expr(base_if_then_else) -> nseq(Attr) Fun . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW base_if_then_else [ Else ]
## fun_expr(base_if_then_else) -> nseq(Attr) Fun . par(type_param_list) nseq(core_irrefutable) ARROW base_if_then_else [ Else ]
## fun_expr(base_if_then_else) -> nseq(Attr) Fun . par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun
##
interactive_expr: Attr Fun With
##
## Ends in an error in state: 516.
##
## fun_expr(expr) -> nseq(Attr) Fun . nseq(core_irrefutable) ARROW expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(expr) -> nseq(Attr) Fun . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(expr) -> nseq(Attr) Fun . par(type_param_list) nseq(core_irrefutable) ARROW expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(expr) -> nseq(Attr) Fun . par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun
##
interactive_expr: If UIdent Then Fun With
##
## Ends in an error in state: 1009.
##
## fun_expr(closed_expr) -> Fun . nseq(core_irrefutable) ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> Fun . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> Fun . par(type_param_list) nseq(core_irrefutable) ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> Fun . par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW closed_expr [ Else ]
## fun_expr(expr) -> Fun . nseq(core_irrefutable) ARROW expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(expr) -> Fun . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(expr) -> Fun . par(type_param_list) nseq(core_irrefutable) ARROW expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(expr) -> Fun . par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun
##
interactive_expr: Begin Fun With
##
## Ends in an error in state: 909.
##
## fun_expr(last_expr) -> Fun . nseq(core_irrefutable) ARROW last_expr [ End ]
## fun_expr(last_expr) -> Fun . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW last_expr [ End ]
## fun_expr(last_expr) -> Fun . par(type_param_list) nseq(core_irrefutable) ARROW last_expr [ End ]
## fun_expr(last_expr) -> Fun . par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW last_expr [ End ]
##
## The known suffix of the stack is as follows:
## Fun
##
interactive_expr: Begin If UIdent Then Fun With
##
## Ends in an error in state: 867.
##
## fun_expr(closed_expr) -> Fun . nseq(core_irrefutable) ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> Fun . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> Fun . par(type_param_list) nseq(core_irrefutable) ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> Fun . par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Fun
##
interactive_expr: Begin Match UIdent With UIdent ARROW Fun With
##
## Ends in an error in state: 839.
##
## fun_expr(base_cond) -> Fun . nseq(core_irrefutable) ARROW base_cond [ VBAR ]
## fun_expr(base_cond) -> Fun . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW base_cond [ VBAR ]
## fun_expr(base_cond) -> Fun . par(type_param_list) nseq(core_irrefutable) ARROW base_cond [ VBAR ]
## fun_expr(base_cond) -> Fun . par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW base_cond [ VBAR ]
## fun_expr(last_expr) -> Fun . nseq(core_irrefutable) ARROW last_expr [ End ]
## fun_expr(last_expr) -> Fun . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW last_expr [ End ]
## fun_expr(last_expr) -> Fun . par(type_param_list) nseq(core_irrefutable) ARROW last_expr [ End ]
## fun_expr(last_expr) -> Fun . par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW last_expr [ End ]
##
## The known suffix of the stack is as follows:
## Fun
##
interactive_expr: Match UIdent With UIdent ARROW Fun With
##
## Ends in an error in state: 799.
##
## fun_expr(base_cond) -> Fun . nseq(core_irrefutable) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_cond) -> Fun . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_cond) -> Fun . par(type_param_list) nseq(core_irrefutable) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_cond) -> Fun . par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun
##
interactive_expr: If UIdent Then Match UIdent With UIdent ARROW Fun With
##
## Ends in an error in state: 718.
##
## fun_expr(base_cond) -> Fun . nseq(core_irrefutable) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_cond) -> Fun . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_cond) -> Fun . par(type_param_list) nseq(core_irrefutable) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_cond) -> Fun . par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_if_then_else) -> Fun . nseq(core_irrefutable) ARROW base_if_then_else [ Else ]
## fun_expr(base_if_then_else) -> Fun . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW base_if_then_else [ Else ]
## fun_expr(base_if_then_else) -> Fun . par(type_param_list) nseq(core_irrefutable) ARROW base_if_then_else [ Else ]
## fun_expr(base_if_then_else) -> Fun . par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## Fun
##
interactive_expr: Fun With
##
## Ends in an error in state: 279.
##
## fun_expr(expr) -> Fun . nseq(core_irrefutable) ARROW expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(expr) -> Fun . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(expr) -> Fun . par(type_param_list) nseq(core_irrefutable) ARROW expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(expr) -> Fun . par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun
##
interactive_expr: Match UIdent With UIdent ARROW If UIdent Then Fun With
##
## Ends in an error in state: 625.
##
## fun_expr(base_cond) -> Fun . nseq(core_irrefutable) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_cond) -> Fun . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_cond) -> Fun . par(type_param_list) nseq(core_irrefutable) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_cond) -> Fun . par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(closed_expr) -> Fun . nseq(core_irrefutable) ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> Fun . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> Fun . par(type_param_list) nseq(core_irrefutable) ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> Fun . par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Fun
##
interactive_expr: Match UIdent With UIdent ARROW If UIdent Then Attr Fun With
##
## Ends in an error in state: 671.
##
## fun_expr(base_cond) -> nseq(Attr) Fun . nseq(core_irrefutable) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_cond) -> nseq(Attr) Fun . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_cond) -> nseq(Attr) Fun . par(type_param_list) nseq(core_irrefutable) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_cond) -> nseq(Attr) Fun . par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(closed_expr) -> nseq(Attr) Fun . nseq(core_irrefutable) ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> nseq(Attr) Fun . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> nseq(Attr) Fun . par(type_param_list) nseq(core_irrefutable) ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> nseq(Attr) Fun . par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun
##

Ill-formed functional expression.
At this point, one of the following is expected:
  * parameters as irrefutable patterns, e.g. variables;
  * bound type parameters between parentheses, like '(type a b)'.

interactive_expr: If UIdent Then Match With
##
## Ends in an error in state: 997.
##
## match_expr(base_cond) -> Match . expr With option(VBAR) cases(base_cond) [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## match_expr(base_if_then_else) -> Match . expr With option(VBAR) cases(base_if_then_else) [ Else ]
##
## The known suffix of the stack is as follows:
## Match
##
interactive_expr: Begin Match With
##
## Ends in an error in state: 316.
##
## match_expr(last_expr) -> Match . expr With option(VBAR) cases(last_expr) [ End ]
##
## The known suffix of the stack is as follows:
## Match
##
interactive_expr: Match With
##
## Ends in an error in state: 147.
##
## match_expr(base_cond) -> Match . expr With option(VBAR) cases(base_cond) [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Match
##
interactive_expr: Begin If UIdent Then Match With
##
## Ends in an error in state: 605.
##
## match_expr(base_if_then_else) -> Match . expr With option(VBAR) cases(base_if_then_else) [ Else ]
##
## The known suffix of the stack is as follows:
## Match
##

Ill-formed match expression.
At this point, the expression whose value is being matched is
expected.

interactive_expr: Module UIdent EQ Struct Directive End In With
##
## Ends in an error in state: 368.
##
## local_module_decl(expr) -> module_decl In . expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## module_decl In
##
interactive_expr: If UIdent Then Module UIdent EQ Struct Directive End In With
##
## Ends in an error in state: 1022.
##
## local_module_decl(closed_expr) -> module_decl In . closed_expr [ Else ]
## local_module_decl(expr) -> module_decl In . expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## module_decl In
##
interactive_expr: Begin If UIdent Then Module UIdent EQ Struct Directive End In With
##
## Ends in an error in state: 880.
##
## local_module_decl(closed_expr) -> module_decl In . closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## module_decl In
##
interactive_expr: Match UIdent With UIdent ARROW Module UIdent EQ Struct Directive End In With
##
## Ends in an error in state: 812.
##
## local_module_decl(base_cond) -> module_decl In . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## module_decl In
##
interactive_expr: If UIdent Then Match UIdent With UIdent ARROW Module UIdent EQ Struct Directive End In With
##
## Ends in an error in state: 731.
##
## local_module_decl(base_cond) -> module_decl In . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## local_module_decl(base_if_then_else) -> module_decl In . base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## module_decl In
##
interactive_expr: Match UIdent With UIdent ARROW If UIdent Then Module UIdent EQ Struct Directive End In With
##
## Ends in an error in state: 638.
##
## local_module_decl(base_cond) -> module_decl In . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## local_module_decl(closed_expr) -> module_decl In . closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## module_decl In
##

Ill-formed local module declaration.
At this point, an expression is expected.

interactive_expr: Module UIdent EQ UIdent In With
##
## Ends in an error in state: 370.
##
## local_module_alias(expr) -> module_alias In . expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## module_alias In
##
interactive_expr: If UIdent Then Module UIdent EQ UIdent In With
##
## Ends in an error in state: 1024.
##
## local_module_alias(closed_expr) -> module_alias In . closed_expr [ Else ]
## local_module_alias(expr) -> module_alias In . expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## module_alias In
##
interactive_expr: Begin If UIdent Then Module UIdent EQ UIdent In With
##
## Ends in an error in state: 882.
##
## local_module_alias(closed_expr) -> module_alias In . closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## module_alias In
##
interactive_expr: Match UIdent With UIdent ARROW If UIdent Then Module UIdent EQ UIdent In With
##
## Ends in an error in state: 640.
##
## local_module_alias(base_cond) -> module_alias In . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## local_module_alias(closed_expr) -> module_alias In . closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## module_alias In
##
interactive_expr: If UIdent Then Match UIdent With UIdent ARROW Module UIdent EQ UIdent In With
##
## Ends in an error in state: 733.
##
## local_module_alias(base_cond) -> module_alias In . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## local_module_alias(base_if_then_else) -> module_alias In . base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## module_alias In
##
interactive_expr: Match UIdent With UIdent ARROW Module UIdent EQ UIdent In With
##
## Ends in an error in state: 814.
##
## local_module_alias(base_cond) -> module_alias In . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## module_alias In
##

Ill-formed local module alias declaration.
At this point, an expression is expected.

contract: Let Ident LPAR With
##
## Ends in an error in state: 271.
##
## par(irrefutable) -> LPAR . tuple(core_irrefutable) RPAR [ WILD UIdent LPAR LBRACE Ident EQ COLON Attr ARROW ]
## par(irrefutable) -> LPAR . WILD RPAR [ WILD UIdent LPAR LBRACE Ident EQ COLON Attr ARROW ]
## par(irrefutable) -> LPAR . var_pattern RPAR [ WILD UIdent LPAR LBRACE Ident EQ COLON Attr ARROW ]
## par(irrefutable) -> LPAR . unit RPAR [ WILD UIdent LPAR LBRACE Ident EQ COLON Attr ARROW ]
## par(irrefutable) -> LPAR . record_pattern(irrefutable) RPAR [ WILD UIdent LPAR LBRACE Ident EQ COLON Attr ARROW ]
## par(irrefutable) -> LPAR . par(typed_irrefutable) RPAR [ WILD UIdent LPAR LBRACE Ident EQ COLON Attr ARROW ]
## par(irrefutable) -> LPAR . par(irrefutable) RPAR [ WILD UIdent LPAR LBRACE Ident EQ COLON Attr ARROW ]
## par(irrefutable) -> LPAR . constr_irrefutable RPAR [ WILD UIdent LPAR LBRACE Ident EQ COLON Attr ARROW ]
## par(non_const_constr_irrefutable) -> LPAR . non_const_constr_irrefutable RPAR [ WILD UIdent LPAR LBRACE Ident EQ COLON Attr ARROW ]
## par(type_param_list) -> LPAR . type_param_list RPAR [ WILD UIdent LPAR LBRACE Ident EQ COLON Attr ]
## par(typed_irrefutable) -> LPAR . typed_irrefutable RPAR [ WILD UIdent LPAR LBRACE Ident EQ COLON Attr ARROW ]
## unit -> LPAR . RPAR [ WILD UIdent LPAR LBRACE Ident EQ COLON Attr ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR
##

Ill-formed value declaration.
At this point, one of the following is expected:
  * the keyword 'type' followed by type parameters and a closing
    parenthesis ')';
  * a closing parenthesis ')' if matching the unit pattern;
  * a parameter as an irrefutable pattern followed by a closing
    parenthesis ')'.

contract: Let Ident COLON LPAR With
##
## Ends in an error in state: 25.
##
## par(tuple(type_expr)) -> LPAR . tuple(type_expr) RPAR [ Ident ]
## par(type_expr) -> LPAR . type_expr RPAR [ VBAR Type TIMES SEMI RPAR RBRACE Module Let In Ident End EQ EOF Directive COMMA Attr ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR
##

Ill-formed parenthesised expression.
At this point, an expression is expected.
Note: Tuples of expressions do not require in general to be
parenthesised, but parentheses improve readability.

contract: Let Ident LPAR Type Ident RPAR With
##
## Ends in an error in state: 1095.
##
## let_binding -> var_pattern par(type_param_list) . parameters EQ expr [ Type Module Let In End EOF Directive Attr ]
## let_binding -> var_pattern par(type_param_list) . parameters type_annotation(type_expr) EQ expr [ Type Module Let In End EOF Directive Attr ]
## let_binding -> var_pattern par(type_param_list) . EQ expr [ Type Module Let In End EOF Directive Attr ]
## let_binding -> var_pattern par(type_param_list) . type_annotation(type_expr) EQ expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## var_pattern par(type_param_list)
##

Ill-formed polymorphic function declaration.
At this point, one of the following is expected:
  * parameters as irrefutable patterns, e.g. variables;
  * the assignment symbol '=' followed by the body as an expression;
  * a type annotation starting with a colon ':' for the body.

contract: Let Ident LPAR Type Ident RPAR Ident EQ With
##
## Ends in an error in state: 1102.
##
## let_binding -> var_pattern par(type_param_list) parameters EQ . expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## var_pattern par(type_param_list) parameters EQ
##
contract: Let Ident LPAR Type Ident RPAR Ident COLON Ident EQ With
##
## Ends in an error in state: 1105.
##
## let_binding -> var_pattern par(type_param_list) parameters type_annotation(type_expr) EQ . expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## var_pattern par(type_param_list) parameters type_annotation(type_expr) EQ
##

Ill-formed function declaration.
At this point, the body of the function is expected as an expression.

interactive_expr: Fun WILD With
##
## Ends in an error in state: 255.
##
## nseq(core_irrefutable) -> WILD . seq(core_irrefutable) [ EQ COLON ARROW ]
##
## The known suffix of the stack is as follows:
## WILD
##
interactive_expr: Fun WILD WILD With
##
## Ends in an error in state: 256.
##
## seq(core_irrefutable) -> WILD . seq(core_irrefutable) [ EQ COLON ARROW ]
##
## The known suffix of the stack is as follows:
## WILD
##
interactive_expr: Fun WILD LPAR RPAR With
##
## Ends in an error in state: 258.
##
## seq(core_irrefutable) -> unit . seq(core_irrefutable) [ EQ COLON ARROW ]
##
## The known suffix of the stack is as follows:
## unit
##
interactive_expr: Fun WILD LBRACE Ident RBRACE With
##
## Ends in an error in state: 260.
##
## seq(core_irrefutable) -> record_pattern(irrefutable) . seq(core_irrefutable) [ EQ COLON ARROW ]
##
## The known suffix of the stack is as follows:
## record_pattern(irrefutable)
##
interactive_expr: Fun WILD LPAR UIdent COLON Ident RPAR With
##
## Ends in an error in state: 262.
##
## seq(core_irrefutable) -> par(typed_irrefutable) . seq(core_irrefutable) [ EQ COLON ARROW ]
##
## The known suffix of the stack is as follows:
## par(typed_irrefutable)
##
interactive_expr: Fun WILD LPAR WILD RPAR With
##
## Ends in an error in state: 264.
##
## seq(core_irrefutable) -> par(irrefutable) . seq(core_irrefutable) [ EQ COLON ARROW ]
##
## The known suffix of the stack is as follows:
## par(irrefutable)
##
interactive_expr: Fun WILD UIdent With
##
## Ends in an error in state: 266.
##
## seq(core_irrefutable) -> constr_irrefutable . seq(core_irrefutable) [ EQ COLON ARROW ]
##
## The known suffix of the stack is as follows:
## constr_irrefutable
##
interactive_expr: Fun LPAR RPAR With
##
## Ends in an error in state: 282.
##
## nseq(core_irrefutable) -> unit . seq(core_irrefutable) [ EQ COLON ARROW ]
##
## The known suffix of the stack is as follows:
## unit
##
interactive_expr: Fun LBRACE Ident RBRACE With
##
## Ends in an error in state: 284.
##
## nseq(core_irrefutable) -> record_pattern(irrefutable) . seq(core_irrefutable) [ EQ COLON ARROW ]
##
## The known suffix of the stack is as follows:
## record_pattern(irrefutable)
##
interactive_expr: Fun LPAR UIdent COLON Ident RPAR With
##
## Ends in an error in state: 286.
##
## nseq(core_irrefutable) -> par(typed_irrefutable) . seq(core_irrefutable) [ EQ COLON ARROW ]
##
## The known suffix of the stack is as follows:
## par(typed_irrefutable)
##
interactive_expr: Fun LPAR WILD RPAR With
##
## Ends in an error in state: 289.
##
## nseq(core_irrefutable) -> par(irrefutable) . seq(core_irrefutable) [ EQ COLON ARROW ]
##
## The known suffix of the stack is as follows:
## par(irrefutable)
##
interactive_expr: Fun UIdent With
##
## Ends in an error in state: 524.
##
## nseq(core_irrefutable) -> constr_irrefutable . seq(core_irrefutable) [ EQ COLON ARROW ]
##
## The known suffix of the stack is as follows:
## constr_irrefutable
##

Ill-formed function parameters.
At this point, one of the following is expected:
  * another parameter as an irrefutable pattern, e.g a variable;
  * a type annotation starting with a colon ':' for the body;
  * the assignment symbol '=' followed by an expression.

interactive_expr: Match UIdent With VBAR With
##
## Ends in an error in state: 1127.
##
## match_expr(base_cond) -> Match expr With option(VBAR) . cases(base_cond) [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Match expr With option(VBAR)
##
interactive_expr: Match UIdent With UIdent ARROW UIdent VBAR With
##
## Ends in an error in state: 1131.
##
## cases(base_cond) -> cases(base_cond) VBAR . case_clause(base_cond) [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## cases(base_cond) VBAR
##
interactive_expr: Begin Match UIdent With UIdent ARROW UIdent VBAR With
##
## Ends in an error in state: 979.
##
## cases(base_cond) -> cases(base_cond) VBAR . case_clause(base_cond) [ VBAR ]
## cases(last_expr) -> cases(base_cond) VBAR . case_clause(last_expr) [ End ]
##
## The known suffix of the stack is as follows:
## cases(base_cond) VBAR
##
interactive_expr: If UIdent Then Match UIdent With UIdent ARROW UIdent VBAR With
##
## Ends in an error in state: 783.
##
## cases(base_cond) -> cases(base_cond) VBAR . case_clause(base_cond) [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## cases(base_if_then_else) -> cases(base_cond) VBAR . case_clause(base_if_then_else) [ Else ]
##
## The known suffix of the stack is as follows:
## cases(base_cond) VBAR
##
interactive_expr: If UIdent Then Match UIdent With VBAR With
##
## Ends in an error in state: 1000.
##
## match_expr(base_cond) -> Match expr With option(VBAR) . cases(base_cond) [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## match_expr(base_if_then_else) -> Match expr With option(VBAR) . cases(base_if_then_else) [ Else ]
##
## The known suffix of the stack is as follows:
## Match expr With option(VBAR)
##
interactive_expr: Begin Match UIdent With VBAR With
##
## Ends in an error in state: 536.
##
## match_expr(last_expr) -> Match expr With option(VBAR) . cases(last_expr) [ End ]
##
## The known suffix of the stack is as follows:
## Match expr With option(VBAR)
##
interactive_expr: Begin If UIdent Then Match UIdent With VBAR With
##
## Ends in an error in state: 608.
##
## match_expr(base_if_then_else) -> Match expr With option(VBAR) . cases(base_if_then_else) [ Else ]
##
## The known suffix of the stack is as follows:
## Match expr With option(VBAR)
##

Ill-formed pattern matching.
At this point, a case is expected to start with a pattern.

interactive_expr: Match UIdent With UIdent CONS With
##
## Ends in an error in state: 574.
##
## cons_pattern_level -> core_pattern CONS . cons_pattern_level [ SEMI RPAR RBRACKET COMMA COLON ARROW ]
##
## The known suffix of the stack is as follows:
## core_pattern CONS
##

Ill-formed list pattern.
At this point, a pattern that matches as list is expected.

interactive_expr: Match UIdent With LBRACKET UIdent SEMI With
##
## Ends in an error in state: 577.
##
## nsepseq(cons_pattern_level,SEMI) -> cons_pattern_level SEMI . nsepseq(cons_pattern_level,SEMI) [ RBRACKET ]
## nseq(__anonymous_0(cons_pattern_level,SEMI)) -> cons_pattern_level SEMI . seq(__anonymous_0(cons_pattern_level,SEMI)) [ RBRACKET ]
##
## The known suffix of the stack is as follows:
## cons_pattern_level SEMI
##
interactive_expr: Match UIdent With LBRACKET UIdent SEMI UIdent SEMI With
##
## Ends in an error in state: 581.
##
## nsepseq(cons_pattern_level,SEMI) -> cons_pattern_level SEMI . nsepseq(cons_pattern_level,SEMI) [ RBRACKET ]
## seq(__anonymous_0(cons_pattern_level,SEMI)) -> cons_pattern_level SEMI . seq(__anonymous_0(cons_pattern_level,SEMI)) [ RBRACKET ]
##
## The known suffix of the stack is as follows:
## cons_pattern_level SEMI
##

Ill-formed list of patterns.
At this point, one of the following is expected:
  * a list element as a pattern;
  * a closing bracket ']' if the list is complete.

interactive_expr: If UIdent Then Match UIdent With UIdent ARROW Attr With
##
## Ends in an error in state: 725.
##
## fun_expr(base_cond) -> nseq(Attr) . Fun nseq(core_irrefutable) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_cond) -> nseq(Attr) . Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_cond) -> nseq(Attr) . Fun par(type_param_list) nseq(core_irrefutable) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_cond) -> nseq(Attr) . Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_if_then_else) -> nseq(Attr) . Fun nseq(core_irrefutable) ARROW base_if_then_else [ Else ]
## fun_expr(base_if_then_else) -> nseq(Attr) . Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW base_if_then_else [ Else ]
## fun_expr(base_if_then_else) -> nseq(Attr) . Fun par(type_param_list) nseq(core_irrefutable) ARROW base_if_then_else [ Else ]
## fun_expr(base_if_then_else) -> nseq(Attr) . Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW base_if_then_else [ Else ]
## let_in_expr(base_cond) -> nseq(Attr) . Let let_binding In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## let_in_expr(base_cond) -> nseq(Attr) . Let Rec let_binding In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## let_in_expr(base_if_then_else) -> nseq(Attr) . Let let_binding In base_if_then_else [ Else ]
## let_in_expr(base_if_then_else) -> nseq(Attr) . Let Rec let_binding In base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 33, spurious reduction of production seq(Attr) ->
## In state 36, spurious reduction of production nseq(Attr) -> Attr seq(Attr)
##
interactive_expr: Match UIdent With UIdent ARROW Attr With
##
## Ends in an error in state: 806.
##
## fun_expr(base_cond) -> nseq(Attr) . Fun nseq(core_irrefutable) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_cond) -> nseq(Attr) . Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_cond) -> nseq(Attr) . Fun par(type_param_list) nseq(core_irrefutable) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_cond) -> nseq(Attr) . Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## let_in_expr(base_cond) -> nseq(Attr) . Let let_binding In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## let_in_expr(base_cond) -> nseq(Attr) . Let Rec let_binding In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 33, spurious reduction of production seq(Attr) ->
## In state 36, spurious reduction of production nseq(Attr) -> Attr seq(Attr)
##
interactive_expr: Begin Match UIdent With UIdent ARROW Attr With
##
## Ends in an error in state: 845.
##
## fun_expr(base_cond) -> nseq(Attr) . Fun nseq(core_irrefutable) ARROW base_cond [ VBAR ]
## fun_expr(base_cond) -> nseq(Attr) . Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW base_cond [ VBAR ]
## fun_expr(base_cond) -> nseq(Attr) . Fun par(type_param_list) nseq(core_irrefutable) ARROW base_cond [ VBAR ]
## fun_expr(base_cond) -> nseq(Attr) . Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW base_cond [ VBAR ]
## fun_expr(last_expr) -> nseq(Attr) . Fun nseq(core_irrefutable) ARROW last_expr [ End ]
## fun_expr(last_expr) -> nseq(Attr) . Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW last_expr [ End ]
## fun_expr(last_expr) -> nseq(Attr) . Fun par(type_param_list) nseq(core_irrefutable) ARROW last_expr [ End ]
## fun_expr(last_expr) -> nseq(Attr) . Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW last_expr [ End ]
## let_in_expr(base_cond) -> nseq(Attr) . Let let_binding In base_cond [ VBAR ]
## let_in_expr(base_cond) -> nseq(Attr) . Let Rec let_binding In base_cond [ VBAR ]
## let_in_sequence -> nseq(Attr) . Let let_binding In series [ End ]
## let_in_sequence -> nseq(Attr) . Let Rec let_binding In series [ End ]
##
## The known suffix of the stack is as follows:
## nseq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 33, spurious reduction of production seq(Attr) ->
## In state 36, spurious reduction of production nseq(Attr) -> Attr seq(Attr)
##
interactive_expr: Begin If UIdent Then Attr With
##
## Ends in an error in state: 874.
##
## fun_expr(closed_expr) -> nseq(Attr) . Fun nseq(core_irrefutable) ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> nseq(Attr) . Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> nseq(Attr) . Fun par(type_param_list) nseq(core_irrefutable) ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> nseq(Attr) . Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW closed_expr [ Else ]
## let_in_expr(closed_expr) -> nseq(Attr) . Let let_binding In closed_expr [ Else ]
## let_in_expr(closed_expr) -> nseq(Attr) . Let Rec let_binding In closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 33, spurious reduction of production seq(Attr) ->
## In state 36, spurious reduction of production nseq(Attr) -> Attr seq(Attr)
##
interactive_expr: Begin Attr With
##
## Ends in an error in state: 914.
##
## fun_expr(last_expr) -> nseq(Attr) . Fun nseq(core_irrefutable) ARROW last_expr [ End ]
## fun_expr(last_expr) -> nseq(Attr) . Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW last_expr [ End ]
## fun_expr(last_expr) -> nseq(Attr) . Fun par(type_param_list) nseq(core_irrefutable) ARROW last_expr [ End ]
## fun_expr(last_expr) -> nseq(Attr) . Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW last_expr [ End ]
## let_in_sequence -> nseq(Attr) . Let let_binding In series [ End ]
## let_in_sequence -> nseq(Attr) . Let Rec let_binding In series [ End ]
##
## The known suffix of the stack is as follows:
## nseq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 33, spurious reduction of production seq(Attr) ->
## In state 36, spurious reduction of production nseq(Attr) -> Attr seq(Attr)
##
interactive_expr: If UIdent Then Attr With
##
## Ends in an error in state: 1016.
##
## fun_expr(closed_expr) -> nseq(Attr) . Fun nseq(core_irrefutable) ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> nseq(Attr) . Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> nseq(Attr) . Fun par(type_param_list) nseq(core_irrefutable) ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> nseq(Attr) . Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW closed_expr [ Else ]
## fun_expr(expr) -> nseq(Attr) . Fun nseq(core_irrefutable) ARROW expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(expr) -> nseq(Attr) . Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(expr) -> nseq(Attr) . Fun par(type_param_list) nseq(core_irrefutable) ARROW expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(expr) -> nseq(Attr) . Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## let_in_expr(closed_expr) -> nseq(Attr) . Let let_binding In closed_expr [ Else ]
## let_in_expr(closed_expr) -> nseq(Attr) . Let Rec let_binding In closed_expr [ Else ]
## let_in_expr(expr) -> nseq(Attr) . Let let_binding In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## let_in_expr(expr) -> nseq(Attr) . Let Rec let_binding In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 33, spurious reduction of production seq(Attr) ->
## In state 36, spurious reduction of production nseq(Attr) -> Attr seq(Attr)
##
contract: Attr With
##
## Ends in an error in state: 1158.
##
## let_declaration -> nseq(Attr) . Let let_binding [ Type Module Let End EOF Directive Attr ]
## let_declaration -> nseq(Attr) . Let Rec let_binding [ Type Module Let End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 33, spurious reduction of production seq(Attr) ->
## In state 36, spurious reduction of production nseq(Attr) -> Attr seq(Attr)
##
interactive_expr: Match UIdent With UIdent ARROW If UIdent Then Attr With
##
## Ends in an error in state: 632.
##
## fun_expr(base_cond) -> nseq(Attr) . Fun nseq(core_irrefutable) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_cond) -> nseq(Attr) . Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_cond) -> nseq(Attr) . Fun par(type_param_list) nseq(core_irrefutable) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_cond) -> nseq(Attr) . Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(closed_expr) -> nseq(Attr) . Fun nseq(core_irrefutable) ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> nseq(Attr) . Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> nseq(Attr) . Fun par(type_param_list) nseq(core_irrefutable) ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> nseq(Attr) . Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW closed_expr [ Else ]
## let_in_expr(base_cond) -> nseq(Attr) . Let let_binding In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## let_in_expr(base_cond) -> nseq(Attr) . Let Rec let_binding In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## let_in_expr(closed_expr) -> nseq(Attr) . Let let_binding In closed_expr [ Else ]
## let_in_expr(closed_expr) -> nseq(Attr) . Let Rec let_binding In closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 33, spurious reduction of production seq(Attr) ->
## In state 36, spurious reduction of production nseq(Attr) -> Attr seq(Attr)
##
interactive_expr: Attr With
##
## Ends in an error in state: 349.
##
## fun_expr(expr) -> nseq(Attr) . Fun nseq(core_irrefutable) ARROW expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(expr) -> nseq(Attr) . Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(expr) -> nseq(Attr) . Fun par(type_param_list) nseq(core_irrefutable) ARROW expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(expr) -> nseq(Attr) . Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## let_in_expr(expr) -> nseq(Attr) . Let let_binding In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## let_in_expr(expr) -> nseq(Attr) . Let Rec let_binding In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 33, spurious reduction of production seq(Attr) ->
## In state 36, spurious reduction of production nseq(Attr) -> Attr seq(Attr)
##

Ill-formed attributed expression.
At this point, if the attributes are complete, one of the following is
expected:
  * a functional expression starting with the keyword 'fun';
  * a local value declaration starting with the keyword 'let'.

interactive_expr: Fun Ident With
##
## Ends in an error in state: 280.
##
## nseq(core_irrefutable) -> var_pattern . seq(core_irrefutable) [ EQ COLON ARROW ]
##
## The known suffix of the stack is as follows:
## var_pattern
##
interactive_expr: Fun Ident Ident With
##
## Ends in an error in state: 257.
##
## seq(core_irrefutable) -> var_pattern . seq(core_irrefutable) [ EQ COLON ARROW ]
##
## The known suffix of the stack is as follows:
## var_pattern
##

Ill-formed functional expression.
At this point, one of the following is expected:
  * a parameter as an irrefutable pattern, e.g. a variable;
  * an arrow '->' followed by the body as an expression.

interactive_expr: Match UIdent With UIdent ARROW If UIdent Then Type Ident EQ Ident In With
##
## Ends in an error in state: 630.
##
## local_type_decl(base_cond) -> type_decl In . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## local_type_decl(closed_expr) -> type_decl In . closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## type_decl In
##
interactive_expr: If UIdent Then Type Ident EQ Ident In With
##
## Ends in an error in state: 1014.
##
## local_type_decl(closed_expr) -> type_decl In . closed_expr [ Else ]
## local_type_decl(expr) -> type_decl In . expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## type_decl In
##
#
#interactive_expr: Match UIdent With UIdent ARROW If UIdent Then Type Ident EQ Ident In With
interactive_expr: If UIdent Then Match UIdent With UIdent ARROW Type Ident EQ Ident In With
##
## Ends in an error in state: 723.
##
## local_type_decl(base_cond) -> type_decl In . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## local_type_decl(base_if_then_else) -> type_decl In . base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## type_decl In
##
interactive_expr: Type Ident EQ Ident In With
##
## Ends in an error in state: 345.
##
## local_type_decl(expr) -> type_decl In . expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## type_decl In
##
interactive_expr: Match UIdent With UIdent ARROW Type Ident EQ Ident In With
##
## Ends in an error in state: 804.
##
## local_type_decl(base_cond) -> type_decl In . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## type_decl In
##
interactive_expr: Begin If UIdent Then Type Ident EQ Ident In With
##
## Ends in an error in state: 872.
##
## local_type_decl(closed_expr) -> type_decl In . closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## type_decl In
##

Ill-formed local type declaration.
At this point, an expression is expected.

interactive_expr: LBRACE Ident With Ident EQ With
##
## Ends in an error in state: 1064.
##
## field_path_assignment -> path EQ . expr [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## path EQ
##

Ill-formed record update.
At this point, the expression assigned to the field is expected.

interactive_expr: LBRACKET UIdent SEMI With
##
## Ends in an error in state: 1118.
##
## nsepseq(expr,SEMI) -> expr SEMI . nsepseq(expr,SEMI) [ RBRACKET ]
## nseq(__anonymous_0(expr,SEMI)) -> expr SEMI . seq(__anonymous_0(expr,SEMI)) [ RBRACKET ]
##
## The known suffix of the stack is as follows:
## expr SEMI
##
interactive_expr: LBRACKET UIdent SEMI UIdent SEMI With
##
## Ends in an error in state: 1122.
##
## nsepseq(expr,SEMI) -> expr SEMI . nsepseq(expr,SEMI) [ RBRACKET ]
## seq(__anonymous_0(expr,SEMI)) -> expr SEMI . seq(__anonymous_0(expr,SEMI)) [ RBRACKET ]
##
## The known suffix of the stack is as follows:
## expr SEMI
##

Ill-formed list of expressions.
At this point, one of the following is expected:
  * a list element as an expression;
  * a closing bracket ']' if the list is complete.

contract: Let Ident COLON UIdent Of Attr With
##
## Ends in an error in state: 54.
##
## record_type -> nseq(Attr) . LBRACE sep_or_term_list(field_decl,SEMI) RBRACE [ VBAR Type TIMES SEMI RPAR RBRACE Module Let In Ident End EQ EOF Directive COMMA Attr ARROW ]
##
## The known suffix of the stack is as follows:
## nseq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 33, spurious reduction of production seq(Attr) ->
## In state 36, spurious reduction of production nseq(Attr) -> Attr seq(Attr)
##

Ill-formed record type.
At this point, if the attribute is complete, an opening brace '{' is
expected.

contract: Type QUOTE Ident Ident With
##
## Ends in an error in state: 100.
##
## type_decl -> Type quoted_type_params Ident . EQ type_expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## Type quoted_type_params Ident
##
contract: Type Ident With
##
## Ends in an error in state: 13.
##
## type_decl -> Type Ident . EQ type_expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## Type Ident
##

Ill-formed type declaration.
At this point, the assignment symbol '=' is expected, followed by a
type expression.

contract: Type QUOTE Ident Ident EQ With
##
## Ends in an error in state: 101.
##
## type_decl -> Type quoted_type_params Ident EQ . type_expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## Type quoted_type_params Ident EQ
##
contract: Type Ident EQ With
##
## Ends in an error in state: 14.
##
## type_decl -> Type Ident EQ . type_expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## Type Ident EQ
##

Ill-formed type declaration.
At this point, a type expression is expected.

contract: Type Ident EQ VBAR Attr With
##
## Ends in an error in state: 39.
##
## variant(fun_type_level) -> nseq(Attr) . UIdent [ VBAR Type SEMI RPAR RBRACE Module Let In End EQ EOF Directive COMMA Attr ]
## variant(fun_type_level) -> nseq(Attr) . UIdent of_type(fun_type_level) [ VBAR Type SEMI RPAR RBRACE Module Let In End EQ EOF Directive COMMA Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 33, spurious reduction of production seq(Attr) ->
## In state 36, spurious reduction of production nseq(Attr) -> Attr seq(Attr)
##
interactive_expr: Fun Ident COLON VBAR Attr With
##
## Ends in an error in state: 300.
##
## variant(prod_type_level) -> nseq(Attr) . UIdent [ VBAR ARROW ]
## variant(prod_type_level) -> nseq(Attr) . UIdent of_type(prod_type_level) [ VBAR ARROW ]
##
## The known suffix of the stack is as follows:
## nseq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 33, spurious reduction of production seq(Attr) ->
## In state 36, spurious reduction of production nseq(Attr) -> Attr seq(Attr)
##

Ill-formed variant.
At this point, if the attributes of the variant are complete, a data
constructor is expected.

contract: Let Ident COLON Attr With
##
## Ends in an error in state: 63.
##
## record_type -> nseq(Attr) . LBRACE sep_or_term_list(field_decl,SEMI) RBRACE [ Type TIMES SEMI RPAR RBRACE Module Let In Ident End EQ EOF Directive COMMA Attr ARROW ]
## sum_type(fun_type_level) -> nseq(Attr) . VBAR nsepseq(variant(fun_type_level),VBAR) [ Type SEMI RPAR RBRACE Module Let In End EQ EOF Directive COMMA Attr ]
## variant(fun_type_level) -> nseq(Attr) . UIdent [ VBAR Type SEMI RPAR RBRACE Module Let In End EQ EOF Directive COMMA Attr ]
## variant(fun_type_level) -> nseq(Attr) . UIdent of_type(fun_type_level) [ VBAR Type SEMI RPAR RBRACE Module Let In End EQ EOF Directive COMMA Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 33, spurious reduction of production seq(Attr) ->
## In state 36, spurious reduction of production nseq(Attr) -> Attr seq(Attr)
##
interactive_expr: Fun Ident COLON Attr With
##
## Ends in an error in state: 308.
##
## record_type -> nseq(Attr) . LBRACE sep_or_term_list(field_decl,SEMI) RBRACE [ TIMES Ident ARROW ]
## sum_type(prod_type_level) -> nseq(Attr) . VBAR nsepseq(variant(prod_type_level),VBAR) [ ARROW ]
## variant(prod_type_level) -> nseq(Attr) . UIdent [ VBAR ARROW ]
## variant(prod_type_level) -> nseq(Attr) . UIdent of_type(prod_type_level) [ VBAR ARROW ]
##
## The known suffix of the stack is as follows:
## nseq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 33, spurious reduction of production seq(Attr) ->
## In state 36, spurious reduction of production nseq(Attr) -> Attr seq(Attr)
##

Ill-formed attributed sum type or record type.
At this point, if the attributes are complete, one of the following is
expected:
  * an opening brace '{' followed by field declarations, if defining a
    record type;
  * a variant starting with a value constructor, if defining a sum
    type (the attributes then apply to the variant, not the type);
  * a vertical bar followed by a variant (the attributes then apply to
    the sum type, not the variant).

interactive_expr: If UIdent Then Attr Fun Ident COLON Ident DOT
##
## Ends in an error in state: 1036.
##
## fun_expr(closed_expr) -> nseq(Attr) Fun nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW closed_expr [ Else ]
## fun_expr(expr) -> nseq(Attr) Fun nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun nseq(core_irrefutable) type_annotation(lambda_app_type)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 69, spurious reduction of production prod_type_level -> core_type
## In state 307, spurious reduction of production lambda_app_type -> prod_type_level
## In state 312, spurious reduction of production type_annotation(lambda_app_type) -> COLON lambda_app_type
##
interactive_expr: If UIdent Then Attr Fun LPAR Type Ident RPAR Ident COLON Ident DOT
##
## Ends in an error in state: 1032.
##
## fun_expr(closed_expr) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW closed_expr [ Else ]
## fun_expr(expr) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 69, spurious reduction of production prod_type_level -> core_type
## In state 307, spurious reduction of production lambda_app_type -> prod_type_level
## In state 312, spurious reduction of production type_annotation(lambda_app_type) -> COLON lambda_app_type
##
interactive_expr: Begin Match UIdent With UIdent ARROW Attr Fun Ident COLON Ident DOT
##
## Ends in an error in state: 966.
##
## fun_expr(base_cond) -> nseq(Attr) Fun nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW base_cond [ VBAR ]
## fun_expr(last_expr) -> nseq(Attr) Fun nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW last_expr [ End ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun nseq(core_irrefutable) type_annotation(lambda_app_type)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 69, spurious reduction of production prod_type_level -> core_type
## In state 307, spurious reduction of production lambda_app_type -> prod_type_level
## In state 312, spurious reduction of production type_annotation(lambda_app_type) -> COLON lambda_app_type
##
interactive_expr: Begin Match UIdent With UIdent ARROW Attr Fun LPAR Type Ident RPAR Ident COLON Ident DOT
##
## Ends in an error in state: 962.
##
## fun_expr(base_cond) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW base_cond [ VBAR ]
## fun_expr(last_expr) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW last_expr [ End ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 69, spurious reduction of production prod_type_level -> core_type
## In state 307, spurious reduction of production lambda_app_type -> prod_type_level
## In state 312, spurious reduction of production type_annotation(lambda_app_type) -> COLON lambda_app_type
##
interactive_expr: Begin Attr Fun LPAR Type Ident RPAR Ident COLON Ident DOT
##
## Ends in an error in state: 932.
##
## fun_expr(last_expr) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW last_expr [ End ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 69, spurious reduction of production prod_type_level -> core_type
## In state 307, spurious reduction of production lambda_app_type -> prod_type_level
## In state 312, spurious reduction of production type_annotation(lambda_app_type) -> COLON lambda_app_type
##
interactive_expr: Begin If UIdent Then Attr Fun Ident COLON Ident DOT
##
## Ends in an error in state: 894.
##
## fun_expr(closed_expr) -> nseq(Attr) Fun nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun nseq(core_irrefutable) type_annotation(lambda_app_type)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 69, spurious reduction of production prod_type_level -> core_type
## In state 307, spurious reduction of production lambda_app_type -> prod_type_level
## In state 312, spurious reduction of production type_annotation(lambda_app_type) -> COLON lambda_app_type
##
interactive_expr: Begin If UIdent Then Attr Fun LPAR Type Ident RPAR Ident COLON Ident DOT
##
## Ends in an error in state: 890.
##
## fun_expr(closed_expr) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 69, spurious reduction of production prod_type_level -> core_type
## In state 307, spurious reduction of production lambda_app_type -> prod_type_level
## In state 312, spurious reduction of production type_annotation(lambda_app_type) -> COLON lambda_app_type
##
interactive_expr: Match UIdent With UIdent ARROW Attr Fun Ident COLON Ident DOT
##
## Ends in an error in state: 826.
##
## fun_expr(base_cond) -> nseq(Attr) Fun nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun nseq(core_irrefutable) type_annotation(lambda_app_type)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 69, spurious reduction of production prod_type_level -> core_type
## In state 307, spurious reduction of production lambda_app_type -> prod_type_level
## In state 312, spurious reduction of production type_annotation(lambda_app_type) -> COLON lambda_app_type
##
interactive_expr: Match UIdent With UIdent ARROW Attr Fun LPAR Type Ident RPAR Ident COLON Ident DOT
##
## Ends in an error in state: 822.
##
## fun_expr(base_cond) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 69, spurious reduction of production prod_type_level -> core_type
## In state 307, spurious reduction of production lambda_app_type -> prod_type_level
## In state 312, spurious reduction of production type_annotation(lambda_app_type) -> COLON lambda_app_type
##
interactive_expr: If UIdent Then Match UIdent With UIdent ARROW Attr Fun Ident COLON Ident DOT
##
## Ends in an error in state: 760.
##
## fun_expr(base_cond) -> nseq(Attr) Fun nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_if_then_else) -> nseq(Attr) Fun nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun nseq(core_irrefutable) type_annotation(lambda_app_type)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 69, spurious reduction of production prod_type_level -> core_type
## In state 307, spurious reduction of production lambda_app_type -> prod_type_level
## In state 312, spurious reduction of production type_annotation(lambda_app_type) -> COLON lambda_app_type
##
interactive_expr: If UIdent Then Match UIdent With UIdent ARROW Attr Fun LPAR Type Ident RPAR Ident COLON Ident DOT
##
## Ends in an error in state: 754.
##
## fun_expr(base_cond) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_if_then_else) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 69, spurious reduction of production prod_type_level -> core_type
## In state 307, spurious reduction of production lambda_app_type -> prod_type_level
## In state 312, spurious reduction of production type_annotation(lambda_app_type) -> COLON lambda_app_type
##
interactive_expr: If UIdent Then Match UIdent With UIdent ARROW Fun LPAR Type Ident RPAR Ident COLON Ident DOT
##
## Ends in an error in state: 765.
##
## fun_expr(base_cond) -> Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_if_then_else) -> Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 69, spurious reduction of production prod_type_level -> core_type
## In state 307, spurious reduction of production lambda_app_type -> prod_type_level
## In state 312, spurious reduction of production type_annotation(lambda_app_type) -> COLON lambda_app_type
##
interactive_expr: If UIdent Then Match UIdent With UIdent ARROW Fun Ident COLON Ident DOT
##
## Ends in an error in state: 771.
##
## fun_expr(base_cond) -> Fun nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_if_then_else) -> Fun nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable) type_annotation(lambda_app_type)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 69, spurious reduction of production prod_type_level -> core_type
## In state 307, spurious reduction of production lambda_app_type -> prod_type_level
## In state 312, spurious reduction of production type_annotation(lambda_app_type) -> COLON lambda_app_type
##
interactive_expr: Match UIdent With UIdent ARROW Fun LPAR Type Ident RPAR Ident COLON Ident DOT
##
## Ends in an error in state: 828.
##
## fun_expr(base_cond) -> Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 69, spurious reduction of production prod_type_level -> core_type
## In state 307, spurious reduction of production lambda_app_type -> prod_type_level
## In state 312, spurious reduction of production type_annotation(lambda_app_type) -> COLON lambda_app_type
##
interactive_expr: Match UIdent With UIdent ARROW Fun Ident COLON Ident DOT
##
## Ends in an error in state: 832.
##
## fun_expr(base_cond) -> Fun nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable) type_annotation(lambda_app_type)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 69, spurious reduction of production prod_type_level -> core_type
## In state 307, spurious reduction of production lambda_app_type -> prod_type_level
## In state 312, spurious reduction of production type_annotation(lambda_app_type) -> COLON lambda_app_type
##
interactive_expr: Begin If UIdent Then Fun LPAR Type Ident RPAR Ident COLON Ident DOT
##
## Ends in an error in state: 896.
##
## fun_expr(closed_expr) -> Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 69, spurious reduction of production prod_type_level -> core_type
## In state 307, spurious reduction of production lambda_app_type -> prod_type_level
## In state 312, spurious reduction of production type_annotation(lambda_app_type) -> COLON lambda_app_type
##
interactive_expr: Begin If UIdent Then Fun Ident COLON Ident DOT
##
## Ends in an error in state: 900.
##
## fun_expr(closed_expr) -> Fun nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable) type_annotation(lambda_app_type)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 69, spurious reduction of production prod_type_level -> core_type
## In state 307, spurious reduction of production lambda_app_type -> prod_type_level
## In state 312, spurious reduction of production type_annotation(lambda_app_type) -> COLON lambda_app_type
##
interactive_expr: Begin Fun LPAR Type Ident RPAR Ident COLON Ident DOT
##
## Ends in an error in state: 942.
##
## fun_expr(last_expr) -> Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW last_expr [ End ]
##
## The known suffix of the stack is as follows:
## Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 69, spurious reduction of production prod_type_level -> core_type
## In state 307, spurious reduction of production lambda_app_type -> prod_type_level
## In state 312, spurious reduction of production type_annotation(lambda_app_type) -> COLON lambda_app_type
##
interactive_expr: Begin Fun Ident COLON Ident DOT
##
## Ends in an error in state: 948.
##
## fun_expr(last_expr) -> Fun nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW last_expr [ End ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable) type_annotation(lambda_app_type)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 69, spurious reduction of production prod_type_level -> core_type
## In state 307, spurious reduction of production lambda_app_type -> prod_type_level
## In state 312, spurious reduction of production type_annotation(lambda_app_type) -> COLON lambda_app_type
##
interactive_expr: Begin Match UIdent With UIdent ARROW Fun LPAR Type Ident RPAR Ident COLON Ident DOT
##
## Ends in an error in state: 968.
##
## fun_expr(base_cond) -> Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW base_cond [ VBAR ]
## fun_expr(last_expr) -> Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW last_expr [ End ]
##
## The known suffix of the stack is as follows:
## Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 69, spurious reduction of production prod_type_level -> core_type
## In state 307, spurious reduction of production lambda_app_type -> prod_type_level
## In state 312, spurious reduction of production type_annotation(lambda_app_type) -> COLON lambda_app_type
##
interactive_expr: Begin Match UIdent With UIdent ARROW Fun Ident COLON Ident DOT
##
## Ends in an error in state: 972.
##
## fun_expr(base_cond) -> Fun nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW base_cond [ VBAR ]
## fun_expr(last_expr) -> Fun nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW last_expr [ End ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable) type_annotation(lambda_app_type)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 69, spurious reduction of production prod_type_level -> core_type
## In state 307, spurious reduction of production lambda_app_type -> prod_type_level
## In state 312, spurious reduction of production type_annotation(lambda_app_type) -> COLON lambda_app_type
##
interactive_expr: Fun LPAR Type Ident RPAR Ident COLON Ident DOT
##
## Ends in an error in state: 986.
##
## fun_expr(expr) -> Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 69, spurious reduction of production prod_type_level -> core_type
## In state 307, spurious reduction of production lambda_app_type -> prod_type_level
## In state 312, spurious reduction of production type_annotation(lambda_app_type) -> COLON lambda_app_type
##
interactive_expr: Fun Ident COLON Ident DOT
##
## Ends in an error in state: 992.
##
## fun_expr(expr) -> Fun nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable) type_annotation(lambda_app_type)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 69, spurious reduction of production prod_type_level -> core_type
## In state 307, spurious reduction of production lambda_app_type -> prod_type_level
## In state 312, spurious reduction of production type_annotation(lambda_app_type) -> COLON lambda_app_type
##
interactive_expr: If UIdent Then Fun LPAR Type Ident RPAR Ident COLON Ident DOT
##
## Ends in an error in state: 1038.
##
## fun_expr(closed_expr) -> Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW closed_expr [ Else ]
## fun_expr(expr) -> Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 69, spurious reduction of production prod_type_level -> core_type
## In state 307, spurious reduction of production lambda_app_type -> prod_type_level
## In state 312, spurious reduction of production type_annotation(lambda_app_type) -> COLON lambda_app_type
##
interactive_expr: If UIdent Then Fun Ident COLON Ident DOT
##
## Ends in an error in state: 1042.
##
## fun_expr(closed_expr) -> Fun nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW closed_expr [ Else ]
## fun_expr(expr) -> Fun nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable) type_annotation(lambda_app_type)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 69, spurious reduction of production prod_type_level -> core_type
## In state 307, spurious reduction of production lambda_app_type -> prod_type_level
## In state 312, spurious reduction of production type_annotation(lambda_app_type) -> COLON lambda_app_type
##
interactive_expr: Match UIdent With UIdent ARROW If UIdent Then Fun Ident COLON Ident DOT
##
## Ends in an error in state: 701.
##
## fun_expr(base_cond) -> Fun nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(closed_expr) -> Fun nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable) type_annotation(lambda_app_type)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 69, spurious reduction of production prod_type_level -> core_type
## In state 307, spurious reduction of production lambda_app_type -> prod_type_level
## In state 312, spurious reduction of production type_annotation(lambda_app_type) -> COLON lambda_app_type
##
interactive_expr: Match UIdent With UIdent ARROW If UIdent Then Fun LPAR Type Ident RPAR Ident COLON Ident DOT
##
## Ends in an error in state: 693.
##
## fun_expr(base_cond) -> Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(closed_expr) -> Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 69, spurious reduction of production prod_type_level -> core_type
## In state 307, spurious reduction of production lambda_app_type -> prod_type_level
## In state 312, spurious reduction of production type_annotation(lambda_app_type) -> COLON lambda_app_type
##
interactive_expr: Attr Fun Ident COLON Ident DOT
##
## Ends in an error in state: 529.
##
## fun_expr(expr) -> nseq(Attr) Fun nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun nseq(core_irrefutable) type_annotation(lambda_app_type)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 69, spurious reduction of production prod_type_level -> core_type
## In state 307, spurious reduction of production lambda_app_type -> prod_type_level
## In state 312, spurious reduction of production type_annotation(lambda_app_type) -> COLON lambda_app_type
##
interactive_expr: Match UIdent With UIdent ARROW If UIdent Then Attr Fun LPAR Type Ident RPAR Ident COLON Ident DOT
##
## Ends in an error in state: 677.
##
## fun_expr(base_cond) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(closed_expr) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 69, spurious reduction of production prod_type_level -> core_type
## In state 307, spurious reduction of production lambda_app_type -> prod_type_level
## In state 312, spurious reduction of production type_annotation(lambda_app_type) -> COLON lambda_app_type
##
interactive_expr: Match UIdent With UIdent ARROW If UIdent Then Attr Fun Ident COLON Ident DOT
##
## Ends in an error in state: 685.
##
## fun_expr(base_cond) -> nseq(Attr) Fun nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(closed_expr) -> nseq(Attr) Fun nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun nseq(core_irrefutable) type_annotation(lambda_app_type)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 69, spurious reduction of production prod_type_level -> core_type
## In state 307, spurious reduction of production lambda_app_type -> prod_type_level
## In state 312, spurious reduction of production type_annotation(lambda_app_type) -> COLON lambda_app_type
##
interactive_expr: Attr Fun LPAR Type Ident RPAR Ident COLON Ident DOT
##
## Ends in an error in state: 521.
##
## fun_expr(expr) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) type_annotation(lambda_app_type)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 69, spurious reduction of production prod_type_level -> core_type
## In state 307, spurious reduction of production lambda_app_type -> prod_type_level
## In state 312, spurious reduction of production type_annotation(lambda_app_type) -> COLON lambda_app_type
##
interactive_expr: Begin Attr Fun Ident COLON Ident DOT
##
## Ends in an error in state: 938.
##
## fun_expr(last_expr) -> nseq(Attr) Fun nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW last_expr [ End ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun nseq(core_irrefutable) type_annotation(lambda_app_type)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 69, spurious reduction of production prod_type_level -> core_type
## In state 307, spurious reduction of production lambda_app_type -> prod_type_level
## In state 312, spurious reduction of production type_annotation(lambda_app_type) -> COLON lambda_app_type
##

Ill-formed functional expression.
At this point, if the type of the body is complete, an arrow '->' is
expected, followed by the body as an expression.

contract: Let LPAR UIdent COLON Ident With
##
## Ends in an error in state: 235.
##
## par(typed_irrefutable) -> LPAR typed_irrefutable . RPAR [ WILD UIdent SEMI RPAR RBRACE LPAR LBRACE Ident EQ COMMA COLON Attr ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR typed_irrefutable
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 69, spurious reduction of production prod_type_level -> core_type
## In state 50, spurious reduction of production fun_type_level -> prod_type_level
## In state 68, spurious reduction of production type_expr -> fun_type_level
## In state 219, spurious reduction of production type_annotation(type_expr) -> COLON type_expr
## In state 253, spurious reduction of production typed_irrefutable -> constr_irrefutable type_annotation(type_expr)
##

Ill-formed typed pattern.
At this point, if the type annotation is complete, then a closing
parenthesis ')' is expected.

interactive_expr: Verbatim With
##
## Ends in an error in state: 1178.
##
## interactive_expr -> expr . EOF [ # ]
##
## The known suffix of the stack is as follows:
## expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 329, spurious reduction of production call_expr_level -> core_expr
## In state 338, spurious reduction of production unary_expr_level -> call_expr_level
## In state 319, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 348, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 354, spurious reduction of production add_expr_level -> mult_expr_level
## In state 395, spurious reduction of production cons_expr_level -> add_expr_level
## In state 382, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 417, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 424, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 431, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 380, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 437, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 438, spurious reduction of production expr -> base_cond__open(expr)
##

Ill-formed expression.
At this point, if the expression is complete, the end of the input is
expected.

contract: Let WILD LPAR With
##
## Ends in an error in state: 113.
##
## par(type_param_list) -> LPAR . type_param_list RPAR [ EQ COLON ]
##
## The known suffix of the stack is as follows:
## LPAR
##

Ill-formed value declaration.
At this point, the keyword 'type' is expected, followed by type
parameters and a closing parenthesis ')'.

interactive_expr: Fun LBRACE Ident EQ UIdent With
##
## Ends in an error in state: 202.
##
## field_pattern(irrefutable) -> Ident EQ constr_irrefutable . [ SEMI RBRACE ]
## tuple(core_irrefutable) -> constr_irrefutable . COMMA nsepseq(core_irrefutable,COMMA) [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## Ident EQ constr_irrefutable
##
contract: Let LBRACE Ident EQ WILD With
##
## Ends in an error in state: 162.
##
## field_pattern(irrefutable) -> Ident EQ WILD . [ SEMI RBRACE ]
## tuple(core_irrefutable) -> WILD . COMMA nsepseq(core_irrefutable,COMMA) [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## Ident EQ WILD
##
contract: Let LBRACE Ident EQ Ident With
##
## Ends in an error in state: 164.
##
## field_pattern(irrefutable) -> Ident EQ var_pattern . [ SEMI RBRACE ]
## tuple(core_irrefutable) -> var_pattern . COMMA nsepseq(core_irrefutable,COMMA) [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## Ident EQ var_pattern
##
contract: Let LBRACE Ident EQ LPAR RPAR With
##
## Ends in an error in state: 189.
##
## field_pattern(irrefutable) -> Ident EQ unit . [ SEMI RBRACE ]
## tuple(core_irrefutable) -> unit . COMMA nsepseq(core_irrefutable,COMMA) [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## Ident EQ unit
##
contract: Let LBRACE Ident EQ LBRACE Ident RBRACE With
##
## Ends in an error in state: 193.
##
## field_pattern(irrefutable) -> Ident EQ record_pattern(irrefutable) . [ SEMI RBRACE ]
## tuple(core_irrefutable) -> record_pattern(irrefutable) . COMMA nsepseq(core_irrefutable,COMMA) [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## Ident EQ record_pattern(irrefutable)
##
contract: Let LBRACE Ident EQ LPAR UIdent COLON Ident RPAR With
##
## Ends in an error in state: 196.
##
## field_pattern(irrefutable) -> Ident EQ par(typed_irrefutable) . [ SEMI RBRACE ]
## tuple(core_irrefutable) -> par(typed_irrefutable) . COMMA nsepseq(core_irrefutable,COMMA) [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## Ident EQ par(typed_irrefutable)
##
contract: Let LBRACE Ident EQ LPAR WILD RPAR With
##
## Ends in an error in state: 199.
##
## field_pattern(irrefutable) -> Ident EQ par(irrefutable) . [ SEMI RBRACE ]
## tuple(core_irrefutable) -> par(irrefutable) . COMMA nsepseq(core_irrefutable,COMMA) [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## Ident EQ par(irrefutable)
##

Ill-formed record pattern.
At this point, one of the following is expected:
  * a comma ',' followed by a tuple component as a pattern, if the
    field is a tuple;
  * a semicolon ';' if the field is punned (that is, a variable with
    the same name is implicitly the pattern);
  * a closing brace '}' if the record pattern is complete.

contract: Let LPAR Ident With
##
## Ends in an error in state: 229.
##
## par(irrefutable) -> LPAR var_pattern . RPAR [ WILD UIdent SEMI RPAR RBRACE LPAR LBRACE Ident EQ COMMA COLON Attr ARROW ]
## tuple(core_irrefutable) -> var_pattern . COMMA nsepseq(core_irrefutable,COMMA) [ RPAR COLON ]
## typed_irrefutable -> var_pattern . type_annotation(type_expr) [ RPAR ]
##
## The known suffix of the stack is as follows:
## LPAR var_pattern
##
contract: Let LPAR LPAR RPAR With
##
## Ends in an error in state: 232.
##
## par(irrefutable) -> LPAR unit . RPAR [ WILD UIdent SEMI RPAR RBRACE LPAR LBRACE Ident EQ COMMA COLON Attr ARROW ]
## tuple(core_irrefutable) -> unit . COMMA nsepseq(core_irrefutable,COMMA) [ RPAR COLON ]
## typed_irrefutable -> unit . type_annotation(type_expr) [ RPAR ]
##
## The known suffix of the stack is as follows:
## LPAR unit
##
contract: Let LPAR WILD WILD
##
## Ends in an error in state: 154.
##
## par(irrefutable) -> LPAR WILD . RPAR [ WILD UIdent SEMI RPAR RBRACE LPAR LBRACE Ident EQ COMMA COLON Attr ARROW ]
## tuple(core_irrefutable) -> WILD . COMMA nsepseq(core_irrefutable,COMMA) [ RPAR COLON ]
## typed_irrefutable -> WILD . type_annotation(type_expr) [ RPAR ]
##
## The known suffix of the stack is as follows:
## LPAR WILD
##
contract: Let LPAR LBRACE Ident RBRACE With
##
## Ends in an error in state: 240.
##
## par(irrefutable) -> LPAR record_pattern(irrefutable) . RPAR [ WILD UIdent SEMI RPAR RBRACE LPAR LBRACE Ident EQ COMMA COLON Attr ARROW ]
## tuple(core_irrefutable) -> record_pattern(irrefutable) . COMMA nsepseq(core_irrefutable,COMMA) [ RPAR COLON ]
## typed_irrefutable -> record_pattern(irrefutable) . type_annotation(type_expr) [ RPAR ]
##
## The known suffix of the stack is as follows:
## LPAR record_pattern(irrefutable)
##
contract: Let LPAR LPAR UIdent COLON Ident RPAR With
##
## Ends in an error in state: 243.
##
## par(irrefutable) -> LPAR par(typed_irrefutable) . RPAR [ WILD UIdent SEMI RPAR RBRACE LPAR LBRACE Ident EQ COMMA COLON Attr ARROW ]
## tuple(core_irrefutable) -> par(typed_irrefutable) . COMMA nsepseq(core_irrefutable,COMMA) [ RPAR COLON ]
## typed_irrefutable -> par(typed_irrefutable) . type_annotation(type_expr) [ RPAR ]
##
## The known suffix of the stack is as follows:
## LPAR par(typed_irrefutable)
##
contract: Let LPAR LPAR WILD RPAR With
##
## Ends in an error in state: 246.
##
## par(irrefutable) -> LPAR par(irrefutable) . RPAR [ WILD UIdent SEMI RPAR RBRACE LPAR LBRACE Ident EQ COMMA COLON Attr ARROW ]
## tuple(core_irrefutable) -> par(irrefutable) . COMMA nsepseq(core_irrefutable,COMMA) [ RPAR COLON ]
## typed_irrefutable -> par(irrefutable) . type_annotation(type_expr) [ RPAR ]
##
## The known suffix of the stack is as follows:
## LPAR par(irrefutable)
##
contract: Let LPAR UIdent With
##
## Ends in an error in state: 251.
##
## par(irrefutable) -> LPAR constr_irrefutable . RPAR [ WILD UIdent SEMI RPAR RBRACE LPAR LBRACE Ident EQ COMMA COLON Attr ARROW ]
## tuple(core_irrefutable) -> constr_irrefutable . COMMA nsepseq(core_irrefutable,COMMA) [ RPAR COLON ]
## typed_irrefutable -> constr_irrefutable . type_annotation(type_expr) [ RPAR ]
##
## The known suffix of the stack is as follows:
## LPAR constr_irrefutable
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 221, spurious reduction of production constant_constr_pattern -> UIdent
## In state 183, spurious reduction of production constr_irrefutable -> constant_constr_pattern
##

Ill-formed pattern.
At this point, one of the following is expected:
  * a closing parenthesis ')', if the pattern is complete;
  * a comma ',' followed by another component as a pattern, if
    defining a tuple pattern;
  * a type annotation starting with ':'.

contract: Let Ident With
##
## Ends in an error in state: 254.
##
## let_binding -> var_pattern . parameters EQ expr [ Type Module Let In End EOF Directive Attr ]
## let_binding -> var_pattern . parameters type_annotation(type_expr) EQ expr [ Type Module Let In End EOF Directive Attr ]
## let_binding -> var_pattern . par(type_param_list) parameters EQ expr [ Type Module Let In End EOF Directive Attr ]
## let_binding -> var_pattern . par(type_param_list) parameters type_annotation(type_expr) EQ expr [ Type Module Let In End EOF Directive Attr ]
## let_binding -> var_pattern . EQ expr [ Type Module Let In End EOF Directive Attr ]
## let_binding -> var_pattern . type_annotation(type_expr) EQ expr [ Type Module Let In End EOF Directive Attr ]
## let_binding -> var_pattern . par(type_param_list) EQ expr [ Type Module Let In End EOF Directive Attr ]
## let_binding -> var_pattern . par(type_param_list) type_annotation(type_expr) EQ expr [ Type Module Let In End EOF Directive Attr ]
## tuple(core_irrefutable) -> var_pattern . COMMA nsepseq(core_irrefutable,COMMA) [ LPAR EQ COLON ]
##
## The known suffix of the stack is as follows:
## var_pattern
##

Ill-formed value declaration.
At this point, one of the following is expected:
  * parameters as irrefutable patterns, e.g. variables, if defining a
    function;
  * the assignment symbol '=' followed by an expression;
  * a type annotation starting with a colon ':';
  * a comma ',' followed by another tuple component, if defining a
    tuple.

contract: Let LPAR RPAR LPAR Type Ident RPAR With
##
## Ends in an error in state: 444.
##
## let_binding -> unit par(type_param_list) . EQ expr [ Type Module Let In End EOF Directive Attr ]
## let_binding -> unit par(type_param_list) . type_annotation(type_expr) EQ expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## unit par(type_param_list)
##
contract: Let WILD COMMA Ident LPAR Type Ident RPAR With
##
## Ends in an error in state: 456.
##
## let_binding -> tuple(core_irrefutable) par(type_param_list) . EQ expr [ Type Module Let In End EOF Directive Attr ]
## let_binding -> tuple(core_irrefutable) par(type_param_list) . type_annotation(type_expr) EQ expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## tuple(core_irrefutable) par(type_param_list)
##
contract: Let LBRACE Ident RBRACE LPAR Type Ident RPAR With
##
## Ends in an error in state: 468.
##
## let_binding -> record_pattern(irrefutable) par(type_param_list) . EQ expr [ Type Module Let In End EOF Directive Attr ]
## let_binding -> record_pattern(irrefutable) par(type_param_list) . type_annotation(type_expr) EQ expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## record_pattern(irrefutable) par(type_param_list)
##
contract: Let LPAR UIdent COLON Ident RPAR LPAR Type Ident RPAR With
##
## Ends in an error in state: 480.
##
## let_binding -> par(typed_irrefutable) par(type_param_list) . EQ expr [ Type Module Let In End EOF Directive Attr ]
## let_binding -> par(typed_irrefutable) par(type_param_list) . type_annotation(type_expr) EQ expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## par(typed_irrefutable) par(type_param_list)
##
contract: Let LPAR WILD RPAR LPAR Type Ident RPAR With
##
## Ends in an error in state: 492.
##
## let_binding -> par(irrefutable) par(type_param_list) . EQ expr [ Type Module Let In End EOF Directive Attr ]
## let_binding -> par(irrefutable) par(type_param_list) . type_annotation(type_expr) EQ expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## par(irrefutable) par(type_param_list)
##
contract: Let UIdent LPAR Type Ident RPAR With
##
## Ends in an error in state: 507.
##
## let_binding -> constr_irrefutable par(type_param_list) . EQ expr [ Type Module Let In End EOF Directive Attr ]
## let_binding -> constr_irrefutable par(type_param_list) . type_annotation(type_expr) EQ expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## constr_irrefutable par(type_param_list)
##
contract: Let WILD LPAR Type Ident RPAR With
##
## Ends in an error in state: 1146.
##
## let_binding -> WILD par(type_param_list) . EQ expr [ Type Module Let In End EOF Directive Attr ]
## let_binding -> WILD par(type_param_list) . type_annotation(type_expr) EQ expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## WILD par(type_param_list)
##

Ill-formed value declaration.
At this point, one of the following is expected:
  * the assignment symbol '=' followed by an expression;
  * a type annotation starting with a colon ':'.

contract: Let Ident LPAR Type Ident RPAR WILD ARROW
##
## Ends in an error in state: 1101.
##
## let_binding -> var_pattern par(type_param_list) parameters . EQ expr [ Type Module Let In End EOF Directive Attr ]
## let_binding -> var_pattern par(type_param_list) parameters . type_annotation(type_expr) EQ expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## var_pattern par(type_param_list) parameters
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 255, spurious reduction of production seq(core_irrefutable) ->
## In state 270, spurious reduction of production nseq(core_irrefutable) -> WILD seq(core_irrefutable)
## In state 1107, spurious reduction of production parameters -> nseq(core_irrefutable)
##
contract: Let Ident WILD ARROW
##
## Ends in an error in state: 1089.
##
## let_binding -> var_pattern parameters . EQ expr [ Type Module Let In End EOF Directive Attr ]
## let_binding -> var_pattern parameters . type_annotation(type_expr) EQ expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## var_pattern parameters
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 255, spurious reduction of production seq(core_irrefutable) ->
## In state 270, spurious reduction of production nseq(core_irrefutable) -> WILD seq(core_irrefutable)
## In state 1107, spurious reduction of production parameters -> nseq(core_irrefutable)
##

Ill-formed function declaration.
At this point, if there are no more parameters, one of the following
is expected:
  * the assignment symbol '=' followed by an expression;
  * a type annotation starting with a colon ':'.

contract: Let WILD COMMA Ident With
##
## Ends in an error in state: 450.
##
## let_binding -> tuple(core_irrefutable) . EQ expr [ Type Module Let In End EOF Directive Attr ]
## let_binding -> tuple(core_irrefutable) . type_annotation(type_expr) EQ expr [ Type Module Let In End EOF Directive Attr ]
## let_binding -> tuple(core_irrefutable) . par(type_param_list) EQ expr [ Type Module Let In End EOF Directive Attr ]
## let_binding -> tuple(core_irrefutable) . par(type_param_list) type_annotation(type_expr) EQ expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## tuple(core_irrefutable)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 166, spurious reduction of production nsepseq(core_irrefutable,COMMA) -> var_pattern
## In state 217, spurious reduction of production tuple(core_irrefutable) -> WILD COMMA nsepseq(core_irrefutable,COMMA)
##

Ill-formed tuple declaration.
At this point, if there are no more components, one of the following
is expected:
  * the assignment symbol '=' followed by an expression;
  * a type annotation starting with a colon ':';
  * bound type parameters between parentheses, like '(type a b)'.

contract: Let LBRACE Ident RBRACE With
##
## Ends in an error in state: 462.
##
## let_binding -> record_pattern(irrefutable) . EQ expr [ Type Module Let In End EOF Directive Attr ]
## let_binding -> record_pattern(irrefutable) . type_annotation(type_expr) EQ expr [ Type Module Let In End EOF Directive Attr ]
## let_binding -> record_pattern(irrefutable) . par(type_param_list) EQ expr [ Type Module Let In End EOF Directive Attr ]
## let_binding -> record_pattern(irrefutable) . par(type_param_list) type_annotation(type_expr) EQ expr [ Type Module Let In End EOF Directive Attr ]
## tuple(core_irrefutable) -> record_pattern(irrefutable) . COMMA nsepseq(core_irrefutable,COMMA) [ LPAR EQ COLON ]
##
## The known suffix of the stack is as follows:
## record_pattern(irrefutable)
##
contract: Let LPAR UIdent COLON Ident RPAR With
##
## Ends in an error in state: 474.
##
## let_binding -> par(typed_irrefutable) . EQ expr [ Type Module Let In End EOF Directive Attr ]
## let_binding -> par(typed_irrefutable) . type_annotation(type_expr) EQ expr [ Type Module Let In End EOF Directive Attr ]
## let_binding -> par(typed_irrefutable) . par(type_param_list) EQ expr [ Type Module Let In End EOF Directive Attr ]
## let_binding -> par(typed_irrefutable) . par(type_param_list) type_annotation(type_expr) EQ expr [ Type Module Let In End EOF Directive Attr ]
## tuple(core_irrefutable) -> par(typed_irrefutable) . COMMA nsepseq(core_irrefutable,COMMA) [ LPAR EQ COLON ]
##
## The known suffix of the stack is as follows:
## par(typed_irrefutable)
##
contract: Let LPAR WILD RPAR With
##
## Ends in an error in state: 486.
##
## let_binding -> par(irrefutable) . EQ expr [ Type Module Let In End EOF Directive Attr ]
## let_binding -> par(irrefutable) . type_annotation(type_expr) EQ expr [ Type Module Let In End EOF Directive Attr ]
## let_binding -> par(irrefutable) . par(type_param_list) EQ expr [ Type Module Let In End EOF Directive Attr ]
## let_binding -> par(irrefutable) . par(type_param_list) type_annotation(type_expr) EQ expr [ Type Module Let In End EOF Directive Attr ]
## tuple(core_irrefutable) -> par(irrefutable) . COMMA nsepseq(core_irrefutable,COMMA) [ LPAR EQ COLON ]
##
## The known suffix of the stack is as follows:
## par(irrefutable)
##
contract: Let UIdent With
##
## Ends in an error in state: 501.
##
## let_binding -> constr_irrefutable . EQ expr [ Type Module Let In End EOF Directive Attr ]
## let_binding -> constr_irrefutable . type_annotation(type_expr) EQ expr [ Type Module Let In End EOF Directive Attr ]
## let_binding -> constr_irrefutable . par(type_param_list) EQ expr [ Type Module Let In End EOF Directive Attr ]
## let_binding -> constr_irrefutable . par(type_param_list) type_annotation(type_expr) EQ expr [ Type Module Let In End EOF Directive Attr ]
## tuple(core_irrefutable) -> constr_irrefutable . COMMA nsepseq(core_irrefutable,COMMA) [ LPAR EQ COLON ]
##
## The known suffix of the stack is as follows:
## constr_irrefutable
##

Ill-formed tuple declaration.
At this point, one of the following is expected:
  * a comma ',' followed by another component as a pattern;
  * the assignment symbol '=' followed by an expression;
  * a type annotation starting with a colon ':';
  * bound type parameters between parentheses, like '(type a b)'.

interactive_expr: Attr Fun LPAR Type Ident RPAR WILD EQ
##
## Ends in an error in state: 518.
##
## fun_expr(expr) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) . ARROW expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(expr) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 255, spurious reduction of production seq(core_irrefutable) ->
## In state 270, spurious reduction of production nseq(core_irrefutable) -> WILD seq(core_irrefutable)
##
interactive_expr: Attr Fun WILD EQ
##
## Ends in an error in state: 526.
##
## fun_expr(expr) -> nseq(Attr) Fun nseq(core_irrefutable) . ARROW expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(expr) -> nseq(Attr) Fun nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun nseq(core_irrefutable)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 255, spurious reduction of production seq(core_irrefutable) ->
## In state 270, spurious reduction of production nseq(core_irrefutable) -> WILD seq(core_irrefutable)
##
interactive_expr: Begin Attr Fun LPAR Type Ident RPAR WILD EQ
##
## Ends in an error in state: 929.
##
## fun_expr(last_expr) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) . ARROW last_expr [ End ]
## fun_expr(last_expr) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW last_expr [ End ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 255, spurious reduction of production seq(core_irrefutable) ->
## In state 270, spurious reduction of production nseq(core_irrefutable) -> WILD seq(core_irrefutable)
##
interactive_expr: Begin Attr Fun WILD EQ
##
## Ends in an error in state: 935.
##
## fun_expr(last_expr) -> nseq(Attr) Fun nseq(core_irrefutable) . ARROW last_expr [ End ]
## fun_expr(last_expr) -> nseq(Attr) Fun nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW last_expr [ End ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun nseq(core_irrefutable)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 255, spurious reduction of production seq(core_irrefutable) ->
## In state 270, spurious reduction of production nseq(core_irrefutable) -> WILD seq(core_irrefutable)
##
interactive_expr: Begin Fun LPAR Type Ident RPAR WILD EQ
##
## Ends in an error in state: 911.
##
## fun_expr(last_expr) -> Fun par(type_param_list) nseq(core_irrefutable) . ARROW last_expr [ End ]
## fun_expr(last_expr) -> Fun par(type_param_list) nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW last_expr [ End ]
##
## The known suffix of the stack is as follows:
## Fun par(type_param_list) nseq(core_irrefutable)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 255, spurious reduction of production seq(core_irrefutable) ->
## In state 270, spurious reduction of production nseq(core_irrefutable) -> WILD seq(core_irrefutable)
##
interactive_expr: Begin Fun WILD EQ
##
## Ends in an error in state: 945.
##
## fun_expr(last_expr) -> Fun nseq(core_irrefutable) . ARROW last_expr [ End ]
## fun_expr(last_expr) -> Fun nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW last_expr [ End ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 255, spurious reduction of production seq(core_irrefutable) ->
## In state 270, spurious reduction of production nseq(core_irrefutable) -> WILD seq(core_irrefutable)
##
interactive_expr: Begin If Verbatim Then Attr Fun LPAR Type Ident RPAR WILD EQ
##
## Ends in an error in state: 888.
##
## fun_expr(closed_expr) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) . ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 255, spurious reduction of production seq(core_irrefutable) ->
## In state 270, spurious reduction of production nseq(core_irrefutable) -> WILD seq(core_irrefutable)
##
interactive_expr: Begin If Verbatim Then Attr Fun WILD EQ
##
## Ends in an error in state: 892.
##
## fun_expr(closed_expr) -> nseq(Attr) Fun nseq(core_irrefutable) . ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> nseq(Attr) Fun nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun nseq(core_irrefutable)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 255, spurious reduction of production seq(core_irrefutable) ->
## In state 270, spurious reduction of production nseq(core_irrefutable) -> WILD seq(core_irrefutable)
##
interactive_expr: Begin If Verbatim Then Fun LPAR Type Ident RPAR WILD EQ
##
## Ends in an error in state: 869.
##
## fun_expr(closed_expr) -> Fun par(type_param_list) nseq(core_irrefutable) . ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> Fun par(type_param_list) nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Fun par(type_param_list) nseq(core_irrefutable)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 255, spurious reduction of production seq(core_irrefutable) ->
## In state 270, spurious reduction of production nseq(core_irrefutable) -> WILD seq(core_irrefutable)
##
interactive_expr: Begin If Verbatim Then Fun WILD EQ
##
## Ends in an error in state: 898.
##
## fun_expr(closed_expr) -> Fun nseq(core_irrefutable) . ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> Fun nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 255, spurious reduction of production seq(core_irrefutable) ->
## In state 270, spurious reduction of production nseq(core_irrefutable) -> WILD seq(core_irrefutable)
##
interactive_expr: Begin Match Verbatim With WILD ARROW Attr Fun LPAR Type Ident RPAR WILD EQ
##
## Ends in an error in state: 960.
##
## fun_expr(base_cond) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) . ARROW base_cond [ VBAR ]
## fun_expr(base_cond) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW base_cond [ VBAR ]
## fun_expr(last_expr) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) . ARROW last_expr [ End ]
## fun_expr(last_expr) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW last_expr [ End ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 255, spurious reduction of production seq(core_irrefutable) ->
## In state 270, spurious reduction of production nseq(core_irrefutable) -> WILD seq(core_irrefutable)
##
interactive_expr: Begin Match Verbatim With WILD ARROW Attr Fun WILD EQ
##
## Ends in an error in state: 964.
##
## fun_expr(base_cond) -> nseq(Attr) Fun nseq(core_irrefutable) . ARROW base_cond [ VBAR ]
## fun_expr(base_cond) -> nseq(Attr) Fun nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW base_cond [ VBAR ]
## fun_expr(last_expr) -> nseq(Attr) Fun nseq(core_irrefutable) . ARROW last_expr [ End ]
## fun_expr(last_expr) -> nseq(Attr) Fun nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW last_expr [ End ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun nseq(core_irrefutable)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 255, spurious reduction of production seq(core_irrefutable) ->
## In state 270, spurious reduction of production nseq(core_irrefutable) -> WILD seq(core_irrefutable)
##
interactive_expr: Begin Match Verbatim With WILD ARROW Fun LPAR Type Ident RPAR WILD EQ
##
## Ends in an error in state: 841.
##
## fun_expr(base_cond) -> Fun par(type_param_list) nseq(core_irrefutable) . ARROW base_cond [ VBAR ]
## fun_expr(base_cond) -> Fun par(type_param_list) nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW base_cond [ VBAR ]
## fun_expr(last_expr) -> Fun par(type_param_list) nseq(core_irrefutable) . ARROW last_expr [ End ]
## fun_expr(last_expr) -> Fun par(type_param_list) nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW last_expr [ End ]
##
## The known suffix of the stack is as follows:
## Fun par(type_param_list) nseq(core_irrefutable)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 255, spurious reduction of production seq(core_irrefutable) ->
## In state 270, spurious reduction of production nseq(core_irrefutable) -> WILD seq(core_irrefutable)
##
interactive_expr: Begin Match Verbatim With WILD ARROW Fun WILD EQ
##
## Ends in an error in state: 970.
##
## fun_expr(base_cond) -> Fun nseq(core_irrefutable) . ARROW base_cond [ VBAR ]
## fun_expr(base_cond) -> Fun nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW base_cond [ VBAR ]
## fun_expr(last_expr) -> Fun nseq(core_irrefutable) . ARROW last_expr [ End ]
## fun_expr(last_expr) -> Fun nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW last_expr [ End ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 255, spurious reduction of production seq(core_irrefutable) ->
## In state 270, spurious reduction of production nseq(core_irrefutable) -> WILD seq(core_irrefutable)
##
interactive_expr: Fun LPAR Type Ident RPAR WILD EQ
##
## Ends in an error in state: 291.
##
## fun_expr(expr) -> Fun par(type_param_list) nseq(core_irrefutable) . ARROW expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(expr) -> Fun par(type_param_list) nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun par(type_param_list) nseq(core_irrefutable)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 255, spurious reduction of production seq(core_irrefutable) ->
## In state 270, spurious reduction of production nseq(core_irrefutable) -> WILD seq(core_irrefutable)
##
interactive_expr: Fun WILD EQ
##
## Ends in an error in state: 989.
##
## fun_expr(expr) -> Fun nseq(core_irrefutable) . ARROW expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(expr) -> Fun nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 255, spurious reduction of production seq(core_irrefutable) ->
## In state 270, spurious reduction of production nseq(core_irrefutable) -> WILD seq(core_irrefutable)
##
interactive_expr: If Verbatim Then Attr Fun LPAR Type Ident RPAR WILD EQ
##
## Ends in an error in state: 1030.
##
## fun_expr(closed_expr) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) . ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW closed_expr [ Else ]
## fun_expr(expr) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) . ARROW expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(expr) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 255, spurious reduction of production seq(core_irrefutable) ->
## In state 270, spurious reduction of production nseq(core_irrefutable) -> WILD seq(core_irrefutable)
##
interactive_expr: If Verbatim Then Attr Fun WILD EQ
##
## Ends in an error in state: 1034.
##
## fun_expr(closed_expr) -> nseq(Attr) Fun nseq(core_irrefutable) . ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> nseq(Attr) Fun nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW closed_expr [ Else ]
## fun_expr(expr) -> nseq(Attr) Fun nseq(core_irrefutable) . ARROW expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(expr) -> nseq(Attr) Fun nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun nseq(core_irrefutable)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 255, spurious reduction of production seq(core_irrefutable) ->
## In state 270, spurious reduction of production nseq(core_irrefutable) -> WILD seq(core_irrefutable)
##
interactive_expr: If Verbatim Then Fun LPAR Type Ident RPAR WILD EQ
##
## Ends in an error in state: 1011.
##
## fun_expr(closed_expr) -> Fun par(type_param_list) nseq(core_irrefutable) . ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> Fun par(type_param_list) nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW closed_expr [ Else ]
## fun_expr(expr) -> Fun par(type_param_list) nseq(core_irrefutable) . ARROW expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(expr) -> Fun par(type_param_list) nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun par(type_param_list) nseq(core_irrefutable)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 255, spurious reduction of production seq(core_irrefutable) ->
## In state 270, spurious reduction of production nseq(core_irrefutable) -> WILD seq(core_irrefutable)
##
interactive_expr: If Verbatim Then Fun WILD EQ
##
## Ends in an error in state: 1040.
##
## fun_expr(closed_expr) -> Fun nseq(core_irrefutable) . ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> Fun nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW closed_expr [ Else ]
## fun_expr(expr) -> Fun nseq(core_irrefutable) . ARROW expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(expr) -> Fun nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 255, spurious reduction of production seq(core_irrefutable) ->
## In state 270, spurious reduction of production nseq(core_irrefutable) -> WILD seq(core_irrefutable)
##
interactive_expr: If Verbatim Then Match Verbatim With WILD ARROW Attr Fun LPAR Type Ident RPAR WILD EQ
##
## Ends in an error in state: 751.
##
## fun_expr(base_cond) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) . ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_cond) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_if_then_else) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) . ARROW base_if_then_else [ Else ]
## fun_expr(base_if_then_else) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 255, spurious reduction of production seq(core_irrefutable) ->
## In state 270, spurious reduction of production nseq(core_irrefutable) -> WILD seq(core_irrefutable)
##
interactive_expr: If Verbatim Then Match Verbatim With WILD ARROW Attr Fun WILD EQ
##
## Ends in an error in state: 757.
##
## fun_expr(base_cond) -> nseq(Attr) Fun nseq(core_irrefutable) . ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_cond) -> nseq(Attr) Fun nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_if_then_else) -> nseq(Attr) Fun nseq(core_irrefutable) . ARROW base_if_then_else [ Else ]
## fun_expr(base_if_then_else) -> nseq(Attr) Fun nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun nseq(core_irrefutable)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 255, spurious reduction of production seq(core_irrefutable) ->
## In state 270, spurious reduction of production nseq(core_irrefutable) -> WILD seq(core_irrefutable)
##
interactive_expr: If Verbatim Then Match Verbatim With WILD ARROW Fun LPAR Type Ident RPAR WILD EQ
##
## Ends in an error in state: 720.
##
## fun_expr(base_cond) -> Fun par(type_param_list) nseq(core_irrefutable) . ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_cond) -> Fun par(type_param_list) nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_if_then_else) -> Fun par(type_param_list) nseq(core_irrefutable) . ARROW base_if_then_else [ Else ]
## fun_expr(base_if_then_else) -> Fun par(type_param_list) nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## Fun par(type_param_list) nseq(core_irrefutable)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 255, spurious reduction of production seq(core_irrefutable) ->
## In state 270, spurious reduction of production nseq(core_irrefutable) -> WILD seq(core_irrefutable)
##
interactive_expr: If Verbatim Then Match Verbatim With WILD ARROW Fun WILD EQ
##
## Ends in an error in state: 768.
##
## fun_expr(base_cond) -> Fun nseq(core_irrefutable) . ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_cond) -> Fun nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_if_then_else) -> Fun nseq(core_irrefutable) . ARROW base_if_then_else [ Else ]
## fun_expr(base_if_then_else) -> Fun nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 255, spurious reduction of production seq(core_irrefutable) ->
## In state 270, spurious reduction of production nseq(core_irrefutable) -> WILD seq(core_irrefutable)
##
interactive_expr: Match Verbatim With WILD ARROW Attr Fun LPAR Type Ident RPAR WILD EQ
##
## Ends in an error in state: 820.
##
## fun_expr(base_cond) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) . ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_cond) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 255, spurious reduction of production seq(core_irrefutable) ->
## In state 270, spurious reduction of production nseq(core_irrefutable) -> WILD seq(core_irrefutable)
##
interactive_expr: Match Verbatim With WILD ARROW Attr Fun WILD EQ
##
## Ends in an error in state: 824.
##
## fun_expr(base_cond) -> nseq(Attr) Fun nseq(core_irrefutable) . ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_cond) -> nseq(Attr) Fun nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun nseq(core_irrefutable)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 255, spurious reduction of production seq(core_irrefutable) ->
## In state 270, spurious reduction of production nseq(core_irrefutable) -> WILD seq(core_irrefutable)
##
interactive_expr: Match Verbatim With WILD ARROW Fun LPAR Type Ident RPAR WILD EQ
##
## Ends in an error in state: 801.
##
## fun_expr(base_cond) -> Fun par(type_param_list) nseq(core_irrefutable) . ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_cond) -> Fun par(type_param_list) nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun par(type_param_list) nseq(core_irrefutable)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 255, spurious reduction of production seq(core_irrefutable) ->
## In state 270, spurious reduction of production nseq(core_irrefutable) -> WILD seq(core_irrefutable)
##
interactive_expr: Match Verbatim With WILD ARROW Fun WILD EQ
##
## Ends in an error in state: 830.
##
## fun_expr(base_cond) -> Fun nseq(core_irrefutable) . ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_cond) -> Fun nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 255, spurious reduction of production seq(core_irrefutable) ->
## In state 270, spurious reduction of production nseq(core_irrefutable) -> WILD seq(core_irrefutable)
##
interactive_expr: Match Verbatim With WILD ARROW If Verbatim Then Attr Fun LPAR Type Ident RPAR WILD EQ
##
## Ends in an error in state: 673.
##
## fun_expr(base_cond) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) . ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_cond) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(closed_expr) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) . ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun par(type_param_list) nseq(core_irrefutable)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 255, spurious reduction of production seq(core_irrefutable) ->
## In state 270, spurious reduction of production nseq(core_irrefutable) -> WILD seq(core_irrefutable)
##
interactive_expr: Match Verbatim With WILD ARROW If Verbatim Then Attr Fun WILD EQ
##
## Ends in an error in state: 681.
##
## fun_expr(base_cond) -> nseq(Attr) Fun nseq(core_irrefutable) . ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_cond) -> nseq(Attr) Fun nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(closed_expr) -> nseq(Attr) Fun nseq(core_irrefutable) . ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> nseq(Attr) Fun nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Fun nseq(core_irrefutable)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 255, spurious reduction of production seq(core_irrefutable) ->
## In state 270, spurious reduction of production nseq(core_irrefutable) -> WILD seq(core_irrefutable)
##
interactive_expr: Match Verbatim With WILD ARROW If Verbatim Then Fun LPAR Type Ident RPAR WILD EQ
##
## Ends in an error in state: 627.
##
## fun_expr(base_cond) -> Fun par(type_param_list) nseq(core_irrefutable) . ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_cond) -> Fun par(type_param_list) nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(closed_expr) -> Fun par(type_param_list) nseq(core_irrefutable) . ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> Fun par(type_param_list) nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Fun par(type_param_list) nseq(core_irrefutable)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 255, spurious reduction of production seq(core_irrefutable) ->
## In state 270, spurious reduction of production nseq(core_irrefutable) -> WILD seq(core_irrefutable)
##
interactive_expr: Match Verbatim With WILD ARROW If Verbatim Then Fun WILD EQ
##
## Ends in an error in state: 697.
##
## fun_expr(base_cond) -> Fun nseq(core_irrefutable) . ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_cond) -> Fun nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(closed_expr) -> Fun nseq(core_irrefutable) . ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> Fun nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 255, spurious reduction of production seq(core_irrefutable) ->
## In state 270, spurious reduction of production nseq(core_irrefutable) -> WILD seq(core_irrefutable)
##

Ill-formed functional expression.
At this point, if there are no more parameters, one of the following
is expected:
  * an arrow '->', followed by the body as an expression;
  * a type annotation for the body, starting with a colon ':'.
