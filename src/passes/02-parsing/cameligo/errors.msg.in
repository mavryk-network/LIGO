interactive_expr: Begin With
##
## Ends in an error in state: 241.
##
## sequence_expr -> Begin . End [ With Verbatim VBAR UIdent Type Then TIMES String SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Lxor Lsr Lsl Lor Let Lang Land LT LPAR LE LBRACKET LBRACE Int In Ident GT End Else EQ EOF Directive CONS COMMA COLON CARET Bytes Begin BOOL_OR BOOL_AND Attr ]
## sequence_expr -> Begin . series End [ With Verbatim VBAR UIdent Type Then TIMES String SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Lxor Lsr Lsl Lor Let Lang Land LT LPAR LE LBRACKET LBRACE Int In Ident GT End Else EQ EOF Directive CONS COMMA COLON CARET Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## Begin
##

Ill-formed sequence of expressions.
At this point, one of the following is expected:
  * an expression of type 'unit';
  * the keyword 'end' if the sequence is empty.

interactive_expr: Begin Fun WILD ARROW Bytes SEMI
##
## Ends in an error in state: 901.
##
## sequence_expr -> Begin series . End [ With Verbatim VBAR UIdent Type Then TIMES String SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Lxor Lsr Lsl Lor Let Lang Land LT LPAR LE LBRACKET LBRACE Int In Ident GT End Else EQ EOF Directive CONS COMMA COLON CARET Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## Begin series
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 320, spurious reduction of production app_expr_level -> core_expr
## In state 327, spurious reduction of production unary_expr_level -> app_expr_level
## In state 307, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 335, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 341, spurious reduction of production add_expr_level -> mult_expr_level
## In state 377, spurious reduction of production cons_expr_level -> add_expr_level
## In state 364, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 401, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 408, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 417, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 864, spurious reduction of production seq_expr -> disj_expr_level
## In state 803, spurious reduction of production last_expr -> seq_expr
## In state 874, spurious reduction of production fun_expr(last_expr) -> Fun nseq(core_irrefutable) ARROW last_expr
## In state 863, spurious reduction of production last_expr -> fun_expr(last_expr)
## In state 862, spurious reduction of production series -> last_expr
##

Ill-formed sequence of expressions.
At this point, if the expression is complete, one of the following is
expected:
  * a semicolon ';' followed by another expression;
  * the keyword 'end' if the sequence is complete.

interactive_expr: Begin Match UIdent With UIdent ARROW If With
##
## Ends in an error in state: 790.
##
## if_then(base_cond) -> If . expr Then base_cond [ VBAR ]
## if_then_else(base_cond) -> If . expr Then closed_expr Else base_cond [ VBAR ]
## if_then_else(seq_expr) -> If . expr Then closed_expr Else seq_expr [ SEMI End ]
##
## The known suffix of the stack is as follows:
## If
##
interactive_expr: If With
##
## Ends in an error in state: 243.
##
## if_then(expr) -> If . expr Then expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## if_then_else(expr) -> If . expr Then closed_expr Else expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## If
##
interactive_expr: If UIdent Then If With
##
## Ends in an error in state: 751.
##
## if_then(expr) -> If . expr Then expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## if_then_else(closed_expr) -> If . expr Then closed_expr Else closed_expr [ Else ]
## if_then_else(expr) -> If . expr Then closed_expr Else expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## If
##
interactive_expr: Begin If UIdent Then If With
##
## Ends in an error in state: 823.
##
## if_then_else(closed_expr) -> If . expr Then closed_expr Else closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## If
##
interactive_expr: Begin If With
##
## Ends in an error in state: 816.
##
## if_then_else(seq_expr) -> If . expr Then closed_expr Else seq_expr [ SEMI End ]
##
## The known suffix of the stack is as follows:
## If
##
interactive_expr: Match UIdent With UIdent ARROW If With
##
## Ends in an error in state: 611.
##
## if_then(base_cond) -> If . expr Then base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## if_then_else(base_cond) -> If . expr Then closed_expr Else base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## If
##
interactive_expr: Match UIdent With UIdent ARROW If UIdent Then If With
##
## Ends in an error in state: 598.
##
## if_then(base_cond) -> If . expr Then base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## if_then_else(base_cond) -> If . expr Then closed_expr Else base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## if_then_else(closed_expr) -> If . expr Then closed_expr Else closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## If
##
interactive_expr: If UIdent Then Match UIdent With UIdent ARROW If With
##
## Ends in an error in state: 579.
##
## if_then(base_cond) -> If . expr Then base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## if_then_else(base_cond) -> If . expr Then closed_expr Else base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## if_then_else(base_if_then_else) -> If . expr Then closed_expr Else base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## If
##

Ill-formed conditional expression.
At this point, the condition is expected as an expression.

interactive_expr: If UIdent Then UIdent Else With
##
## Ends in an error in state: 780.
##
## if_then_else(expr) -> If expr Then closed_expr Else . expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## If expr Then closed_expr Else
##
interactive_expr: Begin If UIdent Then If UIdent Then UIdent Else With
##
## Ends in an error in state: 844.
##
## if_then_else(closed_expr) -> If expr Then closed_expr Else . closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## If expr Then closed_expr Else
##
interactive_expr: Match UIdent With UIdent ARROW If UIdent Then UIdent Else With
##
## Ends in an error in state: 637.
##
## if_then_else(base_cond) -> If expr Then closed_expr Else . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## If expr Then closed_expr Else
##
interactive_expr: If UIdent Then Match UIdent With UIdent ARROW If UIdent Then UIdent Else With
##
## Ends in an error in state: 705.
##
## if_then_else(base_cond) -> If expr Then closed_expr Else . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## if_then_else(base_if_then_else) -> If expr Then closed_expr Else . base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## If expr Then closed_expr Else
##
interactive_expr: Match UIdent With UIdent ARROW If UIdent Then If UIdent Then UIdent Else With
##
## Ends in an error in state: 698.
##
## if_then_else(base_cond) -> If expr Then closed_expr Else . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## if_then_else(closed_expr) -> If expr Then closed_expr Else . closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## If expr Then closed_expr Else
##
interactive_expr: Begin Match UIdent With UIdent ARROW If UIdent Then UIdent Else With
##
## Ends in an error in state: 794.
##
## if_then_else(base_cond) -> If expr Then closed_expr Else . base_cond [ VBAR ]
## if_then_else(seq_expr) -> If expr Then closed_expr Else . seq_expr [ SEMI End ]
##
## The known suffix of the stack is as follows:
## If expr Then closed_expr Else
##
interactive_expr: If UIdent Then If UIdent Then UIdent Else With
##
## Ends in an error in state: 773.
##
## if_then_else(closed_expr) -> If expr Then closed_expr Else . closed_expr [ Else ]
## if_then_else(expr) -> If expr Then closed_expr Else . expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## If expr Then closed_expr Else
##
interactive_expr: Begin If Verbatim Then Verbatim Else With
##
## Ends in an error in state: 848.
##
## if_then_else(seq_expr) -> If expr Then closed_expr Else . seq_expr [ SEMI End ]
##
## The known suffix of the stack is as follows:
## If expr Then closed_expr Else
##

Ill-formed conditional expression.
At this point, the expression of the 'else' branch is expected.

interactive_expr: Fun Ident ARROW With
##
## Ends in an error in state: 441.
##
## fun_expr(expr) -> Fun nseq(core_irrefutable) ARROW . expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable) ARROW
##
interactive_expr: Match UIdent With UIdent ARROW If UIdent Then Fun Ident ARROW With
##
## Ends in an error in state: 692.
##
## fun_expr(base_cond) -> Fun nseq(core_irrefutable) ARROW . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(closed_expr) -> Fun nseq(core_irrefutable) ARROW . closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable) ARROW
##
interactive_expr: If UIdent Then Match UIdent With UIdent ARROW Fun Ident ARROW With
##
## Ends in an error in state: 733.
##
## fun_expr(base_cond) -> Fun nseq(core_irrefutable) ARROW . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_if_then_else) -> Fun nseq(core_irrefutable) ARROW . base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable) ARROW
##
interactive_expr: Match UIdent With UIdent ARROW Fun Ident ARROW With
##
## Ends in an error in state: 661.
##
## fun_expr(base_cond) -> Fun nseq(core_irrefutable) ARROW . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable) ARROW
##
interactive_expr: Begin If UIdent Then Fun Ident ARROW With
##
## Ends in an error in state: 840.
##
## fun_expr(closed_expr) -> Fun nseq(core_irrefutable) ARROW . closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable) ARROW
##
interactive_expr: Begin Fun Ident ARROW With
##
## Ends in an error in state: 873.
##
## fun_expr(last_expr) -> Fun nseq(core_irrefutable) ARROW . last_expr [ End ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable) ARROW
##
interactive_expr: If UIdent Then Fun Ident ARROW With
##
## Ends in an error in state: 768.
##
## fun_expr(closed_expr) -> Fun nseq(core_irrefutable) ARROW . closed_expr [ Else ]
## fun_expr(expr) -> Fun nseq(core_irrefutable) ARROW . expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable) ARROW
##
interactive_expr: Fun LPAR Type Ident RPAR Ident ARROW With
##
## Ends in an error in state: 279.
##
## fun_expr(expr) -> Fun par(__anonymous_7) nseq(core_irrefutable) ARROW . expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun par(__anonymous_7) nseq(core_irrefutable) ARROW
##
interactive_expr: Match UIdent With UIdent ARROW If UIdent Then Fun LPAR Type Ident RPAR Ident ARROW With
##
## Ends in an error in state: 604.
##
## fun_expr(base_cond) -> Fun par(__anonymous_7) nseq(core_irrefutable) ARROW . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(closed_expr) -> Fun par(__anonymous_7) nseq(core_irrefutable) ARROW . closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Fun par(__anonymous_7) nseq(core_irrefutable) ARROW
##
interactive_expr: Match UIdent With UIdent ARROW If UIdent Then Fun LPAR Type Ident RPAR Ident COLON Ident ARROW With
##
## Ends in an error in state: 689.
##
## fun_expr(base_cond) -> Fun par(__anonymous_7) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(closed_expr) -> Fun par(__anonymous_7) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Fun par(__anonymous_7) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW
##
interactive_expr: Match UIdent With UIdent ARROW If UIdent Then Fun Ident COLON Ident ARROW With
##
## Ends in an error in state: 695.
##
## fun_expr(base_cond) -> Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(closed_expr) -> Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW
##
interactive_expr: If UIdent Then Match UIdent With UIdent ARROW Fun LPAR Type Ident RPAR Ident ARROW With
##
## Ends in an error in state: 709.
##
## fun_expr(base_cond) -> Fun par(__anonymous_7) nseq(core_irrefutable) ARROW . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_if_then_else) -> Fun par(__anonymous_7) nseq(core_irrefutable) ARROW . base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## Fun par(__anonymous_7) nseq(core_irrefutable) ARROW
##
interactive_expr: If UIdent Then Match UIdent With UIdent ARROW Fun LPAR Type Ident RPAR Ident COLON Ident ARROW With
##
## Ends in an error in state: 730.
##
## fun_expr(base_cond) -> Fun par(__anonymous_7) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_if_then_else) -> Fun par(__anonymous_7) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## Fun par(__anonymous_7) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW
##
interactive_expr: If UIdent Then Match UIdent With UIdent ARROW Fun Ident COLON Ident ARROW With
##
## Ends in an error in state: 736.
##
## fun_expr(base_cond) -> Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_if_then_else) -> Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW
##
interactive_expr: Match UIdent With UIdent ARROW Fun LPAR Type Ident RPAR Ident ARROW With
##
## Ends in an error in state: 645.
##
## fun_expr(base_cond) -> Fun par(__anonymous_7) nseq(core_irrefutable) ARROW . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun par(__anonymous_7) nseq(core_irrefutable) ARROW
##
interactive_expr: Match UIdent With UIdent ARROW Fun LPAR Type Ident RPAR Ident COLON Ident ARROW With
##
## Ends in an error in state: 658.
##
## fun_expr(base_cond) -> Fun par(__anonymous_7) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun par(__anonymous_7) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW
##
interactive_expr: Match UIdent With UIdent ARROW Fun Ident COLON Ident ARROW With
##
## Ends in an error in state: 664.
##
## fun_expr(base_cond) -> Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW
##
interactive_expr: Begin Match UIdent With UIdent ARROW Fun LPAR Type Ident RPAR Ident ARROW With
##
## Ends in an error in state: 801.
##
## fun_expr(base_cond) -> Fun par(__anonymous_7) nseq(core_irrefutable) ARROW . base_cond [ VBAR ]
## fun_expr(last_expr) -> Fun par(__anonymous_7) nseq(core_irrefutable) ARROW . last_expr [ End ]
##
## The known suffix of the stack is as follows:
## Fun par(__anonymous_7) nseq(core_irrefutable) ARROW
##
interactive_expr: Begin If UIdent Then Fun LPAR Type Ident RPAR Ident ARROW With
##
## Ends in an error in state: 829.
##
## fun_expr(closed_expr) -> Fun par(__anonymous_7) nseq(core_irrefutable) ARROW . closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Fun par(__anonymous_7) nseq(core_irrefutable) ARROW
##
interactive_expr: Begin If UIdent Then Fun LPAR Type Ident RPAR Ident COLON Ident ARROW With
##
## Ends in an error in state: 838.
##
## fun_expr(closed_expr) -> Fun par(__anonymous_7) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Fun par(__anonymous_7) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW
##
interactive_expr: Begin If UIdent Then Fun Ident COLON Ident ARROW With
##
## Ends in an error in state: 842.
##
## fun_expr(closed_expr) -> Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW
##
interactive_expr: Begin Fun LPAR Type Ident RPAR Ident ARROW With
##
## Ends in an error in state: 853.
##
## fun_expr(last_expr) -> Fun par(__anonymous_7) nseq(core_irrefutable) ARROW . last_expr [ End ]
##
## The known suffix of the stack is as follows:
## Fun par(__anonymous_7) nseq(core_irrefutable) ARROW
##
interactive_expr: Begin Fun LPAR Type Ident RPAR Ident COLON Ident ARROW With
##
## Ends in an error in state: 870.
##
## fun_expr(last_expr) -> Fun par(__anonymous_7) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . last_expr [ End ]
##
## The known suffix of the stack is as follows:
## Fun par(__anonymous_7) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW
##
interactive_expr: Begin Fun Ident COLON Ident ARROW With
##
## Ends in an error in state: 876.
##
## fun_expr(last_expr) -> Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . last_expr [ End ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW
##
interactive_expr: Begin Match UIdent With UIdent ARROW Fun LPAR Type Ident RPAR Ident COLON Ident ARROW With
##
## Ends in an error in state: 886.
##
## fun_expr(base_cond) -> Fun par(__anonymous_7) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . base_cond [ VBAR ]
## fun_expr(last_expr) -> Fun par(__anonymous_7) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . last_expr [ End ]
##
## The known suffix of the stack is as follows:
## Fun par(__anonymous_7) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW
##
interactive_expr: Begin Match UIdent With UIdent ARROW Fun Ident COLON Ident ARROW With
##
## Ends in an error in state: 890.
##
## fun_expr(base_cond) -> Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . base_cond [ VBAR ]
## fun_expr(last_expr) -> Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . last_expr [ End ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW
##
interactive_expr: Fun LPAR Type Ident RPAR Ident COLON Ident ARROW With
##
## Ends in an error in state: 438.
##
## fun_expr(expr) -> Fun par(__anonymous_7) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun par(__anonymous_7) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW
##
interactive_expr: Fun Ident COLON Ident ARROW With
##
## Ends in an error in state: 444.
##
## fun_expr(expr) -> Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW
##
interactive_expr: If UIdent Then Fun LPAR Type Ident RPAR Ident ARROW With
##
## Ends in an error in state: 757.
##
## fun_expr(closed_expr) -> Fun par(__anonymous_7) nseq(core_irrefutable) ARROW . closed_expr [ Else ]
## fun_expr(expr) -> Fun par(__anonymous_7) nseq(core_irrefutable) ARROW . expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun par(__anonymous_7) nseq(core_irrefutable) ARROW
##
interactive_expr: If UIdent Then Fun LPAR Type Ident RPAR Ident COLON Ident ARROW With
##
## Ends in an error in state: 766.
##
## fun_expr(closed_expr) -> Fun par(__anonymous_7) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . closed_expr [ Else ]
## fun_expr(expr) -> Fun par(__anonymous_7) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun par(__anonymous_7) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW
##
interactive_expr: If UIdent Then Fun Ident COLON Ident ARROW With
##
## Ends in an error in state: 770.
##
## fun_expr(closed_expr) -> Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . closed_expr [ Else ]
## fun_expr(expr) -> Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW
##
interactive_expr: Begin Match Ident With UIdent ARROW Fun UIdent ARROW ZWSP
##
## Ends in an error in state: 888.
##
## fun_expr(base_cond) -> Fun nseq(core_irrefutable) ARROW . base_cond [ VBAR ]
## fun_expr(last_expr) -> Fun nseq(core_irrefutable) ARROW . last_expr [ End ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable) ARROW
##

Ill-formed functional expression.
At this point, the body of the function is expected as an expression.

interactive_expr: If Verbatim Then Match Verbatim With WILD ARROW With
##
## Ends in an error in state: 537.
##
## match_clause(base_cond) -> pattern ARROW . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## match_clause(base_if_then_else) -> pattern ARROW . base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## pattern ARROW
##
interactive_expr: Begin Match UIdent With UIdent ARROW With
##
## Ends in an error in state: 785.
##
## match_clause(base_cond) -> pattern ARROW . base_cond [ VBAR ]
## match_clause(last_expr) -> pattern ARROW . last_expr [ End ]
##
## The known suffix of the stack is as follows:
## pattern ARROW
##
interactive_expr: Match UIdent With UIdent ARROW With
##
## Ends in an error in state: 983.
##
## match_clause(base_cond) -> pattern ARROW . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## pattern ARROW
##

Ill-formed pattern matching.
At this point, the right-hand side is expected as an expression.

interactive_expr: Begin If Verbatim Then With
##
## Ends in an error in state: 818.
##
## if_then_else(seq_expr) -> If expr Then . closed_expr Else seq_expr [ SEMI End ]
##
## The known suffix of the stack is as follows:
## If expr Then
##
interactive_expr: If Verbatim Then With
##
## Ends in an error in state: 447.
##
## if_then(expr) -> If expr Then . expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## if_then_else(expr) -> If expr Then . closed_expr Else expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## If expr Then
##
interactive_expr: Match Verbatim With WILD ARROW If Verbatim Then With
##
## Ends in an error in state: 613.
##
## if_then(base_cond) -> If expr Then . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## if_then_else(base_cond) -> If expr Then . closed_expr Else base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## If expr Then
##
interactive_expr: Begin Match UIdent With UIdent ARROW If UIdent Then With
##
## Ends in an error in state: 792.
##
## if_then(base_cond) -> If expr Then . base_cond [ VBAR ]
## if_then_else(base_cond) -> If expr Then . closed_expr Else base_cond [ VBAR ]
## if_then_else(seq_expr) -> If expr Then . closed_expr Else seq_expr [ SEMI End ]
##
## The known suffix of the stack is as follows:
## If expr Then
##
interactive_expr: If UIdent Then Match UIdent With UIdent ARROW If UIdent Then With
##
## Ends in an error in state: 581.
##
## if_then(base_cond) -> If expr Then . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## if_then_else(base_cond) -> If expr Then . closed_expr Else base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## if_then_else(base_if_then_else) -> If expr Then . closed_expr Else base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## If expr Then
##
interactive_expr: Match UIdent With UIdent ARROW If UIdent Then If UIdent Then With
##
## Ends in an error in state: 600.
##
## if_then(base_cond) -> If expr Then . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## if_then_else(base_cond) -> If expr Then . closed_expr Else base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## if_then_else(closed_expr) -> If expr Then . closed_expr Else closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## If expr Then
##
interactive_expr: Begin If UIdent Then If UIdent Then With
##
## Ends in an error in state: 825.
##
## if_then_else(closed_expr) -> If expr Then . closed_expr Else closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## If expr Then
##
interactive_expr: If UIdent Then If UIdent Then With
##
## Ends in an error in state: 753.
##
## if_then(expr) -> If expr Then . expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## if_then_else(closed_expr) -> If expr Then . closed_expr Else closed_expr [ Else ]
## if_then_else(expr) -> If expr Then . closed_expr Else expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## If expr Then
##

Ill-formed conditional expression.
At this point, the 'then' branch is expected as an expression.

interactive_expr: Begin Attr Let Rec Ident EQ UIdent In With
##
## Ends in an error in state: 859.
##
## let_in_sequence -> nseq(Attr) Let Rec let_binding In . series [ End ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let Rec let_binding In
##
interactive_expr: Begin If UIdent Then Let Rec Ident EQ UIdent In With
##
## Ends in an error in state: 822.
##
## let_in_expr(closed_expr) -> Let Rec let_binding In . closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Let Rec let_binding In
##
interactive_expr: Begin Attr Let Ident EQ UIdent In With
##
## Ends in an error in state: 866.
##
## let_in_sequence -> nseq(Attr) Let let_binding In . series [ End ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let let_binding In
##
interactive_expr: Begin Let Ident EQ UIdent In With
##
## Ends in an error in state: 880.
##
## let_in_sequence -> Let let_binding In . series [ End ]
##
## The known suffix of the stack is as follows:
## Let let_binding In
##
interactive_expr: Begin Match UIdent With UIdent ARROW Attr Let Ident EQ UIdent In With
##
## Ends in an error in state: 884.
##
## let_in_expr(base_cond) -> Let let_binding In . base_cond [ VBAR ]
## let_in_sequence -> nseq(Attr) Let let_binding In . series [ End ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let let_binding In
##
interactive_expr: Begin Match UIdent With UIdent ARROW Let Ident EQ UIdent In With
##
## Ends in an error in state: 892.
##
## let_in_expr(base_cond) -> Let let_binding In . base_cond [ VBAR ]
## let_in_sequence -> Let let_binding In . series [ End ]
##
## The known suffix of the stack is as follows:
## Let let_binding In
##
interactive_expr: If UIdent Then Let Rec Ident EQ UIdent In With
##
## Ends in an error in state: 750.
##
## let_in_expr(closed_expr) -> Let Rec let_binding In . closed_expr [ Else ]
## let_in_expr(expr) -> Let Rec let_binding In . expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let Rec let_binding In
##
interactive_expr: If UIdent Then Let Ident EQ UIdent In With
##
## Ends in an error in state: 777.
##
## let_in_expr(closed_expr) -> Let let_binding In . closed_expr [ Else ]
## let_in_expr(expr) -> Let let_binding In . expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let let_binding In
##
interactive_expr: Let Ident EQ UIdent In With
##
## Ends in an error in state: 973.
##
## let_in_expr(expr) -> Let let_binding In . expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let let_binding In
##
interactive_expr: Begin If UIdent Then Let Ident EQ UIdent In With
##
## Ends in an error in state: 846.
##
## let_in_expr(closed_expr) -> Let let_binding In . closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Let let_binding In
##
interactive_expr: Match Verbatim With WILD ARROW Let WILD EQ Bytes In With
##
## Ends in an error in state: 681.
##
## let_in_expr(base_cond) -> Let let_binding In . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let let_binding In
##
interactive_expr: Let Rec Ident EQ UIdent In With
##
## Ends in an error in state: 971.
##
## let_in_expr(expr) -> Let Rec let_binding In . expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let Rec let_binding In
##
interactive_expr: Begin Match UIdent With UIdent ARROW Let Rec Ident EQ UIdent In With
##
## Ends in an error in state: 789.
##
## let_in_expr(base_cond) -> Let Rec let_binding In . base_cond [ VBAR ]
## let_in_sequence -> Let Rec let_binding In . series [ End ]
##
## The known suffix of the stack is as follows:
## Let Rec let_binding In
##
interactive_expr: If UIdent Then Match UIdent With UIdent ARROW Let Rec Ident EQ UIdent In With
##
## Ends in an error in state: 578.
##
## let_in_expr(base_cond) -> Let Rec let_binding In . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## let_in_expr(base_if_then_else) -> Let Rec let_binding In . base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## Let Rec let_binding In
##
interactive_expr: Match UIdent With UIdent ARROW If UIdent Then Let Rec Ident EQ UIdent In With
##
## Ends in an error in state: 597.
##
## let_in_expr(base_cond) -> Let Rec let_binding In . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## let_in_expr(closed_expr) -> Let Rec let_binding In . closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Let Rec let_binding In
##
interactive_expr: Match UIdent With UIdent ARROW If UIdent Then Let Ident EQ UIdent In With
##
## Ends in an error in state: 702.
##
## let_in_expr(base_cond) -> Let let_binding In . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## let_in_expr(closed_expr) -> Let let_binding In . closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Let let_binding In
##
interactive_expr: If UIdent Then Match UIdent With UIdent ARROW Let Ident EQ UIdent In With
##
## Ends in an error in state: 741.
##
## let_in_expr(base_cond) -> Let let_binding In . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## let_in_expr(base_if_then_else) -> Let let_binding In . base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## Let let_binding In
##
interactive_expr: Match UIdent With UIdent ARROW Let Rec Ident EQ UIdent In With
##
## Ends in an error in state: 641.
##
## let_in_expr(base_cond) -> Let Rec let_binding In . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let Rec let_binding In
##
interactive_expr: Begin Match UIdent With UIdent ARROW Attr Let Rec Ident EQ UIdent In With
##
## Ends in an error in state: 808.
##
## let_in_expr(base_cond) -> Let Rec let_binding In . base_cond [ VBAR ]
## let_in_sequence -> nseq(Attr) Let Rec let_binding In . series [ End ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let Rec let_binding In
##
interactive_expr: Begin Let Rec Ident EQ UIdent In With
##
## Ends in an error in state: 815.
##
## let_in_sequence -> Let Rec let_binding In . series [ End ]
##
## The known suffix of the stack is as follows:
## Let Rec let_binding In
##

Ill-formed local value declaration.
At this point, an expression is expected.

interactive_expr: With
##
## Ends in an error in state: 1040.
##
## interactive_expr' -> . interactive_expr [ # ]
##
## The known suffix of the stack is as follows:
##
##

Ill-formed expression.
At this point, an expression is expected.

contract: With
##
## Ends in an error in state: 0.
##
## contract' -> . contract [ # ]
##
## The known suffix of the stack is as follows:
##
##

Ill-formed contract.
At this point, a declaration is expected.

interactive_expr: If Ident Then Ident VBAR
##
## Ends in an error in state: 779.
##
## if_then_else(expr) -> If expr Then closed_expr . Else expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## If expr Then closed_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 244, spurious reduction of production variable -> Ident
## In state 281, spurious reduction of production field_path -> variable
## In state 312, spurious reduction of production local_path -> field_path
## In state 310, spurious reduction of production path_expr -> local_path
## In state 295, spurious reduction of production no_attr_expr -> path_expr
## In state 300, spurious reduction of production core_expr -> no_attr_expr
## In state 320, spurious reduction of production app_expr_level -> core_expr
## In state 327, spurious reduction of production unary_expr_level -> app_expr_level
## In state 307, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 335, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 341, spurious reduction of production add_expr_level -> mult_expr_level
## In state 377, spurious reduction of production cons_expr_level -> add_expr_level
## In state 364, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 401, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 408, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 417, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 764, spurious reduction of production base_expr(closed_expr) -> disj_expr_level
## In state 632, spurious reduction of production base_if_then_else__open(closed_expr) -> base_expr(closed_expr)
## In state 631, spurious reduction of production closed_expr -> base_if_then_else__open(closed_expr)
##
interactive_expr: If Ident Then If Ident Then Ident VBAR
##
## Ends in an error in state: 772.
##
## if_then_else(closed_expr) -> If expr Then closed_expr . Else closed_expr [ Else ]
## if_then_else(expr) -> If expr Then closed_expr . Else expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## If expr Then closed_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 244, spurious reduction of production variable -> Ident
## In state 281, spurious reduction of production field_path -> variable
## In state 312, spurious reduction of production local_path -> field_path
## In state 310, spurious reduction of production path_expr -> local_path
## In state 295, spurious reduction of production no_attr_expr -> path_expr
## In state 300, spurious reduction of production core_expr -> no_attr_expr
## In state 320, spurious reduction of production app_expr_level -> core_expr
## In state 327, spurious reduction of production unary_expr_level -> app_expr_level
## In state 307, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 335, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 341, spurious reduction of production add_expr_level -> mult_expr_level
## In state 377, spurious reduction of production cons_expr_level -> add_expr_level
## In state 364, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 401, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 408, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 417, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 764, spurious reduction of production base_expr(closed_expr) -> disj_expr_level
## In state 632, spurious reduction of production base_if_then_else__open(closed_expr) -> base_expr(closed_expr)
## In state 631, spurious reduction of production closed_expr -> base_if_then_else__open(closed_expr)
##
interactive_expr: Begin Match Ident With UIdent ARROW If Ident Then Ident MINUS Bytes ZWSP
##
## Ends in an error in state: 793.
##
## if_then_else(base_cond) -> If expr Then closed_expr . Else base_cond [ VBAR ]
## if_then_else(seq_expr) -> If expr Then closed_expr . Else seq_expr [ SEMI End ]
##
## The known suffix of the stack is as follows:
## If expr Then closed_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 320, spurious reduction of production app_expr_level -> core_expr
## In state 327, spurious reduction of production unary_expr_level -> app_expr_level
## In state 307, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 335, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 381, spurious reduction of production bin_op(add_expr_level,MINUS,mult_expr_level) -> add_expr_level MINUS mult_expr_level
## In state 375, spurious reduction of production add_expr_level -> bin_op(add_expr_level,MINUS,mult_expr_level)
## In state 377, spurious reduction of production cons_expr_level -> add_expr_level
## In state 364, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 401, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 408, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 417, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 628, spurious reduction of production base_expr(closed_expr) -> disj_expr_level
## In state 632, spurious reduction of production base_if_then_else__open(closed_expr) -> base_expr(closed_expr)
## In state 631, spurious reduction of production closed_expr -> base_if_then_else__open(closed_expr)
##
interactive_expr: If Ident Then Match Ident With UIdent ARROW If Ident Then Ident MINUS Bytes ZWSP
##
## Ends in an error in state: 704.
##
## if_then_else(base_cond) -> If expr Then closed_expr . Else base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## if_then_else(base_if_then_else) -> If expr Then closed_expr . Else base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## If expr Then closed_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 320, spurious reduction of production app_expr_level -> core_expr
## In state 327, spurious reduction of production unary_expr_level -> app_expr_level
## In state 307, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 335, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 381, spurious reduction of production bin_op(add_expr_level,MINUS,mult_expr_level) -> add_expr_level MINUS mult_expr_level
## In state 375, spurious reduction of production add_expr_level -> bin_op(add_expr_level,MINUS,mult_expr_level)
## In state 377, spurious reduction of production cons_expr_level -> add_expr_level
## In state 364, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 401, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 408, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 417, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 628, spurious reduction of production base_expr(closed_expr) -> disj_expr_level
## In state 632, spurious reduction of production base_if_then_else__open(closed_expr) -> base_expr(closed_expr)
## In state 631, spurious reduction of production closed_expr -> base_if_then_else__open(closed_expr)
##
interactive_expr: Match Ident With UIdent ARROW If Ident Then If Ident Then Ident MINUS Bytes ZWSP
##
## Ends in an error in state: 697.
##
## if_then_else(base_cond) -> If expr Then closed_expr . Else base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## if_then_else(closed_expr) -> If expr Then closed_expr . Else closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## If expr Then closed_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 320, spurious reduction of production app_expr_level -> core_expr
## In state 327, spurious reduction of production unary_expr_level -> app_expr_level
## In state 307, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 335, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 381, spurious reduction of production bin_op(add_expr_level,MINUS,mult_expr_level) -> add_expr_level MINUS mult_expr_level
## In state 375, spurious reduction of production add_expr_level -> bin_op(add_expr_level,MINUS,mult_expr_level)
## In state 377, spurious reduction of production cons_expr_level -> add_expr_level
## In state 364, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 401, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 408, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 417, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 628, spurious reduction of production base_expr(closed_expr) -> disj_expr_level
## In state 632, spurious reduction of production base_if_then_else__open(closed_expr) -> base_expr(closed_expr)
## In state 631, spurious reduction of production closed_expr -> base_if_then_else__open(closed_expr)
##
interactive_expr: Begin If Verbatim Then If Verbatim Then Verbatim COMMA Bytes With
##
## Ends in an error in state: 843.
##
## if_then_else(closed_expr) -> If expr Then closed_expr . Else closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## If expr Then closed_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 320, spurious reduction of production app_expr_level -> core_expr
## In state 327, spurious reduction of production unary_expr_level -> app_expr_level
## In state 307, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 335, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 341, spurious reduction of production add_expr_level -> mult_expr_level
## In state 377, spurious reduction of production cons_expr_level -> add_expr_level
## In state 364, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 401, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 408, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 417, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 414, spurious reduction of production nsepseq(disj_expr_level,COMMA) -> disj_expr_level
## In state 413, spurious reduction of production tuple(disj_expr_level) -> disj_expr_level COMMA nsepseq(disj_expr_level,COMMA)
## In state 334, spurious reduction of production tuple_expr -> tuple(disj_expr_level)
## In state 832, spurious reduction of production base_expr(closed_expr) -> tuple_expr
## In state 632, spurious reduction of production base_if_then_else__open(closed_expr) -> base_expr(closed_expr)
## In state 631, spurious reduction of production closed_expr -> base_if_then_else__open(closed_expr)
##
interactive_expr: Begin If Verbatim Then Verbatim With
##
## Ends in an error in state: 847.
##
## if_then_else(seq_expr) -> If expr Then closed_expr . Else seq_expr [ SEMI End ]
##
## The known suffix of the stack is as follows:
## If expr Then closed_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 320, spurious reduction of production app_expr_level -> core_expr
## In state 327, spurious reduction of production unary_expr_level -> app_expr_level
## In state 307, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 335, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 341, spurious reduction of production add_expr_level -> mult_expr_level
## In state 377, spurious reduction of production cons_expr_level -> add_expr_level
## In state 364, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 401, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 408, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 417, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 836, spurious reduction of production base_expr(closed_expr) -> disj_expr_level
## In state 632, spurious reduction of production base_if_then_else__open(closed_expr) -> base_expr(closed_expr)
## In state 631, spurious reduction of production closed_expr -> base_if_then_else__open(closed_expr)
##
interactive_expr: Match Verbatim With WILD ARROW If Verbatim Then Verbatim WILD
##
## Ends in an error in state: 636.
##
## if_then_else(base_cond) -> If expr Then closed_expr . Else base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## If expr Then closed_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 320, spurious reduction of production app_expr_level -> core_expr
## In state 327, spurious reduction of production unary_expr_level -> app_expr_level
## In state 307, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 335, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 341, spurious reduction of production add_expr_level -> mult_expr_level
## In state 377, spurious reduction of production cons_expr_level -> add_expr_level
## In state 364, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 401, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 408, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 417, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 628, spurious reduction of production base_expr(closed_expr) -> disj_expr_level
## In state 632, spurious reduction of production base_if_then_else__open(closed_expr) -> base_expr(closed_expr)
## In state 631, spurious reduction of production closed_expr -> base_if_then_else__open(closed_expr)
##

Ill-formed complete conditional expression.
At this point, if the expression of the branch 'then' is complete, the
keyword 'else' is expected, followed by an expression.

interactive_expr: Begin If Verbatim Then If Verbatim With
##
## Ends in an error in state: 824.
##
## if_then_else(closed_expr) -> If expr . Then closed_expr Else closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## If expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 320, spurious reduction of production app_expr_level -> core_expr
## In state 327, spurious reduction of production unary_expr_level -> app_expr_level
## In state 307, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 335, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 341, spurious reduction of production add_expr_level -> mult_expr_level
## In state 377, spurious reduction of production cons_expr_level -> add_expr_level
## In state 364, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 401, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 408, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 417, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 362, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 424, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 425, spurious reduction of production expr -> base_cond__open(expr)
##
interactive_expr: Begin If Verbatim With
##
## Ends in an error in state: 817.
##
## if_then_else(seq_expr) -> If expr . Then closed_expr Else seq_expr [ SEMI End ]
##
## The known suffix of the stack is as follows:
## If expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 320, spurious reduction of production app_expr_level -> core_expr
## In state 327, spurious reduction of production unary_expr_level -> app_expr_level
## In state 307, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 335, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 341, spurious reduction of production add_expr_level -> mult_expr_level
## In state 377, spurious reduction of production cons_expr_level -> add_expr_level
## In state 364, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 401, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 408, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 417, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 362, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 424, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 425, spurious reduction of production expr -> base_cond__open(expr)
##
interactive_expr: Begin Match Verbatim With WILD ARROW If Verbatim With
##
## Ends in an error in state: 791.
##
## if_then(base_cond) -> If expr . Then base_cond [ VBAR ]
## if_then_else(base_cond) -> If expr . Then closed_expr Else base_cond [ VBAR ]
## if_then_else(seq_expr) -> If expr . Then closed_expr Else seq_expr [ SEMI End ]
##
## The known suffix of the stack is as follows:
## If expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 320, spurious reduction of production app_expr_level -> core_expr
## In state 327, spurious reduction of production unary_expr_level -> app_expr_level
## In state 307, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 335, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 341, spurious reduction of production add_expr_level -> mult_expr_level
## In state 377, spurious reduction of production cons_expr_level -> add_expr_level
## In state 364, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 401, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 408, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 417, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 362, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 424, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 425, spurious reduction of production expr -> base_cond__open(expr)
##
interactive_expr: If Verbatim Then If Verbatim With
##
## Ends in an error in state: 752.
##
## if_then(expr) -> If expr . Then expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## if_then_else(closed_expr) -> If expr . Then closed_expr Else closed_expr [ Else ]
## if_then_else(expr) -> If expr . Then closed_expr Else expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## If expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 320, spurious reduction of production app_expr_level -> core_expr
## In state 327, spurious reduction of production unary_expr_level -> app_expr_level
## In state 307, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 335, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 341, spurious reduction of production add_expr_level -> mult_expr_level
## In state 377, spurious reduction of production cons_expr_level -> add_expr_level
## In state 364, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 401, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 408, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 417, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 362, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 424, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 425, spurious reduction of production expr -> base_cond__open(expr)
##
interactive_expr: If Verbatim Then Match Verbatim With WILD ARROW If Verbatim With
##
## Ends in an error in state: 580.
##
## if_then(base_cond) -> If expr . Then base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## if_then_else(base_cond) -> If expr . Then closed_expr Else base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## if_then_else(base_if_then_else) -> If expr . Then closed_expr Else base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## If expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 320, spurious reduction of production app_expr_level -> core_expr
## In state 327, spurious reduction of production unary_expr_level -> app_expr_level
## In state 307, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 335, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 341, spurious reduction of production add_expr_level -> mult_expr_level
## In state 377, spurious reduction of production cons_expr_level -> add_expr_level
## In state 364, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 401, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 408, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 417, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 362, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 424, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 425, spurious reduction of production expr -> base_cond__open(expr)
##
interactive_expr: If Verbatim With
##
## Ends in an error in state: 446.
##
## if_then(expr) -> If expr . Then expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## if_then_else(expr) -> If expr . Then closed_expr Else expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## If expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 320, spurious reduction of production app_expr_level -> core_expr
## In state 327, spurious reduction of production unary_expr_level -> app_expr_level
## In state 307, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 335, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 341, spurious reduction of production add_expr_level -> mult_expr_level
## In state 377, spurious reduction of production cons_expr_level -> add_expr_level
## In state 364, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 401, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 408, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 417, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 362, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 424, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 425, spurious reduction of production expr -> base_cond__open(expr)
##
interactive_expr: Match Verbatim With WILD ARROW If Verbatim Then If Verbatim With
##
## Ends in an error in state: 599.
##
## if_then(base_cond) -> If expr . Then base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## if_then_else(base_cond) -> If expr . Then closed_expr Else base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## if_then_else(closed_expr) -> If expr . Then closed_expr Else closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## If expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 320, spurious reduction of production app_expr_level -> core_expr
## In state 327, spurious reduction of production unary_expr_level -> app_expr_level
## In state 307, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 335, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 341, spurious reduction of production add_expr_level -> mult_expr_level
## In state 377, spurious reduction of production cons_expr_level -> add_expr_level
## In state 364, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 401, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 408, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 417, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 362, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 424, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 425, spurious reduction of production expr -> base_cond__open(expr)
##
interactive_expr: Match Verbatim With WILD ARROW If Verbatim With
##
## Ends in an error in state: 612.
##
## if_then(base_cond) -> If expr . Then base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## if_then_else(base_cond) -> If expr . Then closed_expr Else base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## If expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 320, spurious reduction of production app_expr_level -> core_expr
## In state 327, spurious reduction of production unary_expr_level -> app_expr_level
## In state 307, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 335, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 341, spurious reduction of production add_expr_level -> mult_expr_level
## In state 377, spurious reduction of production cons_expr_level -> add_expr_level
## In state 364, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 401, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 408, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 417, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 362, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 424, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 425, spurious reduction of production expr -> base_cond__open(expr)
##

Ill-formed conditional expression.
At this point, if the condition is complete, the keyword 'then' is
expected, followed by an expression.

interactive_expr: Begin Attr Let Rec Ident EQ UIdent With
##
## Ends in an error in state: 858.
##
## let_in_sequence -> nseq(Attr) Let Rec let_binding . In series [ End ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let Rec let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 29, spurious reduction of production ctor -> UIdent
## In state 313, spurious reduction of production no_attr_expr -> ctor
## In state 300, spurious reduction of production core_expr -> no_attr_expr
## In state 320, spurious reduction of production app_expr_level -> core_expr
## In state 327, spurious reduction of production unary_expr_level -> app_expr_level
## In state 307, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 335, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 341, spurious reduction of production add_expr_level -> mult_expr_level
## In state 377, spurious reduction of production cons_expr_level -> add_expr_level
## In state 364, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 401, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 408, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 417, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 362, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 424, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 425, spurious reduction of production expr -> base_cond__open(expr)
## In state 990, spurious reduction of production non_fun_decl -> var_pattern EQ expr
## In state 576, spurious reduction of production let_binding -> non_fun_decl
##
interactive_expr: Begin Attr Let Ident EQ UIdent With
##
## Ends in an error in state: 865.
##
## let_in_sequence -> nseq(Attr) Let let_binding . In series [ End ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 29, spurious reduction of production ctor -> UIdent
## In state 313, spurious reduction of production no_attr_expr -> ctor
## In state 300, spurious reduction of production core_expr -> no_attr_expr
## In state 320, spurious reduction of production app_expr_level -> core_expr
## In state 327, spurious reduction of production unary_expr_level -> app_expr_level
## In state 307, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 335, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 341, spurious reduction of production add_expr_level -> mult_expr_level
## In state 377, spurious reduction of production cons_expr_level -> add_expr_level
## In state 364, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 401, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 408, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 417, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 362, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 424, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 425, spurious reduction of production expr -> base_cond__open(expr)
## In state 990, spurious reduction of production non_fun_decl -> var_pattern EQ expr
## In state 576, spurious reduction of production let_binding -> non_fun_decl
##
interactive_expr: Begin Match UIdent With UIdent ARROW Attr Let Ident EQ UIdent With
##
## Ends in an error in state: 883.
##
## let_in_expr(base_cond) -> Let let_binding . In base_cond [ VBAR ]
## let_in_sequence -> nseq(Attr) Let let_binding . In series [ End ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 29, spurious reduction of production ctor -> UIdent
## In state 313, spurious reduction of production no_attr_expr -> ctor
## In state 300, spurious reduction of production core_expr -> no_attr_expr
## In state 320, spurious reduction of production app_expr_level -> core_expr
## In state 327, spurious reduction of production unary_expr_level -> app_expr_level
## In state 307, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 335, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 341, spurious reduction of production add_expr_level -> mult_expr_level
## In state 377, spurious reduction of production cons_expr_level -> add_expr_level
## In state 364, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 401, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 408, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 417, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 362, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 424, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 425, spurious reduction of production expr -> base_cond__open(expr)
## In state 990, spurious reduction of production non_fun_decl -> var_pattern EQ expr
## In state 576, spurious reduction of production let_binding -> non_fun_decl
##
interactive_expr: Begin Match UIdent With UIdent ARROW Attr Let Rec Ident EQ UIdent With
##
## Ends in an error in state: 807.
##
## let_in_expr(base_cond) -> Let Rec let_binding . In base_cond [ VBAR ]
## let_in_sequence -> nseq(Attr) Let Rec let_binding . In series [ End ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let Rec let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 29, spurious reduction of production ctor -> UIdent
## In state 313, spurious reduction of production no_attr_expr -> ctor
## In state 300, spurious reduction of production core_expr -> no_attr_expr
## In state 320, spurious reduction of production app_expr_level -> core_expr
## In state 327, spurious reduction of production unary_expr_level -> app_expr_level
## In state 307, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 335, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 341, spurious reduction of production add_expr_level -> mult_expr_level
## In state 377, spurious reduction of production cons_expr_level -> add_expr_level
## In state 364, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 401, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 408, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 417, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 362, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 424, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 425, spurious reduction of production expr -> base_cond__open(expr)
## In state 990, spurious reduction of production non_fun_decl -> var_pattern EQ expr
## In state 576, spurious reduction of production let_binding -> non_fun_decl
##
interactive_expr: Begin Let Rec WILD EQ Bytes With
##
## Ends in an error in state: 814.
##
## let_in_sequence -> Let Rec let_binding . In series [ End ]
##
## The known suffix of the stack is as follows:
## Let Rec let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 320, spurious reduction of production app_expr_level -> core_expr
## In state 327, spurious reduction of production unary_expr_level -> app_expr_level
## In state 307, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 335, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 341, spurious reduction of production add_expr_level -> mult_expr_level
## In state 377, spurious reduction of production cons_expr_level -> add_expr_level
## In state 364, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 401, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 408, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 417, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 362, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 424, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 425, spurious reduction of production expr -> base_cond__open(expr)
## In state 990, spurious reduction of production non_fun_decl -> var_pattern EQ expr
## In state 576, spurious reduction of production let_binding -> non_fun_decl
##
interactive_expr: Begin Match Verbatim With WILD ARROW Let Rec WILD EQ Bytes With
##
## Ends in an error in state: 788.
##
## let_in_expr(base_cond) -> Let Rec let_binding . In base_cond [ VBAR ]
## let_in_sequence -> Let Rec let_binding . In series [ End ]
##
## The known suffix of the stack is as follows:
## Let Rec let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 320, spurious reduction of production app_expr_level -> core_expr
## In state 327, spurious reduction of production unary_expr_level -> app_expr_level
## In state 307, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 335, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 341, spurious reduction of production add_expr_level -> mult_expr_level
## In state 377, spurious reduction of production cons_expr_level -> add_expr_level
## In state 364, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 401, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 408, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 417, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 362, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 424, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 425, spurious reduction of production expr -> base_cond__open(expr)
## In state 990, spurious reduction of production non_fun_decl -> var_pattern EQ expr
## In state 576, spurious reduction of production let_binding -> non_fun_decl
##
interactive_expr: If Verbatim Then Let Rec WILD EQ Bytes With
##
## Ends in an error in state: 749.
##
## let_in_expr(closed_expr) -> Let Rec let_binding . In closed_expr [ Else ]
## let_in_expr(expr) -> Let Rec let_binding . In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let Rec let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 320, spurious reduction of production app_expr_level -> core_expr
## In state 327, spurious reduction of production unary_expr_level -> app_expr_level
## In state 307, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 335, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 341, spurious reduction of production add_expr_level -> mult_expr_level
## In state 377, spurious reduction of production cons_expr_level -> add_expr_level
## In state 364, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 401, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 408, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 417, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 362, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 424, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 425, spurious reduction of production expr -> base_cond__open(expr)
## In state 990, spurious reduction of production non_fun_decl -> var_pattern EQ expr
## In state 576, spurious reduction of production let_binding -> non_fun_decl
##
interactive_expr: If Verbatim Then Match Verbatim With WILD ARROW Let Rec WILD EQ Bytes With
##
## Ends in an error in state: 577.
##
## let_in_expr(base_cond) -> Let Rec let_binding . In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## let_in_expr(base_if_then_else) -> Let Rec let_binding . In base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## Let Rec let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 320, spurious reduction of production app_expr_level -> core_expr
## In state 327, spurious reduction of production unary_expr_level -> app_expr_level
## In state 307, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 335, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 341, spurious reduction of production add_expr_level -> mult_expr_level
## In state 377, spurious reduction of production cons_expr_level -> add_expr_level
## In state 364, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 401, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 408, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 417, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 362, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 424, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 425, spurious reduction of production expr -> base_cond__open(expr)
## In state 990, spurious reduction of production non_fun_decl -> var_pattern EQ expr
## In state 576, spurious reduction of production let_binding -> non_fun_decl
##
interactive_expr: Match Verbatim With WILD ARROW If Verbatim Then Let Rec WILD EQ Bytes With
##
## Ends in an error in state: 596.
##
## let_in_expr(base_cond) -> Let Rec let_binding . In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## let_in_expr(closed_expr) -> Let Rec let_binding . In closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Let Rec let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 320, spurious reduction of production app_expr_level -> core_expr
## In state 327, spurious reduction of production unary_expr_level -> app_expr_level
## In state 307, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 335, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 341, spurious reduction of production add_expr_level -> mult_expr_level
## In state 377, spurious reduction of production cons_expr_level -> add_expr_level
## In state 364, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 401, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 408, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 417, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 362, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 424, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 425, spurious reduction of production expr -> base_cond__open(expr)
## In state 990, spurious reduction of production non_fun_decl -> var_pattern EQ expr
## In state 576, spurious reduction of production let_binding -> non_fun_decl
##
interactive_expr: Match Verbatim With WILD ARROW Let Rec WILD EQ Bytes With
##
## Ends in an error in state: 640.
##
## let_in_expr(base_cond) -> Let Rec let_binding . In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let Rec let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 320, spurious reduction of production app_expr_level -> core_expr
## In state 327, spurious reduction of production unary_expr_level -> app_expr_level
## In state 307, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 335, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 341, spurious reduction of production add_expr_level -> mult_expr_level
## In state 377, spurious reduction of production cons_expr_level -> add_expr_level
## In state 364, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 401, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 408, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 417, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 362, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 424, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 425, spurious reduction of production expr -> base_cond__open(expr)
## In state 990, spurious reduction of production non_fun_decl -> var_pattern EQ expr
## In state 576, spurious reduction of production let_binding -> non_fun_decl
##
interactive_expr: Begin If Verbatim Then Let WILD EQ Bytes With
##
## Ends in an error in state: 845.
##
## let_in_expr(closed_expr) -> Let let_binding . In closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Let let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 320, spurious reduction of production app_expr_level -> core_expr
## In state 327, spurious reduction of production unary_expr_level -> app_expr_level
## In state 307, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 335, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 341, spurious reduction of production add_expr_level -> mult_expr_level
## In state 377, spurious reduction of production cons_expr_level -> add_expr_level
## In state 364, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 401, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 408, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 417, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 362, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 424, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 425, spurious reduction of production expr -> base_cond__open(expr)
## In state 990, spurious reduction of production non_fun_decl -> var_pattern EQ expr
## In state 576, spurious reduction of production let_binding -> non_fun_decl
##
interactive_expr: Begin Let WILD EQ Bytes With
##
## Ends in an error in state: 879.
##
## let_in_sequence -> Let let_binding . In series [ End ]
##
## The known suffix of the stack is as follows:
## Let let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 320, spurious reduction of production app_expr_level -> core_expr
## In state 327, spurious reduction of production unary_expr_level -> app_expr_level
## In state 307, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 335, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 341, spurious reduction of production add_expr_level -> mult_expr_level
## In state 377, spurious reduction of production cons_expr_level -> add_expr_level
## In state 364, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 401, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 408, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 417, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 362, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 424, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 425, spurious reduction of production expr -> base_cond__open(expr)
## In state 990, spurious reduction of production non_fun_decl -> var_pattern EQ expr
## In state 576, spurious reduction of production let_binding -> non_fun_decl
##
interactive_expr: Begin Match Verbatim With WILD ARROW Let WILD EQ Bytes With
##
## Ends in an error in state: 891.
##
## let_in_expr(base_cond) -> Let let_binding . In base_cond [ VBAR ]
## let_in_sequence -> Let let_binding . In series [ End ]
##
## The known suffix of the stack is as follows:
## Let let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 320, spurious reduction of production app_expr_level -> core_expr
## In state 327, spurious reduction of production unary_expr_level -> app_expr_level
## In state 307, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 335, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 341, spurious reduction of production add_expr_level -> mult_expr_level
## In state 377, spurious reduction of production cons_expr_level -> add_expr_level
## In state 364, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 401, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 408, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 417, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 362, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 424, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 425, spurious reduction of production expr -> base_cond__open(expr)
## In state 990, spurious reduction of production non_fun_decl -> var_pattern EQ expr
## In state 576, spurious reduction of production let_binding -> non_fun_decl
##
interactive_expr: If Verbatim Then Match Verbatim With WILD ARROW Let WILD EQ Bytes With
##
## Ends in an error in state: 740.
##
## let_in_expr(base_cond) -> Let let_binding . In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## let_in_expr(base_if_then_else) -> Let let_binding . In base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## Let let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 320, spurious reduction of production app_expr_level -> core_expr
## In state 327, spurious reduction of production unary_expr_level -> app_expr_level
## In state 307, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 335, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 341, spurious reduction of production add_expr_level -> mult_expr_level
## In state 377, spurious reduction of production cons_expr_level -> add_expr_level
## In state 364, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 401, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 408, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 417, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 362, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 424, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 425, spurious reduction of production expr -> base_cond__open(expr)
## In state 990, spurious reduction of production non_fun_decl -> var_pattern EQ expr
## In state 576, spurious reduction of production let_binding -> non_fun_decl
##
interactive_expr: If Verbatim Then Let WILD EQ Bytes With
##
## Ends in an error in state: 776.
##
## let_in_expr(closed_expr) -> Let let_binding . In closed_expr [ Else ]
## let_in_expr(expr) -> Let let_binding . In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 320, spurious reduction of production app_expr_level -> core_expr
## In state 327, spurious reduction of production unary_expr_level -> app_expr_level
## In state 307, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 335, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 341, spurious reduction of production add_expr_level -> mult_expr_level
## In state 377, spurious reduction of production cons_expr_level -> add_expr_level
## In state 364, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 401, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 408, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 417, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 362, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 424, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 425, spurious reduction of production expr -> base_cond__open(expr)
## In state 990, spurious reduction of production non_fun_decl -> var_pattern EQ expr
## In state 576, spurious reduction of production let_binding -> non_fun_decl
##
interactive_expr: Let WILD EQ Bytes With
##
## Ends in an error in state: 972.
##
## let_in_expr(expr) -> Let let_binding . In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 320, spurious reduction of production app_expr_level -> core_expr
## In state 327, spurious reduction of production unary_expr_level -> app_expr_level
## In state 307, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 335, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 341, spurious reduction of production add_expr_level -> mult_expr_level
## In state 377, spurious reduction of production cons_expr_level -> add_expr_level
## In state 364, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 401, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 408, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 417, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 362, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 424, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 425, spurious reduction of production expr -> base_cond__open(expr)
## In state 990, spurious reduction of production non_fun_decl -> var_pattern EQ expr
## In state 576, spurious reduction of production let_binding -> non_fun_decl
##
interactive_expr: Match Verbatim With WILD ARROW If Verbatim Then Let WILD EQ Bytes With
##
## Ends in an error in state: 701.
##
## let_in_expr(base_cond) -> Let let_binding . In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## let_in_expr(closed_expr) -> Let let_binding . In closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Let let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 320, spurious reduction of production app_expr_level -> core_expr
## In state 327, spurious reduction of production unary_expr_level -> app_expr_level
## In state 307, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 335, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 341, spurious reduction of production add_expr_level -> mult_expr_level
## In state 377, spurious reduction of production cons_expr_level -> add_expr_level
## In state 364, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 401, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 408, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 417, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 362, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 424, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 425, spurious reduction of production expr -> base_cond__open(expr)
## In state 990, spurious reduction of production non_fun_decl -> var_pattern EQ expr
## In state 576, spurious reduction of production let_binding -> non_fun_decl
##
interactive_expr: Match Verbatim With WILD ARROW Let WILD EQ Bytes With
##
## Ends in an error in state: 680.
##
## let_in_expr(base_cond) -> Let let_binding . In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 320, spurious reduction of production app_expr_level -> core_expr
## In state 327, spurious reduction of production unary_expr_level -> app_expr_level
## In state 307, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 335, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 341, spurious reduction of production add_expr_level -> mult_expr_level
## In state 377, spurious reduction of production cons_expr_level -> add_expr_level
## In state 364, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 401, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 408, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 417, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 362, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 424, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 425, spurious reduction of production expr -> base_cond__open(expr)
## In state 990, spurious reduction of production non_fun_decl -> var_pattern EQ expr
## In state 576, spurious reduction of production let_binding -> non_fun_decl
##
interactive_expr: Attr Let Rec Ident EQ UIdent With
##
## Ends in an error in state: 970.
##
## let_in_expr(expr) -> Let Rec let_binding . In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let Rec let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 29, spurious reduction of production ctor -> UIdent
## In state 313, spurious reduction of production no_attr_expr -> ctor
## In state 300, spurious reduction of production core_expr -> no_attr_expr
## In state 320, spurious reduction of production app_expr_level -> core_expr
## In state 327, spurious reduction of production unary_expr_level -> app_expr_level
## In state 307, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 335, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 341, spurious reduction of production add_expr_level -> mult_expr_level
## In state 377, spurious reduction of production cons_expr_level -> add_expr_level
## In state 364, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 401, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 408, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 417, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 362, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 424, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 425, spurious reduction of production expr -> base_cond__open(expr)
## In state 990, spurious reduction of production non_fun_decl -> var_pattern EQ expr
## In state 576, spurious reduction of production let_binding -> non_fun_decl
##
interactive_expr: Begin If Ident Then Let Rec Ident EQ Ident Type
##
## Ends in an error in state: 821.
##
## let_in_expr(closed_expr) -> Let Rec let_binding . In closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Let Rec let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 244, spurious reduction of production variable -> Ident
## In state 281, spurious reduction of production field_path -> variable
## In state 312, spurious reduction of production local_path -> field_path
## In state 310, spurious reduction of production path_expr -> local_path
## In state 295, spurious reduction of production no_attr_expr -> path_expr
## In state 300, spurious reduction of production core_expr -> no_attr_expr
## In state 320, spurious reduction of production app_expr_level -> core_expr
## In state 327, spurious reduction of production unary_expr_level -> app_expr_level
## In state 307, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 335, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 341, spurious reduction of production add_expr_level -> mult_expr_level
## In state 377, spurious reduction of production cons_expr_level -> add_expr_level
## In state 364, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 401, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 408, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 417, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 362, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 424, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 425, spurious reduction of production expr -> base_cond__open(expr)
## In state 990, spurious reduction of production non_fun_decl -> var_pattern EQ expr
## In state 576, spurious reduction of production let_binding -> non_fun_decl
##

Ill-formed local value declaration.
At this point, if the expression is complete, the keyword 'in' is
expected, followed by an expression.

interactive_expr: Begin Match Ident With UIdent ARROW Let Rec ZWSP
##
## Ends in an error in state: 787.
##
## let_in_expr(base_cond) -> Let Rec . let_binding In base_cond [ VBAR ]
## let_in_sequence -> Let Rec . let_binding In series [ End ]
##
## The known suffix of the stack is as follows:
## Let Rec
##
interactive_expr: If UIdent Then Let Rec With
##
## Ends in an error in state: 748.
##
## let_in_expr(closed_expr) -> Let Rec . let_binding In closed_expr [ Else ]
## let_in_expr(expr) -> Let Rec . let_binding In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let Rec
##
interactive_expr: Begin Attr Let Rec With
##
## Ends in an error in state: 857.
##
## let_in_sequence -> nseq(Attr) Let Rec . let_binding In series [ End ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let Rec
##
interactive_expr: Begin If UIdent Then Let Rec With
##
## Ends in an error in state: 820.
##
## let_in_expr(closed_expr) -> Let Rec . let_binding In closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Let Rec
##
interactive_expr: Begin Let Rec With
##
## Ends in an error in state: 813.
##
## let_in_sequence -> Let Rec . let_binding In series [ End ]
##
## The known suffix of the stack is as follows:
## Let Rec
##
interactive_expr: Begin Match UIdent With UIdent ARROW Attr Let Rec With
##
## Ends in an error in state: 806.
##
## let_in_expr(base_cond) -> Let Rec . let_binding In base_cond [ VBAR ]
## let_in_sequence -> nseq(Attr) Let Rec . let_binding In series [ End ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let Rec
##
interactive_expr: Match UIdent With UIdent ARROW Let Rec With
##
## Ends in an error in state: 639.
##
## let_in_expr(base_cond) -> Let Rec . let_binding In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let Rec
##
contract: Let Rec With
##
## Ends in an error in state: 127.
##
## let_decl -> Let Rec . let_binding [ Type Module Let End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## Let Rec
##
interactive_expr: Let Rec With
##
## Ends in an error in state: 232.
##
## let_in_expr(expr) -> Let Rec . let_binding In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let Rec
##
interactive_expr: If UIdent Then Match UIdent With UIdent ARROW Let Rec With
##
## Ends in an error in state: 539.
##
## let_in_expr(base_cond) -> Let Rec . let_binding In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## let_in_expr(base_if_then_else) -> Let Rec . let_binding In base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## Let Rec
##
interactive_expr: Match UIdent With UIdent ARROW If UIdent Then Let Rec With
##
## Ends in an error in state: 595.
##
## let_in_expr(base_cond) -> Let Rec . let_binding In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## let_in_expr(closed_expr) -> Let Rec . let_binding In closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Let Rec
##

Ill-formed recursive value declaration.
At this point, a pattern is expected, e.g. an identifier.

interactive_expr: If UIdent Then Let With
##
## Ends in an error in state: 747.
##
## let_in_expr(closed_expr) -> Let . let_binding In closed_expr [ Else ]
## let_in_expr(closed_expr) -> Let . Rec let_binding In closed_expr [ Else ]
## let_in_expr(expr) -> Let . let_binding In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## let_in_expr(expr) -> Let . Rec let_binding In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let
##
interactive_expr: Begin Attr Let With
##
## Ends in an error in state: 856.
##
## let_in_sequence -> nseq(Attr) Let . let_binding In series [ End ]
## let_in_sequence -> nseq(Attr) Let . Rec let_binding In series [ End ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let
##
interactive_expr: Begin If UIdent Then Let With
##
## Ends in an error in state: 819.
##
## let_in_expr(closed_expr) -> Let . let_binding In closed_expr [ Else ]
## let_in_expr(closed_expr) -> Let . Rec let_binding In closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Let
##
interactive_expr: Begin Let With
##
## Ends in an error in state: 812.
##
## let_in_sequence -> Let . let_binding In series [ End ]
## let_in_sequence -> Let . Rec let_binding In series [ End ]
##
## The known suffix of the stack is as follows:
## Let
##
interactive_expr: Begin Match UIdent With UIdent ARROW Attr Let With
##
## Ends in an error in state: 805.
##
## let_in_expr(base_cond) -> Let . let_binding In base_cond [ VBAR ]
## let_in_expr(base_cond) -> Let . Rec let_binding In base_cond [ VBAR ]
## let_in_sequence -> nseq(Attr) Let . let_binding In series [ End ]
## let_in_sequence -> nseq(Attr) Let . Rec let_binding In series [ End ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let
##
interactive_expr: Match UIdent With UIdent ARROW Let With
##
## Ends in an error in state: 638.
##
## let_in_expr(base_cond) -> Let . let_binding In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## let_in_expr(base_cond) -> Let . Rec let_binding In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let
##
interactive_expr: Match UIdent With UIdent ARROW If UIdent Then Let With
##
## Ends in an error in state: 594.
##
## let_in_expr(base_cond) -> Let . let_binding In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## let_in_expr(base_cond) -> Let . Rec let_binding In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## let_in_expr(closed_expr) -> Let . let_binding In closed_expr [ Else ]
## let_in_expr(closed_expr) -> Let . Rec let_binding In closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Let
##
contract: Let With
##
## Ends in an error in state: 125.
##
## let_decl -> Let . let_binding [ Type Module Let End EOF Directive Attr ]
## let_decl -> Let . Rec let_binding [ Type Module Let End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## Let
##
interactive_expr: Attr Let With
##
## Ends in an error in state: 231.
##
## let_in_expr(expr) -> Let . let_binding In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## let_in_expr(expr) -> Let . Rec let_binding In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let
##
interactive_expr: Begin Match UIdent With UIdent ARROW Let With
##
## Ends in an error in state: 786.
##
## let_in_expr(base_cond) -> Let . let_binding In base_cond [ VBAR ]
## let_in_expr(base_cond) -> Let . Rec let_binding In base_cond [ VBAR ]
## let_in_sequence -> Let . let_binding In series [ End ]
## let_in_sequence -> Let . Rec let_binding In series [ End ]
##
## The known suffix of the stack is as follows:
## Let
##
interactive_expr: If UIdent Then Match UIdent With UIdent ARROW Let With
##
## Ends in an error in state: 538.
##
## let_in_expr(base_cond) -> Let . let_binding In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## let_in_expr(base_cond) -> Let . Rec let_binding In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## let_in_expr(base_if_then_else) -> Let . let_binding In base_if_then_else [ Else ]
## let_in_expr(base_if_then_else) -> Let . Rec let_binding In base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## Let
##

Ill-formed value declaration.
At this point, one of the following is expected:
  * a pattern, e.g. an identifier;
  * the keyword 'rec' if defining a recursive function.

interactive_expr: Begin If Verbatim Then Match Verbatim Type
##
## Ends in an error in state: 583.
##
## match_expr(base_if_then_else) -> Match expr . With cases(base_if_then_else) [ Else ]
## match_expr(base_if_then_else) -> Match expr . With VBAR cases(base_if_then_else) [ Else ]
##
## The known suffix of the stack is as follows:
## Match expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 320, spurious reduction of production app_expr_level -> core_expr
## In state 327, spurious reduction of production unary_expr_level -> app_expr_level
## In state 307, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 335, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 341, spurious reduction of production add_expr_level -> mult_expr_level
## In state 377, spurious reduction of production cons_expr_level -> add_expr_level
## In state 364, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 401, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 408, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 417, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 362, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 424, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 425, spurious reduction of production expr -> base_cond__open(expr)
##
interactive_expr: Begin Match Verbatim Type
##
## Ends in an error in state: 781.
##
## match_expr(last_expr) -> Match expr . With cases(last_expr) [ End ]
## match_expr(last_expr) -> Match expr . With VBAR cases(last_expr) [ End ]
##
## The known suffix of the stack is as follows:
## Match expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 320, spurious reduction of production app_expr_level -> core_expr
## In state 327, spurious reduction of production unary_expr_level -> app_expr_level
## In state 307, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 335, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 341, spurious reduction of production add_expr_level -> mult_expr_level
## In state 377, spurious reduction of production cons_expr_level -> add_expr_level
## In state 364, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 401, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 408, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 417, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 362, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 424, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 425, spurious reduction of production expr -> base_cond__open(expr)
##
interactive_expr: Match Verbatim Type
##
## Ends in an error in state: 979.
##
## match_expr(base_cond) -> Match expr . With cases(base_cond) [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## match_expr(base_cond) -> Match expr . With VBAR cases(base_cond) [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Match expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 320, spurious reduction of production app_expr_level -> core_expr
## In state 327, spurious reduction of production unary_expr_level -> app_expr_level
## In state 307, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 335, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 341, spurious reduction of production add_expr_level -> mult_expr_level
## In state 377, spurious reduction of production cons_expr_level -> add_expr_level
## In state 364, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 401, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 408, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 417, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 362, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 424, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 425, spurious reduction of production expr -> base_cond__open(expr)
##
interactive_expr: If Verbatim Then Match Verbatim Type
##
## Ends in an error in state: 449.
##
## match_expr(base_cond) -> Match expr . With cases(base_cond) [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## match_expr(base_cond) -> Match expr . With VBAR cases(base_cond) [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## match_expr(base_if_then_else) -> Match expr . With cases(base_if_then_else) [ Else ]
## match_expr(base_if_then_else) -> Match expr . With VBAR cases(base_if_then_else) [ Else ]
##
## The known suffix of the stack is as follows:
## Match expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 320, spurious reduction of production app_expr_level -> core_expr
## In state 327, spurious reduction of production unary_expr_level -> app_expr_level
## In state 307, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 335, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 341, spurious reduction of production add_expr_level -> mult_expr_level
## In state 377, spurious reduction of production cons_expr_level -> add_expr_level
## In state 364, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 401, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 408, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 417, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 362, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 424, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 425, spurious reduction of production expr -> base_cond__open(expr)
##

Ill-formed pattern matching.
At this point, if the subject expression is complete, then the keyword
'with' is expected, followed by matching cases.

interactive_expr: Begin If Verbatim Then Match Verbatim With WILD ARROW Bytes With
##
## Ends in an error in state: 589.
##
## cases(base_cond) -> cases(base_cond) . VBAR match_clause(base_cond) [ VBAR ]
## cases(base_if_then_else) -> cases(base_cond) . VBAR match_clause(base_if_then_else) [ Else ]
##
## The known suffix of the stack is as follows:
## cases(base_cond)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 320, spurious reduction of production app_expr_level -> core_expr
## In state 327, spurious reduction of production unary_expr_level -> app_expr_level
## In state 307, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 335, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 341, spurious reduction of production add_expr_level -> mult_expr_level
## In state 377, spurious reduction of production cons_expr_level -> add_expr_level
## In state 364, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 401, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 408, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 417, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 723, spurious reduction of production base_expr(base_cond) -> disj_expr_level
## In state 633, spurious reduction of production base_cond__open(base_cond) -> base_expr(base_cond)
## In state 634, spurious reduction of production base_cond -> base_cond__open(base_cond)
## In state 744, spurious reduction of production match_clause(base_cond) -> pattern ARROW base_cond
## In state 587, spurious reduction of production cases(base_cond) -> match_clause(base_cond)
##
interactive_expr: Begin Match Ident With UIdent ARROW Ident COMMA Bytes ZWSP
##
## Ends in an error in state: 896.
##
## cases(base_cond) -> cases(base_cond) . VBAR match_clause(base_cond) [ VBAR ]
## cases(last_expr) -> cases(base_cond) . VBAR match_clause(last_expr) [ End ]
##
## The known suffix of the stack is as follows:
## cases(base_cond)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 320, spurious reduction of production app_expr_level -> core_expr
## In state 327, spurious reduction of production unary_expr_level -> app_expr_level
## In state 307, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 335, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 341, spurious reduction of production add_expr_level -> mult_expr_level
## In state 377, spurious reduction of production cons_expr_level -> add_expr_level
## In state 364, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 401, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 408, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 417, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 414, spurious reduction of production nsepseq(disj_expr_level,COMMA) -> disj_expr_level
## In state 413, spurious reduction of production tuple(disj_expr_level) -> disj_expr_level COMMA nsepseq(disj_expr_level,COMMA)
## In state 334, spurious reduction of production tuple_expr -> tuple(disj_expr_level)
## In state 802, spurious reduction of production base_expr(base_cond) -> tuple_expr
## In state 633, spurious reduction of production base_cond__open(base_cond) -> base_expr(base_cond)
## In state 634, spurious reduction of production base_cond -> base_cond__open(base_cond)
## In state 744, spurious reduction of production match_clause(base_cond) -> pattern ARROW base_cond
## In state 587, spurious reduction of production cases(base_cond) -> match_clause(base_cond)
##

Ill-formed pattern matching.
At this point, if the case is complete, the last case is expected to
start with a vertical bar '|'.

interactive_expr: Begin Match Verbatim With WILD RPAR
##
## Ends in an error in state: 784.
##
## match_clause(base_cond) -> pattern . ARROW base_cond [ VBAR ]
## match_clause(last_expr) -> pattern . ARROW last_expr [ End ]
##
## The known suffix of the stack is as follows:
## pattern
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 501, spurious reduction of production cons_pattern_level -> core_pattern
## In state 504, spurious reduction of production pattern -> cons_pattern_level
##
interactive_expr: If Verbatim Then Match Verbatim With WILD RPAR
##
## Ends in an error in state: 536.
##
## match_clause(base_cond) -> pattern . ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## match_clause(base_if_then_else) -> pattern . ARROW base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## pattern
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 501, spurious reduction of production cons_pattern_level -> core_pattern
## In state 504, spurious reduction of production pattern -> cons_pattern_level
##
interactive_expr: Match Ident With UIdent RPAR
##
## Ends in an error in state: 982.
##
## match_clause(base_cond) -> pattern . ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## pattern
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 29, spurious reduction of production ctor -> UIdent
## In state 496, spurious reduction of production ctor_app_pattern -> ctor
## In state 495, spurious reduction of production core_pattern -> ctor_app_pattern
## In state 501, spurious reduction of production cons_pattern_level -> core_pattern
## In state 504, spurious reduction of production pattern -> cons_pattern_level
##

Ill-formed pattern matching.
At this point, if the pattern is complete, an arrow '->' is expected,
followed by an expression.

interactive_expr: Begin If Verbatim Then Match Verbatim With With
##
## Ends in an error in state: 584.
##
## match_expr(base_if_then_else) -> Match expr With . cases(base_if_then_else) [ Else ]
## match_expr(base_if_then_else) -> Match expr With . VBAR cases(base_if_then_else) [ Else ]
##
## The known suffix of the stack is as follows:
## Match expr With
##
interactive_expr: Begin Match Verbatim With With
##
## Ends in an error in state: 782.
##
## match_expr(last_expr) -> Match expr With . cases(last_expr) [ End ]
## match_expr(last_expr) -> Match expr With . VBAR cases(last_expr) [ End ]
##
## The known suffix of the stack is as follows:
## Match expr With
##
interactive_expr: If Verbatim Then Match Verbatim With With
##
## Ends in an error in state: 450.
##
## match_expr(base_cond) -> Match expr With . cases(base_cond) [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## match_expr(base_cond) -> Match expr With . VBAR cases(base_cond) [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## match_expr(base_if_then_else) -> Match expr With . cases(base_if_then_else) [ Else ]
## match_expr(base_if_then_else) -> Match expr With . VBAR cases(base_if_then_else) [ Else ]
##
## The known suffix of the stack is as follows:
## Match expr With
##
interactive_expr: Match Verbatim With With
##
## Ends in an error in state: 980.
##
## match_expr(base_cond) -> Match expr With . cases(base_cond) [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## match_expr(base_cond) -> Match expr With . VBAR cases(base_cond) [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Match expr With
##

Ill-formed pattern matching.
At this point, the first case is expected to start with a pattern or a
vertical bar.

interactive_expr: Begin UIdent SEMI With
##
## Ends in an error in state: 811.
##
## series -> seq_expr SEMI . series [ End ]
##
## The known suffix of the stack is as follows:
## seq_expr SEMI
##

Ill-formed sequence of expressions.
At this point, an expression of type 'unit' is expected.
Note: The last expression in a sequence cannot be terminated by a
semicolon ';'.

interactive_expr: Begin Verbatim With
##
## Ends in an error in state: 810.
##
## last_expr -> seq_expr . [ End ]
## series -> seq_expr . SEMI series [ End ]
##
## The known suffix of the stack is as follows:
## seq_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 320, spurious reduction of production app_expr_level -> core_expr
## In state 327, spurious reduction of production unary_expr_level -> app_expr_level
## In state 307, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 335, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 341, spurious reduction of production add_expr_level -> mult_expr_level
## In state 377, spurious reduction of production cons_expr_level -> add_expr_level
## In state 364, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 401, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 408, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 417, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 864, spurious reduction of production seq_expr -> disj_expr_level
##

Ill-formed sequence of expressions.
At this point, if the expression is complete, one of the following is
expected:
  * a semicolon ';' followed by another expression;
  * the keyword 'end' if the sequence is complete.
Note: The last expression in a sequence cannot be terminated by a
semicolon ';'.

interactive_expr: UIdent DOT With
##
## Ends in an error in state: 303.
##
## module_path(selected) -> module_name DOT . module_path(selected) [ With Verbatim VBAR UIdent Type Then TIMES String SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Lxor Lsr Lsl Lor Let Lang Land LT LPAR LE LBRACKET LBRACE Int In Ident GT End Else EQ EOF Directive CONS COMMA COLON CARET Bytes Begin BOOL_OR BOOL_AND Attr ]
## module_path(selected) -> module_name DOT . selected [ With Verbatim VBAR UIdent Type Then TIMES String SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Lxor Lsr Lsl Lor Let Lang Land LT LPAR LE LBRACKET LBRACE Int In Ident GT End Else EQ EOF Directive CONS COMMA COLON CARET Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## module_name DOT
##

Ill-formed selection of a value from a module.
At this point, the qualified name of a value is expected, e.g. 'M.C'
or 'M.x.0' or 'C' or 'x.0' etc.

contract: Type Ident EQ UIdent DOT With
##
## Ends in an error in state: 68.
##
## module_path(__anonymous_5) -> module_name DOT . module_path(__anonymous_5) [ VBAR UIdent Type TIMES SEMI RPAR RBRACE Module Let In Ident End EQ EOF Directive COMMA Attr ARROW ]
## module_path(__anonymous_5) -> module_name DOT . type_name [ VBAR UIdent Type TIMES SEMI RPAR RBRACE Module Let In Ident End EQ EOF Directive COMMA Attr ARROW ]
## module_path(__anonymous_6) -> module_name DOT . module_path(__anonymous_6) [ VBAR UIdent Type TIMES SEMI RPAR RBRACE Module Let In Ident End EQ EOF Directive COMMA Attr ARROW ]
## module_path(__anonymous_6) -> module_name DOT . par(type_expr) [ VBAR UIdent Type TIMES SEMI RPAR RBRACE Module Let In Ident End EQ EOF Directive COMMA Attr ARROW ]
##
## The known suffix of the stack is as follows:
## module_name DOT
##

Ill-formed selection of a type in a module.
At this point, one of the following is expected:
  * the qualified name of a type, e.g. 'M.t';
  * a parenthesised type expression.

interactive_expr: UIdent DOT Ident DOT With
##
## Ends in an error in state: 286.
##
## field_path -> record_or_tuple DOT . nsepseq(selection,DOT) [ With Verbatim VBAR UIdent Type Then TIMES String SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Lxor Lsr Lsl Lor Let Lang Land LT LPAR LE LBRACKET LBRACE Int In Ident GT End Else EQ EOF Directive CONS COMMA COLON CARET Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## record_or_tuple DOT
##
interactive_expr: Ident DOT Int DOT With
##
## Ends in an error in state: 289.
##
## nsepseq(selection,DOT) -> selection DOT . nsepseq(selection,DOT) [ With Verbatim VBAR_EQ VBAR UIdent Type Then TIMES_EQ TIMES String SLASH_EQ SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS_EQ PLUS Or Nat NE Mutez Module Mod MINUS_EQ MINUS Lxor Lsr Lsl Lor Let Lang Land LT LPAR LE LBRACKET LBRACE Int In Ident GT End Else EQ EOF Directive CONS COMMA COLON CARET Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## selection DOT
##

Ill-formed selection in a record or a tuple.
At this point, one of the following is expected:
  * the name of a record field;
  * the index of a component in a tuple, '0' denoting the first
    component.

interactive_expr: LBRACE Ident DOT Ident Verbatim
##
## Ends in an error in state: 914.
##
## update_expr -> no_attr_expr . With sep_or_term_list(field_path_assignment,SEMI) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## no_attr_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 288, spurious reduction of production nsepseq(selection,DOT) -> selection
## In state 292, spurious reduction of production field_path -> record_or_tuple DOT nsepseq(selection,DOT)
## In state 312, spurious reduction of production local_path -> field_path
## In state 310, spurious reduction of production path_expr -> local_path
## In state 295, spurious reduction of production no_attr_expr -> path_expr
##

Ill-formed record update.
At this point, if the record is complete, then the keyword 'with' is
expected, followed by field updates (assignments) separated by
semicolons ';'.

interactive_expr: LBRACE Ident EQ Bytes SEMI With
##
## Ends in an error in state: 948.
##
## nsepseq(field_assignment,SEMI) -> field_assignment SEMI . nsepseq(field_assignment,SEMI) [ RBRACE ]
## nseq(__anonymous_0(field_assignment,SEMI)) -> field_assignment SEMI . [ RBRACE ]
## nseq(__anonymous_0(field_assignment,SEMI)) -> field_assignment SEMI . nseq(__anonymous_0(field_assignment,SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_assignment SEMI
##

Ill-formed record expression.
At this point, one of the following is expected:
  * more field assignments separated by semicolons ';';
  * a closing brace '}' if the record is complete.

interactive_expr: LBRACE Ident EQ Bytes With
##
## Ends in an error in state: 947.
##
## nsepseq(field_assignment,SEMI) -> field_assignment . [ RBRACE ]
## nsepseq(field_assignment,SEMI) -> field_assignment . SEMI nsepseq(field_assignment,SEMI) [ RBRACE ]
## nseq(__anonymous_0(field_assignment,SEMI)) -> field_assignment . SEMI [ RBRACE ]
## nseq(__anonymous_0(field_assignment,SEMI)) -> field_assignment . SEMI nseq(__anonymous_0(field_assignment,SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_assignment
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 320, spurious reduction of production app_expr_level -> core_expr
## In state 327, spurious reduction of production unary_expr_level -> app_expr_level
## In state 307, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 335, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 341, spurious reduction of production add_expr_level -> mult_expr_level
## In state 377, spurious reduction of production cons_expr_level -> add_expr_level
## In state 364, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 401, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 408, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 417, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 362, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 424, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 425, spurious reduction of production expr -> base_cond__open(expr)
## In state 946, spurious reduction of production field_assignment -> field_name EQ expr
##

Ill-formed record expression.
At this point, if the expression assigned to the field is complete,
one of the following is expected:
  * a semicolon ';' followed by another field assignment;
  * a closing brace '}' if the record is complete.

interactive_expr: LBRACE Ident With Ident EQ Bytes With
##
## Ends in an error in state: 939.
##
## nsepseq(field_path_assignment,SEMI) -> field_path_assignment . [ RBRACE ]
## nsepseq(field_path_assignment,SEMI) -> field_path_assignment . SEMI nsepseq(field_path_assignment,SEMI) [ RBRACE ]
## nseq(__anonymous_0(field_path_assignment,SEMI)) -> field_path_assignment . SEMI [ RBRACE ]
## nseq(__anonymous_0(field_path_assignment,SEMI)) -> field_path_assignment . SEMI nseq(__anonymous_0(field_path_assignment,SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_path_assignment
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 320, spurious reduction of production app_expr_level -> core_expr
## In state 327, spurious reduction of production unary_expr_level -> app_expr_level
## In state 307, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 335, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 341, spurious reduction of production add_expr_level -> mult_expr_level
## In state 377, spurious reduction of production cons_expr_level -> add_expr_level
## In state 364, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 401, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 408, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 417, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 362, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 424, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 425, spurious reduction of production expr -> base_cond__open(expr)
## In state 931, spurious reduction of production field_path_assignment -> path field_lens expr
##

Ill-formed record update.
At this point, if the expression assigned to the field (update) is
complete, one of the following is expected:
  * a semicolon ';' followed by another field assignment;
  * a closing brace '}' if the update is complete.

interactive_expr: LBRACE Ident EQ Bytes SEMI Ident With
##
## Ends in an error in state: 944.
##
## field_assignment -> field_name . EQ expr [ SEMI RBRACE ]
## field_assignment -> field_name . [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## field_name
##
interactive_expr: LBRACE Attr Ident ZWSP
##
## Ends in an error in state: 910.
##
## field_assignment -> nseq(Attr) field_name . EQ expr [ SEMI RBRACE ]
## field_assignment -> nseq(Attr) field_name . [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) field_name
##

Ill-formed assignment to a field in a record.
At this point, one of the following is expected:
  * an assignment symbol '=', followed by an expression;
  * a semicolon ';', followed by another assignment;
  * a closing brace '}' if the record is complete.

interactive_expr: LBRACE Ident With Attr Ident DOT Ident With
##
## Ends in an error in state: 934.
##
## field_path_assignment -> nseq(Attr) path . field_lens expr [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) path
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 288, spurious reduction of production nsepseq(selection,DOT) -> selection
## In state 920, spurious reduction of production projection -> record_or_tuple DOT nsepseq(selection,DOT)
## In state 922, spurious reduction of production path -> projection
##
interactive_expr: LBRACE Ident With Ident DOT Ident With
##
## Ends in an error in state: 923.
##
## field_path_assignment -> path . field_lens expr [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## path
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 288, spurious reduction of production nsepseq(selection,DOT) -> selection
## In state 920, spurious reduction of production projection -> record_or_tuple DOT nsepseq(selection,DOT)
## In state 922, spurious reduction of production path -> projection
##

Ill-formed record update.
At this point, if the left-hand side of the field is complete, a lens
is expected amongst: '=', '+=', '-=', '*=', '/='. or '|='.

interactive_expr: LBRACE Ident With Ident EQ Bytes SEMI With
##
## Ends in an error in state: 940.
##
## nsepseq(field_path_assignment,SEMI) -> field_path_assignment SEMI . nsepseq(field_path_assignment,SEMI) [ RBRACE ]
## nseq(__anonymous_0(field_path_assignment,SEMI)) -> field_path_assignment SEMI . [ RBRACE ]
## nseq(__anonymous_0(field_path_assignment,SEMI)) -> field_path_assignment SEMI . nseq(__anonymous_0(field_path_assignment,SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_path_assignment SEMI
##

Ill-formed record update.
At this point, one of the following is expected:
  * more field assignments (updates) separated by semicolons ';';
  * a closing brace '}' if the update is complete.

interactive_expr: LBRACE Ident With Ident With
##
## Ends in an error in state: 916.
##
## field_name -> Ident . [ SEMI RBRACE ]
## record_name -> Ident . [ VBAR_EQ TIMES_EQ SLASH_EQ PLUS_EQ MINUS_EQ EQ ]
## record_or_tuple -> Ident . [ DOT ]
##
## The known suffix of the stack is as follows:
## Ident
##

Ill-formed record update.
At this point, one of the following is expected:
  * a lens amongst: '=', '+=', '-=', '*=', '/='. or '|=', if the field
    to update is fully qualified;
  * the selection symbol '.' to further qualify the field to update;
  * a semicolon ';', followed by another assignment;
  * a closing brace '}' if the update is complete.

interactive_expr: LBRACE Ident With With
##
## Ends in an error in state: 915.
##
## update_expr -> no_attr_expr With . sep_or_term_list(field_path_assignment,SEMI) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## no_attr_expr With
##

Ill-formed record update.
At this point, assignments to fields (updates) are expected, separated
by semicolons ';' and each starting with fully qualified field names.

interactive_expr: LBRACE With
##
## Ends in an error in state: 237.
##
## braces(option(__anonymous_2(field_assignment))) -> LBRACE . option(__anonymous_2(field_assignment)) RBRACE [ With Verbatim VBAR UIdent Type Then TIMES String SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Lxor Lsr Lsl Lor Let Lang Land LT LPAR LE LBRACKET LBRACE Int In Ident GT End Else EQ EOF Directive CONS COMMA COLON CARET Bytes Begin BOOL_OR BOOL_AND Attr ]
## braces(update_expr) -> LBRACE . update_expr RBRACE [ With Verbatim VBAR UIdent Type Then TIMES String SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Lxor Lsr Lsl Lor Let Lang Land LT LPAR LE LBRACKET LBRACE Int In Ident GT End Else EQ EOF Directive CONS COMMA COLON CARET Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## LBRACE
##

Ill-formed record expression or update.
At this point, one of the following is expected:
  * field assignments separated by semicolons ';', if defining a record;
  * the record to update as an expression, otherwise.

interactive_expr: LBRACKET Verbatim With
##
## Ends in an error in state: 956.
##
## nsepseq(expr,SEMI) -> expr . [ RBRACKET ]
## nsepseq(expr,SEMI) -> expr . SEMI nsepseq(expr,SEMI) [ RBRACKET ]
## nseq(__anonymous_0(expr,SEMI)) -> expr . SEMI [ RBRACKET ]
## nseq(__anonymous_0(expr,SEMI)) -> expr . SEMI nseq(__anonymous_0(expr,SEMI)) [ RBRACKET ]
##
## The known suffix of the stack is as follows:
## expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 320, spurious reduction of production app_expr_level -> core_expr
## In state 327, spurious reduction of production unary_expr_level -> app_expr_level
## In state 307, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 335, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 341, spurious reduction of production add_expr_level -> mult_expr_level
## In state 377, spurious reduction of production cons_expr_level -> add_expr_level
## In state 364, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 401, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 408, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 417, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 362, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 424, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 425, spurious reduction of production expr -> base_cond__open(expr)
##

Ill-formed list of expressions.
At this point, if the list element is complete, one of the
following is expected:
  * a semicolon ';' followed by more elements as expressions;
  * a closing bracket ']' if the list is complete.

interactive_expr: LPAR Verbatim COLON Ident VBAR
##
## Ends in an error in state: 974.
##
## par(typed_expr) -> LPAR typed_expr . RPAR [ With Verbatim VBAR UIdent Type Then TIMES String SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Lxor Lsr Lsl Lor Let Lang Land LT LPAR LE LBRACKET LBRACE Int In Ident GT End Else EQ EOF Directive CONS COMMA COLON CARET Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## LPAR typed_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 64, spurious reduction of production core_type -> no_attr_type
## In state 82, spurious reduction of production cartesian_level -> core_type
## In state 91, spurious reduction of production fun_type_level -> cartesian_level
## In state 81, spurious reduction of production type_expr -> fun_type_level
## In state 98, spurious reduction of production type_annotation(type_expr) -> COLON type_expr
## In state 977, spurious reduction of production typed_expr -> expr type_annotation(type_expr)
##

Ill-formed typed expression.
At this point, if the type annotation is complete, then a closing
parenthesis ')' is expected.

interactive_expr: LPAR Verbatim With
##
## Ends in an error in state: 976.
##
## par(expr) -> LPAR expr . RPAR [ With Verbatim VBAR UIdent Type Then TIMES String SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Lxor Lsr Lsl Lor Let Lang Land LT LPAR LE LBRACKET LBRACE Int In Ident GT End Else EQ EOF Directive DOT CONS COMMA COLON CARET Bytes Begin BOOL_OR BOOL_AND Attr ]
## typed_expr -> expr . type_annotation(type_expr) [ RPAR ]
##
## The known suffix of the stack is as follows:
## LPAR expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 320, spurious reduction of production app_expr_level -> core_expr
## In state 327, spurious reduction of production unary_expr_level -> app_expr_level
## In state 307, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 335, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 341, spurious reduction of production add_expr_level -> mult_expr_level
## In state 377, spurious reduction of production cons_expr_level -> add_expr_level
## In state 364, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 401, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 408, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 417, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 362, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 424, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 425, spurious reduction of production expr -> base_cond__open(expr)
##

Ill formed parenthesised expression.
At this point, if the expression is complete, one of the following is
expected:
  * a type annotation starting with a colon ':';
  * a closing parenthesis ')'.

interactive_expr: Lang Verbatim With
##
## Ends in an error in state: 987.
##
## code_inj -> Lang expr . RBRACKET [ With Verbatim VBAR UIdent Type Then TIMES String SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Lxor Lsr Lsl Lor Let Lang Land LT LPAR LE LBRACKET LBRACE Int In Ident GT End Else EQ EOF Directive CONS COMMA COLON CARET Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## Lang expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 320, spurious reduction of production app_expr_level -> core_expr
## In state 327, spurious reduction of production unary_expr_level -> app_expr_level
## In state 307, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 335, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 341, spurious reduction of production add_expr_level -> mult_expr_level
## In state 377, spurious reduction of production cons_expr_level -> add_expr_level
## In state 364, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 401, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 408, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 417, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 362, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 424, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 425, spurious reduction of production expr -> base_cond__open(expr)
##

Ill-formed code injection.
At this point, if the code as an expression is complete, a closing
bracket ']' is expected.

interactive_expr: MINUS With
##
## Ends in an error in state: 229.
##
## unary_op(MINUS,app_expr_level) -> MINUS . app_expr_level [ With VBAR Type Then TIMES SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or NE Module Mod MINUS Lxor Lsr Lsl Lor Let Land LT LE In GT End Else EQ EOF Directive CONS COMMA COLON CARET BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## MINUS
##
interactive_expr: Bytes REV_APP With
##
## Ends in an error in state: 363.
##
## bin_op(disj_expr_level,REV_APP,conj_expr_level) -> disj_expr_level REV_APP . conj_expr_level [ With VBAR Type Then SEMI RPAR REV_APP RBRACKET RBRACE Or Module Let In End Else EOF Directive COMMA COLON BOOL_OR Attr ]
##
## The known suffix of the stack is as follows:
## disj_expr_level REV_APP
##
interactive_expr: Verbatim CARET With
##
## Ends in an error in state: 365.
##
## bin_op(cons_expr_level,CARET,cat_expr_level) -> cons_expr_level CARET . cat_expr_level [ With VBAR Type Then SEMI RPAR REV_APP RBRACKET RBRACE Or NE Module Let LT LE In GT End Else EQ EOF Directive COMMA COLON BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## cons_expr_level CARET
##
interactive_expr: Verbatim MINUS With
##
## Ends in an error in state: 380.
##
## bin_op(add_expr_level,MINUS,mult_expr_level) -> add_expr_level MINUS . mult_expr_level [ With VBAR Type Then SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or NE Module MINUS Let LT LE In GT End Else EQ EOF Directive CONS COMMA COLON CARET BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## add_expr_level MINUS
##
interactive_expr: Verbatim Mod With
##
## Ends in an error in state: 346.
##
## bin_op(mult_expr_level,Mod,shift_expr_level) -> mult_expr_level Mod . shift_expr_level [ With VBAR Type Then TIMES SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or NE Module Mod MINUS Lxor Lor Let Land LT LE In GT End Else EQ EOF Directive CONS COMMA COLON CARET BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## mult_expr_level Mod
##
interactive_expr: Verbatim PLUS With
##
## Ends in an error in state: 378.
##
## bin_op(add_expr_level,PLUS,mult_expr_level) -> add_expr_level PLUS . mult_expr_level [ With VBAR Type Then SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or NE Module MINUS Let LT LE In GT End Else EQ EOF Directive CONS COMMA COLON CARET BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## add_expr_level PLUS
##
interactive_expr: Verbatim SLASH With
##
## Ends in an error in state: 344.
##
## bin_op(mult_expr_level,SLASH,shift_expr_level) -> mult_expr_level SLASH . shift_expr_level [ With VBAR Type Then TIMES SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or NE Module Mod MINUS Lxor Lor Let Land LT LE In GT End Else EQ EOF Directive CONS COMMA COLON CARET BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## mult_expr_level SLASH
##
interactive_expr: Verbatim TIMES With
##
## Ends in an error in state: 342.
##
## bin_op(mult_expr_level,TIMES,shift_expr_level) -> mult_expr_level TIMES . shift_expr_level [ With VBAR Type Then TIMES SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or NE Module Mod MINUS Lxor Lor Let Land LT LE In GT End Else EQ EOF Directive CONS COMMA COLON CARET BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## mult_expr_level TIMES
##
interactive_expr: Verbatim Lsr With
##
## Ends in an error in state: 308.
##
## bin_op(unary_expr_level,Lsr,shift_expr_level) -> unary_expr_level Lsr . shift_expr_level [ With VBAR Type Then TIMES SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or NE Module Mod MINUS Lxor Lor Let Land LT LE In GT End Else EQ EOF Directive CONS COMMA COLON CARET BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## unary_expr_level Lsr
##
interactive_expr: Verbatim Lsl With
##
## Ends in an error in state: 329.
##
## bin_op(unary_expr_level,Lsl,shift_expr_level) -> unary_expr_level Lsl . shift_expr_level [ With VBAR Type Then TIMES SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or NE Module Mod MINUS Lxor Lor Let Land LT LE In GT End Else EQ EOF Directive CONS COMMA COLON CARET BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## unary_expr_level Lsl
##
interactive_expr: Verbatim Lxor With
##
## Ends in an error in state: 348.
##
## bin_op(mult_expr_level,Lxor,shift_expr_level) -> mult_expr_level Lxor . shift_expr_level [ With VBAR Type Then TIMES SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or NE Module Mod MINUS Lxor Lor Let Land LT LE In GT End Else EQ EOF Directive CONS COMMA COLON CARET BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## mult_expr_level Lxor
##
interactive_expr: Verbatim Lor With
##
## Ends in an error in state: 350.
##
## bin_op(mult_expr_level,Lor,shift_expr_level) -> mult_expr_level Lor . shift_expr_level [ With VBAR Type Then TIMES SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or NE Module Mod MINUS Lxor Lor Let Land LT LE In GT End Else EQ EOF Directive CONS COMMA COLON CARET BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## mult_expr_level Lor
##
interactive_expr: Verbatim Land With
##
## Ends in an error in state: 352.
##
## bin_op(mult_expr_level,Land,shift_expr_level) -> mult_expr_level Land . shift_expr_level [ With VBAR Type Then TIMES SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or NE Module Mod MINUS Lxor Lor Let Land LT LE In GT End Else EQ EOF Directive CONS COMMA COLON CARET BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## mult_expr_level Land
##

Ill-formed expression.
At this point, an expression is expected.
Hint: To check your understanding of the syntax, try and add
parentheses around what you think is the expression.

interactive_expr: Not With
##
## Ends in an error in state: 224.
##
## unary_op(Not,app_expr_level) -> Not . app_expr_level [ With VBAR Type Then TIMES SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or NE Module Mod MINUS Lxor Lsr Lsl Lor Let Land LT LE In GT End Else EQ EOF Directive CONS COMMA COLON CARET BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## Not
##
interactive_expr: Verbatim BOOL_AND With
##
## Ends in an error in state: 385.
##
## bin_op(conj_expr_level,BOOL_AND,comp_expr_level) -> conj_expr_level BOOL_AND . comp_expr_level [ With VBAR Type Then SEMI RPAR REV_APP RBRACKET RBRACE Or Module Let In End Else EOF Directive COMMA COLON BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## conj_expr_level BOOL_AND
##
interactive_expr: Verbatim BOOL_OR With
##
## Ends in an error in state: 421.
##
## bin_op(disj_expr_level,BOOL_OR,conj_expr_level) -> disj_expr_level BOOL_OR . conj_expr_level [ With VBAR Type Then SEMI RPAR REV_APP RBRACKET RBRACE Or Module Let In End Else EOF Directive COMMA COLON BOOL_OR Attr ]
##
## The known suffix of the stack is as follows:
## disj_expr_level BOOL_OR
##
interactive_expr: Verbatim Or With
##
## Ends in an error in state: 410.
##
## bin_op(disj_expr_level,Or,conj_expr_level) -> disj_expr_level Or . conj_expr_level [ With VBAR Type Then SEMI RPAR REV_APP RBRACKET RBRACE Or Module Let In End Else EOF Directive COMMA COLON BOOL_OR Attr ]
##
## The known suffix of the stack is as follows:
## disj_expr_level Or
##
interactive_expr: Verbatim EQ With
##
## Ends in an error in state: 397.
##
## bin_op(comp_expr_level,EQ,cat_expr_level) -> comp_expr_level EQ . cat_expr_level [ With VBAR Type Then SEMI RPAR REV_APP RBRACKET RBRACE Or NE Module Let LT LE In GT End Else EQ EOF Directive COMMA COLON BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## comp_expr_level EQ
##
interactive_expr: Verbatim GT With
##
## Ends in an error in state: 393.
##
## bin_op(comp_expr_level,GT,cat_expr_level) -> comp_expr_level GT . cat_expr_level [ With VBAR Type Then SEMI RPAR REV_APP RBRACKET RBRACE Or NE Module Let LT LE In GT End Else EQ EOF Directive COMMA COLON BOOL_OR BOOL_AND Attr ]
## ge -> GT . ZWSP EQ [ Verbatim UIdent String Not Nat Mutez MINUS Lang LPAR LBRACKET LBRACE Int Ident Bytes Begin Attr ]
##
## The known suffix of the stack is as follows:
## comp_expr_level GT
##
interactive_expr: Bytes GT ZWSP EQ ZWSP
##
## Ends in an error in state: 399.
##
## bin_op(comp_expr_level,ge,cat_expr_level) -> comp_expr_level ge . cat_expr_level [ With VBAR Type Then SEMI RPAR REV_APP RBRACKET RBRACE Or NE Module Let LT LE In GT End Else EQ EOF Directive COMMA COLON BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## comp_expr_level ge
##
interactive_expr: Verbatim LE With
##
## Ends in an error in state: 391.
##
## bin_op(comp_expr_level,LE,cat_expr_level) -> comp_expr_level LE . cat_expr_level [ With VBAR Type Then SEMI RPAR REV_APP RBRACKET RBRACE Or NE Module Let LT LE In GT End Else EQ EOF Directive COMMA COLON BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## comp_expr_level LE
##
interactive_expr: Verbatim LT With
##
## Ends in an error in state: 389.
##
## bin_op(comp_expr_level,LT,cat_expr_level) -> comp_expr_level LT . cat_expr_level [ With VBAR Type Then SEMI RPAR REV_APP RBRACKET RBRACE Or NE Module Let LT LE In GT End Else EQ EOF Directive COMMA COLON BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## comp_expr_level LT
##
interactive_expr: Verbatim NE With
##
## Ends in an error in state: 387.
##
## bin_op(comp_expr_level,NE,cat_expr_level) -> comp_expr_level NE . cat_expr_level [ With VBAR Type Then SEMI RPAR REV_APP RBRACKET RBRACE Or NE Module Let LT LE In GT End Else EQ EOF Directive COMMA COLON BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## comp_expr_level NE
##

Ill-formed Boolean expression.
At this point, a Boolean expression is expected.
Hint: You may want to check the priority and associativity of
operators, or use parentheses around what you think is an expression.

interactive_expr: Verbatim COMMA Verbatim COMMA With
##
## Ends in an error in state: 415.
##
## nsepseq(disj_expr_level,COMMA) -> disj_expr_level COMMA . nsepseq(disj_expr_level,COMMA) [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End Else EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## disj_expr_level COMMA
##
interactive_expr: Verbatim COMMA With
##
## Ends in an error in state: 412.
##
## tuple(disj_expr_level) -> disj_expr_level COMMA . nsepseq(disj_expr_level,COMMA) [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End Else EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## disj_expr_level COMMA
##

Ill-formed tuple of expressions.
At this point, another component is expected as an expression.
Hint: You may want to check the priority and associativity of
operators, or use parentheses around what you think is an expression.

interactive_expr: Verbatim CONS With
##
## Ends in an error in state: 382.
##
## bin_op(add_expr_level,CONS,cons_expr_level) -> add_expr_level CONS . cons_expr_level [ With VBAR Type Then SEMI RPAR REV_APP RBRACKET RBRACE Or NE Module Let LT LE In GT End Else EQ EOF Directive COMMA COLON CARET BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## add_expr_level CONS
##

Ill-formed list expression.
At this point, an expression of type list is expected.

contract: Let LBRACE Ident With
##
## Ends in an error in state: 183.
##
## field_pattern(irrefutable) -> field_name . [ SEMI RBRACE ]
## field_pattern(irrefutable) -> field_name . EQ tuple(core_irrefutable) [ SEMI RBRACE ]
## field_pattern(irrefutable) -> field_name . EQ unit [ SEMI RBRACE ]
## field_pattern(irrefutable) -> field_name . EQ record_pattern(irrefutable) [ SEMI RBRACE ]
## field_pattern(irrefutable) -> field_name . EQ par(in_core_irrefutable) [ SEMI RBRACE ]
## field_pattern(irrefutable) -> field_name . EQ var_pattern [ SEMI RBRACE ]
## field_pattern(irrefutable) -> field_name . EQ ctor_irrefutable [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## field_name
##
interactive_expr: Match Verbatim With LBRACE Ident With
##
## Ends in an error in state: 524.
##
## field_pattern(core_pattern) -> field_name . [ SEMI RBRACE ]
## field_pattern(core_pattern) -> field_name . EQ core_pattern [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## field_name
##
interactive_expr: Match Ident With LBRACE Attr Ident ZWSP
##
## Ends in an error in state: 466.
##
## field_pattern(core_pattern) -> nseq(Attr) field_name . [ SEMI RBRACE ]
## field_pattern(core_pattern) -> nseq(Attr) field_name . EQ core_pattern [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) field_name
##

Ill-formed record pattern.
At this point, one of the following is expected:
  * a semicolon ';' if the field is punned;
  * a closing brace '}' if the record pattern is complete;
  * the assignment symbol '=' followed by a pattern matching the field.

contract: Let LBRACE With
##
## Ends in an error in state: 130.
##
## braces(option(__anonymous_2(field_pattern(irrefutable)))) -> LBRACE . option(__anonymous_2(field_pattern(irrefutable))) RBRACE [ WILD UIdent SEMI RPAR RBRACE LPAR LBRACE Ident EQ COMMA COLON Attr ARROW ]
##
## The known suffix of the stack is as follows:
## LBRACE
##
interactive_expr: Match Verbatim With LBRACE With
##
## Ends in an error in state: 459.
##
## braces(option(__anonymous_2(field_pattern(core_pattern)))) -> LBRACE . option(__anonymous_2(field_pattern(core_pattern))) RBRACE [ SEMI RPAR RBRACKET RBRACE CONS COMMA COLON ARROW ]
##
## The known suffix of the stack is as follows:
## LBRACE
##

Ill-formed record pattern.
At this point, one of the of the following is expected:
   * a field pattern;
   * a closing brace '}' if the record pattern is empty.

contract: Let LPAR UIdent UIdent With
##
## Ends in an error in state: 202.
##
## par(non_const_ctor_irrefutable) -> LPAR non_const_ctor_irrefutable . RPAR [ WILD UIdent SEMI RPAR RBRACE LPAR LBRACE Ident EQ COMMA COLON Attr ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR non_const_ctor_irrefutable
##

Ill-formed parenthesised pattern.
At this point, if the enclosed pattern is complete, a closing
parenthesis ')' is expected.

contract: Let LPAR WILD COMMA Ident With
##
## Ends in an error in state: 196.
##
## in_core_irrefutable -> tuple(core_irrefutable) . [ RPAR ]
## typed_irrefutable -> tuple(core_irrefutable) . type_annotation(type_expr) [ RPAR ]
##
## The known suffix of the stack is as follows:
## tuple(core_irrefutable)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 144, spurious reduction of production nsepseq(core_irrefutable,COMMA) -> var_pattern
## In state 164, spurious reduction of production tuple(core_irrefutable) -> var_pattern COMMA nsepseq(core_irrefutable,COMMA)
##

Ill-formed parenthesised pattern.
At this point, if the enclosed pattern is complete, one of the
following is expected:
  * a colon ':' followed by a type expression;
  * a closing parenthesis ')'.

contract: Type Ident EQ LBRACE Ident COLON Ident VBAR
##
## Ends in an error in state: 100.
##
## nsepseq(field_decl,SEMI) -> field_decl . [ RBRACE ]
## nsepseq(field_decl,SEMI) -> field_decl . SEMI nsepseq(field_decl,SEMI) [ RBRACE ]
## nseq(__anonymous_0(field_decl,SEMI)) -> field_decl . SEMI [ RBRACE ]
## nseq(__anonymous_0(field_decl,SEMI)) -> field_decl . SEMI nseq(__anonymous_0(field_decl,SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_decl
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 64, spurious reduction of production core_type -> no_attr_type
## In state 82, spurious reduction of production cartesian_level -> core_type
## In state 91, spurious reduction of production fun_type_level -> cartesian_level
## In state 81, spurious reduction of production type_expr -> fun_type_level
## In state 98, spurious reduction of production type_annotation(type_expr) -> COLON type_expr
## In state 99, spurious reduction of production field_decl -> field_decl_attr field_name type_annotation(type_expr)
##

Ill-formed record type.
At this point, if the field is complete, one of the following is
expected:
  * a semicolon ';' followed by another field declaration;
  * a closing brace '}' if the record type is complete.

contract: Type Ident EQ LBRACE With
##
## Ends in an error in state: 30.
##
## braces(option(__anonymous_2(field_decl))) -> LBRACE . option(__anonymous_2(field_decl)) RBRACE [ VBAR UIdent Type TIMES SEMI RPAR RBRACE Module Let In Ident End EQ EOF Directive COMMA Attr ARROW ]
##
## The known suffix of the stack is as follows:
## LBRACE
##

Ill-formed record type.
At this point, one of the following is expected:
  * a field declaration;
  * a closing brace '}' if the record type is empty.

contract: Type Ident EQ LPAR String COMMA String VBAR
##
## Ends in an error in state: 106.
##
## nsepseq(type_expr,COMMA) -> type_expr . [ RPAR ]
## nsepseq(type_expr,COMMA) -> type_expr . COMMA nsepseq(type_expr,COMMA) [ RPAR ]
##
## The known suffix of the stack is as follows:
## type_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 64, spurious reduction of production core_type -> no_attr_type
## In state 82, spurious reduction of production cartesian_level -> core_type
## In state 91, spurious reduction of production fun_type_level -> cartesian_level
## In state 81, spurious reduction of production type_expr -> fun_type_level
##

Ill-formed argument to a type constructor.
At this point, if the tuple component is complete, one of the
following is expected:
  * a comma ',' followed by another component as a type expression;
  * a closing parenthesis ')' if the tuple is complete.

contract: Type Ident EQ LPAR String VBAR
##
## Ends in an error in state: 104.
##
## par(type_expr) -> LPAR type_expr . RPAR [ VBAR UIdent Type TIMES SEMI RPAR RBRACE Module Let In Ident End EQ EOF Directive COMMA Attr ARROW ]
## tuple(type_expr) -> type_expr . COMMA nsepseq(type_expr,COMMA) [ RPAR ]
##
## The known suffix of the stack is as follows:
## LPAR type_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 64, spurious reduction of production core_type -> no_attr_type
## In state 82, spurious reduction of production cartesian_level -> core_type
## In state 91, spurious reduction of production fun_type_level -> cartesian_level
## In state 81, spurious reduction of production type_expr -> fun_type_level
##

Ill-formed parenthesised type or argument to a type constructor.
At this point, one of the following is expected:
  * a closing parenthesis ')' if the enclosed type is complete;
  * a comma ',' followed by another component as a type expression, if
    defining the argument to a type constructor.

contract: Type Ident EQ String ARROW With
##
## Ends in an error in state: 92.
##
## fun_type_level -> cartesian_level ARROW . fun_type_level [ VBAR Type SEMI RPAR RBRACE Module Let In End EQ EOF Directive COMMA Attr ]
##
## The known suffix of the stack is as follows:
## cartesian_level ARROW
##

Ill-formed functional type.
At this point, a type expression for the codomain (range) is expected.
Note: If you want a variant type, enclose it between parentheses.

interactive_expr: Fun Ident COLON UIdent Of With
##
## Ends in an error in state: 263.
##
## of_type(cartesian_level) -> Of . cartesian_level [ VBAR ARROW ]
##
## The known suffix of the stack is as follows:
## Of
##
contract: Let Ident COLON UIdent Of With
##
## Ends in an error in state: 25.
##
## of_type(fun_type_level) -> Of . fun_type_level [ VBAR Type SEMI RPAR RBRACE Module Let In End EQ EOF Directive COMMA Attr ]
##
## The known suffix of the stack is as follows:
## Of
##

Ill-formed variant type.
At this point, the parameter of the constructor is expected as a type
expression.
Note: If you want a variant type, enclose it between parentheses.

contract: Type Ident EQ String TIMES UIdent With
##
## Ends in an error in state: 67.
##
## module_path(__anonymous_5) -> module_name . DOT module_path(__anonymous_5) [ VBAR UIdent Type TIMES SEMI RPAR RBRACE Module Let In Ident End EQ EOF Directive COMMA Attr ARROW ]
## module_path(__anonymous_5) -> module_name . DOT type_name [ VBAR UIdent Type TIMES SEMI RPAR RBRACE Module Let In Ident End EQ EOF Directive COMMA Attr ARROW ]
## module_path(__anonymous_6) -> module_name . DOT module_path(__anonymous_6) [ VBAR UIdent Type TIMES SEMI RPAR RBRACE Module Let In Ident End EQ EOF Directive COMMA Attr ARROW ]
## module_path(__anonymous_6) -> module_name . DOT par(type_expr) [ VBAR UIdent Type TIMES SEMI RPAR RBRACE Module Let In Ident End EQ EOF Directive COMMA Attr ARROW ]
##
## The known suffix of the stack is as follows:
## module_name
##

Ill-formed selection of a type in a module.
At this point, the selection symbol '.' is expected, followed by a
qualified type expression, e.g. 'M.t' or 't' or '(t)' etc.

contract: Type Ident EQ String TIMES String TIMES With
##
## Ends in an error in state: 89.
##
## nsepseq(core_type,TIMES) -> core_type TIMES . nsepseq(core_type,TIMES) [ VBAR Type SEMI RPAR RBRACE Module Let In End EQ EOF Directive COMMA Attr ARROW ]
##
## The known suffix of the stack is as follows:
## core_type TIMES
##
contract: Type Ident EQ String TIMES With
##
## Ends in an error in state: 83.
##
## cartesian_level -> core_type TIMES . nsepseq(core_type,TIMES) [ VBAR Type SEMI RPAR RBRACE Module Let In End EQ EOF Directive COMMA Attr ARROW ]
##
## The known suffix of the stack is as follows:
## core_type TIMES
##

Ill-formed product type.
At this point, a type expression is expected.
Hint: If you want a variant type, put it between parentheses.

contract: Type Ident EQ VBAR With
##
## Ends in an error in state: 20.
##
## long_variant(fun_type_level) -> VBAR . short_variant(fun_type_level) [ VBAR Type SEMI RPAR RBRACE Module Let In End EQ EOF Directive COMMA Attr ]
##
## The known suffix of the stack is as follows:
## VBAR
##
interactive_expr: Fun Ident COLON VBAR With
##
## Ends in an error in state: 259.
##
## long_variant(cartesian_level) -> VBAR . short_variant(cartesian_level) [ VBAR ARROW ]
##
## The known suffix of the stack is as follows:
## VBAR
##

Ill-formed variant of sum type.
At this point, a variant starting with a data constructor is expected.

contract: Type With
##
## Ends in an error in state: 1.
##
## type_decl -> Type . type_name EQ type_expr [ Type Module Let In End EOF Directive Attr ]
## type_decl -> Type . type_vars type_name EQ type_expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## Type
##

Ill-formed type declaration.
At this point, one of the following is expected:
  * the name of the type being defined;
  * a quoted type parameter, like 'a;
  * a tuple of quoted type parameters, like ('a, 'b).

contract: Directive With
##
## Ends in an error in state: 1034.
##
## nseq(top_declaration) -> top_declaration . [ EOF ]
## nseq(top_declaration) -> top_declaration . nseq(top_declaration) [ EOF ]
##
## The known suffix of the stack is as follows:
## top_declaration
##

Ill-formed contract.
At this point, if the current declaration is complete, one of the
following is expected:
  * another declaration;
  * the end of the file.

contract: Module UIdent EQ Struct Type Ident EQ UIdent EOF
##
## Ends in an error in state: 1024.
##
## nseq(declaration) -> declaration . [ End ]
## nseq(declaration) -> declaration . nseq(declaration) [ End ]
##
## The known suffix of the stack is as follows:
## declaration
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 29, spurious reduction of production ctor -> UIdent
## In state 24, spurious reduction of production short_variant(fun_type_level) -> ctor
## In state 73, spurious reduction of production variant_type(fun_type_level) -> short_variant(fun_type_level)
## In state 70, spurious reduction of production type_expr -> variant_type(fun_type_level)
## In state 119, spurious reduction of production type_decl -> Type type_name EQ type_expr
## In state 1017, spurious reduction of production declaration -> type_decl
##

Ill-formed module declaration.
At this point, if the current declaration is complete, one of the
following is expected:
  * another declaration;
  * the end of the file.

contract: Module UIdent EQ With
##
## Ends in an error in state: 123.
##
## module_decl -> Module module_name EQ . module_expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## Module module_name EQ
##

Ill-formed module declaration declaration.
At this point, one of the following is expected:
  * the name of the module being aliases;
  * the qualified name of the module being aliased, e.g. 'M.N';
  * the keyword 'struct' followed by declarations, if
    defining a new module.

contract: Module UIdent With
##
## Ends in an error in state: 122.
##
## module_decl -> Module module_name . EQ module_expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## Module module_name
##

Ill-formed module declaration.
At this point, the assignment symbol '='.

contract: Module With
##
## Ends in an error in state: 121.
##
## module_decl -> Module . module_name EQ module_expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## Module
##

Ill-formed module declaration.
At this point, the name of the module being declared is expected.

interactive_expr: Begin If Verbatim Then Module UIdent EQ Struct Type Ident EQ UIdent End With
##
## Ends in an error in state: 834.
##
## local_module_decl(closed_expr) -> module_decl . In closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## module_decl
##
interactive_expr: Module UIdent EQ UIdent Type
##
## Ends in an error in state: 339.
##
## local_module_decl(expr) -> module_decl . In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## module_decl
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 1028, spurious reduction of production module_expr -> module_name
## In state 1032, spurious reduction of production module_decl -> Module module_name EQ module_expr
##
interactive_expr: Match Verbatim With WILD ARROW If Verbatim Then Module UIdent EQ UIdent Type
##
## Ends in an error in state: 614.
##
## local_module_decl(base_cond) -> module_decl . In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## local_module_decl(closed_expr) -> module_decl . In closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## module_decl
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 1028, spurious reduction of production module_expr -> module_name
## In state 1032, spurious reduction of production module_decl -> Module module_name EQ module_expr
##
interactive_expr: If Verbatim Then Match Verbatim With WILD ARROW Module UIdent EQ UIdent Type
##
## Ends in an error in state: 716.
##
## local_module_decl(base_cond) -> module_decl . In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## local_module_decl(base_if_then_else) -> module_decl . In base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## module_decl
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 1028, spurious reduction of production module_expr -> module_name
## In state 1032, spurious reduction of production module_decl -> Module module_name EQ module_expr
##
interactive_expr: Match Verbatim With WILD ARROW Module UIdent EQ UIdent Type
##
## Ends in an error in state: 651.
##
## local_module_decl(base_cond) -> module_decl . In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## module_decl
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 1028, spurious reduction of production module_expr -> module_name
## In state 1032, spurious reduction of production module_decl -> Module module_name EQ module_expr
##
interactive_expr: If Verbatim Then Module UIdent EQ UIdent Type
##
## Ends in an error in state: 762.
##
## local_module_decl(closed_expr) -> module_decl . In closed_expr [ Else ]
## local_module_decl(expr) -> module_decl . In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## module_decl
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 1028, spurious reduction of production module_expr -> module_name
## In state 1032, spurious reduction of production module_decl -> Module module_name EQ module_expr
##

Ill-formed local module declaration.
At this point, if the module declaration is complete, the keyword 'in'
is expected, followed by an expression.

contract: Module UIdent EQ UIdent DOT With
##
## Ends in an error in state: 1029.
##
## module_path(module_name) -> module_name DOT . module_path(module_name) [ Type Module Let In End EOF Directive Attr ]
## module_path(module_name) -> module_name DOT . module_name [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## module_name DOT
##

Ill-formed module qualification.
At this point, a module name is expected.

contract: Type QUOTE With
##
## Ends in an error in state: 3.
##
## quoted_type_var -> QUOTE . variable [ VBAR UIdent Type TIMES SEMI RPAR RBRACE Module Let In Ident End EQ EOF Directive COMMA Attr ARROW ]
##
## The known suffix of the stack is as follows:
## QUOTE
##

Ill-formed polymorphic type expression.
At this point, a type variable is expected.

contract: Type QUOTE Ident With
##
## Ends in an error in state: 17.
##
## type_decl -> Type type_vars . type_name EQ type_expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## Type type_vars
##

Ill-formed parametric type declaration.
At this point, the name of the type being defined is expected.

interactive_expr: Match Verbatim With LBRACE Ident EQ Bytes With
##
## Ends in an error in state: 520.
##
## nsepseq(field_pattern(core_pattern),SEMI) -> field_pattern(core_pattern) . [ RBRACE ]
## nsepseq(field_pattern(core_pattern),SEMI) -> field_pattern(core_pattern) . SEMI nsepseq(field_pattern(core_pattern),SEMI) [ RBRACE ]
## nseq(__anonymous_0(field_pattern(core_pattern),SEMI)) -> field_pattern(core_pattern) . SEMI [ RBRACE ]
## nseq(__anonymous_0(field_pattern(core_pattern),SEMI)) -> field_pattern(core_pattern) . SEMI nseq(__anonymous_0(field_pattern(core_pattern),SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_pattern(core_pattern)
##
contract: Let LBRACE Ident SEMI Ident EQ UIdent COMMA UIdent LPAR
##
## Ends in an error in state: 179.
##
## nsepseq(field_pattern(irrefutable),SEMI) -> field_pattern(irrefutable) . [ RBRACE ]
## nsepseq(field_pattern(irrefutable),SEMI) -> field_pattern(irrefutable) . SEMI nsepseq(field_pattern(irrefutable),SEMI) [ RBRACE ]
## nseq(__anonymous_0(field_pattern(irrefutable),SEMI)) -> field_pattern(irrefutable) . SEMI [ RBRACE ]
## nseq(__anonymous_0(field_pattern(irrefutable),SEMI)) -> field_pattern(irrefutable) . SEMI nseq(__anonymous_0(field_pattern(irrefutable),SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_pattern(irrefutable)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 155, spurious reduction of production nsepseq(core_irrefutable,COMMA) -> ctor_irrefutable
## In state 177, spurious reduction of production tuple(core_irrefutable) -> ctor_irrefutable COMMA nsepseq(core_irrefutable,COMMA)
## In state 187, spurious reduction of production field_pattern(irrefutable) -> field_name EQ tuple(core_irrefutable)
##

Ill-formed record pattern.
At this point, if the field pattern is complete, one of the following
is expected:
  * a semicolon ';' followed by another field pattern;
  * a closing brace '}' if the record pattern is complete.

interactive_expr: Fun LBRACE Ident SEMI With
##
## Ends in an error in state: 180.
##
## nsepseq(field_pattern(irrefutable),SEMI) -> field_pattern(irrefutable) SEMI . nsepseq(field_pattern(irrefutable),SEMI) [ RBRACE ]
## nseq(__anonymous_0(field_pattern(irrefutable),SEMI)) -> field_pattern(irrefutable) SEMI . [ RBRACE ]
## nseq(__anonymous_0(field_pattern(irrefutable),SEMI)) -> field_pattern(irrefutable) SEMI . nseq(__anonymous_0(field_pattern(irrefutable),SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_pattern(irrefutable) SEMI
##
interactive_expr: Match Verbatim With LBRACE Ident SEMI With
##
## Ends in an error in state: 521.
##
## nsepseq(field_pattern(core_pattern),SEMI) -> field_pattern(core_pattern) SEMI . nsepseq(field_pattern(core_pattern),SEMI) [ RBRACE ]
## nseq(__anonymous_0(field_pattern(core_pattern),SEMI)) -> field_pattern(core_pattern) SEMI . [ RBRACE ]
## nseq(__anonymous_0(field_pattern(core_pattern),SEMI)) -> field_pattern(core_pattern) SEMI . nseq(__anonymous_0(field_pattern(core_pattern),SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_pattern(core_pattern) SEMI
##

Ill-formed record pattern.
At this point, one of the following is expected:
  * another field pattern starting with a field name;
  * a closing brace '}' if the record pattern is complete.

contract: Let Ident LPAR Type With
##
## Ends in an error in state: 216.
##
## par(__anonymous_7) -> LPAR Type . nseq(variable) RPAR [ WILD UIdent LPAR LBRACE Ident EQ COLON Attr ]
##
## The known suffix of the stack is as follows:
## LPAR Type
##

Ill-formed type parameter.
At this point, a type parameter without a quote is expected.

contract: Let Ident LPAR Type Ident With
##
## Ends in an error in state: 217.
##
## nseq(variable) -> variable . [ RPAR ]
## nseq(variable) -> variable . nseq(variable) [ RPAR ]
##
## The known suffix of the stack is as follows:
## variable
##

Ill-formed type parameters.
At this point, one of the following is expected:
  * a type parameter without a quote;
  * a closing parenthesis ')' if there are no more parameters.

interactive_expr: Match Verbatim With LBRACKET WILD With
##
## Ends in an error in state: 532.
##
## nsepseq(cons_pattern_level,SEMI) -> cons_pattern_level . [ RBRACKET ]
## nsepseq(cons_pattern_level,SEMI) -> cons_pattern_level . SEMI nsepseq(cons_pattern_level,SEMI) [ RBRACKET ]
## nseq(__anonymous_0(cons_pattern_level,SEMI)) -> cons_pattern_level . SEMI [ RBRACKET ]
## nseq(__anonymous_0(cons_pattern_level,SEMI)) -> cons_pattern_level . SEMI nseq(__anonymous_0(cons_pattern_level,SEMI)) [ RBRACKET ]
##
## The known suffix of the stack is as follows:
## cons_pattern_level
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 501, spurious reduction of production cons_pattern_level -> core_pattern
##

Ill-formed list of patterns.
At this point, if the element as a pattern is complete, one of
the following is expected:
  * a semicolon ';' followed by another pattern;
  * a closing bracket ']' if the list is complete.

contract: Type LPAR With
##
## Ends in an error in state: 6.
##
## par(tuple(type_var)) -> LPAR . tuple(type_var) RPAR [ Ident ]
##
## The known suffix of the stack is as follows:
## LPAR
##
contract: Type LPAR QUOTE Ident COMMA QUOTE Ident COMMA With
##
## Ends in an error in state: 10.
##
## nsepseq(type_var,COMMA) -> type_var COMMA . nsepseq(type_var,COMMA) [ RPAR ]
##
## The known suffix of the stack is as follows:
## type_var COMMA
##
contract: Type LPAR QUOTE Ident COMMA With
##
## Ends in an error in state: 8.
##
## tuple(type_var) -> type_var COMMA . nsepseq(type_var,COMMA) [ RPAR ]
##
## The known suffix of the stack is as follows:
## type_var COMMA
##

Ill-formed parametric type declaration.
At this point, a quoted type parameter is expected, like 'a.

contract: Type LPAR QUOTE Ident With
##
## Ends in an error in state: 7.
##
## tuple(type_var) -> type_var . COMMA nsepseq(type_var,COMMA) [ RPAR ]
##
## The known suffix of the stack is as follows:
## type_var
##

Ill-formed parametric type declaration.
At this point, a comma ',' is expected, followed by another quoted
type parameter, like 'a.

contract: Type LPAR QUOTE Ident COMMA QUOTE Ident With
##
## Ends in an error in state: 9.
##
## nsepseq(type_var,COMMA) -> type_var . [ RPAR ]
## nsepseq(type_var,COMMA) -> type_var . COMMA nsepseq(type_var,COMMA) [ RPAR ]
##
## The known suffix of the stack is as follows:
## type_var
##

Ill-formed parametric type declaration.
At this point, one of the following is expected:
  * a comma ',' followed by another quoted type parameter, like 'a;
  * a closing parenthesis ')' if there are no more parameters.

interactive_expr: LPAR UIdent COLON LPAR Ident COMMA Ident RPAR With
##
## Ends in an error in state: 48.
##
## qualified_type -> type_ctor_arg . type_in_module(__anonymous_4) [ VBAR UIdent Type TIMES SEMI RPAR RBRACE Module Let In Ident End EQ EOF Directive COMMA Attr ARROW ]
## type_ctor_app -> type_ctor_arg . type_ctor [ VBAR UIdent Type TIMES SEMI RPAR RBRACE Module Let In Ident End EQ EOF Directive COMMA Attr ARROW ]
##
## The known suffix of the stack is as follows:
## type_ctor_arg
##

Ill-formed type expression.
At this point, one of the following is expected:
  * a type constructor, e.g. 'list';
  * a selection of a type constructor in a module, e.g. `M.N.t`.
Note: A type constructor is the analogue of a function name at the
type level. For example, 'list', 'map' and 'set' are type
constructors. Contrary to function names, type constructors are
written _after_ their arguments.

contract: Type Ident EQ LBRACE Ident With
##
## Ends in an error in state: 41.
##
## field_decl -> field_decl_attr field_name . [ SEMI RBRACE ]
## field_decl -> field_decl_attr field_name . type_annotation(type_expr) [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## field_decl_attr field_name
##

Ill-formed record type.
At this point, one of the following is expected:
  * a semicolon ';' if the field is punned;
  * a colon ':' followed by the type of the field;
  * a closing brace '}' if the record is complete.

contract: Let UIdent COLON LBRACE Attr WILD
##
## Ends in an error in state: 31.
##
## nseq(Attr) -> Attr . [ Ident ]
## nseq(Attr) -> Attr . nseq(Attr) [ Ident ]
##
## The known suffix of the stack is as follows:
## Attr
##

Ill-formed record.
At this point, if the attribute is complete, one of the following is
expected:
  * another attribute;
  * a field name.

contract: Let Ident COLON LBRACE Ident COLON Ident SEMI With
##
## Ends in an error in state: 101.
##
## nsepseq(field_decl,SEMI) -> field_decl SEMI . nsepseq(field_decl,SEMI) [ RBRACE ]
## nseq(__anonymous_0(field_decl,SEMI)) -> field_decl SEMI . [ RBRACE ]
## nseq(__anonymous_0(field_decl,SEMI)) -> field_decl SEMI . nseq(__anonymous_0(field_decl,SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_decl SEMI
##

Ill-formed record type.
At this point one of the following is expected:
  * a field declaration, starting with a field name;
  * a closing brace '}' if the record is complete.

interactive_expr: Fun Ident COLON With
##
## Ends in an error in state: 258.
##
## type_annotation(lambda_app_type) -> COLON . lambda_app_type [ ARROW ]
##
## The known suffix of the stack is as follows:
## COLON
##

Ill-formed type annotation.
At this point, a type expression is expected.
Note: If you want a functional type, enclose it between parentheses.

interactive_expr: LPAR UIdent COLON With
##
## Ends in an error in state: 42.
##
## type_annotation(type_expr) -> COLON . type_expr [ SEMI RPAR RBRACE EQ ]
##
## The known suffix of the stack is as follows:
## COLON
##

Ill-formed type annotation.
At this point, a type expression is expected.

contract: Let Ident COLON LPAR Ident COMMA With
##
## Ends in an error in state: 105.
##
## tuple(type_expr) -> type_expr COMMA . nsepseq(type_expr,COMMA) [ RPAR ]
##
## The known suffix of the stack is as follows:
## type_expr COMMA
##
contract: Let Ident COLON LPAR Ident COMMA Ident COMMA With
##
## Ends in an error in state: 107.
##
## nsepseq(type_expr,COMMA) -> type_expr COMMA . nsepseq(type_expr,COMMA) [ RPAR ]
##
## The known suffix of the stack is as follows:
## type_expr COMMA
##

Ill-formed parametric type expression.
At this point, a type argument is expected as a type expression.

contract: Module UIdent EQ Struct With
##
## Ends in an error in state: 124.
##
## structure -> Struct . End [ Type Module Let In End EOF Directive Attr ]
## structure -> Struct . nseq(declaration) End [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## Struct
##

Ill-formed module declaration.
At this point, one of the following is expected:
  * a declaration;
  * the keyword 'end' if the module is empty.

contract: Let LPAR With
##
## Ends in an error in state: 128.
##
## par(in_core_irrefutable) -> LPAR . in_core_irrefutable RPAR [ WILD UIdent SEMI RPAR RBRACE LPAR LBRACE Ident EQ COMMA COLON Attr ARROW ]
## par(non_const_ctor_irrefutable) -> LPAR . non_const_ctor_irrefutable RPAR [ WILD UIdent SEMI RPAR RBRACE LPAR LBRACE Ident EQ COMMA COLON Attr ARROW ]
## unit -> LPAR . RPAR [ WILD UIdent SEMI RPAR RBRACE LPAR LBRACE Ident EQ COMMA COLON Attr ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR
##
interactive_expr: Match UIdent With LPAR With
##
## Ends in an error in state: 457.
##
## par(__anonymous_8) -> LPAR . pattern RPAR [ SEMI RPAR RBRACKET RBRACE CONS COMMA COLON ARROW ]
## par(__anonymous_8) -> LPAR . typed_pattern RPAR [ SEMI RPAR RBRACKET RBRACE CONS COMMA COLON ARROW ]
## unit -> LPAR . RPAR [ SEMI RPAR RBRACKET RBRACE CONS COMMA COLON ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR
##

Ill-formed pattern.
At this point, one of the following is expected:
  * a pattern followed by a closing parenthesis ')';
  * a closing parenthesis ')' if matching against the unit pattern '()'.

contract: Let LBRACE Ident EQ With
##
## Ends in an error in state: 184.
##
## field_pattern(irrefutable) -> field_name EQ . tuple(core_irrefutable) [ SEMI RBRACE ]
## field_pattern(irrefutable) -> field_name EQ . unit [ SEMI RBRACE ]
## field_pattern(irrefutable) -> field_name EQ . record_pattern(irrefutable) [ SEMI RBRACE ]
## field_pattern(irrefutable) -> field_name EQ . par(in_core_irrefutable) [ SEMI RBRACE ]
## field_pattern(irrefutable) -> field_name EQ . var_pattern [ SEMI RBRACE ]
## field_pattern(irrefutable) -> field_name EQ . ctor_irrefutable [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## field_name EQ
##

Ill-formed record pattern.
At this point, an irrefutable pattern for the field is expected,
e.g. a variable.

interactive_expr: Match UIdent With LBRACE Ident EQ With
##
## Ends in an error in state: 525.
##
## field_pattern(core_pattern) -> field_name EQ . core_pattern [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## field_name EQ
##

Ill-formed record pattern.
At this point, a pattern for the field is expected.

contract: Let Attr With
##
## Ends in an error in state: 139.
##
## var_pattern -> Attr . var_pattern [ WILD UIdent SEMI RPAR RBRACE LPAR LBRACE Ident EQ COMMA COLON Attr ARROW ]
##
## The known suffix of the stack is as follows:
## Attr
##

Ill-formed attributed variable in a pattern.
At this point, a variable is expected.

contract: Let Ident EQ With
##
## Ends in an error in state: 221.
##
## non_fun_decl -> var_pattern EQ . expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## var_pattern EQ
##
contract: Let Ident Ident EQ With
##
## Ends in an error in state: 995.
##
## fun_decl -> var_pattern parameters EQ . expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## var_pattern parameters EQ
##
contract: Let Ident Ident COLON Ident EQ With
##
## Ends in an error in state: 998.
##
## fun_decl -> var_pattern parameters type_annotation(type_expr) EQ . expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## var_pattern parameters type_annotation(type_expr) EQ
##
contract: Let LPAR RPAR COLON Ident EQ With
##
## Ends in an error in state: 962.
##
## non_fun_decl -> unit type_annotation(type_expr) EQ . expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## unit type_annotation(type_expr) EQ
##
contract: Let LPAR RPAR EQ With
##
## Ends in an error in state: 235.
##
## non_fun_decl -> unit EQ . expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## unit EQ
##
contract: Let LPAR RPAR LPAR Type Ident RPAR EQ With
##
## Ends in an error in state: 965.
##
## non_fun_decl -> unit par(__anonymous_7) EQ . expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## unit par(__anonymous_7) EQ
##
contract: Let LPAR RPAR LPAR Type Ident RPAR COLON Ident EQ With
##
## Ends in an error in state: 968.
##
## non_fun_decl -> unit par(__anonymous_7) type_annotation(type_expr) EQ . expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## unit par(__anonymous_7) type_annotation(type_expr) EQ
##
contract: Let WILD COMMA Ident EQ With
##
## Ends in an error in state: 541.
##
## non_fun_decl -> tuple(core_irrefutable) EQ . expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## tuple(core_irrefutable) EQ
##
contract: Let WILD COMMA Ident COLON Ident EQ With
##
## Ends in an error in state: 544.
##
## non_fun_decl -> tuple(core_irrefutable) type_annotation(type_expr) EQ . expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## tuple(core_irrefutable) type_annotation(type_expr) EQ
##
contract: Let WILD COMMA Ident LPAR Type Ident RPAR EQ With
##
## Ends in an error in state: 547.
##
## non_fun_decl -> tuple(core_irrefutable) par(__anonymous_7) EQ . expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## tuple(core_irrefutable) par(__anonymous_7) EQ
##
contract: Let WILD COMMA Ident LPAR Type Ident RPAR COLON Ident EQ With
##
## Ends in an error in state: 550.
##
## non_fun_decl -> tuple(core_irrefutable) par(__anonymous_7) type_annotation(type_expr) EQ . expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## tuple(core_irrefutable) par(__anonymous_7) type_annotation(type_expr) EQ
##
contract: Let LBRACE Ident RBRACE EQ With
##
## Ends in an error in state: 553.
##
## non_fun_decl -> record_pattern(irrefutable) EQ . expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## record_pattern(irrefutable) EQ
##
contract: Let LBRACE Ident RBRACE COLON Ident EQ With
##
## Ends in an error in state: 556.
##
## non_fun_decl -> record_pattern(irrefutable) type_annotation(type_expr) EQ . expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## record_pattern(irrefutable) type_annotation(type_expr) EQ
##
contract: Let LBRACE Ident RBRACE LPAR Type Ident RPAR EQ With
##
## Ends in an error in state: 559.
##
## non_fun_decl -> record_pattern(irrefutable) par(__anonymous_7) EQ . expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## record_pattern(irrefutable) par(__anonymous_7) EQ
##
contract: Let LBRACE Ident RBRACE LPAR Type Ident RPAR COLON Ident EQ With
##
## Ends in an error in state: 562.
##
## non_fun_decl -> record_pattern(irrefutable) par(__anonymous_7) type_annotation(type_expr) EQ . expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## record_pattern(irrefutable) par(__anonymous_7) type_annotation(type_expr) EQ
##
contract: Let LPAR UIdent COLON Ident RPAR COLON Ident EQ With
##
## Ends in an error in state: 568.
##
## non_fun_decl -> par(in_core_irrefutable) type_annotation(type_expr) EQ . expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## par(in_core_irrefutable) type_annotation(type_expr) EQ
##
contract: Let LPAR WILD RPAR EQ With
##
## Ends in an error in state: 565.
##
## non_fun_decl -> par(in_core_irrefutable) EQ . expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## par(in_core_irrefutable) EQ
##
contract: Let LPAR WILD RPAR LPAR Type Ident RPAR EQ With
##
## Ends in an error in state: 571.
##
## non_fun_decl -> par(in_core_irrefutable) par(__anonymous_7) EQ . expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## par(in_core_irrefutable) par(__anonymous_7) EQ
##
contract: Let LPAR WILD RPAR LPAR Type Ident RPAR COLON Ident EQ With
##
## Ends in an error in state: 574.
##
## non_fun_decl -> par(in_core_irrefutable) par(__anonymous_7) type_annotation(type_expr) EQ . expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## par(in_core_irrefutable) par(__anonymous_7) type_annotation(type_expr) EQ
##
contract: Let UIdent EQ With
##
## Ends in an error in state: 669.
##
## non_fun_decl -> ctor_irrefutable EQ . expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## ctor_irrefutable EQ
##
contract: Let UIdent COLON Ident EQ With
##
## Ends in an error in state: 672.
##
## non_fun_decl -> ctor_irrefutable type_annotation(type_expr) EQ . expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## ctor_irrefutable type_annotation(type_expr) EQ
##
contract: Let UIdent LPAR Type Ident RPAR EQ With
##
## Ends in an error in state: 675.
##
## non_fun_decl -> ctor_irrefutable par(__anonymous_7) EQ . expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## ctor_irrefutable par(__anonymous_7) EQ
##
contract: Let UIdent LPAR Type Ident RPAR COLON Ident EQ With
##
## Ends in an error in state: 678.
##
## non_fun_decl -> ctor_irrefutable par(__anonymous_7) type_annotation(type_expr) EQ . expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## ctor_irrefutable par(__anonymous_7) type_annotation(type_expr) EQ
##
contract: Let WILD LPAR Type Ident RPAR EQ With
##
## Ends in an error in state: 1001.
##
## non_fun_decl -> var_pattern par(__anonymous_7) EQ . expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## var_pattern par(__anonymous_7) EQ
##
contract: Let WILD LPAR Type Ident RPAR COLON Ident EQ With
##
## Ends in an error in state: 1004.
##
## non_fun_decl -> var_pattern par(__anonymous_7) type_annotation(type_expr) EQ . expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## var_pattern par(__anonymous_7) type_annotation(type_expr) EQ
##
contract: Let Ident COLON Ident EQ ZWSP
##
## Ends in an error in state: 992.
##
## non_fun_decl -> var_pattern type_annotation(type_expr) EQ . expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## var_pattern type_annotation(type_expr) EQ
##

Ill-formed value declaration.
At this point, an expression is expected.

interactive_expr: Lang With
##
## Ends in an error in state: 227.
##
## code_inj -> Lang . expr RBRACKET [ With Verbatim VBAR UIdent Type Then TIMES String SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Lxor Lsr Lsl Lor Let Lang Land LT LPAR LE LBRACKET LBRACE Int In Ident GT End Else EQ EOF Directive CONS COMMA COLON CARET Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## Lang
##

Ill-formed code injection.
At this point, the code is expected as an expression whose value is a
verbatim string.

interactive_expr: LPAR With
##
## Ends in an error in state: 230.
##
## par(expr) -> LPAR . expr RPAR [ With Verbatim VBAR UIdent Type Then TIMES String SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Lxor Lsr Lsl Lor Let Lang Land LT LPAR LE LBRACKET LBRACE Int In Ident GT End Else EQ EOF Directive DOT CONS COMMA COLON CARET Bytes Begin BOOL_OR BOOL_AND Attr ]
## par(typed_expr) -> LPAR . typed_expr RPAR [ With Verbatim VBAR UIdent Type Then TIMES String SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Lxor Lsr Lsl Lor Let Lang Land LT LPAR LE LBRACKET LBRACE Int In Ident GT End Else EQ EOF Directive CONS COMMA COLON CARET Bytes Begin BOOL_OR BOOL_AND Attr ]
## unit -> LPAR . RPAR [ With Verbatim VBAR UIdent Type Then TIMES String SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Lxor Lsr Lsl Lor Let Lang Land LT LPAR LE LBRACKET LBRACE Int In Ident GT End Else EQ EOF Directive CONS COMMA COLON CARET Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## LPAR
##

Ill-formed expression.
At this point, one of following is expected:
  * an expression is expected, if defining a parenthesised expression.
  * a closing parenthesis ')' if defining the unit value.

interactive_expr: UIdent DOT LPAR ZWSP
##
## Ends in an error in state: 304.
##
## par(expr) -> LPAR . expr RPAR [ With Verbatim VBAR UIdent Type Then TIMES String SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Lxor Lsr Lsl Lor Let Lang Land LT LPAR LE LBRACKET LBRACE Int In Ident GT End Else EQ EOF Directive CONS COMMA COLON CARET Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## LPAR
##

Ill-formed parenthesised expression.
At this point, an expression is expected.

interactive_expr: Match UIdent With LBRACKET With
##
## Ends in an error in state: 458.
##
## brackets(option(__anonymous_1(cons_pattern_level))) -> LBRACKET . option(__anonymous_1(cons_pattern_level)) RBRACKET [ SEMI RPAR RBRACKET RBRACE CONS COMMA COLON ARROW ]
##
## The known suffix of the stack is as follows:
## LBRACKET
##

Ill-formed list of patterns.
At this point, one of the following is expected:
  * a list element as a pattern;
  * a closing bracket ']' if matching the empty list.

interactive_expr: Match UIdent With UIdent COMMA With
##
## Ends in an error in state: 505.
##
## tuple(cons_pattern_level) -> cons_pattern_level COMMA . nsepseq(cons_pattern_level,COMMA) [ RPAR COLON ARROW ]
##
## The known suffix of the stack is as follows:
## cons_pattern_level COMMA
##
interactive_expr: Match UIdent With UIdent COMMA UIdent COMMA With
##
## Ends in an error in state: 508.
##
## nsepseq(cons_pattern_level,COMMA) -> cons_pattern_level COMMA . nsepseq(cons_pattern_level,COMMA) [ RPAR COLON ARROW ]
##
## The known suffix of the stack is as follows:
## cons_pattern_level COMMA
##
contract: Let Ident COMMA With
##
## Ends in an error in state: 143.
##
## tuple(core_irrefutable) -> var_pattern COMMA . nsepseq(core_irrefutable,COMMA) [ SEMI RPAR RBRACE LPAR EQ COLON ]
##
## The known suffix of the stack is as follows:
## var_pattern COMMA
##
contract: Let WILD COMMA WILD COMMA With
##
## Ends in an error in state: 145.
##
## nsepseq(core_irrefutable,COMMA) -> var_pattern COMMA . nsepseq(core_irrefutable,COMMA) [ SEMI RPAR RBRACE LPAR EQ COLON ]
##
## The known suffix of the stack is as follows:
## var_pattern COMMA
##
contract: Let WILD COMMA LPAR RPAR COMMA With
##
## Ends in an error in state: 147.
##
## nsepseq(core_irrefutable,COMMA) -> unit COMMA . nsepseq(core_irrefutable,COMMA) [ SEMI RPAR RBRACE LPAR EQ COLON ]
##
## The known suffix of the stack is as follows:
## unit COMMA
##
contract: Let WILD COMMA LBRACE Ident RBRACE COMMA With
##
## Ends in an error in state: 149.
##
## nsepseq(core_irrefutable,COMMA) -> record_pattern(irrefutable) COMMA . nsepseq(core_irrefutable,COMMA) [ SEMI RPAR RBRACE LPAR EQ COLON ]
##
## The known suffix of the stack is as follows:
## record_pattern(irrefutable) COMMA
##
contract: Let WILD COMMA LPAR WILD RPAR COMMA With
##
## Ends in an error in state: 153.
##
## nsepseq(core_irrefutable,COMMA) -> par(in_core_irrefutable) COMMA . nsepseq(core_irrefutable,COMMA) [ SEMI RPAR RBRACE LPAR EQ COLON ]
##
## The known suffix of the stack is as follows:
## par(in_core_irrefutable) COMMA
##
contract: Let WILD COMMA UIdent COMMA With
##
## Ends in an error in state: 156.
##
## nsepseq(core_irrefutable,COMMA) -> ctor_irrefutable COMMA . nsepseq(core_irrefutable,COMMA) [ SEMI RPAR RBRACE LPAR EQ COLON ]
##
## The known suffix of the stack is as follows:
## ctor_irrefutable COMMA
##
contract: Let LPAR RPAR COMMA With
##
## Ends in an error in state: 166.
##
## tuple(core_irrefutable) -> unit COMMA . nsepseq(core_irrefutable,COMMA) [ SEMI RPAR RBRACE LPAR EQ COLON ]
##
## The known suffix of the stack is as follows:
## unit COMMA
##
contract: Let LBRACE Ident RBRACE COMMA With
##
## Ends in an error in state: 170.
##
## tuple(core_irrefutable) -> record_pattern(irrefutable) COMMA . nsepseq(core_irrefutable,COMMA) [ SEMI RPAR RBRACE LPAR EQ COLON ]
##
## The known suffix of the stack is as follows:
## record_pattern(irrefutable) COMMA
##
contract: Let LPAR WILD RPAR COMMA With
##
## Ends in an error in state: 173.
##
## tuple(core_irrefutable) -> par(in_core_irrefutable) COMMA . nsepseq(core_irrefutable,COMMA) [ SEMI RPAR RBRACE LPAR EQ COLON ]
##
## The known suffix of the stack is as follows:
## par(in_core_irrefutable) COMMA
##
contract: Let UIdent COMMA With
##
## Ends in an error in state: 176.
##
## tuple(core_irrefutable) -> ctor_irrefutable COMMA . nsepseq(core_irrefutable,COMMA) [ SEMI RPAR RBRACE LPAR EQ COLON ]
##
## The known suffix of the stack is as follows:
## ctor_irrefutable COMMA
##

Ill-formed tuple of patterns.
At this point, another component is expected as a pattern.

interactive_expr: LBRACKET With
##
## Ends in an error in state: 236.
##
## brackets(option(__anonymous_1(expr))) -> LBRACKET . option(__anonymous_1(expr)) RBRACKET [ With Verbatim VBAR UIdent Type Then TIMES String SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Lxor Lsr Lsl Lor Let Lang Land LT LPAR LE LBRACKET LBRACE Int In Ident GT End Else EQ EOF Directive CONS COMMA COLON CARET Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## LBRACKET
##

Ill-formed list of expressions.
At this point, one of the following is expected:
  * a list element as an expression;
  * a closing bracket ']' if defining the empty list.

interactive_expr: LBRACE Ident EQ With
##
## Ends in an error in state: 945.
##
## field_assignment -> field_name EQ . expr [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## field_name EQ
##
interactive_expr: LBRACE Attr Ident EQ ZWSP
##
## Ends in an error in state: 911.
##
## field_assignment -> nseq(Attr) field_name EQ . expr [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) field_name EQ
##

Ill-formed record expression.
At this point, an expression is expected to be assigned to the field.

interactive_expr: Begin Match UIdent With UIdent ARROW Fun LPAR Type Ident RPAR With
##
## Ends in an error in state: 799.
##
## fun_expr(base_cond) -> Fun par(__anonymous_7) . nseq(core_irrefutable) ARROW base_cond [ VBAR ]
## fun_expr(base_cond) -> Fun par(__anonymous_7) . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW base_cond [ VBAR ]
## fun_expr(last_expr) -> Fun par(__anonymous_7) . nseq(core_irrefutable) ARROW last_expr [ End ]
## fun_expr(last_expr) -> Fun par(__anonymous_7) . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW last_expr [ End ]
##
## The known suffix of the stack is as follows:
## Fun par(__anonymous_7)
##
interactive_expr: If UIdent Then Match UIdent With UIdent ARROW Attr Fun LPAR Type Ident RPAR With
##
## Ends in an error in state: 707.
##
## fun_expr(base_cond) -> Fun par(__anonymous_7) . nseq(core_irrefutable) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_cond) -> Fun par(__anonymous_7) . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_if_then_else) -> Fun par(__anonymous_7) . nseq(core_irrefutable) ARROW base_if_then_else [ Else ]
## fun_expr(base_if_then_else) -> Fun par(__anonymous_7) . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## Fun par(__anonymous_7)
##
interactive_expr: Match UIdent With UIdent ARROW If UIdent Then Attr Fun LPAR Type Ident RPAR With
##
## Ends in an error in state: 602.
##
## fun_expr(base_cond) -> Fun par(__anonymous_7) . nseq(core_irrefutable) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_cond) -> Fun par(__anonymous_7) . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(closed_expr) -> Fun par(__anonymous_7) . nseq(core_irrefutable) ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> Fun par(__anonymous_7) . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Fun par(__anonymous_7)
##
interactive_expr: Fun LPAR Type Ident RPAR With
##
## Ends in an error in state: 256.
##
## fun_expr(expr) -> Fun par(__anonymous_7) . nseq(core_irrefutable) ARROW expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(expr) -> Fun par(__anonymous_7) . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun par(__anonymous_7)
##
interactive_expr: Begin Fun LPAR Type Ident RPAR With
##
## Ends in an error in state: 851.
##
## fun_expr(last_expr) -> Fun par(__anonymous_7) . nseq(core_irrefutable) ARROW last_expr [ End ]
## fun_expr(last_expr) -> Fun par(__anonymous_7) . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW last_expr [ End ]
##
## The known suffix of the stack is as follows:
## Fun par(__anonymous_7)
##
interactive_expr: If UIdent Then Fun LPAR Type Ident RPAR With
##
## Ends in an error in state: 755.
##
## fun_expr(closed_expr) -> Fun par(__anonymous_7) . nseq(core_irrefutable) ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> Fun par(__anonymous_7) . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW closed_expr [ Else ]
## fun_expr(expr) -> Fun par(__anonymous_7) . nseq(core_irrefutable) ARROW expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(expr) -> Fun par(__anonymous_7) . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun par(__anonymous_7)
##
interactive_expr: Begin If UIdent Then Fun LPAR Type Ident RPAR With
##
## Ends in an error in state: 827.
##
## fun_expr(closed_expr) -> Fun par(__anonymous_7) . nseq(core_irrefutable) ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> Fun par(__anonymous_7) . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Fun par(__anonymous_7)
##
interactive_expr: Begin Match UIdent With UIdent ARROW Attr Fun LPAR Type Ident RPAR With
##
## Ends in an error in state: 643.
##
## fun_expr(base_cond) -> Fun par(__anonymous_7) . nseq(core_irrefutable) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_cond) -> Fun par(__anonymous_7) . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun par(__anonymous_7)
##

Ill-formed functional expression.
At this point, parameters are expected as irrefutable patterns,
e.g. variables.

interactive_expr: If UIdent Then Fun With
##
## Ends in an error in state: 754.
##
## fun_expr(closed_expr) -> Fun . nseq(core_irrefutable) ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> Fun . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> Fun . par(__anonymous_7) nseq(core_irrefutable) ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> Fun . par(__anonymous_7) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW closed_expr [ Else ]
## fun_expr(expr) -> Fun . nseq(core_irrefutable) ARROW expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(expr) -> Fun . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(expr) -> Fun . par(__anonymous_7) nseq(core_irrefutable) ARROW expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(expr) -> Fun . par(__anonymous_7) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun
##
interactive_expr: Begin Fun With
##
## Ends in an error in state: 850.
##
## fun_expr(last_expr) -> Fun . nseq(core_irrefutable) ARROW last_expr [ End ]
## fun_expr(last_expr) -> Fun . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW last_expr [ End ]
## fun_expr(last_expr) -> Fun . par(__anonymous_7) nseq(core_irrefutable) ARROW last_expr [ End ]
## fun_expr(last_expr) -> Fun . par(__anonymous_7) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW last_expr [ End ]
##
## The known suffix of the stack is as follows:
## Fun
##
interactive_expr: Begin If UIdent Then Fun With
##
## Ends in an error in state: 826.
##
## fun_expr(closed_expr) -> Fun . nseq(core_irrefutable) ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> Fun . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> Fun . par(__anonymous_7) nseq(core_irrefutable) ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> Fun . par(__anonymous_7) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Fun
##
interactive_expr: Begin Match UIdent With UIdent ARROW Fun With
##
## Ends in an error in state: 798.
##
## fun_expr(base_cond) -> Fun . nseq(core_irrefutable) ARROW base_cond [ VBAR ]
## fun_expr(base_cond) -> Fun . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW base_cond [ VBAR ]
## fun_expr(base_cond) -> Fun . par(__anonymous_7) nseq(core_irrefutable) ARROW base_cond [ VBAR ]
## fun_expr(base_cond) -> Fun . par(__anonymous_7) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW base_cond [ VBAR ]
## fun_expr(last_expr) -> Fun . nseq(core_irrefutable) ARROW last_expr [ End ]
## fun_expr(last_expr) -> Fun . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW last_expr [ End ]
## fun_expr(last_expr) -> Fun . par(__anonymous_7) nseq(core_irrefutable) ARROW last_expr [ End ]
## fun_expr(last_expr) -> Fun . par(__anonymous_7) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW last_expr [ End ]
##
## The known suffix of the stack is as follows:
## Fun
##
interactive_expr: Match UIdent With UIdent ARROW Fun With
##
## Ends in an error in state: 642.
##
## fun_expr(base_cond) -> Fun . nseq(core_irrefutable) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_cond) -> Fun . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_cond) -> Fun . par(__anonymous_7) nseq(core_irrefutable) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_cond) -> Fun . par(__anonymous_7) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun
##
interactive_expr: If UIdent Then Match UIdent With UIdent ARROW Fun With
##
## Ends in an error in state: 706.
##
## fun_expr(base_cond) -> Fun . nseq(core_irrefutable) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_cond) -> Fun . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_cond) -> Fun . par(__anonymous_7) nseq(core_irrefutable) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_cond) -> Fun . par(__anonymous_7) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_if_then_else) -> Fun . nseq(core_irrefutable) ARROW base_if_then_else [ Else ]
## fun_expr(base_if_then_else) -> Fun . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW base_if_then_else [ Else ]
## fun_expr(base_if_then_else) -> Fun . par(__anonymous_7) nseq(core_irrefutable) ARROW base_if_then_else [ Else ]
## fun_expr(base_if_then_else) -> Fun . par(__anonymous_7) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## Fun
##
interactive_expr: Fun With
##
## Ends in an error in state: 245.
##
## fun_expr(expr) -> Fun . nseq(core_irrefutable) ARROW expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(expr) -> Fun . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(expr) -> Fun . par(__anonymous_7) nseq(core_irrefutable) ARROW expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(expr) -> Fun . par(__anonymous_7) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun
##
interactive_expr: Match UIdent With UIdent ARROW If UIdent Then Attr Fun With
##
## Ends in an error in state: 601.
##
## fun_expr(base_cond) -> Fun . nseq(core_irrefutable) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_cond) -> Fun . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_cond) -> Fun . par(__anonymous_7) nseq(core_irrefutable) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_cond) -> Fun . par(__anonymous_7) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(closed_expr) -> Fun . nseq(core_irrefutable) ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> Fun . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> Fun . par(__anonymous_7) nseq(core_irrefutable) ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> Fun . par(__anonymous_7) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Fun
##

Ill-formed functional expression.
At this point, one of the following is expected:
  * value parameters as irrefutable patterns, e.g. variables;
  * type parameters between parentheses, e.g. '(type a b)'.

interactive_expr: If UIdent Then Match With
##
## Ends in an error in state: 448.
##
## match_expr(base_cond) -> Match . expr With cases(base_cond) [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## match_expr(base_cond) -> Match . expr With VBAR cases(base_cond) [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## match_expr(base_if_then_else) -> Match . expr With cases(base_if_then_else) [ Else ]
## match_expr(base_if_then_else) -> Match . expr With VBAR cases(base_if_then_else) [ Else ]
##
## The known suffix of the stack is as follows:
## Match
##
interactive_expr: Begin Match With
##
## Ends in an error in state: 242.
##
## match_expr(last_expr) -> Match . expr With cases(last_expr) [ End ]
## match_expr(last_expr) -> Match . expr With VBAR cases(last_expr) [ End ]
##
## The known suffix of the stack is as follows:
## Match
##
interactive_expr: Match With
##
## Ends in an error in state: 228.
##
## match_expr(base_cond) -> Match . expr With cases(base_cond) [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## match_expr(base_cond) -> Match . expr With VBAR cases(base_cond) [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Match
##
interactive_expr: Begin If UIdent Then Match With
##
## Ends in an error in state: 582.
##
## match_expr(base_if_then_else) -> Match . expr With cases(base_if_then_else) [ Else ]
## match_expr(base_if_then_else) -> Match . expr With VBAR cases(base_if_then_else) [ Else ]
##
## The known suffix of the stack is as follows:
## Match
##

Ill-formed match expression.
At this point, the subject expression is expected.

interactive_expr: Module UIdent EQ UIdent In With
##
## Ends in an error in state: 340.
##
## local_module_decl(expr) -> module_decl In . expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## module_decl In
##
interactive_expr: If UIdent Then Module UIdent EQ UIdent In With
##
## Ends in an error in state: 763.
##
## local_module_decl(closed_expr) -> module_decl In . closed_expr [ Else ]
## local_module_decl(expr) -> module_decl In . expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## module_decl In
##
interactive_expr: Begin If UIdent Then Module UIdent EQ UIdent In With
##
## Ends in an error in state: 835.
##
## local_module_decl(closed_expr) -> module_decl In . closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## module_decl In
##
interactive_expr: Match UIdent With UIdent ARROW If UIdent Then Module UIdent EQ UIdent In With
##
## Ends in an error in state: 615.
##
## local_module_decl(base_cond) -> module_decl In . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## local_module_decl(closed_expr) -> module_decl In . closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## module_decl In
##
interactive_expr: If UIdent Then Match UIdent With UIdent ARROW Module UIdent EQ UIdent In With
##
## Ends in an error in state: 717.
##
## local_module_decl(base_cond) -> module_decl In . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## local_module_decl(base_if_then_else) -> module_decl In . base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## module_decl In
##
interactive_expr: Match UIdent With UIdent ARROW Module UIdent EQ UIdent In With
##
## Ends in an error in state: 652.
##
## local_module_decl(base_cond) -> module_decl In . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## module_decl In
##

Ill-formed local module declaration.
At this point, an expression is expected.

contract: Let Ident LPAR With
##
## Ends in an error in state: 215.
##
## par(__anonymous_7) -> LPAR . Type nseq(variable) RPAR [ WILD UIdent LPAR LBRACE Ident EQ COLON Attr ]
## par(in_core_irrefutable) -> LPAR . in_core_irrefutable RPAR [ WILD UIdent LPAR LBRACE Ident EQ COLON Attr ARROW ]
## par(non_const_ctor_irrefutable) -> LPAR . non_const_ctor_irrefutable RPAR [ WILD UIdent LPAR LBRACE Ident EQ COLON Attr ARROW ]
## unit -> LPAR . RPAR [ WILD UIdent LPAR LBRACE Ident EQ COLON Attr ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR
##

Ill-formed value declaration.
At this point, one of the following is expected:
  * the keyword 'type' followed by type parameters, e.g., '(type a
    b)';
  * a closing parenthesis ')' if matching the unit value;
  * a parameter as an irrefutable pattern followed by a closing
    parenthesis ')'.

contract: Let UIdent LPAR ZWSP
##
## Ends in an error in state: 234.
##
## par(__anonymous_7) -> LPAR . Type nseq(variable) RPAR [ EQ COLON ]
##
## The known suffix of the stack is as follows:
## LPAR
##

Ill-formed polymorphic function declaration or expression.
At this point, the keyword 'type' followed by type parameters, e.g.,
'(type a b)'.

contract: Let Ident COLON LPAR With
##
## Ends in an error in state: 28.
##
## par(tuple(type_expr)) -> LPAR . tuple(type_expr) RPAR [ UIdent Ident ]
## par(type_expr) -> LPAR . type_expr RPAR [ VBAR UIdent Type TIMES SEMI RPAR RBRACE Module Let In Ident End EQ EOF Directive COMMA Attr ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR
##

Ill-formed parenthesised expression or tuple expression.
At this point, an expression is expected.
Note: Tuples of expressions do not require in general to be
parenthesised, but parentheses often improve readability.

contract: Let Ident LPAR Type Ident RPAR Ident EQ With
##
## Ends in an error in state: 1007.
##
## fun_decl -> var_pattern par(__anonymous_7) parameters EQ . expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## var_pattern par(__anonymous_7) parameters EQ
##
contract: Let Ident LPAR Type Ident RPAR Ident COLON Ident EQ With
##
## Ends in an error in state: 1010.
##
## fun_decl -> var_pattern par(__anonymous_7) parameters type_annotation(type_expr) EQ . expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## var_pattern par(__anonymous_7) parameters type_annotation(type_expr) EQ
##

Ill-formed function declaration.
At this point, the body of the function is expected as an expression.

interactive_expr: Fun WILD LPAR RPAR With
##
## Ends in an error in state: 247.
##
## nseq(core_irrefutable) -> unit . [ EQ COLON ARROW ]
## nseq(core_irrefutable) -> unit . nseq(core_irrefutable) [ EQ COLON ARROW ]
##
## The known suffix of the stack is as follows:
## unit
##
interactive_expr: Fun LBRACE Ident RBRACE With
##
## Ends in an error in state: 248.
##
## nseq(core_irrefutable) -> record_pattern(irrefutable) . [ EQ COLON ARROW ]
## nseq(core_irrefutable) -> record_pattern(irrefutable) . nseq(core_irrefutable) [ EQ COLON ARROW ]
##
## The known suffix of the stack is as follows:
## record_pattern(irrefutable)
##
interactive_expr: Fun LPAR WILD RPAR With
##
## Ends in an error in state: 249.
##
## nseq(core_irrefutable) -> par(in_core_irrefutable) . [ EQ COLON ARROW ]
## nseq(core_irrefutable) -> par(in_core_irrefutable) . nseq(core_irrefutable) [ EQ COLON ARROW ]
##
## The known suffix of the stack is as follows:
## par(in_core_irrefutable)
##
interactive_expr: Fun UIdent With
##
## Ends in an error in state: 251.
##
## nseq(core_irrefutable) -> ctor_irrefutable . [ EQ COLON ARROW ]
## nseq(core_irrefutable) -> ctor_irrefutable . nseq(core_irrefutable) [ EQ COLON ARROW ]
##
## The known suffix of the stack is as follows:
## ctor_irrefutable
##

Ill-formed function parameters.
At this point, one of the following is expected:
  * another parameter as an irrefutable pattern, e.g a variable;
  * a type annotation starting with a colon ':' for the body;
  * the assignment symbol '=' followed by an expression.

interactive_expr: Match UIdent With VBAR With
##
## Ends in an error in state: 981.
##
## match_expr(base_cond) -> Match expr With VBAR . cases(base_cond) [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Match expr With VBAR
##
interactive_expr: Match UIdent With UIdent ARROW UIdent VBAR With
##
## Ends in an error in state: 985.
##
## cases(base_cond) -> cases(base_cond) VBAR . match_clause(base_cond) [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## cases(base_cond) VBAR
##
interactive_expr: Begin Match UIdent With UIdent ARROW UIdent VBAR With
##
## Ends in an error in state: 897.
##
## cases(base_cond) -> cases(base_cond) VBAR . match_clause(base_cond) [ VBAR ]
## cases(last_expr) -> cases(base_cond) VBAR . match_clause(last_expr) [ End ]
##
## The known suffix of the stack is as follows:
## cases(base_cond) VBAR
##
interactive_expr: If UIdent Then Match UIdent With UIdent ARROW UIdent VBAR With
##
## Ends in an error in state: 590.
##
## cases(base_cond) -> cases(base_cond) VBAR . match_clause(base_cond) [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## cases(base_if_then_else) -> cases(base_cond) VBAR . match_clause(base_if_then_else) [ Else ]
##
## The known suffix of the stack is as follows:
## cases(base_cond) VBAR
##
interactive_expr: If UIdent Then Match UIdent With VBAR With
##
## Ends in an error in state: 453.
##
## match_expr(base_cond) -> Match expr With VBAR . cases(base_cond) [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## match_expr(base_if_then_else) -> Match expr With VBAR . cases(base_if_then_else) [ Else ]
##
## The known suffix of the stack is as follows:
## Match expr With VBAR
##
interactive_expr: Begin Match UIdent With VBAR With
##
## Ends in an error in state: 783.
##
## match_expr(last_expr) -> Match expr With VBAR . cases(last_expr) [ End ]
##
## The known suffix of the stack is as follows:
## Match expr With VBAR
##
interactive_expr: Begin If UIdent Then Match UIdent With VBAR With
##
## Ends in an error in state: 585.
##
## match_expr(base_if_then_else) -> Match expr With VBAR . cases(base_if_then_else) [ Else ]
##
## The known suffix of the stack is as follows:
## Match expr With VBAR
##

Ill-formed pattern matching.
At this point, a case is expected to start with a pattern.

interactive_expr: Match UIdent With UIdent CONS With
##
## Ends in an error in state: 502.
##
## cons_pattern_level -> core_pattern CONS . cons_pattern_level [ SEMI RPAR RBRACKET COMMA COLON ARROW ]
##
## The known suffix of the stack is as follows:
## core_pattern CONS
##

Ill-formed list pattern.
At this point, a pattern that matches as list is expected.

interactive_expr: Match UIdent With LBRACKET UIdent SEMI With
##
## Ends in an error in state: 533.
##
## nsepseq(cons_pattern_level,SEMI) -> cons_pattern_level SEMI . nsepseq(cons_pattern_level,SEMI) [ RBRACKET ]
## nseq(__anonymous_0(cons_pattern_level,SEMI)) -> cons_pattern_level SEMI . [ RBRACKET ]
## nseq(__anonymous_0(cons_pattern_level,SEMI)) -> cons_pattern_level SEMI . nseq(__anonymous_0(cons_pattern_level,SEMI)) [ RBRACKET ]
##
## The known suffix of the stack is as follows:
## cons_pattern_level SEMI
##

Ill-formed list of patterns.
At this point, one of the following is expected:
  * a list element as a pattern;
  * a closing bracket ']' if the list is complete.

contract: Attr With
##
## Ends in an error in state: 1016.
##
## attr_decl -> Attr . declaration [ Type Module Let End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## Attr
##
interactive_expr: Attr With
##
## Ends in an error in state: 280.
##
## core_expr -> Attr . core_expr [ With Verbatim VBAR UIdent Type Then TIMES String SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Lxor Lsr Lsl Lor Let Lang Land LT LPAR LE LBRACKET LBRACE Int In Ident GT End Else EQ EOF Directive CONS COMMA COLON CARET Bytes Begin BOOL_OR BOOL_AND Attr ]
## nseq(Attr) -> Attr . [ Type Module Match Let If Fun ]
## nseq(Attr) -> Attr . nseq(Attr) [ Type Module Match Let If Fun ]
##
## The known suffix of the stack is as follows:
## Attr
##

Ill-formed attributed expression.
At this point, if the attributes are complete, one of the following is
expected:
  * a functional expression starting with the keyword 'fun';
  * a local value declaration starting with the keyword 'let'.

interactive_expr: Fun Ident With
##
## Ends in an error in state: 246.
##
## nseq(core_irrefutable) -> var_pattern . [ EQ COLON ARROW ]
## nseq(core_irrefutable) -> var_pattern . nseq(core_irrefutable) [ EQ COLON ARROW ]
##
## The known suffix of the stack is as follows:
## var_pattern
##

Ill-formed functional expression.
At this point, one of the following is expected:
  * a parameter as an irrefutable pattern, e.g. a variable;
  * an arrow '->' followed by the body as an expression.

interactive_expr: Match UIdent With UIdent ARROW If UIdent Then Type Ident EQ Ident In With
##
## Ends in an error in state: 606.
##
## local_type_decl(base_cond) -> type_decl In . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## local_type_decl(closed_expr) -> type_decl In . closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## type_decl In
##
interactive_expr: If UIdent Then Type Ident EQ Ident In With
##
## Ends in an error in state: 759.
##
## local_type_decl(closed_expr) -> type_decl In . closed_expr [ Else ]
## local_type_decl(expr) -> type_decl In . expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## type_decl In
##
#
#interactive_expr: Match UIdent With UIdent ARROW If UIdent Then Type Ident EQ Ident In With
interactive_expr: If UIdent Then Match UIdent With UIdent ARROW Type Ident EQ Ident In With
##
## Ends in an error in state: 711.
##
## local_type_decl(base_cond) -> type_decl In . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## local_type_decl(base_if_then_else) -> type_decl In . base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## type_decl In
##
interactive_expr: Type Ident EQ Ident In With
##
## Ends in an error in state: 332.
##
## local_type_decl(expr) -> type_decl In . expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## type_decl In
##
interactive_expr: Match UIdent With UIdent ARROW Type Ident EQ Ident In With
##
## Ends in an error in state: 647.
##
## local_type_decl(base_cond) -> type_decl In . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## type_decl In
##
interactive_expr: Begin If UIdent Then Type Ident EQ Ident In With
##
## Ends in an error in state: 831.
##
## local_type_decl(closed_expr) -> type_decl In . closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## type_decl In
##

Ill-formed local type declaration.
At this point, an expression is expected.

interactive_expr: LBRACE Ident With Attr Ident EQ ZWSP
##
## Ends in an error in state: 935.
##
## field_path_assignment -> nseq(Attr) path field_lens . expr [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) path field_lens
##
interactive_expr: LBRACE Ident With Ident EQ With
##
## Ends in an error in state: 930.
##
## field_path_assignment -> path field_lens . expr [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## path field_lens
##

Ill-formed record update.
At this point, the expression assigned to the field is expected.

interactive_expr: LBRACKET UIdent SEMI With
##
## Ends in an error in state: 957.
##
## nsepseq(expr,SEMI) -> expr SEMI . nsepseq(expr,SEMI) [ RBRACKET ]
## nseq(__anonymous_0(expr,SEMI)) -> expr SEMI . [ RBRACKET ]
## nseq(__anonymous_0(expr,SEMI)) -> expr SEMI . nseq(__anonymous_0(expr,SEMI)) [ RBRACKET ]
##
## The known suffix of the stack is as follows:
## expr SEMI
##

Ill-formed list of expressions.
At this point, one of the following is expected:
  * a list element as an expression;
  * a closing bracket ']' if the list is complete.

contract: Let Ident COLON UIdent Of Attr With
##
## Ends in an error in state: 84.
##
## core_type -> Attr . core_type [ VBAR Type TIMES SEMI RPAR RBRACE Module Let In End EQ EOF Directive COMMA Attr ARROW ]
##
## The known suffix of the stack is as follows:
## Attr
##

Ill-formed record type.
At this point, if the attribute is complete, an opening brace '{' is
expected.

contract: Type QUOTE Ident Ident With
##
## Ends in an error in state: 18.
##
## type_decl -> Type type_vars type_name . EQ type_expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## Type type_vars type_name
##
contract: Type Ident With
##
## Ends in an error in state: 117.
##
## type_decl -> Type type_name . EQ type_expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## Type type_name
##

Ill-formed type declaration.
At this point, the assignment symbol '=' is expected, followed by a
type expression.

contract: Type QUOTE Ident Ident EQ With
##
## Ends in an error in state: 19.
##
## type_decl -> Type type_vars type_name EQ . type_expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## Type type_vars type_name EQ
##
contract: Type Ident EQ With
##
## Ends in an error in state: 118.
##
## type_decl -> Type type_name EQ . type_expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## Type type_name EQ
##

Ill-formed type declaration.
At this point, a type expression is expected.

interactive_expr: Fun Ident COLON VBAR Attr With
##
## Ends in an error in state: 260.
##
## short_variant(cartesian_level) -> Attr . short_variant(cartesian_level) [ VBAR ARROW ]
##
## The known suffix of the stack is as follows:
## Attr
##
contract: Let UIdent COLON VBAR Attr ZWSP
##
## Ends in an error in state: 22.
##
## short_variant(fun_type_level) -> Attr . short_variant(fun_type_level) [ VBAR Type SEMI RPAR RBRACE Module Let In End EQ EOF Directive COMMA Attr ]
##
## The known suffix of the stack is as follows:
## Attr
##

Ill-formed variant.
At this point, if the attributes of the variant are complete, a data
constructor is expected.

contract: Let Ident COLON Attr With
##
## Ends in an error in state: 44.
##
## core_type -> Attr . core_type [ Type TIMES SEMI RPAR RBRACE Module Let In End EQ EOF Directive COMMA Attr ARROW ]
## nseq(Attr) -> Attr . [ VBAR ]
## nseq(Attr) -> Attr . nseq(Attr) [ VBAR ]
## short_variant(fun_type_level) -> Attr . short_variant(fun_type_level) [ VBAR Type SEMI RPAR RBRACE Module Let In End EQ EOF Directive COMMA Attr ]
##
## The known suffix of the stack is as follows:
## Attr
##
interactive_expr: Fun Ident COLON Attr With
##
## Ends in an error in state: 267.
##
## core_type -> Attr . core_type [ TIMES ARROW ]
## nseq(Attr) -> Attr . [ VBAR ]
## nseq(Attr) -> Attr . nseq(Attr) [ VBAR ]
## short_variant(cartesian_level) -> Attr . short_variant(cartesian_level) [ VBAR ARROW ]
##
## The known suffix of the stack is as follows:
## Attr
##

Ill-formed attributed sum type or record type.
At this point, if the attributes are complete, one of the following is
expected:
  * an opening brace '{' followed by field declarations, if defining a
    record type;
  * a variant starting with a value constructor, if defining a sum
    type (the attributes then apply to the variant, not the type);
  * a vertical bar followed by a variant (the attributes then apply to
    the sum type, not the variant).

interactive_expr: Fun LBRACE Ident EQ UIdent With
##
## Ends in an error in state: 190.
##
## field_pattern(irrefutable) -> field_name EQ ctor_irrefutable . [ SEMI RBRACE ]
## tuple(core_irrefutable) -> ctor_irrefutable . COMMA nsepseq(core_irrefutable,COMMA) [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## field_name EQ ctor_irrefutable
##
contract: Let LBRACE Ident EQ Ident With
##
## Ends in an error in state: 185.
##
## field_pattern(irrefutable) -> field_name EQ var_pattern . [ SEMI RBRACE ]
## tuple(core_irrefutable) -> var_pattern . COMMA nsepseq(core_irrefutable,COMMA) [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## field_name EQ var_pattern
##
contract: Let LBRACE Ident EQ LPAR RPAR With
##
## Ends in an error in state: 186.
##
## field_pattern(irrefutable) -> field_name EQ unit . [ SEMI RBRACE ]
## tuple(core_irrefutable) -> unit . COMMA nsepseq(core_irrefutable,COMMA) [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## field_name EQ unit
##
contract: Let LBRACE Ident EQ LBRACE Ident RBRACE With
##
## Ends in an error in state: 188.
##
## field_pattern(irrefutable) -> field_name EQ record_pattern(irrefutable) . [ SEMI RBRACE ]
## tuple(core_irrefutable) -> record_pattern(irrefutable) . COMMA nsepseq(core_irrefutable,COMMA) [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## field_name EQ record_pattern(irrefutable)
##
contract: Let LBRACE Ident EQ LPAR WILD RPAR With
##
## Ends in an error in state: 189.
##
## field_pattern(irrefutable) -> field_name EQ par(in_core_irrefutable) . [ SEMI RBRACE ]
## tuple(core_irrefutable) -> par(in_core_irrefutable) . COMMA nsepseq(core_irrefutable,COMMA) [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## field_name EQ par(in_core_irrefutable)
##

Ill-formed record pattern.
At this point, one of the following is expected:
  * a comma ',' followed by a tuple component as a pattern, if the
    field is a tuple;
  * a semicolon ';' if the field is punned (that is, a variable with
    the same name is implicitly the pattern);
  * a closing brace '}' if the record pattern is complete.

contract: Let LPAR Ident With
##
## Ends in an error in state: 191.
##
## in_core_irrefutable -> var_pattern . [ RPAR ]
## tuple(core_irrefutable) -> var_pattern . COMMA nsepseq(core_irrefutable,COMMA) [ RPAR COLON ]
## typed_irrefutable -> var_pattern . type_annotation(type_expr) [ RPAR ]
##
## The known suffix of the stack is as follows:
## var_pattern
##
contract: Let LPAR LPAR RPAR With
##
## Ends in an error in state: 193.
##
## in_core_irrefutable -> unit . [ RPAR ]
## tuple(core_irrefutable) -> unit . COMMA nsepseq(core_irrefutable,COMMA) [ RPAR COLON ]
## typed_irrefutable -> unit . type_annotation(type_expr) [ RPAR ]
##
## The known suffix of the stack is as follows:
## unit
##
contract: Let LPAR LBRACE Ident RBRACE With
##
## Ends in an error in state: 198.
##
## in_core_irrefutable -> record_pattern(irrefutable) . [ RPAR ]
## tuple(core_irrefutable) -> record_pattern(irrefutable) . COMMA nsepseq(core_irrefutable,COMMA) [ RPAR COLON ]
## typed_irrefutable -> record_pattern(irrefutable) . type_annotation(type_expr) [ RPAR ]
##
## The known suffix of the stack is as follows:
## record_pattern(irrefutable)
##
contract: Let LPAR LPAR WILD RPAR With
##
## Ends in an error in state: 200.
##
## in_core_irrefutable -> par(in_core_irrefutable) . [ RPAR ]
## tuple(core_irrefutable) -> par(in_core_irrefutable) . COMMA nsepseq(core_irrefutable,COMMA) [ RPAR COLON ]
## typed_irrefutable -> par(in_core_irrefutable) . type_annotation(type_expr) [ RPAR ]
##
## The known suffix of the stack is as follows:
## par(in_core_irrefutable)
##
contract: Let LPAR UIdent With
##
## Ends in an error in state: 208.
##
## const_ctor_pattern -> ctor . [ RPAR COMMA COLON ]
## non_const_ctor_irrefutable -> ctor . unit [ RPAR ]
## non_const_ctor_irrefutable -> ctor . record_pattern(irrefutable) [ RPAR ]
## non_const_ctor_irrefutable -> ctor . par(in_core_irrefutable) [ RPAR ]
## non_const_ctor_irrefutable -> ctor . var_pattern [ RPAR ]
## non_const_ctor_irrefutable -> ctor . ctor_irrefutable [ RPAR ]
##
## The known suffix of the stack is as follows:
## ctor
##

Ill-formed pattern.
At this point, one of the following is expected:
  * a closing parenthesis ')', if the pattern is complete;
  * a comma ',' followed by another component as a pattern, if
    defining a tuple pattern;
  * a type annotation starting with ':'.

contract: Let Ident With
##
## Ends in an error in state: 214.
##
## fun_decl -> var_pattern . parameters EQ expr [ Type Module Let In End EOF Directive Attr ]
## fun_decl -> var_pattern . parameters type_annotation(type_expr) EQ expr [ Type Module Let In End EOF Directive Attr ]
## fun_decl -> var_pattern . par(__anonymous_7) parameters EQ expr [ Type Module Let In End EOF Directive Attr ]
## fun_decl -> var_pattern . par(__anonymous_7) parameters type_annotation(type_expr) EQ expr [ Type Module Let In End EOF Directive Attr ]
## non_fun_decl -> var_pattern . EQ expr [ Type Module Let In End EOF Directive Attr ]
## non_fun_decl -> var_pattern . type_annotation(type_expr) EQ expr [ Type Module Let In End EOF Directive Attr ]
## non_fun_decl -> var_pattern . par(__anonymous_7) EQ expr [ Type Module Let In End EOF Directive Attr ]
## non_fun_decl -> var_pattern . par(__anonymous_7) type_annotation(type_expr) EQ expr [ Type Module Let In End EOF Directive Attr ]
## tuple(core_irrefutable) -> var_pattern . COMMA nsepseq(core_irrefutable,COMMA) [ LPAR EQ COLON ]
##
## The known suffix of the stack is as follows:
## var_pattern
##

Ill-formed value declaration.
At this point, one of the following is expected:
  * parameters as irrefutable patterns, e.g. variables, if defining a
    function;
  * the assignment symbol '=' followed by an expression;
  * a type annotation starting with a colon ':';
  * a comma ',' followed by another tuple component, if defining a
    tuple.

contract: Let LPAR RPAR LPAR Type Ident RPAR With
##
## Ends in an error in state: 964.
##
## non_fun_decl -> unit par(__anonymous_7) . EQ expr [ Type Module Let In End EOF Directive Attr ]
## non_fun_decl -> unit par(__anonymous_7) . type_annotation(type_expr) EQ expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## unit par(__anonymous_7)
##
contract: Let WILD COMMA Ident LPAR Type Ident RPAR With
##
## Ends in an error in state: 546.
##
## non_fun_decl -> tuple(core_irrefutable) par(__anonymous_7) . EQ expr [ Type Module Let In End EOF Directive Attr ]
## non_fun_decl -> tuple(core_irrefutable) par(__anonymous_7) . type_annotation(type_expr) EQ expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## tuple(core_irrefutable) par(__anonymous_7)
##
contract: Let LBRACE Ident RBRACE LPAR Type Ident RPAR With
##
## Ends in an error in state: 558.
##
## non_fun_decl -> record_pattern(irrefutable) par(__anonymous_7) . EQ expr [ Type Module Let In End EOF Directive Attr ]
## non_fun_decl -> record_pattern(irrefutable) par(__anonymous_7) . type_annotation(type_expr) EQ expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## record_pattern(irrefutable) par(__anonymous_7)
##
contract: Let LPAR WILD RPAR LPAR Type Ident RPAR With
##
## Ends in an error in state: 570.
##
## non_fun_decl -> par(in_core_irrefutable) par(__anonymous_7) . EQ expr [ Type Module Let In End EOF Directive Attr ]
## non_fun_decl -> par(in_core_irrefutable) par(__anonymous_7) . type_annotation(type_expr) EQ expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## par(in_core_irrefutable) par(__anonymous_7)
##
contract: Let UIdent LPAR Type Ident RPAR With
##
## Ends in an error in state: 674.
##
## non_fun_decl -> ctor_irrefutable par(__anonymous_7) . EQ expr [ Type Module Let In End EOF Directive Attr ]
## non_fun_decl -> ctor_irrefutable par(__anonymous_7) . type_annotation(type_expr) EQ expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## ctor_irrefutable par(__anonymous_7)
##
contract: Let WILD LPAR Type Ident RPAR With
##
## Ends in an error in state: 1000.
##
## fun_decl -> var_pattern par(__anonymous_7) . parameters EQ expr [ Type Module Let In End EOF Directive Attr ]
## fun_decl -> var_pattern par(__anonymous_7) . parameters type_annotation(type_expr) EQ expr [ Type Module Let In End EOF Directive Attr ]
## non_fun_decl -> var_pattern par(__anonymous_7) . EQ expr [ Type Module Let In End EOF Directive Attr ]
## non_fun_decl -> var_pattern par(__anonymous_7) . type_annotation(type_expr) EQ expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## var_pattern par(__anonymous_7)
##

Ill-formed value declaration.
At this point, one of the following is expected:
  * parameters if defining a function;
  * the assignment symbol '=' followed by an expression;
  * a type annotation starting with a colon ':'.

contract: Let Ident LPAR Type Ident RPAR WILD ARROW
##
## Ends in an error in state: 1006.
##
## fun_decl -> var_pattern par(__anonymous_7) parameters . EQ expr [ Type Module Let In End EOF Directive Attr ]
## fun_decl -> var_pattern par(__anonymous_7) parameters . type_annotation(type_expr) EQ expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## var_pattern par(__anonymous_7) parameters
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 246, spurious reduction of production nseq(core_irrefutable) -> var_pattern
## In state 1012, spurious reduction of production parameters -> nseq(core_irrefutable)
##
contract: Let Ident WILD ARROW
##
## Ends in an error in state: 994.
##
## fun_decl -> var_pattern parameters . EQ expr [ Type Module Let In End EOF Directive Attr ]
## fun_decl -> var_pattern parameters . type_annotation(type_expr) EQ expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## var_pattern parameters
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 246, spurious reduction of production nseq(core_irrefutable) -> var_pattern
## In state 1012, spurious reduction of production parameters -> nseq(core_irrefutable)
##

Ill-formed function declaration.
At this point, if there are no more parameters, one of the following
is expected:
  * the assignment symbol '=' followed by an expression;
  * a type annotation starting with a colon ':'.

contract: Let LBRACE Ident RBRACE With
##
## Ends in an error in state: 552.
##
## non_fun_decl -> record_pattern(irrefutable) . EQ expr [ Type Module Let In End EOF Directive Attr ]
## non_fun_decl -> record_pattern(irrefutable) . type_annotation(type_expr) EQ expr [ Type Module Let In End EOF Directive Attr ]
## non_fun_decl -> record_pattern(irrefutable) . par(__anonymous_7) EQ expr [ Type Module Let In End EOF Directive Attr ]
## non_fun_decl -> record_pattern(irrefutable) . par(__anonymous_7) type_annotation(type_expr) EQ expr [ Type Module Let In End EOF Directive Attr ]
## tuple(core_irrefutable) -> record_pattern(irrefutable) . COMMA nsepseq(core_irrefutable,COMMA) [ LPAR EQ COLON ]
##
## The known suffix of the stack is as follows:
## record_pattern(irrefutable)
##
contract: Let LPAR WILD RPAR With
##
## Ends in an error in state: 564.
##
## non_fun_decl -> par(in_core_irrefutable) . EQ expr [ Type Module Let In End EOF Directive Attr ]
## non_fun_decl -> par(in_core_irrefutable) . type_annotation(type_expr) EQ expr [ Type Module Let In End EOF Directive Attr ]
## non_fun_decl -> par(in_core_irrefutable) . par(__anonymous_7) EQ expr [ Type Module Let In End EOF Directive Attr ]
## non_fun_decl -> par(in_core_irrefutable) . par(__anonymous_7) type_annotation(type_expr) EQ expr [ Type Module Let In End EOF Directive Attr ]
## tuple(core_irrefutable) -> par(in_core_irrefutable) . COMMA nsepseq(core_irrefutable,COMMA) [ LPAR EQ COLON ]
##
## The known suffix of the stack is as follows:
## par(in_core_irrefutable)
##
contract: Let UIdent With
##
## Ends in an error in state: 668.
##
## non_fun_decl -> ctor_irrefutable . EQ expr [ Type Module Let In End EOF Directive Attr ]
## non_fun_decl -> ctor_irrefutable . type_annotation(type_expr) EQ expr [ Type Module Let In End EOF Directive Attr ]
## non_fun_decl -> ctor_irrefutable . par(__anonymous_7) EQ expr [ Type Module Let In End EOF Directive Attr ]
## non_fun_decl -> ctor_irrefutable . par(__anonymous_7) type_annotation(type_expr) EQ expr [ Type Module Let In End EOF Directive Attr ]
## tuple(core_irrefutable) -> ctor_irrefutable . COMMA nsepseq(core_irrefutable,COMMA) [ LPAR EQ COLON ]
##
## The known suffix of the stack is as follows:
## ctor_irrefutable
##
contract: Let LPAR RPAR With
##
## Ends in an error in state: 233.
##
## non_fun_decl -> unit . EQ expr [ Type Module Let In End EOF Directive Attr ]
## non_fun_decl -> unit . type_annotation(type_expr) EQ expr [ Type Module Let In End EOF Directive Attr ]
## non_fun_decl -> unit . par(__anonymous_7) EQ expr [ Type Module Let In End EOF Directive Attr ]
## non_fun_decl -> unit . par(__anonymous_7) type_annotation(type_expr) EQ expr [ Type Module Let In End EOF Directive Attr ]
## tuple(core_irrefutable) -> unit . COMMA nsepseq(core_irrefutable,COMMA) [ LPAR EQ COLON ]
##
## The known suffix of the stack is as follows:
## unit
##

Ill-formed value declaration.
At this point, one of the following is expected:
  * a comma ',' followed by another component as a pattern, if
    defining a tuple;
  * the assignment symbol '=' followed by an expression;
  * a type annotation starting with a colon ':';
  * type parameters between parentheses, e.g. '(type a b)'.

interactive_expr: Begin If Ident Then Fun LPAR Type Ident RPAR UIdent EQ
##
## Ends in an error in state: 828.
##
## fun_expr(closed_expr) -> Fun par(__anonymous_7) nseq(core_irrefutable) . ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> Fun par(__anonymous_7) nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Fun par(__anonymous_7) nseq(core_irrefutable)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 251, spurious reduction of production nseq(core_irrefutable) -> ctor_irrefutable
##
interactive_expr: Begin Fun LPAR Type Ident RPAR WILD EQ
##
## Ends in an error in state: 852.
##
## fun_expr(last_expr) -> Fun par(__anonymous_7) nseq(core_irrefutable) . ARROW last_expr [ End ]
## fun_expr(last_expr) -> Fun par(__anonymous_7) nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW last_expr [ End ]
##
## The known suffix of the stack is as follows:
## Fun par(__anonymous_7) nseq(core_irrefutable)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 246, spurious reduction of production nseq(core_irrefutable) -> var_pattern
##
interactive_expr: Begin Fun WILD EQ
##
## Ends in an error in state: 872.
##
## fun_expr(last_expr) -> Fun nseq(core_irrefutable) . ARROW last_expr [ End ]
## fun_expr(last_expr) -> Fun nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW last_expr [ End ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 246, spurious reduction of production nseq(core_irrefutable) -> var_pattern
##
interactive_expr: Begin If Verbatim Then Fun WILD EQ
##
## Ends in an error in state: 839.
##
## fun_expr(closed_expr) -> Fun nseq(core_irrefutable) . ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> Fun nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 246, spurious reduction of production nseq(core_irrefutable) -> var_pattern
##
interactive_expr: Begin Match Verbatim With WILD ARROW Fun LPAR Type Ident RPAR WILD EQ
##
## Ends in an error in state: 800.
##
## fun_expr(base_cond) -> Fun par(__anonymous_7) nseq(core_irrefutable) . ARROW base_cond [ VBAR ]
## fun_expr(base_cond) -> Fun par(__anonymous_7) nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW base_cond [ VBAR ]
## fun_expr(last_expr) -> Fun par(__anonymous_7) nseq(core_irrefutable) . ARROW last_expr [ End ]
## fun_expr(last_expr) -> Fun par(__anonymous_7) nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW last_expr [ End ]
##
## The known suffix of the stack is as follows:
## Fun par(__anonymous_7) nseq(core_irrefutable)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 246, spurious reduction of production nseq(core_irrefutable) -> var_pattern
##
interactive_expr: Begin Match Verbatim With WILD ARROW Fun WILD EQ
##
## Ends in an error in state: 887.
##
## fun_expr(base_cond) -> Fun nseq(core_irrefutable) . ARROW base_cond [ VBAR ]
## fun_expr(base_cond) -> Fun nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW base_cond [ VBAR ]
## fun_expr(last_expr) -> Fun nseq(core_irrefutable) . ARROW last_expr [ End ]
## fun_expr(last_expr) -> Fun nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW last_expr [ End ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 246, spurious reduction of production nseq(core_irrefutable) -> var_pattern
##
interactive_expr: Fun LPAR Type Ident RPAR WILD EQ
##
## Ends in an error in state: 257.
##
## fun_expr(expr) -> Fun par(__anonymous_7) nseq(core_irrefutable) . ARROW expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(expr) -> Fun par(__anonymous_7) nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun par(__anonymous_7) nseq(core_irrefutable)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 246, spurious reduction of production nseq(core_irrefutable) -> var_pattern
##
interactive_expr: Fun WILD EQ
##
## Ends in an error in state: 440.
##
## fun_expr(expr) -> Fun nseq(core_irrefutable) . ARROW expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(expr) -> Fun nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 246, spurious reduction of production nseq(core_irrefutable) -> var_pattern
##
interactive_expr: If Verbatim Then Fun LPAR Type Ident RPAR WILD EQ
##
## Ends in an error in state: 756.
##
## fun_expr(closed_expr) -> Fun par(__anonymous_7) nseq(core_irrefutable) . ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> Fun par(__anonymous_7) nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW closed_expr [ Else ]
## fun_expr(expr) -> Fun par(__anonymous_7) nseq(core_irrefutable) . ARROW expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(expr) -> Fun par(__anonymous_7) nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun par(__anonymous_7) nseq(core_irrefutable)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 246, spurious reduction of production nseq(core_irrefutable) -> var_pattern
##
interactive_expr: If Verbatim Then Fun WILD EQ
##
## Ends in an error in state: 767.
##
## fun_expr(closed_expr) -> Fun nseq(core_irrefutable) . ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> Fun nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW closed_expr [ Else ]
## fun_expr(expr) -> Fun nseq(core_irrefutable) . ARROW expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(expr) -> Fun nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 246, spurious reduction of production nseq(core_irrefutable) -> var_pattern
##
interactive_expr: If Verbatim Then Match Verbatim With WILD ARROW Fun LPAR Type Ident RPAR WILD EQ
##
## Ends in an error in state: 708.
##
## fun_expr(base_cond) -> Fun par(__anonymous_7) nseq(core_irrefutable) . ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_cond) -> Fun par(__anonymous_7) nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_if_then_else) -> Fun par(__anonymous_7) nseq(core_irrefutable) . ARROW base_if_then_else [ Else ]
## fun_expr(base_if_then_else) -> Fun par(__anonymous_7) nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## Fun par(__anonymous_7) nseq(core_irrefutable)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 246, spurious reduction of production nseq(core_irrefutable) -> var_pattern
##
interactive_expr: If Verbatim Then Match Verbatim With WILD ARROW Fun WILD EQ
##
## Ends in an error in state: 732.
##
## fun_expr(base_cond) -> Fun nseq(core_irrefutable) . ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_cond) -> Fun nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_if_then_else) -> Fun nseq(core_irrefutable) . ARROW base_if_then_else [ Else ]
## fun_expr(base_if_then_else) -> Fun nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 246, spurious reduction of production nseq(core_irrefutable) -> var_pattern
##
interactive_expr: Match Verbatim With WILD ARROW Fun LPAR Type Ident RPAR WILD EQ
##
## Ends in an error in state: 644.
##
## fun_expr(base_cond) -> Fun par(__anonymous_7) nseq(core_irrefutable) . ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_cond) -> Fun par(__anonymous_7) nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun par(__anonymous_7) nseq(core_irrefutable)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 246, spurious reduction of production nseq(core_irrefutable) -> var_pattern
##
interactive_expr: Match Verbatim With WILD ARROW Fun WILD EQ
##
## Ends in an error in state: 660.
##
## fun_expr(base_cond) -> Fun nseq(core_irrefutable) . ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_cond) -> Fun nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 246, spurious reduction of production nseq(core_irrefutable) -> var_pattern
##
interactive_expr: Match Verbatim With WILD ARROW If Verbatim Then Fun LPAR Type Ident RPAR WILD EQ
##
## Ends in an error in state: 603.
##
## fun_expr(base_cond) -> Fun par(__anonymous_7) nseq(core_irrefutable) . ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_cond) -> Fun par(__anonymous_7) nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(closed_expr) -> Fun par(__anonymous_7) nseq(core_irrefutable) . ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> Fun par(__anonymous_7) nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Fun par(__anonymous_7) nseq(core_irrefutable)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 246, spurious reduction of production nseq(core_irrefutable) -> var_pattern
##
interactive_expr: Match Verbatim With WILD ARROW If Verbatim Then Fun WILD EQ
##
## Ends in an error in state: 691.
##
## fun_expr(base_cond) -> Fun nseq(core_irrefutable) . ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_cond) -> Fun nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(closed_expr) -> Fun nseq(core_irrefutable) . ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> Fun nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 246, spurious reduction of production nseq(core_irrefutable) -> var_pattern
##

Ill-formed functional expression.
At this point, if there are no more parameters, one of the following
is expected:
  * an arrow '->', followed by the function body as an expression;
  * a type annotation for the body, starting with a colon ':'.

interactive_expr: Bytes GT ZWSP ZWSP
##
## Ends in an error in state: 394.
##
## ge -> GT ZWSP . EQ [ Verbatim UIdent String Not Nat Mutez MINUS Lang LPAR LBRACKET LBRACE Int Ident Bytes Begin Attr ]
##
## The known suffix of the stack is as follows:
## GT ZWSP
##

This syntax error should not happen. Please report to the developpers.

contract: Let UIdent COLON UIdent DOT LPAR ZWSP
##
## Ends in an error in state: 69.
##
## par(type_expr) -> LPAR . type_expr RPAR [ VBAR UIdent Type TIMES SEMI RPAR RBRACE Module Let In Ident End EQ EOF Directive COMMA Attr ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR
##

Ill-formed parenthesised type expression.
At this point, a type expression is expected.

contract: Let UIdent COLON Ident UIdent ZWSP
##
## Ends in an error in state: 53.
##
## module_path(__anonymous_4) -> module_name . DOT module_path(__anonymous_4) [ VBAR UIdent Type TIMES SEMI RPAR RBRACE Module Let In Ident End EQ EOF Directive COMMA Attr ARROW ]
## module_path(__anonymous_4) -> module_name . DOT type_ctor [ VBAR UIdent Type TIMES SEMI RPAR RBRACE Module Let In Ident End EQ EOF Directive COMMA Attr ARROW ]
##
## The known suffix of the stack is as follows:
## module_name
##

Ill-formed selection of a type constructor in a module.
At this point, the selection symbol '.' is expected.

contract: Let UIdent COLON Ident UIdent DOT ZWSP
##
## Ends in an error in state: 54.
##
## module_path(__anonymous_4) -> module_name DOT . module_path(__anonymous_4) [ VBAR UIdent Type TIMES SEMI RPAR RBRACE Module Let In Ident End EQ EOF Directive COMMA Attr ARROW ]
## module_path(__anonymous_4) -> module_name DOT . type_ctor [ VBAR UIdent Type TIMES SEMI RPAR RBRACE Module Let In Ident End EQ EOF Directive COMMA Attr ARROW ]
##
## The known suffix of the stack is as follows:
## module_name DOT
##

Ill-formed selection of a type constructor in a module.
At this point, one of the following is expected:
  * a type constructor;
  * a module name, if not fully qualified.

contract: Let UIdent COLON UIdent DOT LPAR Ident VBAR
##
## Ends in an error in state: 71.
##
## par(type_expr) -> LPAR type_expr . RPAR [ VBAR UIdent Type TIMES SEMI RPAR RBRACE Module Let In Ident End EQ EOF Directive COMMA Attr ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR type_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 64, spurious reduction of production core_type -> no_attr_type
## In state 82, spurious reduction of production cartesian_level -> core_type
## In state 91, spurious reduction of production fun_type_level -> cartesian_level
## In state 81, spurious reduction of production type_expr -> fun_type_level
##

Ill-formed parenthesised type expression.
At this point, if the type expression is complete, a closing
parenthesis ')' is expected.

contract: Let LBRACE Attr Ident ZWSP
##
## Ends in an error in state: 137.
##
## field_pattern(irrefutable) -> nseq(Attr) field_name . [ SEMI RBRACE ]
## field_pattern(irrefutable) -> nseq(Attr) field_name . EQ tuple(core_irrefutable) [ SEMI RBRACE ]
## field_pattern(irrefutable) -> nseq(Attr) field_name . EQ unit [ SEMI RBRACE ]
## field_pattern(irrefutable) -> nseq(Attr) field_name . EQ record_pattern(irrefutable) [ SEMI RBRACE ]
## field_pattern(irrefutable) -> nseq(Attr) field_name . EQ par(in_core_irrefutable) [ SEMI RBRACE ]
## field_pattern(irrefutable) -> nseq(Attr) field_name . EQ var_pattern [ SEMI RBRACE ]
## field_pattern(irrefutable) -> nseq(Attr) field_name . EQ ctor_irrefutable [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) field_name
##

Ill-formed record pattern.
At this point, one of the following is expected:
  * the assignment symbol '=' followed by a pattern;
  * a semicolon ';' if punning the field;
  * a closing brace '}' if punning the field and the record pattern is
    complete.

contract: Let LBRACE Attr Ident EQ ZWSP
##
## Ends in an error in state: 138.
##
## field_pattern(irrefutable) -> nseq(Attr) field_name EQ . tuple(core_irrefutable) [ SEMI RBRACE ]
## field_pattern(irrefutable) -> nseq(Attr) field_name EQ . unit [ SEMI RBRACE ]
## field_pattern(irrefutable) -> nseq(Attr) field_name EQ . record_pattern(irrefutable) [ SEMI RBRACE ]
## field_pattern(irrefutable) -> nseq(Attr) field_name EQ . par(in_core_irrefutable) [ SEMI RBRACE ]
## field_pattern(irrefutable) -> nseq(Attr) field_name EQ . var_pattern [ SEMI RBRACE ]
## field_pattern(irrefutable) -> nseq(Attr) field_name EQ . ctor_irrefutable [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) field_name EQ
##

Ill-formed record pattern.
At this point, a pattern that matches the field is expected.

contract: Let LBRACE Attr Ident EQ Ident ZWSP
##
## Ends in an error in state: 142.
##
## field_pattern(irrefutable) -> nseq(Attr) field_name EQ var_pattern . [ SEMI RBRACE ]
## tuple(core_irrefutable) -> var_pattern . COMMA nsepseq(core_irrefutable,COMMA) [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) field_name EQ var_pattern
##
contract: Let LBRACE Attr Ident EQ LPAR RPAR ZWSP
##
## Ends in an error in state: 165.
##
## field_pattern(irrefutable) -> nseq(Attr) field_name EQ unit . [ SEMI RBRACE ]
## tuple(core_irrefutable) -> unit . COMMA nsepseq(core_irrefutable,COMMA) [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) field_name EQ unit
##
contract: Let LBRACE Attr Ident EQ LBRACE RBRACE ZWSP
##
## Ends in an error in state: 169.
##
## field_pattern(irrefutable) -> nseq(Attr) field_name EQ record_pattern(irrefutable) . [ SEMI RBRACE ]
## tuple(core_irrefutable) -> record_pattern(irrefutable) . COMMA nsepseq(core_irrefutable,COMMA) [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) field_name EQ record_pattern(irrefutable)
##
contract: Let LBRACE Attr Ident EQ LPAR UIdent RPAR ZWSP
##
## Ends in an error in state: 172.
##
## field_pattern(irrefutable) -> nseq(Attr) field_name EQ par(in_core_irrefutable) . [ SEMI RBRACE ]
## tuple(core_irrefutable) -> par(in_core_irrefutable) . COMMA nsepseq(core_irrefutable,COMMA) [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) field_name EQ par(in_core_irrefutable)
##
contract: Let LBRACE Attr Ident EQ UIdent ZWSP
##
## Ends in an error in state: 175.
##
## field_pattern(irrefutable) -> nseq(Attr) field_name EQ ctor_irrefutable . [ SEMI RBRACE ]
## tuple(core_irrefutable) -> ctor_irrefutable . COMMA nsepseq(core_irrefutable,COMMA) [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) field_name EQ ctor_irrefutable
##

Ill-formed record pattern.
At this point, one of the following is expected:
  * a semicolon ';' if the current field pattern is complete;
  * a comma ',' is the right-hand side of the field pattern is a
    tuple;
  * a closing brace '}' if the record pattern is complete.

interactive_expr: Match Ident With LBRACE Attr Ident EQ ZWSP
##
## Ends in an error in state: 467.
##
## field_pattern(core_pattern) -> nseq(Attr) field_name EQ . core_pattern [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) field_name EQ
##

Ill-formed record pattern.
At this point, the right-hand side of the field pattern is expected.

contract: Let LPAR LPAR UIdent UIdent RPAR ZWSP
##
## Ends in an error in state: 206.
##
## in_core_irrefutable -> ctor_irrefutable . [ RPAR ]
## tuple(core_irrefutable) -> ctor_irrefutable . COMMA nsepseq(core_irrefutable,COMMA) [ RPAR COLON ]
## typed_irrefutable -> ctor_irrefutable . type_annotation(type_expr) [ RPAR ]
##
## The known suffix of the stack is as follows:
## ctor_irrefutable
##

Ill-formed parenthesised pattern.
At this point, one of the following is expected:
  * a closing parenthesis ')' if the pattern is complete;
  * a comma ',' if defining a tuple pattern;
  * a colon ':' if annotating the pattern with a type expression.

interactive_expr: Fun UIdent COLON VBAR UIdent ZWSP
##
## Ends in an error in state: 262.
##
## short_variant(cartesian_level) -> ctor . [ VBAR ARROW ]
## short_variant(cartesian_level) -> ctor . of_type(cartesian_level) [ VBAR ARROW ]
##
## The known suffix of the stack is as follows:
## ctor
##

Ill-formed variant type.
At this point, one of the following is expected:
  * a vertical bar '|' if the constructor is constant;
  * the keyword 'of' followed by the type of the variant;
  * the arrow '->' followed by the codomain as a type expression.

interactive_expr: Fun UIdent COLON UIdent Of Ident Type
##
## Ends in an error in state: 269.
##
## variant_type(cartesian_level) -> short_variant(cartesian_level) . [ ARROW ]
## variant_type(cartesian_level) -> short_variant(cartesian_level) . long_variants(cartesian_level) [ ARROW ]
##
## The known suffix of the stack is as follows:
## short_variant(cartesian_level)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 64, spurious reduction of production core_type -> no_attr_type
## In state 82, spurious reduction of production cartesian_level -> core_type
## In state 264, spurious reduction of production of_type(cartesian_level) -> Of cartesian_level
## In state 265, spurious reduction of production short_variant(cartesian_level) -> ctor of_type(cartesian_level)
##
#
#interactive_expr: Fun UIdent COLON VBAR UIdent VBAR UIdent Of Ident Type
interactive_expr: Fun UIdent COLON VBAR UIdent Of Ident ZWSP
##
## Ends in an error in state: 272.
##
## nseq(long_variant(cartesian_level)) -> long_variant(cartesian_level) . [ ARROW ]
## nseq(long_variant(cartesian_level)) -> long_variant(cartesian_level) . nseq(long_variant(cartesian_level)) [ ARROW ]
##
## The known suffix of the stack is as follows:
## long_variant(cartesian_level)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 64, spurious reduction of production core_type -> no_attr_type
## In state 82, spurious reduction of production cartesian_level -> core_type
## In state 264, spurious reduction of production of_type(cartesian_level) -> Of cartesian_level
## In state 265, spurious reduction of production short_variant(cartesian_level) -> ctor of_type(cartesian_level)
## In state 266, spurious reduction of production long_variant(cartesian_level) -> VBAR short_variant(cartesian_level)
##

Ill-formed type expression.
At this point, if the variant is complete, one of the following is
expected:
  * a vertical bar '|' followed by another variant;
  * an arrow '->' if the parameter of the constructor has a function
    type.

interactive_expr: LBRACE Ident With Ident DOT ZWSP
##
## Ends in an error in state: 919.
##
## projection -> record_or_tuple DOT . nsepseq(selection,DOT) [ VBAR_EQ TIMES_EQ SLASH_EQ PLUS_EQ MINUS_EQ EQ ]
##
## The known suffix of the stack is as follows:
## record_or_tuple DOT
##
interactive_expr: LPAR Ident RPAR DOT ZWSP
##
## Ends in an error in state: 298.
##
## local_path -> par(expr) DOT . nsepseq(selection,DOT) [ With Verbatim VBAR UIdent Type Then TIMES String SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Lxor Lsr Lsl Lor Let Lang Land LT LPAR LE LBRACKET LBRACE Int In Ident GT End Else EQ EOF Directive CONS COMMA COLON CARET Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## par(expr) DOT
##

Ill-formed selection in a record or a tuple.
At this point, one of the following is expected:
  * the name of a record field;
  * the index of a component in a tuple, '0' denoting the first
    component.

interactive_expr: MINUS Attr ZWSP
##
## Ends in an error in state: 309.
##
## core_expr -> Attr . core_expr [ With Verbatim VBAR UIdent Type Then TIMES String SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Lxor Lsr Lsl Lor Let Lang Land LT LPAR LE LBRACKET LBRACE Int In Ident GT End Else EQ EOF Directive CONS COMMA COLON CARET Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## Attr
##

Ill-formed attributed expression.
At this point, an expression is expected.

interactive_expr: Ident Bytes ZWSP
##
## Ends in an error in state: 1042.
##
## interactive_expr -> expr . EOF [ # ]
##
## The known suffix of the stack is as follows:
## expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 322, spurious reduction of production nseq(no_attr_expr) -> no_attr_expr
## In state 321, spurious reduction of production arguments -> nseq(no_attr_expr)
## In state 324, spurious reduction of production app_expr -> core_expr arguments
## In state 328, spurious reduction of production app_expr_level -> app_expr
## In state 327, spurious reduction of production unary_expr_level -> app_expr_level
## In state 307, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 335, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 341, spurious reduction of production add_expr_level -> mult_expr_level
## In state 377, spurious reduction of production cons_expr_level -> add_expr_level
## In state 364, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 401, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 408, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 417, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 362, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 424, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 425, spurious reduction of production expr -> base_cond__open(expr)
##

Ill-formed expression.
At this point, if the expression is complete, the end of the input is
expected.

interactive_expr: Type Ident EQ Ident Type
##
## Ends in an error in state: 331.
##
## local_type_decl(expr) -> type_decl . In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## type_decl
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 64, spurious reduction of production core_type -> no_attr_type
## In state 82, spurious reduction of production cartesian_level -> core_type
## In state 91, spurious reduction of production fun_type_level -> cartesian_level
## In state 81, spurious reduction of production type_expr -> fun_type_level
## In state 119, spurious reduction of production type_decl -> Type type_name EQ type_expr
##
interactive_expr: Match Ident With UIdent ARROW If Ident Then Type Ident EQ Ident Type
##
## Ends in an error in state: 605.
##
## local_type_decl(base_cond) -> type_decl . In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## local_type_decl(closed_expr) -> type_decl . In closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## type_decl
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 64, spurious reduction of production core_type -> no_attr_type
## In state 82, spurious reduction of production cartesian_level -> core_type
## In state 91, spurious reduction of production fun_type_level -> cartesian_level
## In state 81, spurious reduction of production type_expr -> fun_type_level
## In state 119, spurious reduction of production type_decl -> Type type_name EQ type_expr
##
interactive_expr: Match Ident With UIdent ARROW Type Ident EQ Ident Type
##
## Ends in an error in state: 646.
##
## local_type_decl(base_cond) -> type_decl . In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## type_decl
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 64, spurious reduction of production core_type -> no_attr_type
## In state 82, spurious reduction of production cartesian_level -> core_type
## In state 91, spurious reduction of production fun_type_level -> cartesian_level
## In state 81, spurious reduction of production type_expr -> fun_type_level
## In state 119, spurious reduction of production type_decl -> Type type_name EQ type_expr
##
interactive_expr: If Ident Then Match Ident With UIdent ARROW Type Ident EQ Ident Type
##
## Ends in an error in state: 710.
##
## local_type_decl(base_cond) -> type_decl . In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## local_type_decl(base_if_then_else) -> type_decl . In base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## type_decl
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 64, spurious reduction of production core_type -> no_attr_type
## In state 82, spurious reduction of production cartesian_level -> core_type
## In state 91, spurious reduction of production fun_type_level -> cartesian_level
## In state 81, spurious reduction of production type_expr -> fun_type_level
## In state 119, spurious reduction of production type_decl -> Type type_name EQ type_expr
##
interactive_expr: Begin If Ident Then Type Ident EQ Ident Type
##
## Ends in an error in state: 830.
##
## local_type_decl(closed_expr) -> type_decl . In closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## type_decl
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 64, spurious reduction of production core_type -> no_attr_type
## In state 82, spurious reduction of production cartesian_level -> core_type
## In state 91, spurious reduction of production fun_type_level -> cartesian_level
## In state 81, spurious reduction of production type_expr -> fun_type_level
## In state 119, spurious reduction of production type_decl -> Type type_name EQ type_expr
##
interactive_expr: If Ident Then Type Ident EQ Ident Type
##
## Ends in an error in state: 758.
##
## local_type_decl(closed_expr) -> type_decl . In closed_expr [ Else ]
## local_type_decl(expr) -> type_decl . In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## type_decl
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 64, spurious reduction of production core_type -> no_attr_type
## In state 82, spurious reduction of production cartesian_level -> core_type
## In state 91, spurious reduction of production fun_type_level -> cartesian_level
## In state 81, spurious reduction of production type_expr -> fun_type_level
## In state 119, spurious reduction of production type_decl -> Type type_name EQ type_expr
##

Ill-formed local type declaration.
At this point, if the type expression is complete, the keyword 'in' is
expected, followed by an expression.

interactive_expr: Match Ident With Attr ZWSP
##
## Ends in an error in state: 470.
##
## attr_pattern -> Attr . core_pattern [ SEMI RPAR RBRACKET RBRACE CONS COMMA COLON ARROW ]
##
## The known suffix of the stack is as follows:
## Attr
##

Ill-formed attributed pattern.
At this point, a pattern is expected.

interactive_expr: Match Ident With LPAR UIdent ARROW
##
## Ends in an error in state: 489.
##
## par(__anonymous_8) -> LPAR pattern . RPAR [ SEMI RPAR RBRACKET RBRACE CONS COMMA COLON ARROW ]
## typed_pattern -> pattern . type_annotation(type_expr) [ RPAR ]
##
## The known suffix of the stack is as follows:
## LPAR pattern
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 29, spurious reduction of production ctor -> UIdent
## In state 496, spurious reduction of production ctor_app_pattern -> ctor
## In state 495, spurious reduction of production core_pattern -> ctor_app_pattern
## In state 501, spurious reduction of production cons_pattern_level -> core_pattern
## In state 504, spurious reduction of production pattern -> cons_pattern_level
##
contract: Let LPAR UIdent COLON Ident Type
##
## Ends in an error in state: 204.
##
## par(in_core_irrefutable) -> LPAR in_core_irrefutable . RPAR [ WILD UIdent SEMI RPAR RBRACE LPAR LBRACE Ident EQ COMMA COLON Attr ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR in_core_irrefutable
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 64, spurious reduction of production core_type -> no_attr_type
## In state 82, spurious reduction of production cartesian_level -> core_type
## In state 91, spurious reduction of production fun_type_level -> cartesian_level
## In state 81, spurious reduction of production type_expr -> fun_type_level
## In state 98, spurious reduction of production type_annotation(type_expr) -> COLON type_expr
## In state 207, spurious reduction of production typed_irrefutable -> ctor_irrefutable type_annotation(type_expr)
## In state 195, spurious reduction of production in_core_irrefutable -> typed_irrefutable
##

Ill-formed parenthesised pattern,
At this point, if the pattern is complete, a closing parenthesis ')'
is expected.

interactive_expr: Match Ident With LPAR UIdent COLON Ident Type
##
## Ends in an error in state: 486.
##
## par(__anonymous_8) -> LPAR typed_pattern . RPAR [ SEMI RPAR RBRACKET RBRACE CONS COMMA COLON ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR typed_pattern
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 64, spurious reduction of production core_type -> no_attr_type
## In state 82, spurious reduction of production cartesian_level -> core_type
## In state 91, spurious reduction of production fun_type_level -> cartesian_level
## In state 81, spurious reduction of production type_expr -> fun_type_level
## In state 98, spurious reduction of production type_annotation(type_expr) -> COLON type_expr
## In state 491, spurious reduction of production typed_pattern -> pattern type_annotation(type_expr)
##

Ill-formed parenthesised pattern.
At this point, if the type annotation is complete, a closing
parenthesis ')' is expected.

interactive_expr: Match Ident With UIdent DOT ZWSP
##
## Ends in an error in state: 484.
##
## module_path(__anonymous_10) -> module_name DOT . module_path(__anonymous_10) [ SEMI RPAR RBRACKET RBRACE CONS COMMA COLON ARROW ]
## module_path(__anonymous_10) -> module_name DOT . variable [ SEMI RPAR RBRACKET RBRACE CONS COMMA COLON ARROW ]
## module_path(__anonymous_11) -> module_name DOT . module_path(__anonymous_11) [ SEMI RPAR RBRACKET RBRACE CONS COMMA COLON ARROW ]
## module_path(__anonymous_11) -> module_name DOT . in_pattern [ SEMI RPAR RBRACKET RBRACE CONS COMMA COLON ARROW ]
## module_path(__anonymous_9) -> module_name DOT . module_path(__anonymous_9) [ WILD Verbatim UIdent String Nat Mutez LPAR LBRACKET LBRACE Int Ident Bytes Attr ]
## module_path(__anonymous_9) -> module_name DOT . ctor [ WILD Verbatim UIdent String Nat Mutez LPAR LBRACKET LBRACE Int Ident Bytes Attr ]
##
## The known suffix of the stack is as follows:
## module_name DOT
##

Ill-formed qualified pattern.
At this point, one of the following is expected:
  * a (sub)module name;
  * a variable;
  * a parenthesised pattern;
  * a data constructor.

interactive_expr: Match Ident With UIdent DOT UIdent ZWSP
##
## Ends in an error in state: 476.
##
## qualified_pattern -> pattern_in_module(__anonymous_9) . core_pattern [ SEMI RPAR RBRACKET RBRACE CONS COMMA COLON ARROW ]
##
## The known suffix of the stack is as follows:
## pattern_in_module(__anonymous_9)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 29, spurious reduction of production ctor -> UIdent
## In state 515, spurious reduction of production module_path(__anonymous_9) -> module_name DOT ctor
## In state 480, spurious reduction of production pattern_in_module(__anonymous_9) -> module_path(__anonymous_9)
##

Ill-formed qualified pattern.
At this point, a pattern is expected.

interactive_expr: Match Ident With UIdent DOT LPAR ZWSP
##
## Ends in an error in state: 485.
##
## par(__anonymous_8) -> LPAR . pattern RPAR [ SEMI RPAR RBRACKET RBRACE CONS COMMA COLON ARROW ]
## par(__anonymous_8) -> LPAR . typed_pattern RPAR [ SEMI RPAR RBRACKET RBRACE CONS COMMA COLON ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR
##

Ill-formed parenthesised pattern.
At this point, a pattern is expected.

contract: Let UIdent COMMA UIdent SEMI
##
## Ends in an error in state: 540.
##
## non_fun_decl -> tuple(core_irrefutable) . EQ expr [ Type Module Let In End EOF Directive Attr ]
## non_fun_decl -> tuple(core_irrefutable) . type_annotation(type_expr) EQ expr [ Type Module Let In End EOF Directive Attr ]
## non_fun_decl -> tuple(core_irrefutable) . par(__anonymous_7) EQ expr [ Type Module Let In End EOF Directive Attr ]
## non_fun_decl -> tuple(core_irrefutable) . par(__anonymous_7) type_annotation(type_expr) EQ expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## tuple(core_irrefutable)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 155, spurious reduction of production nsepseq(core_irrefutable,COMMA) -> ctor_irrefutable
## In state 177, spurious reduction of production tuple(core_irrefutable) -> ctor_irrefutable COMMA nsepseq(core_irrefutable,COMMA)
##

Ill-formed value declaration.
At this point, if the irrefutable pattern is complete, one of the
following is expected:
  * the assignment symbol '=' followed by an expression;
  * a colon ':' followed by a type expression;
  * type parameters between parentheses, like '(type a b)'.

contract: Let Ident WILD COLON String VBAR
##
## Ends in an error in state: 997.
##
## fun_decl -> var_pattern parameters type_annotation(type_expr) . EQ expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## var_pattern parameters type_annotation(type_expr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 64, spurious reduction of production core_type -> no_attr_type
## In state 82, spurious reduction of production cartesian_level -> core_type
## In state 91, spurious reduction of production fun_type_level -> cartesian_level
## In state 81, spurious reduction of production type_expr -> fun_type_level
## In state 98, spurious reduction of production type_annotation(type_expr) -> COLON type_expr
##
contract: Let Ident LPAR Type Ident RPAR UIdent COLON Ident Type
##
## Ends in an error in state: 1009.
##
## fun_decl -> var_pattern par(__anonymous_7) parameters type_annotation(type_expr) . EQ expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## var_pattern par(__anonymous_7) parameters type_annotation(type_expr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 64, spurious reduction of production core_type -> no_attr_type
## In state 82, spurious reduction of production cartesian_level -> core_type
## In state 91, spurious reduction of production fun_type_level -> cartesian_level
## In state 81, spurious reduction of production type_expr -> fun_type_level
## In state 98, spurious reduction of production type_annotation(type_expr) -> COLON type_expr
##

Ill-formed function declaration.
At this point, if the type annotation is complete, the assignment
symbol '=' is expected, followed by the function body as an
expression.

contract: Let WILD COLON Ident VBAR
##
## Ends in an error in state: 991.
##
## non_fun_decl -> var_pattern type_annotation(type_expr) . EQ expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## var_pattern type_annotation(type_expr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 64, spurious reduction of production core_type -> no_attr_type
## In state 82, spurious reduction of production cartesian_level -> core_type
## In state 91, spurious reduction of production fun_type_level -> cartesian_level
## In state 81, spurious reduction of production type_expr -> fun_type_level
## In state 98, spurious reduction of production type_annotation(type_expr) -> COLON type_expr
##
contract: Let UIdent COMMA UIdent COLON Ident Type
##
## Ends in an error in state: 543.
##
## non_fun_decl -> tuple(core_irrefutable) type_annotation(type_expr) . EQ expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## tuple(core_irrefutable) type_annotation(type_expr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 64, spurious reduction of production core_type -> no_attr_type
## In state 82, spurious reduction of production cartesian_level -> core_type
## In state 91, spurious reduction of production fun_type_level -> cartesian_level
## In state 81, spurious reduction of production type_expr -> fun_type_level
## In state 98, spurious reduction of production type_annotation(type_expr) -> COLON type_expr
##
contract: Let UIdent COMMA UIdent LPAR Type Ident RPAR COLON Ident Type
##
## Ends in an error in state: 549.
##
## non_fun_decl -> tuple(core_irrefutable) par(__anonymous_7) type_annotation(type_expr) . EQ expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## tuple(core_irrefutable) par(__anonymous_7) type_annotation(type_expr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 64, spurious reduction of production core_type -> no_attr_type
## In state 82, spurious reduction of production cartesian_level -> core_type
## In state 91, spurious reduction of production fun_type_level -> cartesian_level
## In state 81, spurious reduction of production type_expr -> fun_type_level
## In state 98, spurious reduction of production type_annotation(type_expr) -> COLON type_expr
##
contract: Let LBRACE RBRACE COLON Ident Type
##
## Ends in an error in state: 555.
##
## non_fun_decl -> record_pattern(irrefutable) type_annotation(type_expr) . EQ expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## record_pattern(irrefutable) type_annotation(type_expr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 64, spurious reduction of production core_type -> no_attr_type
## In state 82, spurious reduction of production cartesian_level -> core_type
## In state 91, spurious reduction of production fun_type_level -> cartesian_level
## In state 81, spurious reduction of production type_expr -> fun_type_level
## In state 98, spurious reduction of production type_annotation(type_expr) -> COLON type_expr
##
contract: Let LBRACE RBRACE LPAR Type Ident RPAR COLON Ident Type
##
## Ends in an error in state: 561.
##
## non_fun_decl -> record_pattern(irrefutable) par(__anonymous_7) type_annotation(type_expr) . EQ expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## record_pattern(irrefutable) par(__anonymous_7) type_annotation(type_expr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 64, spurious reduction of production core_type -> no_attr_type
## In state 82, spurious reduction of production cartesian_level -> core_type
## In state 91, spurious reduction of production fun_type_level -> cartesian_level
## In state 81, spurious reduction of production type_expr -> fun_type_level
## In state 98, spurious reduction of production type_annotation(type_expr) -> COLON type_expr
##
contract: Let LPAR UIdent RPAR COLON Ident Type
##
## Ends in an error in state: 567.
##
## non_fun_decl -> par(in_core_irrefutable) type_annotation(type_expr) . EQ expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## par(in_core_irrefutable) type_annotation(type_expr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 64, spurious reduction of production core_type -> no_attr_type
## In state 82, spurious reduction of production cartesian_level -> core_type
## In state 91, spurious reduction of production fun_type_level -> cartesian_level
## In state 81, spurious reduction of production type_expr -> fun_type_level
## In state 98, spurious reduction of production type_annotation(type_expr) -> COLON type_expr
##
contract: Let LPAR UIdent RPAR LPAR Type Ident RPAR COLON Ident Type
##
## Ends in an error in state: 573.
##
## non_fun_decl -> par(in_core_irrefutable) par(__anonymous_7) type_annotation(type_expr) . EQ expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## par(in_core_irrefutable) par(__anonymous_7) type_annotation(type_expr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 64, spurious reduction of production core_type -> no_attr_type
## In state 82, spurious reduction of production cartesian_level -> core_type
## In state 91, spurious reduction of production fun_type_level -> cartesian_level
## In state 81, spurious reduction of production type_expr -> fun_type_level
## In state 98, spurious reduction of production type_annotation(type_expr) -> COLON type_expr
##
contract: Let UIdent COLON Ident Type
##
## Ends in an error in state: 671.
##
## non_fun_decl -> ctor_irrefutable type_annotation(type_expr) . EQ expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## ctor_irrefutable type_annotation(type_expr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 64, spurious reduction of production core_type -> no_attr_type
## In state 82, spurious reduction of production cartesian_level -> core_type
## In state 91, spurious reduction of production fun_type_level -> cartesian_level
## In state 81, spurious reduction of production type_expr -> fun_type_level
## In state 98, spurious reduction of production type_annotation(type_expr) -> COLON type_expr
##
contract: Let UIdent LPAR Type Ident RPAR COLON Ident Type
##
## Ends in an error in state: 677.
##
## non_fun_decl -> ctor_irrefutable par(__anonymous_7) type_annotation(type_expr) . EQ expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## ctor_irrefutable par(__anonymous_7) type_annotation(type_expr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 64, spurious reduction of production core_type -> no_attr_type
## In state 82, spurious reduction of production cartesian_level -> core_type
## In state 91, spurious reduction of production fun_type_level -> cartesian_level
## In state 81, spurious reduction of production type_expr -> fun_type_level
## In state 98, spurious reduction of production type_annotation(type_expr) -> COLON type_expr
##
contract: Let LPAR RPAR COLON Ident Type
##
## Ends in an error in state: 961.
##
## non_fun_decl -> unit type_annotation(type_expr) . EQ expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## unit type_annotation(type_expr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 64, spurious reduction of production core_type -> no_attr_type
## In state 82, spurious reduction of production cartesian_level -> core_type
## In state 91, spurious reduction of production fun_type_level -> cartesian_level
## In state 81, spurious reduction of production type_expr -> fun_type_level
## In state 98, spurious reduction of production type_annotation(type_expr) -> COLON type_expr
##
contract: Let LPAR RPAR LPAR Type Ident RPAR COLON Ident Type
##
## Ends in an error in state: 967.
##
## non_fun_decl -> unit par(__anonymous_7) type_annotation(type_expr) . EQ expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## unit par(__anonymous_7) type_annotation(type_expr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 64, spurious reduction of production core_type -> no_attr_type
## In state 82, spurious reduction of production cartesian_level -> core_type
## In state 91, spurious reduction of production fun_type_level -> cartesian_level
## In state 81, spurious reduction of production type_expr -> fun_type_level
## In state 98, spurious reduction of production type_annotation(type_expr) -> COLON type_expr
##
contract: Let Ident LPAR Type Ident RPAR COLON Ident Type
##
## Ends in an error in state: 1003.
##
## non_fun_decl -> var_pattern par(__anonymous_7) type_annotation(type_expr) . EQ expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## var_pattern par(__anonymous_7) type_annotation(type_expr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 64, spurious reduction of production core_type -> no_attr_type
## In state 82, spurious reduction of production cartesian_level -> core_type
## In state 91, spurious reduction of production fun_type_level -> cartesian_level
## In state 81, spurious reduction of production type_expr -> fun_type_level
## In state 98, spurious reduction of production type_annotation(type_expr) -> COLON type_expr
##

Ill-formed value declaration.
At this point, if the type annotation is complete, the assignment
symbol '=' is expected, followed by an expression.

interactive_expr: Match Ident With UIdent ARROW If Ident Then Attr Match
##
## Ends in an error in state: 610.
##
## base_cond__open(base_cond) -> nseq(Attr) . conditional(base_cond) [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## base_expr(base_cond) -> nseq(Attr) . right_opened_expr(base_cond) [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## base_expr(closed_expr) -> nseq(Attr) . right_opened_expr(closed_expr) [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 280, spurious reduction of production nseq(Attr) -> Attr
##
interactive_expr: Match Ident With UIdent ARROW Attr Match
##
## Ends in an error in state: 649.
##
## base_cond__open(base_cond) -> nseq(Attr) . conditional(base_cond) [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## base_expr(base_cond) -> nseq(Attr) . right_opened_expr(base_cond) [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 280, spurious reduction of production nseq(Attr) -> Attr
##
interactive_expr: If Ident Then Match Ident With UIdent ARROW Attr Match
##
## Ends in an error in state: 714.
##
## base_cond__open(base_cond) -> nseq(Attr) . conditional(base_cond) [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## base_expr(base_cond) -> nseq(Attr) . right_opened_expr(base_cond) [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## base_expr(base_if_then_else) -> nseq(Attr) . right_opened_expr(base_if_then_else) [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 280, spurious reduction of production nseq(Attr) -> Attr
##
interactive_expr: Begin Match Ident With UIdent ARROW Attr Match
##
## Ends in an error in state: 804.
##
## base_cond__open(base_cond) -> nseq(Attr) . conditional(base_cond) [ VBAR ]
## base_expr(base_cond) -> nseq(Attr) . right_opened_expr(base_cond) [ VBAR ]
## let_in_sequence -> nseq(Attr) . Let let_binding In series [ End ]
## let_in_sequence -> nseq(Attr) . Let Rec let_binding In series [ End ]
##
## The known suffix of the stack is as follows:
## nseq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 280, spurious reduction of production nseq(Attr) -> Attr
##

Ill-formed attributed expression.
At this point, if the attribute is complete, one of the follwing is
expected:
  * another attribute;
  * the keyword 'if' if declarating a conditional;
  * the keyword 'let' if declaring a local value;
  * the keyword 'type' if declaring a local type;
  * the keyword 'module' if declaring a local module;
  * the keyword 'fun' if defining a functional expression (a.k.a. lambdas).

interactive_expr: Begin If Ident Then Attr Match
##
## Ends in an error in state: 833.
##
## base_expr(closed_expr) -> nseq(Attr) . right_opened_expr(closed_expr) [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 280, spurious reduction of production nseq(Attr) -> Attr
##

Ill-formed attributed expression.
At this point, if the attribute is complete, one of the follwing is
expected:
  * another attribute;
  * the keyword 'let' if declaring a local value;
  * the keyword 'type' if declaring a local type;
  * the keyword 'module' if declaring a local module;
  * the keyword 'fun' if defining a functional expression (a.k.a. lambdas).

interactive_expr: Match Ident With UIdent ARROW Fun LPAR Type Ident RPAR UIdent COLON Ident VBAR
##
## Ends in an error in state: 657.
##
## fun_expr(base_cond) -> Fun par(__anonymous_7) nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun par(__anonymous_7) nseq(core_irrefutable) type_annotation(lambda_app_type)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 64, spurious reduction of production core_type -> no_attr_type
## In state 82, spurious reduction of production cartesian_level -> core_type
## In state 278, spurious reduction of production lambda_app_type -> cartesian_level
## In state 277, spurious reduction of production type_annotation(lambda_app_type) -> COLON lambda_app_type
##
interactive_expr: Fun LPAR Type Ident RPAR UIdent COLON Ident VBAR
##
## Ends in an error in state: 437.
##
## fun_expr(expr) -> Fun par(__anonymous_7) nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun par(__anonymous_7) nseq(core_irrefutable) type_annotation(lambda_app_type)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 64, spurious reduction of production core_type -> no_attr_type
## In state 82, spurious reduction of production cartesian_level -> core_type
## In state 278, spurious reduction of production lambda_app_type -> cartesian_level
## In state 277, spurious reduction of production type_annotation(lambda_app_type) -> COLON lambda_app_type
##
interactive_expr: Match Ident With UIdent ARROW Fun UIdent COLON Ident VBAR
##
## Ends in an error in state: 663.
##
## fun_expr(base_cond) -> Fun nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable) type_annotation(lambda_app_type)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 64, spurious reduction of production core_type -> no_attr_type
## In state 82, spurious reduction of production cartesian_level -> core_type
## In state 278, spurious reduction of production lambda_app_type -> cartesian_level
## In state 277, spurious reduction of production type_annotation(lambda_app_type) -> COLON lambda_app_type
##
interactive_expr: Match Ident With UIdent ARROW If Ident Then Fun LPAR Type Ident RPAR UIdent COLON Ident VBAR
##
## Ends in an error in state: 688.
##
## fun_expr(base_cond) -> Fun par(__anonymous_7) nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(closed_expr) -> Fun par(__anonymous_7) nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Fun par(__anonymous_7) nseq(core_irrefutable) type_annotation(lambda_app_type)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 64, spurious reduction of production core_type -> no_attr_type
## In state 82, spurious reduction of production cartesian_level -> core_type
## In state 278, spurious reduction of production lambda_app_type -> cartesian_level
## In state 277, spurious reduction of production type_annotation(lambda_app_type) -> COLON lambda_app_type
##
interactive_expr: Match Ident With UIdent ARROW If Ident Then Fun UIdent COLON Ident VBAR
##
## Ends in an error in state: 694.
##
## fun_expr(base_cond) -> Fun nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(closed_expr) -> Fun nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable) type_annotation(lambda_app_type)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 64, spurious reduction of production core_type -> no_attr_type
## In state 82, spurious reduction of production cartesian_level -> core_type
## In state 278, spurious reduction of production lambda_app_type -> cartesian_level
## In state 277, spurious reduction of production type_annotation(lambda_app_type) -> COLON lambda_app_type
##
interactive_expr: If Ident Then Match Ident With UIdent ARROW Fun LPAR Type Ident RPAR UIdent COLON Ident VBAR
##
## Ends in an error in state: 729.
##
## fun_expr(base_cond) -> Fun par(__anonymous_7) nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_if_then_else) -> Fun par(__anonymous_7) nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## Fun par(__anonymous_7) nseq(core_irrefutable) type_annotation(lambda_app_type)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 64, spurious reduction of production core_type -> no_attr_type
## In state 82, spurious reduction of production cartesian_level -> core_type
## In state 278, spurious reduction of production lambda_app_type -> cartesian_level
## In state 277, spurious reduction of production type_annotation(lambda_app_type) -> COLON lambda_app_type
##
interactive_expr: If Ident Then Match Ident With UIdent ARROW Fun UIdent COLON Ident VBAR
##
## Ends in an error in state: 735.
##
## fun_expr(base_cond) -> Fun nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_if_then_else) -> Fun nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable) type_annotation(lambda_app_type)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 64, spurious reduction of production core_type -> no_attr_type
## In state 82, spurious reduction of production cartesian_level -> core_type
## In state 278, spurious reduction of production lambda_app_type -> cartesian_level
## In state 277, spurious reduction of production type_annotation(lambda_app_type) -> COLON lambda_app_type
##
interactive_expr: Begin If Ident Then Fun LPAR Type Ident RPAR UIdent COLON Ident VBAR
##
## Ends in an error in state: 837.
##
## fun_expr(closed_expr) -> Fun par(__anonymous_7) nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Fun par(__anonymous_7) nseq(core_irrefutable) type_annotation(lambda_app_type)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 64, spurious reduction of production core_type -> no_attr_type
## In state 82, spurious reduction of production cartesian_level -> core_type
## In state 278, spurious reduction of production lambda_app_type -> cartesian_level
## In state 277, spurious reduction of production type_annotation(lambda_app_type) -> COLON lambda_app_type
##
interactive_expr: Begin If Ident Then Fun UIdent COLON Ident VBAR
##
## Ends in an error in state: 841.
##
## fun_expr(closed_expr) -> Fun nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable) type_annotation(lambda_app_type)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 64, spurious reduction of production core_type -> no_attr_type
## In state 82, spurious reduction of production cartesian_level -> core_type
## In state 278, spurious reduction of production lambda_app_type -> cartesian_level
## In state 277, spurious reduction of production type_annotation(lambda_app_type) -> COLON lambda_app_type
##
interactive_expr: Begin Match Ident With UIdent ARROW Fun LPAR Type Ident RPAR UIdent COLON Ident VBAR
##
## Ends in an error in state: 885.
##
## fun_expr(base_cond) -> Fun par(__anonymous_7) nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW base_cond [ VBAR ]
## fun_expr(last_expr) -> Fun par(__anonymous_7) nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW last_expr [ End ]
##
## The known suffix of the stack is as follows:
## Fun par(__anonymous_7) nseq(core_irrefutable) type_annotation(lambda_app_type)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 64, spurious reduction of production core_type -> no_attr_type
## In state 82, spurious reduction of production cartesian_level -> core_type
## In state 278, spurious reduction of production lambda_app_type -> cartesian_level
## In state 277, spurious reduction of production type_annotation(lambda_app_type) -> COLON lambda_app_type
##
interactive_expr: Begin Match Ident With UIdent ARROW Fun UIdent COLON Ident VBAR
##
## Ends in an error in state: 889.
##
## fun_expr(base_cond) -> Fun nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW base_cond [ VBAR ]
## fun_expr(last_expr) -> Fun nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW last_expr [ End ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable) type_annotation(lambda_app_type)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 64, spurious reduction of production core_type -> no_attr_type
## In state 82, spurious reduction of production cartesian_level -> core_type
## In state 278, spurious reduction of production lambda_app_type -> cartesian_level
## In state 277, spurious reduction of production type_annotation(lambda_app_type) -> COLON lambda_app_type
##
interactive_expr: Begin Fun LPAR Type Ident RPAR UIdent COLON Ident VBAR
##
## Ends in an error in state: 869.
##
## fun_expr(last_expr) -> Fun par(__anonymous_7) nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW last_expr [ End ]
##
## The known suffix of the stack is as follows:
## Fun par(__anonymous_7) nseq(core_irrefutable) type_annotation(lambda_app_type)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 64, spurious reduction of production core_type -> no_attr_type
## In state 82, spurious reduction of production cartesian_level -> core_type
## In state 278, spurious reduction of production lambda_app_type -> cartesian_level
## In state 277, spurious reduction of production type_annotation(lambda_app_type) -> COLON lambda_app_type
##
interactive_expr: Begin Fun UIdent COLON Ident VBAR
##
## Ends in an error in state: 875.
##
## fun_expr(last_expr) -> Fun nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW last_expr [ End ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable) type_annotation(lambda_app_type)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 64, spurious reduction of production core_type -> no_attr_type
## In state 82, spurious reduction of production cartesian_level -> core_type
## In state 278, spurious reduction of production lambda_app_type -> cartesian_level
## In state 277, spurious reduction of production type_annotation(lambda_app_type) -> COLON lambda_app_type
##
interactive_expr: Fun UIdent COLON Ident VBAR
##
## Ends in an error in state: 443.
##
## fun_expr(expr) -> Fun nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable) type_annotation(lambda_app_type)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 64, spurious reduction of production core_type -> no_attr_type
## In state 82, spurious reduction of production cartesian_level -> core_type
## In state 278, spurious reduction of production lambda_app_type -> cartesian_level
## In state 277, spurious reduction of production type_annotation(lambda_app_type) -> COLON lambda_app_type
##
interactive_expr: If Ident Then Fun LPAR Type Ident RPAR UIdent COLON Ident VBAR
##
## Ends in an error in state: 765.
##
## fun_expr(closed_expr) -> Fun par(__anonymous_7) nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW closed_expr [ Else ]
## fun_expr(expr) -> Fun par(__anonymous_7) nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun par(__anonymous_7) nseq(core_irrefutable) type_annotation(lambda_app_type)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 64, spurious reduction of production core_type -> no_attr_type
## In state 82, spurious reduction of production cartesian_level -> core_type
## In state 278, spurious reduction of production lambda_app_type -> cartesian_level
## In state 277, spurious reduction of production type_annotation(lambda_app_type) -> COLON lambda_app_type
##
interactive_expr: If Ident Then Fun UIdent COLON Ident VBAR
##
## Ends in an error in state: 769.
##
## fun_expr(closed_expr) -> Fun nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW closed_expr [ Else ]
## fun_expr(expr) -> Fun nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable) type_annotation(lambda_app_type)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 64, spurious reduction of production core_type -> no_attr_type
## In state 82, spurious reduction of production cartesian_level -> core_type
## In state 278, spurious reduction of production lambda_app_type -> cartesian_level
## In state 277, spurious reduction of production type_annotation(lambda_app_type) -> COLON lambda_app_type
##

Ill-formed functional expression.
At this point, if the return type is complete, an arrow '->' is
expected, followed by the body of the function as an expression.

interactive_expr: Begin Attr Type
##
## Ends in an error in state: 855.
##
## let_in_sequence -> nseq(Attr) . Let let_binding In series [ End ]
## let_in_sequence -> nseq(Attr) . Let Rec let_binding In series [ End ]
##
## The known suffix of the stack is as follows:
## nseq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 280, spurious reduction of production nseq(Attr) -> Attr
##

Ill-formed attributed local value declaration.
At this point, if the attribute is complete, one of the following is
expected:
  * another attribute;
  * the keyword 'let' to declare a local value.

interactive_expr: UIdent DOT LPAR Ident Type
##
## Ends in an error in state: 429.
##
## par(expr) -> LPAR expr . RPAR [ With Verbatim VBAR UIdent Type Then TIMES String SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Lxor Lsr Lsl Lor Let Lang Land LT LPAR LE LBRACKET LBRACE Int In Ident GT End Else EQ EOF Directive CONS COMMA COLON CARET Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## LPAR expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 244, spurious reduction of production variable -> Ident
## In state 281, spurious reduction of production field_path -> variable
## In state 312, spurious reduction of production local_path -> field_path
## In state 310, spurious reduction of production path_expr -> local_path
## In state 295, spurious reduction of production no_attr_expr -> path_expr
## In state 300, spurious reduction of production core_expr -> no_attr_expr
## In state 320, spurious reduction of production app_expr_level -> core_expr
## In state 327, spurious reduction of production unary_expr_level -> app_expr_level
## In state 307, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 335, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 341, spurious reduction of production add_expr_level -> mult_expr_level
## In state 377, spurious reduction of production cons_expr_level -> add_expr_level
## In state 364, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 401, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 408, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 417, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 362, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 424, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 425, spurious reduction of production expr -> base_cond__open(expr)
##

Ill-formed parenthesised expression.
At this point, if the expression is complete, a closing parenthesis
')' is expected.
