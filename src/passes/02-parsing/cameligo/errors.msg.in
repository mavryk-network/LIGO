interactive_expr: Begin Fun WILD ARROW Bytes SEMI
##
## Ends in an error in state: 872.
##
## sequence_expr -> Begin series . End [ With Verbatim VBAR UIdent Type Then TIMES String SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Lxor Lsr Lsl Lor Let Lang Land LT LPAR LE LBRACKET LBRACE Int In Ident GT End Else EQ EOF Directive CONS COMMA COLON CARET Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## Begin series
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 345, spurious reduction of production app_expr_level -> core_expr
## In state 354, spurious reduction of production unary_expr_level -> app_expr_level
## In state 341, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 362, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 368, spurious reduction of production add_expr_level -> mult_expr_level
## In state 404, spurious reduction of production cons_expr_level -> add_expr_level
## In state 391, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 428, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 435, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 444, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 836, spurious reduction of production seq_expr -> disj_expr_level
## In state 775, spurious reduction of production last_expr -> seq_expr
## In state 846, spurious reduction of production fun_expr(last_expr) -> Fun nseq(core_irrefutable) ARROW last_expr
## In state 835, spurious reduction of production last_expr -> fun_expr(last_expr)
## In state 834, spurious reduction of production series -> last_expr
##

Ill-formed sequence of expressions.
At this point, if the expression is complete, one of the following is
expected:
  * a semicolon ';' followed by another expression;
  * the keyword 'end' if the sequence is complete.

interactive_expr: Begin Match UIdent With UIdent ARROW If With
##
## Ends in an error in state: 590.
##
## if_then(base_cond) -> If . expr Then base_cond [ VBAR ]
## if_then_else(base_cond) -> If . expr Then closed_expr Else base_cond [ VBAR ]
## if_then_else(seq_expr) -> If . expr Then closed_expr Else seq_expr [ SEMI End ]
##
## The known suffix of the stack is as follows:
## If
##
interactive_expr: If With
##
## Ends in an error in state: 258.
##
## if_then(expr) -> If . expr Then expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## if_then_else(expr) -> If . expr Then closed_expr Else expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## If
##
interactive_expr: If UIdent Then If With
##
## Ends in an error in state: 895.
##
## if_then(expr) -> If . expr Then expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## if_then_else(closed_expr) -> If . expr Then closed_expr Else closed_expr [ Else ]
## if_then_else(expr) -> If . expr Then closed_expr Else expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## If
##
interactive_expr: Begin If UIdent Then If With
##
## Ends in an error in state: 795.
##
## if_then_else(closed_expr) -> If . expr Then closed_expr Else closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## If
##
interactive_expr: Begin If With
##
## Ends in an error in state: 788.
##
## if_then_else(seq_expr) -> If . expr Then closed_expr Else seq_expr [ SEMI End ]
##
## The known suffix of the stack is as follows:
## If
##
interactive_expr: Match UIdent With UIdent ARROW If With
##
## Ends in an error in state: 623.
##
## if_then(base_cond) -> If . expr Then base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## if_then_else(base_cond) -> If . expr Then closed_expr Else base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## If
##
interactive_expr: Match UIdent With UIdent ARROW If UIdent Then If With
##
## Ends in an error in state: 610.
##
## if_then(base_cond) -> If . expr Then base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## if_then_else(base_cond) -> If . expr Then closed_expr Else base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## if_then_else(closed_expr) -> If . expr Then closed_expr Else closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## If
##
interactive_expr: If UIdent Then Match UIdent With UIdent ARROW If With
##
## Ends in an error in state: 603.
##
## if_then(base_cond) -> If . expr Then base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## if_then_else(base_cond) -> If . expr Then closed_expr Else base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## if_then_else(base_if_then_else) -> If . expr Then closed_expr Else base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## If
##

Ill-formed conditional expression.
At this point, the condition is expected as an expression.

interactive_expr: If UIdent Then UIdent Else With
##
## Ends in an error in state: 924.
##
## if_then_else(expr) -> If expr Then closed_expr Else . expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## If expr Then closed_expr Else
##
interactive_expr: Begin If UIdent Then If UIdent Then UIdent Else With
##
## Ends in an error in state: 816.
##
## if_then_else(closed_expr) -> If expr Then closed_expr Else . closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## If expr Then closed_expr Else
##
interactive_expr: Match UIdent With UIdent ARROW If UIdent Then UIdent Else With
##
## Ends in an error in state: 649.
##
## if_then_else(base_cond) -> If expr Then closed_expr Else . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## If expr Then closed_expr Else
##
interactive_expr: If UIdent Then Match UIdent With UIdent ARROW If UIdent Then UIdent Else With
##
## Ends in an error in state: 718.
##
## if_then_else(base_cond) -> If expr Then closed_expr Else . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## if_then_else(base_if_then_else) -> If expr Then closed_expr Else . base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## If expr Then closed_expr Else
##
interactive_expr: Match UIdent With UIdent ARROW If UIdent Then If UIdent Then UIdent Else With
##
## Ends in an error in state: 711.
##
## if_then_else(base_cond) -> If expr Then closed_expr Else . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## if_then_else(closed_expr) -> If expr Then closed_expr Else . closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## If expr Then closed_expr Else
##
interactive_expr: Begin Match UIdent With UIdent ARROW If UIdent Then UIdent Else With
##
## Ends in an error in state: 766.
##
## if_then_else(base_cond) -> If expr Then closed_expr Else . base_cond [ VBAR ]
## if_then_else(seq_expr) -> If expr Then closed_expr Else . seq_expr [ SEMI End ]
##
## The known suffix of the stack is as follows:
## If expr Then closed_expr Else
##
interactive_expr: If UIdent Then If UIdent Then UIdent Else With
##
## Ends in an error in state: 917.
##
## if_then_else(closed_expr) -> If expr Then closed_expr Else . closed_expr [ Else ]
## if_then_else(expr) -> If expr Then closed_expr Else . expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## If expr Then closed_expr Else
##
interactive_expr: Begin If Verbatim Then Verbatim Else With
##
## Ends in an error in state: 820.
##
## if_then_else(seq_expr) -> If expr Then closed_expr Else . seq_expr [ SEMI End ]
##
## The known suffix of the stack is as follows:
## If expr Then closed_expr Else
##

Ill-formed conditional expression.
At this point, the expression of the 'else' branch is expected.

interactive_expr: Fun Ident ARROW With
##
## Ends in an error in state: 879.
##
## fun_expr(expr) -> Fun nseq(core_irrefutable) ARROW . expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable) ARROW
##
interactive_expr: Match UIdent With UIdent ARROW If UIdent Then Fun Ident ARROW With
##
## Ends in an error in state: 705.
##
## fun_expr(base_cond) -> Fun nseq(core_irrefutable) ARROW . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(closed_expr) -> Fun nseq(core_irrefutable) ARROW . closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable) ARROW
##
interactive_expr: If UIdent Then Match UIdent With UIdent ARROW Fun Ident ARROW With
##
## Ends in an error in state: 746.
##
## fun_expr(base_cond) -> Fun nseq(core_irrefutable) ARROW . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_if_then_else) -> Fun nseq(core_irrefutable) ARROW . base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable) ARROW
##
interactive_expr: Match UIdent With UIdent ARROW Fun Ident ARROW With
##
## Ends in an error in state: 675.
##
## fun_expr(base_cond) -> Fun nseq(core_irrefutable) ARROW . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable) ARROW
##
interactive_expr: Begin If UIdent Then Fun Ident ARROW With
##
## Ends in an error in state: 812.
##
## fun_expr(closed_expr) -> Fun nseq(core_irrefutable) ARROW . closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable) ARROW
##
interactive_expr: Begin Fun Ident ARROW With
##
## Ends in an error in state: 845.
##
## fun_expr(last_expr) -> Fun nseq(core_irrefutable) ARROW . last_expr [ End ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable) ARROW
##
interactive_expr: If UIdent Then Fun Ident ARROW With
##
## Ends in an error in state: 912.
##
## fun_expr(closed_expr) -> Fun nseq(core_irrefutable) ARROW . closed_expr [ Else ]
## fun_expr(expr) -> Fun nseq(core_irrefutable) ARROW . expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable) ARROW
##
interactive_expr: Fun LPAR Type Ident RPAR Ident ARROW With
##
## Ends in an error in state: 313.
##
## fun_expr(expr) -> Fun par(__anonymous_7) nseq(core_irrefutable) ARROW . expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun par(__anonymous_7) nseq(core_irrefutable) ARROW
##
interactive_expr: Match UIdent With UIdent ARROW If UIdent Then Fun LPAR Type Ident RPAR Ident ARROW With
##
## Ends in an error in state: 616.
##
## fun_expr(base_cond) -> Fun par(__anonymous_7) nseq(core_irrefutable) ARROW . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(closed_expr) -> Fun par(__anonymous_7) nseq(core_irrefutable) ARROW . closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Fun par(__anonymous_7) nseq(core_irrefutable) ARROW
##
interactive_expr: Match UIdent With UIdent ARROW If UIdent Then Fun LPAR Type Ident RPAR Ident COLON Ident ARROW With
##
## Ends in an error in state: 702.
##
## fun_expr(base_cond) -> Fun par(__anonymous_7) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(closed_expr) -> Fun par(__anonymous_7) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Fun par(__anonymous_7) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW
##
interactive_expr: Match UIdent With UIdent ARROW If UIdent Then Fun Ident COLON Ident ARROW With
##
## Ends in an error in state: 708.
##
## fun_expr(base_cond) -> Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(closed_expr) -> Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW
##
interactive_expr: If UIdent Then Match UIdent With UIdent ARROW Fun LPAR Type Ident RPAR Ident ARROW With
##
## Ends in an error in state: 722.
##
## fun_expr(base_cond) -> Fun par(__anonymous_7) nseq(core_irrefutable) ARROW . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_if_then_else) -> Fun par(__anonymous_7) nseq(core_irrefutable) ARROW . base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## Fun par(__anonymous_7) nseq(core_irrefutable) ARROW
##
interactive_expr: If UIdent Then Match UIdent With UIdent ARROW Fun LPAR Type Ident RPAR Ident COLON Ident ARROW With
##
## Ends in an error in state: 743.
##
## fun_expr(base_cond) -> Fun par(__anonymous_7) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_if_then_else) -> Fun par(__anonymous_7) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## Fun par(__anonymous_7) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW
##
interactive_expr: If UIdent Then Match UIdent With UIdent ARROW Fun Ident COLON Ident ARROW With
##
## Ends in an error in state: 749.
##
## fun_expr(base_cond) -> Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_if_then_else) -> Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW
##
interactive_expr: Match UIdent With UIdent ARROW Fun LPAR Type Ident RPAR Ident ARROW With
##
## Ends in an error in state: 657.
##
## fun_expr(base_cond) -> Fun par(__anonymous_7) nseq(core_irrefutable) ARROW . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun par(__anonymous_7) nseq(core_irrefutable) ARROW
##
interactive_expr: Match UIdent With UIdent ARROW Fun LPAR Type Ident RPAR Ident COLON Ident ARROW With
##
## Ends in an error in state: 670.
##
## fun_expr(base_cond) -> Fun par(__anonymous_7) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun par(__anonymous_7) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW
##
interactive_expr: Match UIdent With UIdent ARROW Fun Ident COLON Ident ARROW With
##
## Ends in an error in state: 678.
##
## fun_expr(base_cond) -> Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW
##
interactive_expr: Begin Match UIdent With UIdent ARROW Fun LPAR Type Ident RPAR Ident ARROW With
##
## Ends in an error in state: 773.
##
## fun_expr(base_cond) -> Fun par(__anonymous_7) nseq(core_irrefutable) ARROW . base_cond [ VBAR ]
## fun_expr(last_expr) -> Fun par(__anonymous_7) nseq(core_irrefutable) ARROW . last_expr [ End ]
##
## The known suffix of the stack is as follows:
## Fun par(__anonymous_7) nseq(core_irrefutable) ARROW
##
interactive_expr: Begin If UIdent Then Fun LPAR Type Ident RPAR Ident ARROW With
##
## Ends in an error in state: 801.
##
## fun_expr(closed_expr) -> Fun par(__anonymous_7) nseq(core_irrefutable) ARROW . closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Fun par(__anonymous_7) nseq(core_irrefutable) ARROW
##
interactive_expr: Begin If UIdent Then Fun LPAR Type Ident RPAR Ident COLON Ident ARROW With
##
## Ends in an error in state: 810.
##
## fun_expr(closed_expr) -> Fun par(__anonymous_7) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Fun par(__anonymous_7) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW
##
interactive_expr: Begin If UIdent Then Fun Ident COLON Ident ARROW With
##
## Ends in an error in state: 814.
##
## fun_expr(closed_expr) -> Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW
##
interactive_expr: Begin Fun LPAR Type Ident RPAR Ident ARROW With
##
## Ends in an error in state: 825.
##
## fun_expr(last_expr) -> Fun par(__anonymous_7) nseq(core_irrefutable) ARROW . last_expr [ End ]
##
## The known suffix of the stack is as follows:
## Fun par(__anonymous_7) nseq(core_irrefutable) ARROW
##
interactive_expr: Begin Fun LPAR Type Ident RPAR Ident COLON Ident ARROW With
##
## Ends in an error in state: 842.
##
## fun_expr(last_expr) -> Fun par(__anonymous_7) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . last_expr [ End ]
##
## The known suffix of the stack is as follows:
## Fun par(__anonymous_7) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW
##
interactive_expr: Begin Fun Ident COLON Ident ARROW With
##
## Ends in an error in state: 848.
##
## fun_expr(last_expr) -> Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . last_expr [ End ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW
##
interactive_expr: Begin Match UIdent With UIdent ARROW Fun LPAR Type Ident RPAR Ident COLON Ident ARROW With
##
## Ends in an error in state: 858.
##
## fun_expr(base_cond) -> Fun par(__anonymous_7) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . base_cond [ VBAR ]
## fun_expr(last_expr) -> Fun par(__anonymous_7) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . last_expr [ End ]
##
## The known suffix of the stack is as follows:
## Fun par(__anonymous_7) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW
##
interactive_expr: Begin Match UIdent With UIdent ARROW Fun Ident COLON Ident ARROW With
##
## Ends in an error in state: 862.
##
## fun_expr(base_cond) -> Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . base_cond [ VBAR ]
## fun_expr(last_expr) -> Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . last_expr [ End ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW
##
interactive_expr: Fun LPAR Type Ident RPAR Ident COLON Ident ARROW With
##
## Ends in an error in state: 876.
##
## fun_expr(expr) -> Fun par(__anonymous_7) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun par(__anonymous_7) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW
##
interactive_expr: Fun Ident COLON Ident ARROW With
##
## Ends in an error in state: 882.
##
## fun_expr(expr) -> Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW
##
interactive_expr: If UIdent Then Fun LPAR Type Ident RPAR Ident ARROW With
##
## Ends in an error in state: 901.
##
## fun_expr(closed_expr) -> Fun par(__anonymous_7) nseq(core_irrefutable) ARROW . closed_expr [ Else ]
## fun_expr(expr) -> Fun par(__anonymous_7) nseq(core_irrefutable) ARROW . expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun par(__anonymous_7) nseq(core_irrefutable) ARROW
##
interactive_expr: If UIdent Then Fun LPAR Type Ident RPAR Ident COLON Ident ARROW With
##
## Ends in an error in state: 910.
##
## fun_expr(closed_expr) -> Fun par(__anonymous_7) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . closed_expr [ Else ]
## fun_expr(expr) -> Fun par(__anonymous_7) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun par(__anonymous_7) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW
##
interactive_expr: If UIdent Then Fun Ident COLON Ident ARROW With
##
## Ends in an error in state: 914.
##
## fun_expr(closed_expr) -> Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . closed_expr [ Else ]
## fun_expr(expr) -> Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW . expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW
##

Ill-formed functional expression.
At this point, the body of the function is expected as an expression.

interactive_expr: If Verbatim Then Match Verbatim With WILD ARROW With
##
## Ends in an error in state: 598.
##
## match_clause(base_cond) -> pattern ARROW . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## match_clause(base_if_then_else) -> pattern ARROW . base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## pattern ARROW
##
interactive_expr: Begin Match UIdent With UIdent ARROW With
##
## Ends in an error in state: 549.
##
## match_clause(base_cond) -> pattern ARROW . base_cond [ VBAR ]
## match_clause(last_expr) -> pattern ARROW . last_expr [ End ]
##
## The known suffix of the stack is as follows:
## pattern ARROW
##
interactive_expr: Match UIdent With UIdent ARROW With
##
## Ends in an error in state: 1011.
##
## match_clause(base_cond) -> pattern ARROW . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## pattern ARROW
##

Ill-formed pattern matching.
At this point, the right-hand side of the current clause is expected
as an expression.

interactive_expr: Begin With
##
## Ends in an error in state: 315.
##
## sequence_expr -> Begin . End [ With Verbatim VBAR UIdent Type Then TIMES String SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Lxor Lsr Lsl Lor Let Lang Land LT LPAR LE LBRACKET LBRACE Int In Ident GT End Else EQ EOF Directive CONS COMMA COLON CARET Bytes Begin BOOL_OR BOOL_AND Attr ]
## sequence_expr -> Begin . series End [ With Verbatim VBAR UIdent Type Then TIMES String SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Lxor Lsr Lsl Lor Let Lang Land LT LPAR LE LBRACKET LBRACE Int In Ident GT End Else EQ EOF Directive CONS COMMA COLON CARET Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## Begin
##

Ill-formed sequence of expressions.
At this point, one of the following is expected:
  * an expression of type 'unit';
  * the keyword 'end' if the sequence is empty.

interactive_expr: Begin If Verbatim Then With
##
## Ends in an error in state: 790.
##
## if_then_else(seq_expr) -> If expr Then . closed_expr Else seq_expr [ SEMI End ]
##
## The known suffix of the stack is as follows:
## If expr Then
##
interactive_expr: If Verbatim Then With
##
## Ends in an error in state: 885.
##
## if_then(expr) -> If expr Then . expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## if_then_else(expr) -> If expr Then . closed_expr Else expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## If expr Then
##
interactive_expr: Match Verbatim With WILD ARROW If Verbatim Then With
##
## Ends in an error in state: 625.
##
## if_then(base_cond) -> If expr Then . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## if_then_else(base_cond) -> If expr Then . closed_expr Else base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## If expr Then
##
interactive_expr: Begin Match UIdent With UIdent ARROW If UIdent Then With
##
## Ends in an error in state: 592.
##
## if_then(base_cond) -> If expr Then . base_cond [ VBAR ]
## if_then_else(base_cond) -> If expr Then . closed_expr Else base_cond [ VBAR ]
## if_then_else(seq_expr) -> If expr Then . closed_expr Else seq_expr [ SEMI End ]
##
## The known suffix of the stack is as follows:
## If expr Then
##
interactive_expr: If UIdent Then Match UIdent With UIdent ARROW If UIdent Then With
##
## Ends in an error in state: 605.
##
## if_then(base_cond) -> If expr Then . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## if_then_else(base_cond) -> If expr Then . closed_expr Else base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## if_then_else(base_if_then_else) -> If expr Then . closed_expr Else base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## If expr Then
##
interactive_expr: Match UIdent With UIdent ARROW If UIdent Then If UIdent Then With
##
## Ends in an error in state: 612.
##
## if_then(base_cond) -> If expr Then . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## if_then_else(base_cond) -> If expr Then . closed_expr Else base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## if_then_else(closed_expr) -> If expr Then . closed_expr Else closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## If expr Then
##
interactive_expr: Begin If UIdent Then If UIdent Then With
##
## Ends in an error in state: 797.
##
## if_then_else(closed_expr) -> If expr Then . closed_expr Else closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## If expr Then
##
interactive_expr: If UIdent Then If UIdent Then With
##
## Ends in an error in state: 897.
##
## if_then(expr) -> If expr Then . expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## if_then_else(closed_expr) -> If expr Then . closed_expr Else closed_expr [ Else ]
## if_then_else(expr) -> If expr Then . closed_expr Else expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## If expr Then
##

Ill-formed conditional expression.
At this point, the 'then' branch is expected as an expression.

interactive_expr: Begin Attr Let Rec Ident EQ UIdent In With
##
## Ends in an error in state: 831.
##
## let_in_sequence -> nseq(Attr) Let Rec let_binding In . series [ End ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let Rec let_binding In
##
interactive_expr: Begin If UIdent Then Let Rec Ident EQ UIdent In With
##
## Ends in an error in state: 794.
##
## let_in_expr(closed_expr) -> Let Rec let_binding In . closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Let Rec let_binding In
##
interactive_expr: Begin Attr Let Ident EQ UIdent In With
##
## Ends in an error in state: 838.
##
## let_in_sequence -> nseq(Attr) Let let_binding In . series [ End ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let let_binding In
##
interactive_expr: Begin Let Ident EQ UIdent In With
##
## Ends in an error in state: 852.
##
## let_in_sequence -> Let let_binding In . series [ End ]
##
## The known suffix of the stack is as follows:
## Let let_binding In
##
interactive_expr: Begin Match UIdent With UIdent ARROW Attr Let Ident EQ UIdent In With
##
## Ends in an error in state: 856.
##
## let_in_expr(base_cond) -> Let let_binding In . base_cond [ VBAR ]
## let_in_sequence -> nseq(Attr) Let let_binding In . series [ End ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let let_binding In
##
interactive_expr: Begin Match UIdent With UIdent ARROW Let Ident EQ UIdent In With
##
## Ends in an error in state: 864.
##
## let_in_expr(base_cond) -> Let let_binding In . base_cond [ VBAR ]
## let_in_sequence -> Let let_binding In . series [ End ]
##
## The known suffix of the stack is as follows:
## Let let_binding In
##
interactive_expr: If UIdent Then Let Rec Ident EQ UIdent In With
##
## Ends in an error in state: 894.
##
## let_in_expr(closed_expr) -> Let Rec let_binding In . closed_expr [ Else ]
## let_in_expr(expr) -> Let Rec let_binding In . expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let Rec let_binding In
##
interactive_expr: If UIdent Then Let Ident EQ UIdent In With
##
## Ends in an error in state: 921.
##
## let_in_expr(closed_expr) -> Let let_binding In . closed_expr [ Else ]
## let_in_expr(expr) -> Let let_binding In . expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let let_binding In
##
interactive_expr: Let Ident EQ UIdent In With
##
## Ends in an error in state: 1000.
##
## let_in_expr(expr) -> Let let_binding In . expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let let_binding In
##
interactive_expr: Begin If UIdent Then Let Ident EQ UIdent In With
##
## Ends in an error in state: 818.
##
## let_in_expr(closed_expr) -> Let let_binding In . closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Let let_binding In
##
interactive_expr: Match Verbatim With WILD ARROW Let WILD EQ Bytes In With
##
## Ends in an error in state: 694.
##
## let_in_expr(base_cond) -> Let let_binding In . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let let_binding In
##
interactive_expr: Let Rec Ident EQ UIdent In With
##
## Ends in an error in state: 998.
##
## let_in_expr(expr) -> Let Rec let_binding In . expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let Rec let_binding In
##
interactive_expr: Begin Match UIdent With UIdent ARROW Let Rec Ident EQ UIdent In With
##
## Ends in an error in state: 589.
##
## let_in_expr(base_cond) -> Let Rec let_binding In . base_cond [ VBAR ]
## let_in_sequence -> Let Rec let_binding In . series [ End ]
##
## The known suffix of the stack is as follows:
## Let Rec let_binding In
##
interactive_expr: If UIdent Then Match UIdent With UIdent ARROW Let Rec Ident EQ UIdent In With
##
## Ends in an error in state: 602.
##
## let_in_expr(base_cond) -> Let Rec let_binding In . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## let_in_expr(base_if_then_else) -> Let Rec let_binding In . base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## Let Rec let_binding In
##
interactive_expr: Match UIdent With UIdent ARROW If UIdent Then Let Rec Ident EQ UIdent In With
##
## Ends in an error in state: 609.
##
## let_in_expr(base_cond) -> Let Rec let_binding In . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## let_in_expr(closed_expr) -> Let Rec let_binding In . closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Let Rec let_binding In
##
interactive_expr: Match UIdent With UIdent ARROW If UIdent Then Let Ident EQ UIdent In With
##
## Ends in an error in state: 715.
##
## let_in_expr(base_cond) -> Let let_binding In . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## let_in_expr(closed_expr) -> Let let_binding In . closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Let let_binding In
##
interactive_expr: If UIdent Then Match UIdent With UIdent ARROW Let Ident EQ UIdent In With
##
## Ends in an error in state: 754.
##
## let_in_expr(base_cond) -> Let let_binding In . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## let_in_expr(base_if_then_else) -> Let let_binding In . base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## Let let_binding In
##
interactive_expr: Match UIdent With UIdent ARROW Let Rec Ident EQ UIdent In With
##
## Ends in an error in state: 653.
##
## let_in_expr(base_cond) -> Let Rec let_binding In . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let Rec let_binding In
##
interactive_expr: Begin Match UIdent With UIdent ARROW Attr Let Rec Ident EQ UIdent In With
##
## Ends in an error in state: 780.
##
## let_in_expr(base_cond) -> Let Rec let_binding In . base_cond [ VBAR ]
## let_in_sequence -> nseq(Attr) Let Rec let_binding In . series [ End ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let Rec let_binding In
##
interactive_expr: Begin Let Rec Ident EQ UIdent In With
##
## Ends in an error in state: 787.
##
## let_in_sequence -> Let Rec let_binding In . series [ End ]
##
## The known suffix of the stack is as follows:
## Let Rec let_binding In
##

Ill-formed local value declaration.
At this point, an expression is expected.

interactive_expr: With
##
## Ends in an error in state: 1069.
##
## interactive_expr' -> . interactive_expr [ # ]
##
## The known suffix of the stack is as follows:
##
##

Ill-formed expression.
At this point, an expression is expected.

contract: With
##
## Ends in an error in state: 0.
##
## contract' -> . contract [ # ]
##
## The known suffix of the stack is as follows:
##
##

Ill-formed contract.
At this point, a declaration is expected.

interactive_expr: Begin If Verbatim Then If Verbatim Then Verbatim COMMA Bytes With
##
## Ends in an error in state: 815.
##
## if_then_else(closed_expr) -> If expr Then closed_expr . Else closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## If expr Then closed_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 345, spurious reduction of production app_expr_level -> core_expr
## In state 354, spurious reduction of production unary_expr_level -> app_expr_level
## In state 341, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 362, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 368, spurious reduction of production add_expr_level -> mult_expr_level
## In state 404, spurious reduction of production cons_expr_level -> add_expr_level
## In state 391, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 428, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 435, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 444, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 441, spurious reduction of production nsepseq(disj_expr_level,COMMA) -> disj_expr_level
## In state 440, spurious reduction of production tuple(disj_expr_level) -> disj_expr_level COMMA nsepseq(disj_expr_level,COMMA)
## In state 361, spurious reduction of production tuple_expr -> tuple(disj_expr_level)
## In state 804, spurious reduction of production base_expr(closed_expr) -> tuple_expr
## In state 644, spurious reduction of production base_if_then_else__open(closed_expr) -> base_expr(closed_expr)
## In state 643, spurious reduction of production closed_expr -> base_if_then_else__open(closed_expr)
##
interactive_expr: Begin If Verbatim Then Verbatim With
##
## Ends in an error in state: 808.
##
## base_expr(closed_expr) -> disj_expr_level . [ Else ]
## bin_op(disj_expr_level,BOOL_OR,conj_expr_level) -> disj_expr_level . BOOL_OR conj_expr_level [ REV_APP Or Else COMMA BOOL_OR ]
## bin_op(disj_expr_level,Or,conj_expr_level) -> disj_expr_level . Or conj_expr_level [ REV_APP Or Else COMMA BOOL_OR ]
## bin_op(disj_expr_level,REV_APP,conj_expr_level) -> disj_expr_level . REV_APP conj_expr_level [ REV_APP Or Else COMMA BOOL_OR ]
## tuple(disj_expr_level) -> disj_expr_level . COMMA nsepseq(disj_expr_level,COMMA) [ Else ]
##
## The known suffix of the stack is as follows:
## disj_expr_level
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 345, spurious reduction of production app_expr_level -> core_expr
## In state 354, spurious reduction of production unary_expr_level -> app_expr_level
## In state 341, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 362, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 368, spurious reduction of production add_expr_level -> mult_expr_level
## In state 404, spurious reduction of production cons_expr_level -> add_expr_level
## In state 391, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 428, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 435, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 444, spurious reduction of production disj_expr_level -> conj_expr_level
##
interactive_expr: If Verbatim Then Verbatim VBAR
##
## Ends in an error in state: 908.
##
## base_expr(closed_expr) -> disj_expr_level . [ Else ]
## base_expr(expr) -> disj_expr_level . [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## bin_op(disj_expr_level,BOOL_OR,conj_expr_level) -> disj_expr_level . BOOL_OR conj_expr_level [ With Type Then SEMI RPAR REV_APP RBRACKET RBRACE Or Module Let In End Else EOF Directive COMMA COLON BOOL_OR Attr ]
## bin_op(disj_expr_level,Or,conj_expr_level) -> disj_expr_level . Or conj_expr_level [ With Type Then SEMI RPAR REV_APP RBRACKET RBRACE Or Module Let In End Else EOF Directive COMMA COLON BOOL_OR Attr ]
## bin_op(disj_expr_level,REV_APP,conj_expr_level) -> disj_expr_level . REV_APP conj_expr_level [ With Type Then SEMI RPAR REV_APP RBRACKET RBRACE Or Module Let In End Else EOF Directive COMMA COLON BOOL_OR Attr ]
## tuple(disj_expr_level) -> disj_expr_level . COMMA nsepseq(disj_expr_level,COMMA) [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End Else EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## disj_expr_level
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 345, spurious reduction of production app_expr_level -> core_expr
## In state 354, spurious reduction of production unary_expr_level -> app_expr_level
## In state 341, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 362, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 368, spurious reduction of production add_expr_level -> mult_expr_level
## In state 404, spurious reduction of production cons_expr_level -> add_expr_level
## In state 391, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 428, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 435, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 444, spurious reduction of production disj_expr_level -> conj_expr_level
##
interactive_expr: Match Verbatim With WILD ARROW If Verbatim Then Verbatim WILD
##
## Ends in an error in state: 345.
##
## app_expr -> core_expr . arguments [ With VBAR Type Then TIMES SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or NE Module Mod MINUS Lxor Lsr Lsl Lor Let Land LT LE In GT End Else EQ EOF Directive CONS COMMA COLON CARET BOOL_OR BOOL_AND Attr ]
## app_expr_level -> core_expr . [ With VBAR Type Then TIMES SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or NE Module Mod MINUS Lxor Lsr Lsl Lor Let Land LT LE In GT End Else EQ EOF Directive CONS COMMA COLON CARET BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## core_expr
##

Ill-formed complete conditional expression.
At this point, if the expression of the branch 'then' is complete, the
keyword 'else' is expected, followed by an expression.

interactive_expr: Begin If Verbatim Then If Verbatim With
##
## Ends in an error in state: 796.
##
## if_then_else(closed_expr) -> If expr . Then closed_expr Else closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## If expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 345, spurious reduction of production app_expr_level -> core_expr
## In state 354, spurious reduction of production unary_expr_level -> app_expr_level
## In state 341, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 362, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 368, spurious reduction of production add_expr_level -> mult_expr_level
## In state 404, spurious reduction of production cons_expr_level -> add_expr_level
## In state 391, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 428, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 435, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 444, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 389, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 451, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 452, spurious reduction of production expr -> base_cond__open(expr)
##
interactive_expr: Begin If Verbatim With
##
## Ends in an error in state: 789.
##
## if_then_else(seq_expr) -> If expr . Then closed_expr Else seq_expr [ SEMI End ]
##
## The known suffix of the stack is as follows:
## If expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 345, spurious reduction of production app_expr_level -> core_expr
## In state 354, spurious reduction of production unary_expr_level -> app_expr_level
## In state 341, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 362, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 368, spurious reduction of production add_expr_level -> mult_expr_level
## In state 404, spurious reduction of production cons_expr_level -> add_expr_level
## In state 391, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 428, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 435, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 444, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 389, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 451, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 452, spurious reduction of production expr -> base_cond__open(expr)
##
interactive_expr: Begin Match Verbatim With WILD ARROW If Verbatim With
##
## Ends in an error in state: 591.
##
## if_then(base_cond) -> If expr . Then base_cond [ VBAR ]
## if_then_else(base_cond) -> If expr . Then closed_expr Else base_cond [ VBAR ]
## if_then_else(seq_expr) -> If expr . Then closed_expr Else seq_expr [ SEMI End ]
##
## The known suffix of the stack is as follows:
## If expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 345, spurious reduction of production app_expr_level -> core_expr
## In state 354, spurious reduction of production unary_expr_level -> app_expr_level
## In state 341, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 362, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 368, spurious reduction of production add_expr_level -> mult_expr_level
## In state 404, spurious reduction of production cons_expr_level -> add_expr_level
## In state 391, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 428, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 435, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 444, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 389, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 451, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 452, spurious reduction of production expr -> base_cond__open(expr)
##
interactive_expr: If Verbatim Then If Verbatim With
##
## Ends in an error in state: 896.
##
## if_then(expr) -> If expr . Then expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## if_then_else(closed_expr) -> If expr . Then closed_expr Else closed_expr [ Else ]
## if_then_else(expr) -> If expr . Then closed_expr Else expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## If expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 345, spurious reduction of production app_expr_level -> core_expr
## In state 354, spurious reduction of production unary_expr_level -> app_expr_level
## In state 341, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 362, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 368, spurious reduction of production add_expr_level -> mult_expr_level
## In state 404, spurious reduction of production cons_expr_level -> add_expr_level
## In state 391, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 428, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 435, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 444, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 389, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 451, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 452, spurious reduction of production expr -> base_cond__open(expr)
##
interactive_expr: If Verbatim Then Match Verbatim With WILD ARROW If Verbatim With
##
## Ends in an error in state: 604.
##
## if_then(base_cond) -> If expr . Then base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## if_then_else(base_cond) -> If expr . Then closed_expr Else base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## if_then_else(base_if_then_else) -> If expr . Then closed_expr Else base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## If expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 345, spurious reduction of production app_expr_level -> core_expr
## In state 354, spurious reduction of production unary_expr_level -> app_expr_level
## In state 341, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 362, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 368, spurious reduction of production add_expr_level -> mult_expr_level
## In state 404, spurious reduction of production cons_expr_level -> add_expr_level
## In state 391, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 428, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 435, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 444, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 389, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 451, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 452, spurious reduction of production expr -> base_cond__open(expr)
##
interactive_expr: If Verbatim With
##
## Ends in an error in state: 884.
##
## if_then(expr) -> If expr . Then expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## if_then_else(expr) -> If expr . Then closed_expr Else expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## If expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 345, spurious reduction of production app_expr_level -> core_expr
## In state 354, spurious reduction of production unary_expr_level -> app_expr_level
## In state 341, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 362, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 368, spurious reduction of production add_expr_level -> mult_expr_level
## In state 404, spurious reduction of production cons_expr_level -> add_expr_level
## In state 391, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 428, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 435, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 444, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 389, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 451, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 452, spurious reduction of production expr -> base_cond__open(expr)
##
interactive_expr: Match Verbatim With WILD ARROW If Verbatim Then If Verbatim With
##
## Ends in an error in state: 611.
##
## if_then(base_cond) -> If expr . Then base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## if_then_else(base_cond) -> If expr . Then closed_expr Else base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## if_then_else(closed_expr) -> If expr . Then closed_expr Else closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## If expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 345, spurious reduction of production app_expr_level -> core_expr
## In state 354, spurious reduction of production unary_expr_level -> app_expr_level
## In state 341, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 362, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 368, spurious reduction of production add_expr_level -> mult_expr_level
## In state 404, spurious reduction of production cons_expr_level -> add_expr_level
## In state 391, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 428, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 435, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 444, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 389, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 451, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 452, spurious reduction of production expr -> base_cond__open(expr)
##
interactive_expr: Match Verbatim With WILD ARROW If Verbatim With
##
## Ends in an error in state: 624.
##
## if_then(base_cond) -> If expr . Then base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## if_then_else(base_cond) -> If expr . Then closed_expr Else base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## If expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 345, spurious reduction of production app_expr_level -> core_expr
## In state 354, spurious reduction of production unary_expr_level -> app_expr_level
## In state 341, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 362, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 368, spurious reduction of production add_expr_level -> mult_expr_level
## In state 404, spurious reduction of production cons_expr_level -> add_expr_level
## In state 391, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 428, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 435, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 444, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 389, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 451, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 452, spurious reduction of production expr -> base_cond__open(expr)
##

Ill-formed conditional expression.
At this point, if the condition is complete, the keyword 'then' is
expected, followed by an expression.

interactive_expr: Begin Attr Let Rec Ident EQ UIdent With
##
## Ends in an error in state: 830.
##
## let_in_sequence -> nseq(Attr) Let Rec let_binding . In series [ End ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let Rec let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 236, spurious reduction of production no_attr_expr -> UIdent
## In state 329, spurious reduction of production core_expr -> no_attr_expr
## In state 345, spurious reduction of production app_expr_level -> core_expr
## In state 354, spurious reduction of production unary_expr_level -> app_expr_level
## In state 341, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 362, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 368, spurious reduction of production add_expr_level -> mult_expr_level
## In state 404, spurious reduction of production cons_expr_level -> add_expr_level
## In state 391, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 428, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 435, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 444, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 389, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 451, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 452, spurious reduction of production expr -> base_cond__open(expr)
## In state 1022, spurious reduction of production let_binding -> var_pattern EQ expr
##
interactive_expr: Begin Attr Let Ident EQ UIdent With
##
## Ends in an error in state: 837.
##
## let_in_sequence -> nseq(Attr) Let let_binding . In series [ End ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 236, spurious reduction of production no_attr_expr -> UIdent
## In state 329, spurious reduction of production core_expr -> no_attr_expr
## In state 345, spurious reduction of production app_expr_level -> core_expr
## In state 354, spurious reduction of production unary_expr_level -> app_expr_level
## In state 341, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 362, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 368, spurious reduction of production add_expr_level -> mult_expr_level
## In state 404, spurious reduction of production cons_expr_level -> add_expr_level
## In state 391, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 428, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 435, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 444, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 389, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 451, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 452, spurious reduction of production expr -> base_cond__open(expr)
## In state 1022, spurious reduction of production let_binding -> var_pattern EQ expr
##
interactive_expr: Begin Match UIdent With UIdent ARROW Attr Let Ident EQ UIdent With
##
## Ends in an error in state: 855.
##
## let_in_expr(base_cond) -> Let let_binding . In base_cond [ VBAR ]
## let_in_sequence -> nseq(Attr) Let let_binding . In series [ End ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 236, spurious reduction of production no_attr_expr -> UIdent
## In state 329, spurious reduction of production core_expr -> no_attr_expr
## In state 345, spurious reduction of production app_expr_level -> core_expr
## In state 354, spurious reduction of production unary_expr_level -> app_expr_level
## In state 341, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 362, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 368, spurious reduction of production add_expr_level -> mult_expr_level
## In state 404, spurious reduction of production cons_expr_level -> add_expr_level
## In state 391, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 428, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 435, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 444, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 389, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 451, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 452, spurious reduction of production expr -> base_cond__open(expr)
## In state 1022, spurious reduction of production let_binding -> var_pattern EQ expr
##
interactive_expr: Begin Match UIdent With UIdent ARROW Attr Let Rec Ident EQ UIdent With
##
## Ends in an error in state: 779.
##
## let_in_expr(base_cond) -> Let Rec let_binding . In base_cond [ VBAR ]
## let_in_sequence -> nseq(Attr) Let Rec let_binding . In series [ End ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let Rec let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 236, spurious reduction of production no_attr_expr -> UIdent
## In state 329, spurious reduction of production core_expr -> no_attr_expr
## In state 345, spurious reduction of production app_expr_level -> core_expr
## In state 354, spurious reduction of production unary_expr_level -> app_expr_level
## In state 341, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 362, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 368, spurious reduction of production add_expr_level -> mult_expr_level
## In state 404, spurious reduction of production cons_expr_level -> add_expr_level
## In state 391, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 428, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 435, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 444, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 389, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 451, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 452, spurious reduction of production expr -> base_cond__open(expr)
## In state 1022, spurious reduction of production let_binding -> var_pattern EQ expr
##
interactive_expr: Begin Let Rec WILD EQ Bytes With
##
## Ends in an error in state: 786.
##
## let_in_sequence -> Let Rec let_binding . In series [ End ]
##
## The known suffix of the stack is as follows:
## Let Rec let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 345, spurious reduction of production app_expr_level -> core_expr
## In state 354, spurious reduction of production unary_expr_level -> app_expr_level
## In state 341, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 362, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 368, spurious reduction of production add_expr_level -> mult_expr_level
## In state 404, spurious reduction of production cons_expr_level -> add_expr_level
## In state 391, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 428, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 435, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 444, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 389, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 451, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 452, spurious reduction of production expr -> base_cond__open(expr)
## In state 1022, spurious reduction of production let_binding -> var_pattern EQ expr
##
interactive_expr: Begin Match Verbatim With WILD ARROW Let Rec WILD EQ Bytes With
##
## Ends in an error in state: 588.
##
## let_in_expr(base_cond) -> Let Rec let_binding . In base_cond [ VBAR ]
## let_in_sequence -> Let Rec let_binding . In series [ End ]
##
## The known suffix of the stack is as follows:
## Let Rec let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 345, spurious reduction of production app_expr_level -> core_expr
## In state 354, spurious reduction of production unary_expr_level -> app_expr_level
## In state 341, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 362, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 368, spurious reduction of production add_expr_level -> mult_expr_level
## In state 404, spurious reduction of production cons_expr_level -> add_expr_level
## In state 391, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 428, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 435, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 444, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 389, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 451, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 452, spurious reduction of production expr -> base_cond__open(expr)
## In state 1022, spurious reduction of production let_binding -> var_pattern EQ expr
##
interactive_expr: If Verbatim Then Let Rec WILD EQ Bytes With
##
## Ends in an error in state: 893.
##
## let_in_expr(closed_expr) -> Let Rec let_binding . In closed_expr [ Else ]
## let_in_expr(expr) -> Let Rec let_binding . In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let Rec let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 345, spurious reduction of production app_expr_level -> core_expr
## In state 354, spurious reduction of production unary_expr_level -> app_expr_level
## In state 341, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 362, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 368, spurious reduction of production add_expr_level -> mult_expr_level
## In state 404, spurious reduction of production cons_expr_level -> add_expr_level
## In state 391, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 428, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 435, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 444, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 389, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 451, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 452, spurious reduction of production expr -> base_cond__open(expr)
## In state 1022, spurious reduction of production let_binding -> var_pattern EQ expr
##
interactive_expr: If Verbatim Then Match Verbatim With WILD ARROW Let Rec WILD EQ Bytes With
##
## Ends in an error in state: 601.
##
## let_in_expr(base_cond) -> Let Rec let_binding . In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## let_in_expr(base_if_then_else) -> Let Rec let_binding . In base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## Let Rec let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 345, spurious reduction of production app_expr_level -> core_expr
## In state 354, spurious reduction of production unary_expr_level -> app_expr_level
## In state 341, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 362, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 368, spurious reduction of production add_expr_level -> mult_expr_level
## In state 404, spurious reduction of production cons_expr_level -> add_expr_level
## In state 391, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 428, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 435, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 444, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 389, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 451, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 452, spurious reduction of production expr -> base_cond__open(expr)
## In state 1022, spurious reduction of production let_binding -> var_pattern EQ expr
##
interactive_expr: Match Verbatim With WILD ARROW If Verbatim Then Let Rec WILD EQ Bytes With
##
## Ends in an error in state: 608.
##
## let_in_expr(base_cond) -> Let Rec let_binding . In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## let_in_expr(closed_expr) -> Let Rec let_binding . In closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Let Rec let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 345, spurious reduction of production app_expr_level -> core_expr
## In state 354, spurious reduction of production unary_expr_level -> app_expr_level
## In state 341, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 362, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 368, spurious reduction of production add_expr_level -> mult_expr_level
## In state 404, spurious reduction of production cons_expr_level -> add_expr_level
## In state 391, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 428, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 435, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 444, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 389, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 451, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 452, spurious reduction of production expr -> base_cond__open(expr)
## In state 1022, spurious reduction of production let_binding -> var_pattern EQ expr
##
interactive_expr: Match Verbatim With WILD ARROW Let Rec WILD EQ Bytes With
##
## Ends in an error in state: 652.
##
## let_in_expr(base_cond) -> Let Rec let_binding . In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let Rec let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 345, spurious reduction of production app_expr_level -> core_expr
## In state 354, spurious reduction of production unary_expr_level -> app_expr_level
## In state 341, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 362, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 368, spurious reduction of production add_expr_level -> mult_expr_level
## In state 404, spurious reduction of production cons_expr_level -> add_expr_level
## In state 391, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 428, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 435, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 444, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 389, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 451, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 452, spurious reduction of production expr -> base_cond__open(expr)
## In state 1022, spurious reduction of production let_binding -> var_pattern EQ expr
##
interactive_expr: Begin If Verbatim Then Let WILD EQ Bytes With
##
## Ends in an error in state: 817.
##
## let_in_expr(closed_expr) -> Let let_binding . In closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Let let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 345, spurious reduction of production app_expr_level -> core_expr
## In state 354, spurious reduction of production unary_expr_level -> app_expr_level
## In state 341, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 362, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 368, spurious reduction of production add_expr_level -> mult_expr_level
## In state 404, spurious reduction of production cons_expr_level -> add_expr_level
## In state 391, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 428, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 435, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 444, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 389, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 451, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 452, spurious reduction of production expr -> base_cond__open(expr)
## In state 1022, spurious reduction of production let_binding -> var_pattern EQ expr
##
interactive_expr: Begin Let WILD EQ Bytes With
##
## Ends in an error in state: 851.
##
## let_in_sequence -> Let let_binding . In series [ End ]
##
## The known suffix of the stack is as follows:
## Let let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 345, spurious reduction of production app_expr_level -> core_expr
## In state 354, spurious reduction of production unary_expr_level -> app_expr_level
## In state 341, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 362, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 368, spurious reduction of production add_expr_level -> mult_expr_level
## In state 404, spurious reduction of production cons_expr_level -> add_expr_level
## In state 391, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 428, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 435, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 444, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 389, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 451, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 452, spurious reduction of production expr -> base_cond__open(expr)
## In state 1022, spurious reduction of production let_binding -> var_pattern EQ expr
##
interactive_expr: Begin Match Verbatim With WILD ARROW Let WILD EQ Bytes With
##
## Ends in an error in state: 863.
##
## let_in_expr(base_cond) -> Let let_binding . In base_cond [ VBAR ]
## let_in_sequence -> Let let_binding . In series [ End ]
##
## The known suffix of the stack is as follows:
## Let let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 345, spurious reduction of production app_expr_level -> core_expr
## In state 354, spurious reduction of production unary_expr_level -> app_expr_level
## In state 341, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 362, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 368, spurious reduction of production add_expr_level -> mult_expr_level
## In state 404, spurious reduction of production cons_expr_level -> add_expr_level
## In state 391, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 428, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 435, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 444, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 389, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 451, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 452, spurious reduction of production expr -> base_cond__open(expr)
## In state 1022, spurious reduction of production let_binding -> var_pattern EQ expr
##
interactive_expr: If Verbatim Then Match Verbatim With WILD ARROW Let WILD EQ Bytes With
##
## Ends in an error in state: 753.
##
## let_in_expr(base_cond) -> Let let_binding . In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## let_in_expr(base_if_then_else) -> Let let_binding . In base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## Let let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 345, spurious reduction of production app_expr_level -> core_expr
## In state 354, spurious reduction of production unary_expr_level -> app_expr_level
## In state 341, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 362, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 368, spurious reduction of production add_expr_level -> mult_expr_level
## In state 404, spurious reduction of production cons_expr_level -> add_expr_level
## In state 391, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 428, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 435, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 444, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 389, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 451, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 452, spurious reduction of production expr -> base_cond__open(expr)
## In state 1022, spurious reduction of production let_binding -> var_pattern EQ expr
##
interactive_expr: If Verbatim Then Let WILD EQ Bytes With
##
## Ends in an error in state: 920.
##
## let_in_expr(closed_expr) -> Let let_binding . In closed_expr [ Else ]
## let_in_expr(expr) -> Let let_binding . In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 345, spurious reduction of production app_expr_level -> core_expr
## In state 354, spurious reduction of production unary_expr_level -> app_expr_level
## In state 341, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 362, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 368, spurious reduction of production add_expr_level -> mult_expr_level
## In state 404, spurious reduction of production cons_expr_level -> add_expr_level
## In state 391, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 428, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 435, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 444, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 389, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 451, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 452, spurious reduction of production expr -> base_cond__open(expr)
## In state 1022, spurious reduction of production let_binding -> var_pattern EQ expr
##
interactive_expr: Let WILD EQ Bytes With
##
## Ends in an error in state: 999.
##
## let_in_expr(expr) -> Let let_binding . In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 345, spurious reduction of production app_expr_level -> core_expr
## In state 354, spurious reduction of production unary_expr_level -> app_expr_level
## In state 341, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 362, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 368, spurious reduction of production add_expr_level -> mult_expr_level
## In state 404, spurious reduction of production cons_expr_level -> add_expr_level
## In state 391, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 428, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 435, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 444, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 389, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 451, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 452, spurious reduction of production expr -> base_cond__open(expr)
## In state 1022, spurious reduction of production let_binding -> var_pattern EQ expr
##
interactive_expr: Match Verbatim With WILD ARROW If Verbatim Then Let WILD EQ Bytes With
##
## Ends in an error in state: 714.
##
## let_in_expr(base_cond) -> Let let_binding . In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## let_in_expr(closed_expr) -> Let let_binding . In closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Let let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 345, spurious reduction of production app_expr_level -> core_expr
## In state 354, spurious reduction of production unary_expr_level -> app_expr_level
## In state 341, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 362, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 368, spurious reduction of production add_expr_level -> mult_expr_level
## In state 404, spurious reduction of production cons_expr_level -> add_expr_level
## In state 391, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 428, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 435, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 444, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 389, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 451, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 452, spurious reduction of production expr -> base_cond__open(expr)
## In state 1022, spurious reduction of production let_binding -> var_pattern EQ expr
##
interactive_expr: Match Verbatim With WILD ARROW Let WILD EQ Bytes With
##
## Ends in an error in state: 693.
##
## let_in_expr(base_cond) -> Let let_binding . In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 345, spurious reduction of production app_expr_level -> core_expr
## In state 354, spurious reduction of production unary_expr_level -> app_expr_level
## In state 341, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 362, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 368, spurious reduction of production add_expr_level -> mult_expr_level
## In state 404, spurious reduction of production cons_expr_level -> add_expr_level
## In state 391, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 428, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 435, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 444, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 389, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 451, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 452, spurious reduction of production expr -> base_cond__open(expr)
## In state 1022, spurious reduction of production let_binding -> var_pattern EQ expr
##
interactive_expr: Attr Let Rec Ident EQ UIdent With
##
## Ends in an error in state: 997.
##
## let_in_expr(expr) -> Let Rec let_binding . In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let Rec let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 236, spurious reduction of production no_attr_expr -> UIdent
## In state 329, spurious reduction of production core_expr -> no_attr_expr
## In state 345, spurious reduction of production app_expr_level -> core_expr
## In state 354, spurious reduction of production unary_expr_level -> app_expr_level
## In state 341, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 362, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 368, spurious reduction of production add_expr_level -> mult_expr_level
## In state 404, spurious reduction of production cons_expr_level -> add_expr_level
## In state 391, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 428, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 435, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 444, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 389, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 451, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 452, spurious reduction of production expr -> base_cond__open(expr)
## In state 1022, spurious reduction of production let_binding -> var_pattern EQ expr
##

Ill-formed local value declaration.
At this point, if the expression of the left-hand side is complete,
the keyword 'in' is expected, followed by an expression.

interactive_expr: If UIdent Then Let Rec With
##
## Ends in an error in state: 892.
##
## let_in_expr(closed_expr) -> Let Rec . let_binding In closed_expr [ Else ]
## let_in_expr(expr) -> Let Rec . let_binding In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let Rec
##
interactive_expr: Begin Attr Let Rec With
##
## Ends in an error in state: 829.
##
## let_in_sequence -> nseq(Attr) Let Rec . let_binding In series [ End ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let Rec
##
interactive_expr: Begin If UIdent Then Let Rec With
##
## Ends in an error in state: 792.
##
## let_in_expr(closed_expr) -> Let Rec . let_binding In closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Let Rec
##
interactive_expr: Begin Let Rec With
##
## Ends in an error in state: 785.
##
## let_in_sequence -> Let Rec . let_binding In series [ End ]
##
## The known suffix of the stack is as follows:
## Let Rec
##
interactive_expr: Begin Match UIdent With UIdent ARROW Attr Let Rec With
##
## Ends in an error in state: 778.
##
## let_in_expr(base_cond) -> Let Rec . let_binding In base_cond [ VBAR ]
## let_in_sequence -> nseq(Attr) Let Rec . let_binding In series [ End ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let Rec
##
interactive_expr: Match UIdent With UIdent ARROW Let Rec With
##
## Ends in an error in state: 651.
##
## let_in_expr(base_cond) -> Let Rec . let_binding In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let Rec
##
contract: Let Rec With
##
## Ends in an error in state: 135.
##
## let_decl -> Let Rec . let_binding [ Type Module Let End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## Let Rec
##
interactive_expr: Let Rec With
##
## Ends in an error in state: 249.
##
## let_in_expr(expr) -> Let Rec . let_binding In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let Rec
##
interactive_expr: If UIdent Then Match UIdent With UIdent ARROW Let Rec With
##
## Ends in an error in state: 600.
##
## let_in_expr(base_cond) -> Let Rec . let_binding In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## let_in_expr(base_if_then_else) -> Let Rec . let_binding In base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## Let Rec
##
interactive_expr: Match UIdent With UIdent ARROW If UIdent Then Let Rec With
##
## Ends in an error in state: 607.
##
## let_in_expr(base_cond) -> Let Rec . let_binding In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## let_in_expr(closed_expr) -> Let Rec . let_binding In closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Let Rec
##

Ill-formed recursive value declaration.
At this point, a pattern is expected, e.g. an identifier.

interactive_expr: If UIdent Then Let With
##
## Ends in an error in state: 891.
##
## let_in_expr(closed_expr) -> Let . let_binding In closed_expr [ Else ]
## let_in_expr(closed_expr) -> Let . Rec let_binding In closed_expr [ Else ]
## let_in_expr(expr) -> Let . let_binding In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## let_in_expr(expr) -> Let . Rec let_binding In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let
##
interactive_expr: Begin Attr Let With
##
## Ends in an error in state: 828.
##
## let_in_sequence -> nseq(Attr) Let . let_binding In series [ End ]
## let_in_sequence -> nseq(Attr) Let . Rec let_binding In series [ End ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let
##
interactive_expr: Begin If UIdent Then Let With
##
## Ends in an error in state: 791.
##
## let_in_expr(closed_expr) -> Let . let_binding In closed_expr [ Else ]
## let_in_expr(closed_expr) -> Let . Rec let_binding In closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Let
##
interactive_expr: Begin Let With
##
## Ends in an error in state: 784.
##
## let_in_sequence -> Let . let_binding In series [ End ]
## let_in_sequence -> Let . Rec let_binding In series [ End ]
##
## The known suffix of the stack is as follows:
## Let
##
interactive_expr: Begin Match UIdent With UIdent ARROW Attr Let With
##
## Ends in an error in state: 777.
##
## let_in_expr(base_cond) -> Let . let_binding In base_cond [ VBAR ]
## let_in_expr(base_cond) -> Let . Rec let_binding In base_cond [ VBAR ]
## let_in_sequence -> nseq(Attr) Let . let_binding In series [ End ]
## let_in_sequence -> nseq(Attr) Let . Rec let_binding In series [ End ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Let
##
interactive_expr: Match UIdent With UIdent ARROW Let With
##
## Ends in an error in state: 650.
##
## let_in_expr(base_cond) -> Let . let_binding In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## let_in_expr(base_cond) -> Let . Rec let_binding In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let
##
interactive_expr: Match UIdent With UIdent ARROW If UIdent Then Let With
##
## Ends in an error in state: 606.
##
## let_in_expr(base_cond) -> Let . let_binding In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## let_in_expr(base_cond) -> Let . Rec let_binding In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## let_in_expr(closed_expr) -> Let . let_binding In closed_expr [ Else ]
## let_in_expr(closed_expr) -> Let . Rec let_binding In closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Let
##
contract: Let With
##
## Ends in an error in state: 132.
##
## let_decl -> Let . let_binding [ Type Module Let End EOF Directive Attr ]
## let_decl -> Let . Rec let_binding [ Type Module Let End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## Let
##
interactive_expr: Attr Let With
##
## Ends in an error in state: 248.
##
## let_in_expr(expr) -> Let . let_binding In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## let_in_expr(expr) -> Let . Rec let_binding In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Let
##
interactive_expr: Begin Match UIdent With UIdent ARROW Let With
##
## Ends in an error in state: 550.
##
## let_in_expr(base_cond) -> Let . let_binding In base_cond [ VBAR ]
## let_in_expr(base_cond) -> Let . Rec let_binding In base_cond [ VBAR ]
## let_in_sequence -> Let . let_binding In series [ End ]
## let_in_sequence -> Let . Rec let_binding In series [ End ]
##
## The known suffix of the stack is as follows:
## Let
##
interactive_expr: If UIdent Then Match UIdent With UIdent ARROW Let With
##
## Ends in an error in state: 599.
##
## let_in_expr(base_cond) -> Let . let_binding In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## let_in_expr(base_cond) -> Let . Rec let_binding In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## let_in_expr(base_if_then_else) -> Let . let_binding In base_if_then_else [ Else ]
## let_in_expr(base_if_then_else) -> Let . Rec let_binding In base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## Let
##

Ill-formed value declaration.
At this point, one of the following is expected:
  * a pattern, e.g. an identifier;
  * the keyword 'rec' if defining a recursive function.

interactive_expr: Begin If Verbatim Then Match Verbatim Type
##
## Ends in an error in state: 594.
##
## match_expr(base_if_then_else) -> Match expr . With option(VBAR) cases(base_if_then_else) [ Else ]
##
## The known suffix of the stack is as follows:
## Match expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 345, spurious reduction of production app_expr_level -> core_expr
## In state 354, spurious reduction of production unary_expr_level -> app_expr_level
## In state 341, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 362, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 368, spurious reduction of production add_expr_level -> mult_expr_level
## In state 404, spurious reduction of production cons_expr_level -> add_expr_level
## In state 391, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 428, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 435, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 444, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 389, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 451, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 452, spurious reduction of production expr -> base_cond__open(expr)
##
interactive_expr: Begin Match Verbatim Type
##
## Ends in an error in state: 456.
##
## match_expr(last_expr) -> Match expr . With option(VBAR) cases(last_expr) [ End ]
##
## The known suffix of the stack is as follows:
## Match expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 345, spurious reduction of production app_expr_level -> core_expr
## In state 354, spurious reduction of production unary_expr_level -> app_expr_level
## In state 341, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 362, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 368, spurious reduction of production add_expr_level -> mult_expr_level
## In state 404, spurious reduction of production cons_expr_level -> add_expr_level
## In state 391, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 428, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 435, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 444, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 389, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 451, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 452, spurious reduction of production expr -> base_cond__open(expr)
##
interactive_expr: Match Verbatim Type
##
## Ends in an error in state: 1007.
##
## match_expr(base_cond) -> Match expr . With option(VBAR) cases(base_cond) [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Match expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 345, spurious reduction of production app_expr_level -> core_expr
## In state 354, spurious reduction of production unary_expr_level -> app_expr_level
## In state 341, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 362, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 368, spurious reduction of production add_expr_level -> mult_expr_level
## In state 404, spurious reduction of production cons_expr_level -> add_expr_level
## In state 391, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 428, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 435, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 444, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 389, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 451, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 452, spurious reduction of production expr -> base_cond__open(expr)
##
interactive_expr: If Verbatim Then Match Verbatim Type
##
## Ends in an error in state: 887.
##
## match_expr(base_cond) -> Match expr . With option(VBAR) cases(base_cond) [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## match_expr(base_if_then_else) -> Match expr . With option(VBAR) cases(base_if_then_else) [ Else ]
##
## The known suffix of the stack is as follows:
## Match expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 345, spurious reduction of production app_expr_level -> core_expr
## In state 354, spurious reduction of production unary_expr_level -> app_expr_level
## In state 341, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 362, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 368, spurious reduction of production add_expr_level -> mult_expr_level
## In state 404, spurious reduction of production cons_expr_level -> add_expr_level
## In state 391, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 428, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 435, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 444, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 389, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 451, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 452, spurious reduction of production expr -> base_cond__open(expr)
##

Ill-formed pattern matching.
At this point, if the expression is complete, then the keyword 'with'
is expected, followed by matching cases.

interactive_expr: Begin Match Verbatim With WILD ARROW Verbatim With
##
## Ends in an error in state: 769.
##
## base_expr(base_cond) -> disj_expr_level . [ VBAR ]
## bin_op(disj_expr_level,BOOL_OR,conj_expr_level) -> disj_expr_level . BOOL_OR conj_expr_level [ VBAR SEMI REV_APP Or End COMMA BOOL_OR ]
## bin_op(disj_expr_level,Or,conj_expr_level) -> disj_expr_level . Or conj_expr_level [ VBAR SEMI REV_APP Or End COMMA BOOL_OR ]
## bin_op(disj_expr_level,REV_APP,conj_expr_level) -> disj_expr_level . REV_APP conj_expr_level [ VBAR SEMI REV_APP Or End COMMA BOOL_OR ]
## seq_expr -> disj_expr_level . [ SEMI End ]
## tuple(disj_expr_level) -> disj_expr_level . COMMA nsepseq(disj_expr_level,COMMA) [ VBAR End ]
##
## The known suffix of the stack is as follows:
## disj_expr_level
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 345, spurious reduction of production app_expr_level -> core_expr
## In state 354, spurious reduction of production unary_expr_level -> app_expr_level
## In state 341, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 362, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 368, spurious reduction of production add_expr_level -> mult_expr_level
## In state 404, spurious reduction of production cons_expr_level -> add_expr_level
## In state 391, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 428, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 435, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 444, spurious reduction of production disj_expr_level -> conj_expr_level
##
interactive_expr: Begin If Verbatim Then Match Verbatim With WILD ARROW Bytes With
##
## Ends in an error in state: 761.
##
## cases(base_cond) -> cases(base_cond) . VBAR match_clause(base_cond) [ VBAR ]
## cases(base_if_then_else) -> cases(base_cond) . VBAR match_clause(base_if_then_else) [ Else ]
##
## The known suffix of the stack is as follows:
## cases(base_cond)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 345, spurious reduction of production app_expr_level -> core_expr
## In state 354, spurious reduction of production unary_expr_level -> app_expr_level
## In state 341, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 362, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 368, spurious reduction of production add_expr_level -> mult_expr_level
## In state 404, spurious reduction of production cons_expr_level -> add_expr_level
## In state 391, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 428, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 435, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 444, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 736, spurious reduction of production base_expr(base_cond) -> disj_expr_level
## In state 645, spurious reduction of production base_cond__open(base_cond) -> base_expr(base_cond)
## In state 646, spurious reduction of production base_cond -> base_cond__open(base_cond)
## In state 757, spurious reduction of production match_clause(base_cond) -> pattern ARROW base_cond
## In state 759, spurious reduction of production cases(base_cond) -> match_clause(base_cond)
##

Ill-formed pattern matching.
At this point, if the case is complete, a vertical bar '|' is
expected, followed by another case starting with a pattern.

interactive_expr: Match Verbatim With WILD CONS Bytes SEMI
##
## Ends in an error in state: 533.
##
## pattern -> cons_pattern_level . [ RPAR COLON ARROW ]
## tuple(cons_pattern_level) -> cons_pattern_level . COMMA nsepseq(cons_pattern_level,COMMA) [ RPAR COLON ARROW ]
##
## The known suffix of the stack is as follows:
## cons_pattern_level
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 517, spurious reduction of production cons_pattern_level -> core_pattern
## In state 519, spurious reduction of production cons_pattern_level -> core_pattern CONS cons_pattern_level
##
interactive_expr: Begin Match Verbatim With WILD RPAR
##
## Ends in an error in state: 548.
##
## match_clause(base_cond) -> pattern . ARROW base_cond [ VBAR ]
## match_clause(last_expr) -> pattern . ARROW last_expr [ End ]
##
## The known suffix of the stack is as follows:
## pattern
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 517, spurious reduction of production cons_pattern_level -> core_pattern
## In state 533, spurious reduction of production pattern -> cons_pattern_level
##
interactive_expr: If Verbatim Then Match Verbatim With WILD RPAR
##
## Ends in an error in state: 597.
##
## match_clause(base_cond) -> pattern . ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## match_clause(base_if_then_else) -> pattern . ARROW base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## pattern
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 517, spurious reduction of production cons_pattern_level -> core_pattern
## In state 533, spurious reduction of production pattern -> cons_pattern_level
##

Ill-formed pattern matching.
At this point, if the pattern is complete, an arrow '->' is expected,
followed by an expression.

interactive_expr: Begin If Verbatim Then Match Verbatim With With
##
## Ends in an error in state: 595.
##
## match_expr(base_if_then_else) -> Match expr With . option(VBAR) cases(base_if_then_else) [ Else ]
##
## The known suffix of the stack is as follows:
## Match expr With
##
interactive_expr: Begin Match Verbatim With With
##
## Ends in an error in state: 457.
##
## match_expr(last_expr) -> Match expr With . option(VBAR) cases(last_expr) [ End ]
##
## The known suffix of the stack is as follows:
## Match expr With
##
interactive_expr: If Verbatim Then Match Verbatim With With
##
## Ends in an error in state: 888.
##
## match_expr(base_cond) -> Match expr With . option(VBAR) cases(base_cond) [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## match_expr(base_if_then_else) -> Match expr With . option(VBAR) cases(base_if_then_else) [ Else ]
##
## The known suffix of the stack is as follows:
## Match expr With
##
interactive_expr: Match Verbatim With With
##
## Ends in an error in state: 1008.
##
## match_expr(base_cond) -> Match expr With . option(VBAR) cases(base_cond) [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Match expr With
##

Ill-formed pattern matching.
At this point, the first case is expected to start with a pattern or a
vertical bar.

interactive_expr: Begin UIdent SEMI With
##
## Ends in an error in state: 783.
##
## series -> seq_expr SEMI . series [ End ]
##
## The known suffix of the stack is as follows:
## seq_expr SEMI
##

Ill-formed sequence of expressions.
At this point, an expression of type 'unit' is expected.
Note: The last expression in a sequence cannot be terminated by a
semicolon ';'.

interactive_expr: Begin Verbatim With
##
## Ends in an error in state: 836.
##
## bin_op(disj_expr_level,BOOL_OR,conj_expr_level) -> disj_expr_level . BOOL_OR conj_expr_level [ SEMI REV_APP Or End COMMA BOOL_OR ]
## bin_op(disj_expr_level,Or,conj_expr_level) -> disj_expr_level . Or conj_expr_level [ SEMI REV_APP Or End COMMA BOOL_OR ]
## bin_op(disj_expr_level,REV_APP,conj_expr_level) -> disj_expr_level . REV_APP conj_expr_level [ SEMI REV_APP Or End COMMA BOOL_OR ]
## seq_expr -> disj_expr_level . [ SEMI End ]
## tuple(disj_expr_level) -> disj_expr_level . COMMA nsepseq(disj_expr_level,COMMA) [ End ]
##
## The known suffix of the stack is as follows:
## disj_expr_level
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 345, spurious reduction of production app_expr_level -> core_expr
## In state 354, spurious reduction of production unary_expr_level -> app_expr_level
## In state 341, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 362, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 368, spurious reduction of production add_expr_level -> mult_expr_level
## In state 404, spurious reduction of production cons_expr_level -> add_expr_level
## In state 391, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 428, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 435, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 444, spurious reduction of production disj_expr_level -> conj_expr_level
##

Ill-formed sequence of expressions.
At this point, if the expression is complete, one of the following is
expected:
  * a semicolon ';' followed by another expression;
  * the keyword 'end' if the sequence is complete.

interactive_expr: UIdent DOT With
##
## Ends in an error in state: 237.
##
## module_path(selected) -> UIdent DOT . module_path(selected) [ With Verbatim VBAR UIdent Type Then TIMES String SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Lxor Lsr Lsl Lor Let Lang Land LT LPAR LE LBRACKET LBRACE Int In Ident GT End Else EQ EOF Directive CONS COMMA COLON CARET Bytes Begin BOOL_OR BOOL_AND Attr ]
## module_path(selected) -> UIdent DOT . selected [ With Verbatim VBAR UIdent Type Then TIMES String SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Lxor Lsr Lsl Lor Let Lang Land LT LPAR LE LBRACKET LBRACE Int In Ident GT End Else EQ EOF Directive CONS COMMA COLON CARET Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## UIdent DOT
##

Ill-formed selection of a value from a module.
At this point, the qualified name of a value is expected.

contract: Type Ident EQ UIdent DOT With
##
## Ends in an error in state: 21.
##
## module_path(__anonymous_5) -> UIdent DOT . module_path(__anonymous_5) [ VBAR UIdent Type TIMES SEMI RPAR RBRACE Module Let In Ident End EQ EOF Directive COMMA Attr ARROW ]
## module_path(__anonymous_5) -> UIdent DOT . Ident [ VBAR UIdent Type TIMES SEMI RPAR RBRACE Module Let In Ident End EQ EOF Directive COMMA Attr ARROW ]
## module_path(__anonymous_6) -> UIdent DOT . module_path(__anonymous_6) [ VBAR UIdent Type TIMES SEMI RPAR RBRACE Module Let In Ident End EQ EOF Directive COMMA Attr ARROW ]
## module_path(__anonymous_6) -> UIdent DOT . par(type_expr) [ VBAR UIdent Type TIMES SEMI RPAR RBRACE Module Let In Ident End EQ EOF Directive COMMA Attr ARROW ]
##
## The known suffix of the stack is as follows:
## UIdent DOT
##

Ill-formed selection of a type in a module.
At this point, the qualified name of a type is expected.

interactive_expr: UIdent DOT Ident DOT With
##
## Ends in an error in state: 260.
##
## field_path -> Ident DOT . nsepseq(selection,DOT) [ With Verbatim VBAR UIdent Type Then TIMES String SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Lxor Lsr Lsl Lor Let Lang Land LT LPAR LE LBRACKET LBRACE Int In Ident GT End Else EQ EOF Directive CONS COMMA COLON CARET Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## Ident DOT
##
interactive_expr: Ident DOT Int DOT With
##
## Ends in an error in state: 264.
##
## nsepseq(selection,DOT) -> selection DOT . nsepseq(selection,DOT) [ With Verbatim VBAR_EQ VBAR UIdent Type Then TIMES_EQ TIMES String SLASH_EQ SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS_EQ PLUS Or Nat NE Mutez Module Mod MINUS_EQ MINUS Lxor Lsr Lsl Lor Let Lang Land LT LPAR LE LBRACKET LBRACE Int In Ident GT End Else EQ EOF Directive CONS COMMA COLON CARET Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## selection DOT
##

Ill-formed selection in a record or a tuple.
At this point, one of the following is expected:
  * the name of a record field;
  * the index of a component in a tuple, '0' denoting the first
    component.

interactive_expr: LBRACE Ident DOT Ident Verbatim
##
## Ends in an error in state: 937.
##
## update_expr -> no_attr_expr . With sep_or_term_list(field_path_assignment,SEMI) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## no_attr_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 263, spurious reduction of production nsepseq(selection,DOT) -> selection
## In state 266, spurious reduction of production field_path -> Ident DOT nsepseq(selection,DOT)
## In state 333, spurious reduction of production local_path -> field_path
## In state 331, spurious reduction of production path_expr -> local_path
## In state 324, spurious reduction of production no_attr_expr -> path_expr
##

Ill-formed record update.
At this point, if the record is fully qualified, then the keyword
'with' is expected, followed by field updates (assignments) separated
by semicolons ';'.

interactive_expr: LBRACE Ident EQ Bytes SEMI Ident EQ Bytes SEMI With
##
## Ends in an error in state: 973.
##
## nsepseq(field_assignment,SEMI) -> field_assignment SEMI . nsepseq(field_assignment,SEMI) [ RBRACE ]
## seq(__anonymous_0(field_assignment,SEMI)) -> field_assignment SEMI . seq(__anonymous_0(field_assignment,SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_assignment SEMI
##
interactive_expr: LBRACE Ident EQ Bytes SEMI With
##
## Ends in an error in state: 968.
##
## nsepseq(field_assignment,SEMI) -> field_assignment SEMI . nsepseq(field_assignment,SEMI) [ RBRACE ]
## nseq(__anonymous_0(field_assignment,SEMI)) -> field_assignment SEMI . seq(__anonymous_0(field_assignment,SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_assignment SEMI
##

Ill-formed record expression.
At this point, one of the following is expected:
  * more field assignments separated by semicolons ';';
  * a closing brace '}' if the record is complete.

interactive_expr: LBRACE Ident EQ Bytes SEMI Ident EQ Bytes With
##
## Ends in an error in state: 972.
##
## nsepseq(field_assignment,SEMI) -> field_assignment . [ RBRACE ]
## nsepseq(field_assignment,SEMI) -> field_assignment . SEMI nsepseq(field_assignment,SEMI) [ RBRACE ]
## seq(__anonymous_0(field_assignment,SEMI)) -> field_assignment . SEMI seq(__anonymous_0(field_assignment,SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_assignment
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 345, spurious reduction of production app_expr_level -> core_expr
## In state 354, spurious reduction of production unary_expr_level -> app_expr_level
## In state 341, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 362, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 368, spurious reduction of production add_expr_level -> mult_expr_level
## In state 404, spurious reduction of production cons_expr_level -> add_expr_level
## In state 391, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 428, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 435, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 444, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 389, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 451, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 452, spurious reduction of production expr -> base_cond__open(expr)
## In state 925, spurious reduction of production field_assignment -> Ident EQ expr
##
interactive_expr: LBRACE Ident EQ Bytes With
##
## Ends in an error in state: 967.
##
## nsepseq(field_assignment,SEMI) -> field_assignment . [ RBRACE ]
## nsepseq(field_assignment,SEMI) -> field_assignment . SEMI nsepseq(field_assignment,SEMI) [ RBRACE ]
## nseq(__anonymous_0(field_assignment,SEMI)) -> field_assignment . SEMI seq(__anonymous_0(field_assignment,SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_assignment
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 345, spurious reduction of production app_expr_level -> core_expr
## In state 354, spurious reduction of production unary_expr_level -> app_expr_level
## In state 341, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 362, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 368, spurious reduction of production add_expr_level -> mult_expr_level
## In state 404, spurious reduction of production cons_expr_level -> add_expr_level
## In state 391, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 428, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 435, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 444, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 389, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 451, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 452, spurious reduction of production expr -> base_cond__open(expr)
## In state 925, spurious reduction of production field_assignment -> Ident EQ expr
##

Ill-formed record expression.
At this point, if the expression assigned to the field is complete,
one of the following is expected:
  * a semicolon ';' followed by another field assignment;
  * a closing brace '}' if the record is complete.

interactive_expr: LBRACE Ident With Ident EQ Bytes SEMI Ident EQ Bytes With
##
## Ends in an error in state: 964.
##
## nsepseq(field_path_assignment,SEMI) -> field_path_assignment . [ RBRACE ]
## nsepseq(field_path_assignment,SEMI) -> field_path_assignment . SEMI nsepseq(field_path_assignment,SEMI) [ RBRACE ]
## seq(__anonymous_0(field_path_assignment,SEMI)) -> field_path_assignment . SEMI seq(__anonymous_0(field_path_assignment,SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_path_assignment
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 345, spurious reduction of production app_expr_level -> core_expr
## In state 354, spurious reduction of production unary_expr_level -> app_expr_level
## In state 341, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 362, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 368, spurious reduction of production add_expr_level -> mult_expr_level
## In state 404, spurious reduction of production cons_expr_level -> add_expr_level
## In state 391, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 428, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 435, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 444, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 389, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 451, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 452, spurious reduction of production expr -> base_cond__open(expr)
## In state 952, spurious reduction of production field_path_assignment -> path field_lens expr
##
interactive_expr: LBRACE Ident With Ident EQ Bytes With
##
## Ends in an error in state: 960.
##
## nsepseq(field_path_assignment,SEMI) -> field_path_assignment . [ RBRACE ]
## nsepseq(field_path_assignment,SEMI) -> field_path_assignment . SEMI nsepseq(field_path_assignment,SEMI) [ RBRACE ]
## nseq(__anonymous_0(field_path_assignment,SEMI)) -> field_path_assignment . SEMI seq(__anonymous_0(field_path_assignment,SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_path_assignment
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 345, spurious reduction of production app_expr_level -> core_expr
## In state 354, spurious reduction of production unary_expr_level -> app_expr_level
## In state 341, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 362, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 368, spurious reduction of production add_expr_level -> mult_expr_level
## In state 404, spurious reduction of production cons_expr_level -> add_expr_level
## In state 391, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 428, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 435, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 444, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 389, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 451, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 452, spurious reduction of production expr -> base_cond__open(expr)
## In state 952, spurious reduction of production field_path_assignment -> path field_lens expr
##

Ill-formed record update.
At this point, if the expression assigned to the field (update) is
complete, one of the following is expected:
  * a semicolon ';' followed by another field assignment;
  * a closing brace '}' if the update is complete.

interactive_expr: LBRACE Ident EQ Bytes SEMI Ident With
##
## Ends in an error in state: 969.
##
## field_assignment -> Ident . EQ expr [ SEMI RBRACE ]
## field_assignment -> Ident . [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## Ident
##

Ill-formed assignment to a field in a record.
At this point, one of the following is expected:
  * an assignment symbol '=', followed by an expression;
  * a semicolon ';', followed by another assignment;
  * a closing brace, if the assignments are complete.

interactive_expr: LBRACE Ident WILD
##
## Ends in an error in state: 256.
##
## field_assignment -> Ident . EQ expr [ SEMI RBRACE ]
## field_assignment -> Ident . [ SEMI RBRACE ]
## field_path -> Ident . DOT nsepseq(selection,DOT) [ With ]
## field_path -> Ident . [ With ]
##
## The known suffix of the stack is as follows:
## Ident
##

Ill-formed record expression or record update.
At this point, one of the following is expected:
  * a semicolon ';', followed by another assignment;
  * the assignment symbol '=' followed by an expression, if defining
    a record (as opposed to a record update);
  * the keyword 'with' followed by field updates (assignments);
  * the selection symbol '.' if the record to update is not fully
    qualified.
  * a closing brace, if the record update is complete.

interactive_expr: LBRACE Ident With Ident DOT Ident With
##
## Ends in an error in state: 944.
##
## field_path_assignment -> path . field_lens expr [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## path
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 263, spurious reduction of production nsepseq(selection,DOT) -> selection
## In state 941, spurious reduction of production projection -> Ident DOT nsepseq(selection,DOT)
## In state 943, spurious reduction of production path -> projection
##

Ill-formed record update.
At this point, the assignment symbol '=' is expected, followed by an
expression (update).

interactive_expr: LBRACE Ident With Ident EQ Bytes SEMI Ident EQ Bytes SEMI With
##
## Ends in an error in state: 965.
##
## nsepseq(field_path_assignment,SEMI) -> field_path_assignment SEMI . nsepseq(field_path_assignment,SEMI) [ RBRACE ]
## seq(__anonymous_0(field_path_assignment,SEMI)) -> field_path_assignment SEMI . seq(__anonymous_0(field_path_assignment,SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_path_assignment SEMI
##
interactive_expr: LBRACE Ident With Ident EQ Bytes SEMI With
##
## Ends in an error in state: 961.
##
## nsepseq(field_path_assignment,SEMI) -> field_path_assignment SEMI . nsepseq(field_path_assignment,SEMI) [ RBRACE ]
## nseq(__anonymous_0(field_path_assignment,SEMI)) -> field_path_assignment SEMI . seq(__anonymous_0(field_path_assignment,SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_path_assignment SEMI
##

Ill-formed record update.
At this point, one of the following is expected:
  * more field assignments (updates) separated by semicolons ';';
  * a closing brace '}' if the update is complete.

interactive_expr: LBRACE Ident With Ident With
##
## Ends in an error in state: 939.
##
## field_path_assignment -> Ident . [ SEMI RBRACE ]
## path -> Ident . [ VBAR_EQ TIMES_EQ SLASH_EQ PLUS_EQ MINUS_EQ EQ ]
## projection -> Ident . DOT nsepseq(selection,DOT) [ VBAR_EQ TIMES_EQ SLASH_EQ PLUS_EQ MINUS_EQ EQ ]
##
## The known suffix of the stack is as follows:
## Ident
##

Ill-formed record update.
At this point, one of the following is expected:
  * the assignment symbol '=' if the field to update is fully
    qualified;
  * the selection symbol '.' to further qualify the field to update.
  * a semicolon, followed by another assignment;
  * a closing brace '}', if the update is complete.

interactive_expr: LBRACE Ident With With
##
## Ends in an error in state: 938.
##
## update_expr -> no_attr_expr With . sep_or_term_list(field_path_assignment,SEMI) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## no_attr_expr With
##

Ill-formed record update.
At this point, assignments to fields (updates) are expected, separated
by semicolons ';' and each starting with fully qualified field names.

interactive_expr: LBRACE With
##
## Ends in an error in state: 254.
##
## braces(option(__anonymous_2(field_assignment))) -> LBRACE . option(__anonymous_2(field_assignment)) RBRACE [ With Verbatim VBAR UIdent Type Then TIMES String SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Lxor Lsr Lsl Lor Let Lang Land LT LPAR LE LBRACKET LBRACE Int In Ident GT End Else EQ EOF Directive CONS COMMA COLON CARET Bytes Begin BOOL_OR BOOL_AND Attr ]
## braces(update_expr) -> LBRACE . update_expr RBRACE [ With Verbatim VBAR UIdent Type Then TIMES String SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Lxor Lsr Lsl Lor Let Lang Land LT LPAR LE LBRACKET LBRACE Int In Ident GT End Else EQ EOF Directive CONS COMMA COLON CARET Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## LBRACE
##

Ill-formed record expression or update.
At this point, one of the following is expected:
  * field assignments separated by semicolons ';', if defining a record;
  * the qualified name of the record to update, otherwise.

interactive_expr: LBRACKET Verbatim SEMI Verbatim With
##
## Ends in an error in state: 984.
##
## nsepseq(expr,SEMI) -> expr . [ RBRACKET ]
## nsepseq(expr,SEMI) -> expr . SEMI nsepseq(expr,SEMI) [ RBRACKET ]
## seq(__anonymous_0(expr,SEMI)) -> expr . SEMI seq(__anonymous_0(expr,SEMI)) [ RBRACKET ]
##
## The known suffix of the stack is as follows:
## expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 345, spurious reduction of production app_expr_level -> core_expr
## In state 354, spurious reduction of production unary_expr_level -> app_expr_level
## In state 341, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 362, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 368, spurious reduction of production add_expr_level -> mult_expr_level
## In state 404, spurious reduction of production cons_expr_level -> add_expr_level
## In state 391, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 428, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 435, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 444, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 389, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 451, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 452, spurious reduction of production expr -> base_cond__open(expr)
##
interactive_expr: LBRACKET Verbatim With
##
## Ends in an error in state: 980.
##
## nsepseq(expr,SEMI) -> expr . [ RBRACKET ]
## nsepseq(expr,SEMI) -> expr . SEMI nsepseq(expr,SEMI) [ RBRACKET ]
## nseq(__anonymous_0(expr,SEMI)) -> expr . SEMI seq(__anonymous_0(expr,SEMI)) [ RBRACKET ]
##
## The known suffix of the stack is as follows:
## expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 345, spurious reduction of production app_expr_level -> core_expr
## In state 354, spurious reduction of production unary_expr_level -> app_expr_level
## In state 341, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 362, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 368, spurious reduction of production add_expr_level -> mult_expr_level
## In state 404, spurious reduction of production cons_expr_level -> add_expr_level
## In state 391, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 428, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 435, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 444, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 389, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 451, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 452, spurious reduction of production expr -> base_cond__open(expr)
##

Ill-formed list of expressions.
At this point, if the list element is complete, one of the
following is expected:
  * a semicolon ';' followed by more elements as expressions;
  * a closing bracket ']' if the list is complete.

interactive_expr: LPAR Verbatim COLON Ident VBAR
##
## Ends in an error in state: 1001.
##
## par(typed_expr) -> LPAR typed_expr . RPAR [ With Verbatim VBAR UIdent Type Then TIMES String SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Lxor Lsr Lsl Lor Let Lang Land LT LPAR LE LBRACKET LBRACE Int In Ident GT End Else EQ EOF Directive CONS COMMA COLON CARET Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## LPAR typed_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 53, spurious reduction of production core_type -> no_attr_type
## In state 72, spurious reduction of production cartesian_level -> core_type
## In state 79, spurious reduction of production fun_type_level -> cartesian_level
## In state 71, spurious reduction of production type_expr -> fun_type_level
## In state 60, spurious reduction of production type_annotation(type_expr) -> COLON type_expr
## In state 1005, spurious reduction of production typed_expr -> expr type_annotation(type_expr)
##

Ill-formed typed expression.
At this point, if the type annotation is complete, then a closing
parenthesis ')' is expected.

interactive_expr: LPAR Verbatim With
##
## Ends in an error in state: 1003.
##
## par(expr) -> LPAR expr . RPAR [ With Verbatim VBAR UIdent Type Then TIMES String SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Lxor Lsr Lsl Lor Let Lang Land LT LPAR LE LBRACKET LBRACE Int In Ident GT End Else EQ EOF Directive DOT CONS COMMA COLON CARET Bytes Begin BOOL_OR BOOL_AND Attr ]
## typed_expr -> expr . type_annotation(type_expr) [ RPAR ]
##
## The known suffix of the stack is as follows:
## LPAR expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 345, spurious reduction of production app_expr_level -> core_expr
## In state 354, spurious reduction of production unary_expr_level -> app_expr_level
## In state 341, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 362, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 368, spurious reduction of production add_expr_level -> mult_expr_level
## In state 404, spurious reduction of production cons_expr_level -> add_expr_level
## In state 391, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 428, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 435, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 444, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 389, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 451, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 452, spurious reduction of production expr -> base_cond__open(expr)
##

Ill formed parenthesised expression.
At this point, if the expression is complete, one of the following is
expected:
  * a type annotation starting with a colon ':';
  * a closing parenthesis ')'.

interactive_expr: Lang Verbatim With
##
## Ends in an error in state: 1014.
##
## code_inj -> Lang expr . RBRACKET [ With Verbatim VBAR UIdent Type Then TIMES String SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Lxor Lsr Lsl Lor Let Lang Land LT LPAR LE LBRACKET LBRACE Int In Ident GT End Else EQ EOF Directive CONS COMMA COLON CARET Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## Lang expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 345, spurious reduction of production app_expr_level -> core_expr
## In state 354, spurious reduction of production unary_expr_level -> app_expr_level
## In state 341, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 362, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 368, spurious reduction of production add_expr_level -> mult_expr_level
## In state 404, spurious reduction of production cons_expr_level -> add_expr_level
## In state 391, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 428, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 435, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 444, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 389, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 451, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 452, spurious reduction of production expr -> base_cond__open(expr)
##

Ill-formed code injection.
At this point, a closing bracket ']' is expected.

interactive_expr: MINUS With
##
## Ends in an error in state: 246.
##
## unary_op(MINUS,app_expr_level) -> MINUS . app_expr_level [ With VBAR Type Then TIMES SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or NE Module Mod MINUS Lxor Lsr Lsl Lor Let Land LT LE In GT End Else EQ EOF Directive CONS COMMA COLON CARET BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## MINUS
##
interactive_expr: Not With
##
## Ends in an error in state: 241.
##
## unary_op(Not,app_expr_level) -> Not . app_expr_level [ With VBAR Type Then TIMES SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or NE Module Mod MINUS Lxor Lsr Lsl Lor Let Land LT LE In GT End Else EQ EOF Directive CONS COMMA COLON CARET BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## Not
##
interactive_expr: Verbatim BOOL_AND With
##
## Ends in an error in state: 412.
##
## bin_op(conj_expr_level,BOOL_AND,comp_expr_level) -> conj_expr_level BOOL_AND . comp_expr_level [ With VBAR Type Then SEMI RPAR REV_APP RBRACKET RBRACE Or Module Let In End Else EOF Directive COMMA COLON BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## conj_expr_level BOOL_AND
##
interactive_expr: Verbatim BOOL_OR With
##
## Ends in an error in state: 448.
##
## bin_op(disj_expr_level,BOOL_OR,conj_expr_level) -> disj_expr_level BOOL_OR . conj_expr_level [ With VBAR Type Then SEMI RPAR REV_APP RBRACKET RBRACE Or Module Let In End Else EOF Directive COMMA COLON BOOL_OR Attr ]
##
## The known suffix of the stack is as follows:
## disj_expr_level BOOL_OR
##
interactive_expr: Verbatim Or With
##
## Ends in an error in state: 437.
##
## bin_op(disj_expr_level,Or,conj_expr_level) -> disj_expr_level Or . conj_expr_level [ With VBAR Type Then SEMI RPAR REV_APP RBRACKET RBRACE Or Module Let In End Else EOF Directive COMMA COLON BOOL_OR Attr ]
##
## The known suffix of the stack is as follows:
## disj_expr_level Or
##
interactive_expr: Bytes REV_APP With
##
## Ends in an error in state: 390.
##
## bin_op(disj_expr_level,REV_APP,conj_expr_level) -> disj_expr_level REV_APP . conj_expr_level [ With VBAR Type Then SEMI RPAR REV_APP RBRACKET RBRACE Or Module Let In End Else EOF Directive COMMA COLON BOOL_OR Attr ]
##
## The known suffix of the stack is as follows:
## disj_expr_level REV_APP
##
interactive_expr: Verbatim CARET With
##
## Ends in an error in state: 392.
##
## bin_op(cons_expr_level,CARET,cat_expr_level) -> cons_expr_level CARET . cat_expr_level [ With VBAR Type Then SEMI RPAR REV_APP RBRACKET RBRACE Or NE Module Let LT LE In GT End Else EQ EOF Directive COMMA COLON BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## cons_expr_level CARET
##
interactive_expr: Verbatim EQ With
##
## Ends in an error in state: 424.
##
## bin_op(comp_expr_level,EQ,cat_expr_level) -> comp_expr_level EQ . cat_expr_level [ With VBAR Type Then SEMI RPAR REV_APP RBRACKET RBRACE Or NE Module Let LT LE In GT End Else EQ EOF Directive COMMA COLON BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## comp_expr_level EQ
##
interactive_expr: Verbatim GT With
##
## Ends in an error in state: 420.
##
## bin_op(comp_expr_level,GT,cat_expr_level) -> comp_expr_level GT . cat_expr_level [ With VBAR Type Then SEMI RPAR REV_APP RBRACKET RBRACE Or NE Module Let LT LE In GT End Else EQ EOF Directive COMMA COLON BOOL_OR BOOL_AND Attr ]
## ge -> GT . ZWSP EQ [ Verbatim UIdent String Not Nat Mutez MINUS Lang LPAR LBRACKET LBRACE Int Ident Bytes Begin Attr ]
##
## The known suffix of the stack is as follows:
## comp_expr_level GT
##
interactive_expr: Bytes GT ZWSP EQ ZWSP
##
## Ends in an error in state: 426.
##
## bin_op(comp_expr_level,ge,cat_expr_level) -> comp_expr_level ge . cat_expr_level [ With VBAR Type Then SEMI RPAR REV_APP RBRACKET RBRACE Or NE Module Let LT LE In GT End Else EQ EOF Directive COMMA COLON BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## comp_expr_level ge
##
interactive_expr: Verbatim LE With
##
## Ends in an error in state: 418.
##
## bin_op(comp_expr_level,LE,cat_expr_level) -> comp_expr_level LE . cat_expr_level [ With VBAR Type Then SEMI RPAR REV_APP RBRACKET RBRACE Or NE Module Let LT LE In GT End Else EQ EOF Directive COMMA COLON BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## comp_expr_level LE
##
interactive_expr: Verbatim LT With
##
## Ends in an error in state: 416.
##
## bin_op(comp_expr_level,LT,cat_expr_level) -> comp_expr_level LT . cat_expr_level [ With VBAR Type Then SEMI RPAR REV_APP RBRACKET RBRACE Or NE Module Let LT LE In GT End Else EQ EOF Directive COMMA COLON BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## comp_expr_level LT
##
interactive_expr: Verbatim NE With
##
## Ends in an error in state: 414.
##
## bin_op(comp_expr_level,NE,cat_expr_level) -> comp_expr_level NE . cat_expr_level [ With VBAR Type Then SEMI RPAR REV_APP RBRACKET RBRACE Or NE Module Let LT LE In GT End Else EQ EOF Directive COMMA COLON BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## comp_expr_level NE
##
interactive_expr: Verbatim MINUS With
##
## Ends in an error in state: 407.
##
## bin_op(add_expr_level,MINUS,mult_expr_level) -> add_expr_level MINUS . mult_expr_level [ With VBAR Type Then SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or NE Module MINUS Let LT LE In GT End Else EQ EOF Directive CONS COMMA COLON CARET BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## add_expr_level MINUS
##
interactive_expr: Verbatim Mod With
##
## Ends in an error in state: 373.
##
## bin_op(mult_expr_level,Mod,shift_expr_level) -> mult_expr_level Mod . shift_expr_level [ With VBAR Type Then TIMES SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or NE Module Mod MINUS Lxor Lor Let Land LT LE In GT End Else EQ EOF Directive CONS COMMA COLON CARET BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## mult_expr_level Mod
##
interactive_expr: Verbatim PLUS With
##
## Ends in an error in state: 405.
##
## bin_op(add_expr_level,PLUS,mult_expr_level) -> add_expr_level PLUS . mult_expr_level [ With VBAR Type Then SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or NE Module MINUS Let LT LE In GT End Else EQ EOF Directive CONS COMMA COLON CARET BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## add_expr_level PLUS
##
interactive_expr: Verbatim SLASH With
##
## Ends in an error in state: 371.
##
## bin_op(mult_expr_level,SLASH,shift_expr_level) -> mult_expr_level SLASH . shift_expr_level [ With VBAR Type Then TIMES SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or NE Module Mod MINUS Lxor Lor Let Land LT LE In GT End Else EQ EOF Directive CONS COMMA COLON CARET BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## mult_expr_level SLASH
##
interactive_expr: Verbatim TIMES With
##
## Ends in an error in state: 369.
##
## bin_op(mult_expr_level,TIMES,shift_expr_level) -> mult_expr_level TIMES . shift_expr_level [ With VBAR Type Then TIMES SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or NE Module Mod MINUS Lxor Lor Let Land LT LE In GT End Else EQ EOF Directive CONS COMMA COLON CARET BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## mult_expr_level TIMES
##
interactive_expr: Verbatim Lsr With
##
## Ends in an error in state: 342.
##
## bin_op(unary_expr_level,Lsr,shift_expr_level) -> unary_expr_level Lsr . shift_expr_level [ With VBAR Type Then TIMES SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or NE Module Mod MINUS Lxor Lor Let Land LT LE In GT End Else EQ EOF Directive CONS COMMA COLON CARET BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## unary_expr_level Lsr
##
interactive_expr: Verbatim Lsl With
##
## Ends in an error in state: 356.
##
## bin_op(unary_expr_level,Lsl,shift_expr_level) -> unary_expr_level Lsl . shift_expr_level [ With VBAR Type Then TIMES SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or NE Module Mod MINUS Lxor Lor Let Land LT LE In GT End Else EQ EOF Directive CONS COMMA COLON CARET BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## unary_expr_level Lsl
##
interactive_expr: Verbatim Lxor With
##
## Ends in an error in state: 375.
##
## bin_op(mult_expr_level,Lxor,shift_expr_level) -> mult_expr_level Lxor . shift_expr_level [ With VBAR Type Then TIMES SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or NE Module Mod MINUS Lxor Lor Let Land LT LE In GT End Else EQ EOF Directive CONS COMMA COLON CARET BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## mult_expr_level Lxor
##
interactive_expr: Verbatim Lor With
##
## Ends in an error in state: 377.
##
## bin_op(mult_expr_level,Lor,shift_expr_level) -> mult_expr_level Lor . shift_expr_level [ With VBAR Type Then TIMES SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or NE Module Mod MINUS Lxor Lor Let Land LT LE In GT End Else EQ EOF Directive CONS COMMA COLON CARET BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## mult_expr_level Lor
##
interactive_expr: Verbatim Land With
##
## Ends in an error in state: 379.
##
## bin_op(mult_expr_level,Land,shift_expr_level) -> mult_expr_level Land . shift_expr_level [ With VBAR Type Then TIMES SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or NE Module Mod MINUS Lxor Lor Let Land LT LE In GT End Else EQ EOF Directive CONS COMMA COLON CARET BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## mult_expr_level Land
##

Ill-formed expression.
At this point, an expression is expected.
Hint: To check your understanding of the syntax, try and add
parentheses around what you think is the expression.

interactive_expr: Verbatim COMMA Verbatim COMMA With
##
## Ends in an error in state: 442.
##
## nsepseq(disj_expr_level,COMMA) -> disj_expr_level COMMA . nsepseq(disj_expr_level,COMMA) [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End Else EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## disj_expr_level COMMA
##
interactive_expr: Verbatim COMMA With
##
## Ends in an error in state: 439.
##
## tuple(disj_expr_level) -> disj_expr_level COMMA . nsepseq(disj_expr_level,COMMA) [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End Else EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## disj_expr_level COMMA
##

Ill-formed tuple of expressions.
At this point, another component is expected as an expression.
Hint: To check your understanding of the syntax, try and add
parentheses around what you think is the expression.

interactive_expr: Verbatim CONS With
##
## Ends in an error in state: 409.
##
## bin_op(add_expr_level,CONS,cons_expr_level) -> add_expr_level CONS . cons_expr_level [ With VBAR Type Then SEMI RPAR REV_APP RBRACKET RBRACE Or NE Module Let LT LE In GT End Else EQ EOF Directive COMMA COLON CARET BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## add_expr_level CONS
##

Ill-formed list expression.
At this point, an expression of type list is expected.

interactive_expr: UIdent DOT UIdent With
##
## Ends in an error in state: 1071.
##
## interactive_expr -> expr . EOF [ # ]
##
## The known suffix of the stack is as follows:
## expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 238, spurious reduction of production selected -> UIdent
## In state 1018, spurious reduction of production module_path(selected) -> UIdent DOT selected
## In state 330, spurious reduction of production path_expr -> module_path(selected)
## In state 324, spurious reduction of production no_attr_expr -> path_expr
## In state 329, spurious reduction of production core_expr -> no_attr_expr
## In state 345, spurious reduction of production app_expr_level -> core_expr
## In state 354, spurious reduction of production unary_expr_level -> app_expr_level
## In state 341, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 362, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 368, spurious reduction of production add_expr_level -> mult_expr_level
## In state 404, spurious reduction of production cons_expr_level -> add_expr_level
## In state 391, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 428, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 435, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 444, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 389, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 451, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 452, spurious reduction of production expr -> base_cond__open(expr)
##

Ill-formed selection of a value from a module.
At this point, the selection symbol '.' is expected, followed by the
qualified name of a value.

contract: Let Ident WILD COLON String VBAR
##
## Ends in an error in state: 1029.
##
## let_binding -> var_pattern parameters type_annotation(type_expr) . EQ expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## var_pattern parameters type_annotation(type_expr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 53, spurious reduction of production core_type -> no_attr_type
## In state 72, spurious reduction of production cartesian_level -> core_type
## In state 79, spurious reduction of production fun_type_level -> cartesian_level
## In state 71, spurious reduction of production type_expr -> fun_type_level
## In state 60, spurious reduction of production type_annotation(type_expr) -> COLON type_expr
##
contract: Let WILD COLON Ident VBAR
##
## Ends in an error in state: 1023.
##
## let_binding -> var_pattern type_annotation(type_expr) . EQ expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## var_pattern type_annotation(type_expr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 53, spurious reduction of production core_type -> no_attr_type
## In state 72, spurious reduction of production cartesian_level -> core_type
## In state 79, spurious reduction of production fun_type_level -> cartesian_level
## In state 71, spurious reduction of production type_expr -> fun_type_level
## In state 60, spurious reduction of production type_annotation(type_expr) -> COLON type_expr
##
contract: Let LPAR RPAR COLON Ident With
##
## Ends in an error in state: 53.
##
## core_type -> no_attr_type . [ VBAR Type TIMES SEMI RPAR RBRACE Module Let In End EQ EOF Directive COMMA Attr ARROW ]
## type_ctor_arg -> no_attr_type . [ UIdent Ident ]
##
## The known suffix of the stack is as follows:
## no_attr_type
##

Ill-formed value declaration.
At this point, if the type annotation is complete, the assignment
symbol '=' is expected, followed by an expression.

contract: Let LBRACE Ident With
##
## Ends in an error in state: 187.
##
## field_pattern(irrefutable) -> field_pattern_lhs . [ SEMI RBRACE ]
## field_pattern(irrefutable) -> field_pattern_lhs . EQ tuple(core_irrefutable) [ SEMI RBRACE ]
## field_pattern(irrefutable) -> field_pattern_lhs . EQ unit [ SEMI RBRACE ]
## field_pattern(irrefutable) -> field_pattern_lhs . EQ record_pattern(irrefutable) [ SEMI RBRACE ]
## field_pattern(irrefutable) -> field_pattern_lhs . EQ par(in_core_irrefutable) [ SEMI RBRACE ]
## field_pattern(irrefutable) -> field_pattern_lhs . EQ var_pattern [ SEMI RBRACE ]
## field_pattern(irrefutable) -> field_pattern_lhs . EQ ctor_irrefutable [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## field_pattern_lhs
##
interactive_expr: Match Verbatim With LBRACE Ident With
##
## Ends in an error in state: 502.
##
## field_pattern(core_pattern) -> field_pattern_lhs . [ SEMI RBRACE ]
## field_pattern(core_pattern) -> field_pattern_lhs . EQ core_pattern [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## field_pattern_lhs
##

Ill-formed record pattern.
At this point, one of the following is expected:
  * the assignment symbol '=' followed by a pattern;
  * a semicolon ';' if the field is punned (that is, a variable with
    the same name denotes implicitly the pattern);
  * a closing brace '}' if the record pattern is complete.

contract: Let LBRACE With
##
## Ends in an error in state: 138.
##
## braces(option(__anonymous_2(field_pattern(irrefutable)))) -> LBRACE . option(__anonymous_2(field_pattern(irrefutable))) RBRACE [ WILD UIdent SEMI RPAR RBRACE LPAR LBRACE Ident EQ COMMA COLON Attr ARROW ]
##
## The known suffix of the stack is as follows:
## LBRACE
##
interactive_expr: Match Verbatim With LBRACE With
##
## Ends in an error in state: 468.
##
## braces(option(__anonymous_2(field_pattern(core_pattern)))) -> LBRACE . option(__anonymous_2(field_pattern(core_pattern))) RBRACE [ SEMI RPAR RBRACKET RBRACE CONS COMMA COLON ARROW ]
##
## The known suffix of the stack is as follows:
## LBRACE
##

Ill-formed record pattern.
At this point, field patterns are expected, separated by semicolons ';'.

contract: Let LPAR UIdent UIdent With
##
## Ends in an error in state: 219.
##
## par(non_const_ctor_irrefutable) -> LPAR non_const_ctor_irrefutable . RPAR [ WILD UIdent SEMI RPAR RBRACE LPAR LBRACE Ident EQ COMMA COLON Attr ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR non_const_ctor_irrefutable
##

Ill-formed parenthesised pattern.
At this point, if the enclosed pattern is complete, a closing
parenthesis ')' is expected.

contract: Let LPAR WILD COMMA Ident With
##
## Ends in an error in state: 153.
##
## nsepseq(core_irrefutable,COMMA) -> var_pattern . [ SEMI RPAR RBRACE LPAR EQ COLON ]
## nsepseq(core_irrefutable,COMMA) -> var_pattern . COMMA nsepseq(core_irrefutable,COMMA) [ SEMI RPAR RBRACE LPAR EQ COLON ]
##
## The known suffix of the stack is as follows:
## var_pattern
##

Ill-formed parenthesised pattern.
At this point, if the enclosed pattern is complete, one of the
following is expected:
  * a type annotation starting with a colon ':', followed by a closing
    parenthesis ')';
  * a closing parenthesis ')'.

contract: Let LPAR RPAR With
##
## Ends in an error in state: 250.
##
## let_binding -> unit . EQ expr [ Type Module Let In End EOF Directive Attr ]
## let_binding -> unit . type_annotation(type_expr) EQ expr [ Type Module Let In End EOF Directive Attr ]
## let_binding -> unit . par(__anonymous_7) EQ expr [ Type Module Let In End EOF Directive Attr ]
## let_binding -> unit . par(__anonymous_7) type_annotation(type_expr) EQ expr [ Type Module Let In End EOF Directive Attr ]
## tuple(core_irrefutable) -> unit . COMMA nsepseq(core_irrefutable,COMMA) [ LPAR EQ COLON ]
##
## The known suffix of the stack is as follows:
## unit
##

Ill-formed value declaration.
At this point, one of the following is expected:
  * a type annotation starting with a colon ':';
  * the assignment symbol '=' followed by an expression;
  * a comma ',' followed by another component as a pattern, if
    defining a tuple.

contract: Type Ident EQ LBRACE Ident COLON UIdent SEMI Ident COLON Ident VBAR
##
## Ends in an error in state: 97.
##
## nsepseq(field_decl,SEMI) -> field_decl . [ RBRACE ]
## nsepseq(field_decl,SEMI) -> field_decl . SEMI nsepseq(field_decl,SEMI) [ RBRACE ]
## seq(__anonymous_0(field_decl,SEMI)) -> field_decl . SEMI seq(__anonymous_0(field_decl,SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_decl
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 53, spurious reduction of production core_type -> no_attr_type
## In state 72, spurious reduction of production cartesian_level -> core_type
## In state 79, spurious reduction of production fun_type_level -> cartesian_level
## In state 71, spurious reduction of production type_expr -> fun_type_level
## In state 60, spurious reduction of production type_annotation(type_expr) -> COLON type_expr
## In state 82, spurious reduction of production field_decl -> Ident type_annotation(type_expr)
##
contract: Type Ident EQ LBRACE Ident COLON Ident VBAR
##
## Ends in an error in state: 93.
##
## nsepseq(field_decl,SEMI) -> field_decl . [ RBRACE ]
## nsepseq(field_decl,SEMI) -> field_decl . SEMI nsepseq(field_decl,SEMI) [ RBRACE ]
## nseq(__anonymous_0(field_decl,SEMI)) -> field_decl . SEMI seq(__anonymous_0(field_decl,SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_decl
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 53, spurious reduction of production core_type -> no_attr_type
## In state 72, spurious reduction of production cartesian_level -> core_type
## In state 79, spurious reduction of production fun_type_level -> cartesian_level
## In state 71, spurious reduction of production type_expr -> fun_type_level
## In state 60, spurious reduction of production type_annotation(type_expr) -> COLON type_expr
## In state 82, spurious reduction of production field_decl -> Ident type_annotation(type_expr)
##

Ill-formed record type.
At this point, if the field is complete, one of the following is
expected:
  * a semicolon ';' followed by another field declaration;
  * a closing brace '}' if the record type is complete.

contract: Type Ident EQ LBRACE With
##
## Ends in an error in state: 27.
##
## braces(option(__anonymous_2(field_decl))) -> LBRACE . option(__anonymous_2(field_decl)) RBRACE [ VBAR UIdent Type TIMES SEMI RPAR RBRACE Module Let In Ident End EQ EOF Directive COMMA Attr ARROW ]
##
## The known suffix of the stack is as follows:
## LBRACE
##

Ill-formed record type.
At this point, field declarations are expected, separated by
semicolons ';'.

contract: Type Ident EQ LPAR String COMMA String VBAR
##
## Ends in an error in state: 103.
##
## nsepseq(type_expr,COMMA) -> type_expr . [ RPAR ]
## nsepseq(type_expr,COMMA) -> type_expr . COMMA nsepseq(type_expr,COMMA) [ RPAR ]
##
## The known suffix of the stack is as follows:
## type_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 53, spurious reduction of production core_type -> no_attr_type
## In state 72, spurious reduction of production cartesian_level -> core_type
## In state 79, spurious reduction of production fun_type_level -> cartesian_level
## In state 71, spurious reduction of production type_expr -> fun_type_level
##

Ill-formed argument to a type constructor.
At this point, if the tuple component is complete, one of the
following is expected:
  * a comma ',' followed by another component as a type expression;
  * a closing parenthesis ')' if the tuple is complete.

contract: Type Ident EQ LPAR String VBAR
##
## Ends in an error in state: 100.
##
## par(type_expr) -> LPAR type_expr . RPAR [ VBAR UIdent Type TIMES SEMI RPAR RBRACE Module Let In Ident End EQ EOF Directive COMMA Attr ARROW ]
## tuple(type_expr) -> type_expr . COMMA nsepseq(type_expr,COMMA) [ RPAR ]
##
## The known suffix of the stack is as follows:
## LPAR type_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 53, spurious reduction of production core_type -> no_attr_type
## In state 72, spurious reduction of production cartesian_level -> core_type
## In state 79, spurious reduction of production fun_type_level -> cartesian_level
## In state 71, spurious reduction of production type_expr -> fun_type_level
##

Ill-formed parenthesised type or argument to a type constructor.
At this point, one of the following is expected:
  * a closing parenthesis if the type is complete;
  * a comma ',' followed by another type expression, if defining the
    argument to a type constructor.

contract: Type Ident EQ String ARROW With
##
## Ends in an error in state: 80.
##
## fun_type_level -> cartesian_level ARROW . fun_type_level [ VBAR Type SEMI RPAR RBRACE Module Let In End EQ EOF Directive COMMA Attr ]
##
## The known suffix of the stack is as follows:
## cartesian_level ARROW
##

Ill-formed functional type.
At this point, a type expression is expected.
Note: If you want a sum type, enclose it between parentheses.

interactive_expr: Fun Ident COLON UIdent Of With
##
## Ends in an error in state: 291.
##
## of_type(cartesian_level) -> Of . cartesian_level [ VBAR ARROW ]
##
## The known suffix of the stack is as follows:
## Of
##
contract: Let Ident COLON UIdent Of With
##
## Ends in an error in state: 19.
##
## of_type(fun_type_level) -> Of . fun_type_level [ VBAR Type SEMI RPAR RBRACE Module Let In End EQ EOF Directive COMMA Attr ]
##
## The known suffix of the stack is as follows:
## Of
##

Ill-formed parameter of a variant.
At this point, a type expression is expected.
Note: If you want a sum type, enclose it between parentheses.

contract: Type Ident EQ String TIMES UIdent With
##
## Ends in an error in state: 20.
##
## module_path(__anonymous_5) -> UIdent . DOT module_path(__anonymous_5) [ VBAR UIdent Type TIMES SEMI RPAR RBRACE Module Let In Ident End EQ EOF Directive COMMA Attr ARROW ]
## module_path(__anonymous_5) -> UIdent . DOT Ident [ VBAR UIdent Type TIMES SEMI RPAR RBRACE Module Let In Ident End EQ EOF Directive COMMA Attr ARROW ]
## module_path(__anonymous_6) -> UIdent . DOT module_path(__anonymous_6) [ VBAR UIdent Type TIMES SEMI RPAR RBRACE Module Let In Ident End EQ EOF Directive COMMA Attr ARROW ]
## module_path(__anonymous_6) -> UIdent . DOT par(type_expr) [ VBAR UIdent Type TIMES SEMI RPAR RBRACE Module Let In Ident End EQ EOF Directive COMMA Attr ARROW ]
##
## The known suffix of the stack is as follows:
## UIdent
##

Ill-formed selection of a type in a module.
At this point, the selection symbol '.' is expected, followed by the
qualified name of a type.

contract: Type Ident EQ String TIMES String TIMES With
##
## Ends in an error in state: 77.
##
## nsepseq(core_type,TIMES) -> core_type TIMES . nsepseq(core_type,TIMES) [ VBAR Type SEMI RPAR RBRACE Module Let In End EQ EOF Directive COMMA Attr ARROW ]
##
## The known suffix of the stack is as follows:
## core_type TIMES
##
contract: Type Ident EQ String TIMES With
##
## Ends in an error in state: 73.
##
## cartesian_level -> core_type TIMES . nsepseq(core_type,TIMES) [ VBAR Type SEMI RPAR RBRACE Module Let In End EQ EOF Directive COMMA Attr ARROW ]
##
## The known suffix of the stack is as follows:
## core_type TIMES
##

Ill-formed product type.
At this point, a type expression is expected.
Hint: If you want a sum type, put it between parentheses.

contract: Type Ident EQ VBAR With
##
## Ends in an error in state: 17.
##
## long_variant(fun_type_level) -> VBAR . short_variant(fun_type_level) [ VBAR Type SEMI RPAR RBRACE Module Let In End EQ EOF Directive COMMA Attr ]
##
## The known suffix of the stack is as follows:
## VBAR
##
interactive_expr: Fun Ident COLON VBAR With
##
## Ends in an error in state: 289.
##
## long_variant(cartesian_level) -> VBAR . short_variant(cartesian_level) [ VBAR ARROW ]
##
## The known suffix of the stack is as follows:
## VBAR
##

Ill-formed variant of sum type.
At this point, a variant starting with a data constructor is expected.

contract: Type With
##
## Ends in an error in state: 1.
##
## type_decl -> Type . Ident EQ type_expr [ Type Module Let In End EOF Directive Attr ]
## type_decl -> Type . type_vars Ident EQ type_expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## Type
##

Ill-formed type declaration.
At this point, one of the following is expected:
  * the name of the type being defined;
  * a quoted type parameter, like 'a;
  * a tuple of quoted type parameters, like ('a, 'b).

interactive_expr: Type Ident EQ UIdent With
##
## Ends in an error in state: 23.
##
## module_path(__anonymous_5) -> UIdent . DOT module_path(__anonymous_5) [ UIdent Type TIMES SEMI RPAR RBRACE Module Let In Ident End EQ EOF Directive COMMA Attr ARROW ]
## module_path(__anonymous_5) -> UIdent . DOT Ident [ UIdent Type TIMES SEMI RPAR RBRACE Module Let In Ident End EQ EOF Directive COMMA Attr ARROW ]
## module_path(__anonymous_6) -> UIdent . DOT module_path(__anonymous_6) [ UIdent Type TIMES SEMI RPAR RBRACE Module Let In Ident End EQ EOF Directive COMMA Attr ARROW ]
## module_path(__anonymous_6) -> UIdent . DOT par(type_expr) [ UIdent Type TIMES SEMI RPAR RBRACE Module Let In Ident End EQ EOF Directive COMMA Attr ARROW ]
## short_variant(fun_type_level) -> UIdent . [ VBAR Type SEMI RPAR RBRACE Module Let In End EQ EOF Directive COMMA Attr ]
## short_variant(fun_type_level) -> UIdent . of_type(fun_type_level) [ VBAR Type SEMI RPAR RBRACE Module Let In End EQ EOF Directive COMMA Attr ]
##
## The known suffix of the stack is as follows:
## UIdent
##

Ill-formed local type declaration.
At this point, if the type expression is complete, the keyword 'in' is
expected, followed by an expression.

contract: Directive With
##
## Ends in an error in state: 1061.
##
## nseq(top_declaration) -> top_declaration . seq(top_declaration) [ EOF ]
##
## The known suffix of the stack is as follows:
## top_declaration
##
contract: Directive Directive With
##
## Ends in an error in state: 1062.
##
## seq(top_declaration) -> top_declaration . seq(top_declaration) [ EOF ]
##
## The known suffix of the stack is as follows:
## top_declaration
##

Ill-formed contract.
At this point, if the declaration is complete, one of the following is
expected:
  * another declaration;
  * the end of the file.

contract: Module UIdent EQ Struct Type Ident EQ UIdent EOF
##
## Ends in an error in state: 1055.
##
## seq(declaration) -> declaration . seq(declaration) [ End ]
##
## The known suffix of the stack is as follows:
## declaration
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 23, spurious reduction of production short_variant(fun_type_level) -> UIdent
## In state 61, spurious reduction of production variant_type(fun_type_level) -> short_variant(fun_type_level)
## In state 59, spurious reduction of production type_expr -> variant_type(fun_type_level)
## In state 117, spurious reduction of production type_decl -> Type Ident EQ type_expr
## In state 1048, spurious reduction of production declaration -> type_decl
##

Ill-formed module declaration.
At this point, if the declaration is complete, one of the following is
expected:
  * another declaration;
  * the end of the file.

contract: Module UIdent EQ With
##
## Ends in an error in state: 126.
##
## module_decl -> Module UIdent EQ . module_expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## Module UIdent EQ
##

Ill-formed module declaration or module alias declaration.
At this point, one of the following is expected:
  * the qualified name of a module being aliased;
  * the keyword 'struct' followed by declarations, if
    defining a module.

contract: Module UIdent With
##
## Ends in an error in state: 125.
##
## module_decl -> Module UIdent . EQ module_expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## Module UIdent
##

Ill-formed module declaration.
At this point, the assignment symbol '=' is expected to introduce
either the qualified name of a module being aliased, or a module
structure.

contract: Module With
##
## Ends in an error in state: 124.
##
## module_decl -> Module . UIdent EQ module_expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## Module
##

Ill-formed module declaration.
At this point, the name of the module being declared or aliased is
expected.

interactive_expr: Begin If Verbatim Then Module UIdent EQ Struct Type Ident EQ UIdent End With
##
## Ends in an error in state: 806.
##
## local_module_decl(closed_expr) -> module_decl . In closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## module_decl
##

Ill-formed local module declaration.
At this point, the keyword 'in' is expected, followed by an
expression.

interactive_expr: Module UIdent EQ UIdent Type
##
## Ends in an error in state: 366.
##
## local_module_decl(expr) -> module_decl . In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## module_decl
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 127, spurious reduction of production module_expr -> UIdent
## In state 1059, spurious reduction of production module_decl -> Module UIdent EQ module_expr
##
interactive_expr: Match Verbatim With WILD ARROW If Verbatim Then Module UIdent EQ UIdent Type
##
## Ends in an error in state: 626.
##
## local_module_decl(base_cond) -> module_decl . In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## local_module_decl(closed_expr) -> module_decl . In closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## module_decl
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 127, spurious reduction of production module_expr -> UIdent
## In state 1059, spurious reduction of production module_decl -> Module UIdent EQ module_expr
##
interactive_expr: If Verbatim Then Match Verbatim With WILD ARROW Module UIdent EQ UIdent Type
##
## Ends in an error in state: 729.
##
## local_module_decl(base_cond) -> module_decl . In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## local_module_decl(base_if_then_else) -> module_decl . In base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## module_decl
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 127, spurious reduction of production module_expr -> UIdent
## In state 1059, spurious reduction of production module_decl -> Module UIdent EQ module_expr
##
interactive_expr: Match Verbatim With WILD ARROW Module UIdent EQ UIdent Type
##
## Ends in an error in state: 663.
##
## local_module_decl(base_cond) -> module_decl . In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## module_decl
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 127, spurious reduction of production module_expr -> UIdent
## In state 1059, spurious reduction of production module_decl -> Module UIdent EQ module_expr
##
interactive_expr: If Verbatim Then Module UIdent EQ UIdent Type
##
## Ends in an error in state: 906.
##
## local_module_decl(closed_expr) -> module_decl . In closed_expr [ Else ]
## local_module_decl(expr) -> module_decl . In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## module_decl
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 127, spurious reduction of production module_expr -> UIdent
## In state 1059, spurious reduction of production module_decl -> Module UIdent EQ module_expr
##

Ill-formed local module declaration.
At this point, if the module to be aliased is fully qualified, the
keyword 'in' is expected, followed by an expression.

contract: Module UIdent EQ UIdent DOT With
##
## Ends in an error in state: 128.
##
## module_path(module_name) -> UIdent DOT . module_path(module_name) [ Type Module Let In End EOF Directive Attr ]
## module_path(module_name) -> UIdent DOT . UIdent [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## UIdent DOT
##

Ill-formed module qualification.
At this point, a module name is expected.

contract: Type QUOTE With
##
## Ends in an error in state: 3.
##
## quoted_type_var -> QUOTE . Ident [ VBAR UIdent Type TIMES SEMI RPAR RBRACE Module Let In Ident End EQ EOF Directive COMMA Attr ARROW ]
##
## The known suffix of the stack is as follows:
## QUOTE
##

Ill-formed quoted type parameter.
At this point, an identifier is expected.

contract: Type QUOTE Ident With
##
## Ends in an error in state: 118.
##
## type_decl -> Type type_vars . Ident EQ type_expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## Type type_vars
##

Ill-formed parametric type declaration.
At this point, the name of the type being defined is expected.

interactive_expr: Match Verbatim With LBRACE Ident SEMI Ident EQ Bytes With
##
## Ends in an error in state: 509.
##
## nsepseq(field_pattern(core_pattern),SEMI) -> field_pattern(core_pattern) . [ RBRACE ]
## nsepseq(field_pattern(core_pattern),SEMI) -> field_pattern(core_pattern) . SEMI nsepseq(field_pattern(core_pattern),SEMI) [ RBRACE ]
## seq(__anonymous_0(field_pattern(core_pattern),SEMI)) -> field_pattern(core_pattern) . SEMI seq(__anonymous_0(field_pattern(core_pattern),SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_pattern(core_pattern)
##
interactive_expr: Match Verbatim With LBRACE Ident EQ Bytes With
##
## Ends in an error in state: 505.
##
## nsepseq(field_pattern(core_pattern),SEMI) -> field_pattern(core_pattern) . [ RBRACE ]
## nsepseq(field_pattern(core_pattern),SEMI) -> field_pattern(core_pattern) . SEMI nsepseq(field_pattern(core_pattern),SEMI) [ RBRACE ]
## nseq(__anonymous_0(field_pattern(core_pattern),SEMI)) -> field_pattern(core_pattern) . SEMI seq(__anonymous_0(field_pattern(core_pattern),SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_pattern(core_pattern)
##

Ill-formed record pattern.
At this point, if the field pattern is complete, one of the following
is expected:
  * a semicolon ';' followed by another field pattern;
  * a closing brace '}' if the record pattern is complete.

interactive_expr: Fun LBRACE Ident SEMI With
##
## Ends in an error in state: 196.
##
## nsepseq(field_pattern(irrefutable),SEMI) -> field_pattern(irrefutable) SEMI . nsepseq(field_pattern(irrefutable),SEMI) [ RBRACE ]
## nseq(__anonymous_0(field_pattern(irrefutable),SEMI)) -> field_pattern(irrefutable) SEMI . seq(__anonymous_0(field_pattern(irrefutable),SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_pattern(irrefutable) SEMI
##
interactive_expr: Fun LBRACE Ident SEMI Ident SEMI With
##
## Ends in an error in state: 200.
##
## nsepseq(field_pattern(irrefutable),SEMI) -> field_pattern(irrefutable) SEMI . nsepseq(field_pattern(irrefutable),SEMI) [ RBRACE ]
## seq(__anonymous_0(field_pattern(irrefutable),SEMI)) -> field_pattern(irrefutable) SEMI . seq(__anonymous_0(field_pattern(irrefutable),SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_pattern(irrefutable) SEMI
##
interactive_expr: Match Verbatim With LBRACE Ident SEMI With
##
## Ends in an error in state: 506.
##
## nsepseq(field_pattern(core_pattern),SEMI) -> field_pattern(core_pattern) SEMI . nsepseq(field_pattern(core_pattern),SEMI) [ RBRACE ]
## nseq(__anonymous_0(field_pattern(core_pattern),SEMI)) -> field_pattern(core_pattern) SEMI . seq(__anonymous_0(field_pattern(core_pattern),SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_pattern(core_pattern) SEMI
##
interactive_expr: Match Verbatim With LBRACE Ident SEMI Ident SEMI With
##
## Ends in an error in state: 510.
##
## nsepseq(field_pattern(core_pattern),SEMI) -> field_pattern(core_pattern) SEMI . nsepseq(field_pattern(core_pattern),SEMI) [ RBRACE ]
## seq(__anonymous_0(field_pattern(core_pattern),SEMI)) -> field_pattern(core_pattern) SEMI . seq(__anonymous_0(field_pattern(core_pattern),SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_pattern(core_pattern) SEMI
##

Ill-formed record pattern.
At this point, if the field pattern is complete, one of the following
is expected:
  * another field pattern starting with a field name;
  * a closing brace '}' if the record pattern is complete.

contract: Let Ident LPAR Type With
##
## Ends in an error in state: 227.
##
## par(__anonymous_7) -> LPAR Type . nseq(variable) RPAR [ WILD UIdent LPAR LBRACE Ident EQ COLON Attr ]
##
## The known suffix of the stack is as follows:
## LPAR Type
##

Ill-formed type parameter.
At this point, a type parameter without a quote is expected.

contract: Let Ident LPAR Type Ident With
##
## Ends in an error in state: 228.
##
## nseq(variable) -> Ident . seq(variable) [ RPAR ]
##
## The known suffix of the stack is as follows:
## Ident
##
contract: Let Ident LPAR Type Ident Ident With
##
## Ends in an error in state: 229.
##
## seq(variable) -> Ident . seq(variable) [ RPAR ]
##
## The known suffix of the stack is as follows:
## Ident
##

Ill-formed type parameters.
At this point, one of the following is expected:
  * a type parameter without a quote;
  * a closing parenthesis ')' if there are no more parameters.

interactive_expr: Match Verbatim With LBRACKET WILD With
##
## Ends in an error in state: 517.
##
## cons_pattern_level -> core_pattern . CONS cons_pattern_level [ SEMI RPAR RBRACKET COMMA COLON ARROW ]
## cons_pattern_level -> core_pattern . [ SEMI RPAR RBRACKET COMMA COLON ARROW ]
##
## The known suffix of the stack is as follows:
## core_pattern
##

Ill-formed list of patterns.
At this point, if the element as a pattern is complete, one of
the following is expected:
  * a semicolon ';' followed by another pattern;
  * a closing bracket ']' if the list is complete.

contract: Type LPAR With
##
## Ends in an error in state: 5.
##
## par(tuple(type_var)) -> LPAR . tuple(type_var) RPAR [ Ident ]
##
## The known suffix of the stack is as follows:
## LPAR
##
contract: Type LPAR QUOTE Ident COMMA QUOTE Ident COMMA With
##
## Ends in an error in state: 9.
##
## nsepseq(type_var,COMMA) -> type_var COMMA . nsepseq(type_var,COMMA) [ RPAR ]
##
## The known suffix of the stack is as follows:
## type_var COMMA
##
contract: Type LPAR QUOTE Ident COMMA With
##
## Ends in an error in state: 7.
##
## tuple(type_var) -> type_var COMMA . nsepseq(type_var,COMMA) [ RPAR ]
##
## The known suffix of the stack is as follows:
## type_var COMMA
##

Ill-formed parametric type declaration.
At this point, a quoted type parameter is expected, like 'a.

contract: Type LPAR QUOTE Ident With
##
## Ends in an error in state: 6.
##
## tuple(type_var) -> type_var . COMMA nsepseq(type_var,COMMA) [ RPAR ]
##
## The known suffix of the stack is as follows:
## type_var
##

Ill-formed parametric type declaration.
At this point, a comma ',' is expected, followed by another quoted
type parameter, like 'a.

contract: Type LPAR QUOTE Ident COMMA QUOTE Ident With
##
## Ends in an error in state: 8.
##
## nsepseq(type_var,COMMA) -> type_var . [ RPAR ]
## nsepseq(type_var,COMMA) -> type_var . COMMA nsepseq(type_var,COMMA) [ RPAR ]
##
## The known suffix of the stack is as follows:
## type_var
##

Ill-formed parametric type declaration.
At this point, one of the following is expected:
  * a comma ',' followed by another quoted type parameter, like 'a;
  * a closing parenthesis ')' if there are no more parameters.

interactive_expr: LPAR UIdent COLON LPAR Ident COMMA Ident RPAR With
##
## Ends in an error in state: 36.
##
## qualified_type -> type_ctor_arg . type_in_module(__anonymous_4) [ VBAR UIdent Type TIMES SEMI RPAR RBRACE Module Let In Ident End EQ EOF Directive COMMA Attr ARROW ]
## type_ctor_app -> type_ctor_arg . Ident [ VBAR UIdent Type TIMES SEMI RPAR RBRACE Module Let In Ident End EQ EOF Directive COMMA Attr ARROW ]
##
## The known suffix of the stack is as follows:
## type_ctor_arg
##

Ill-formed type expression.
At this point, a type constructor is expected.
Note: A type constructor is the analogue of a function name at the
type level. For example, 'list', 'map' and 'set' are type
constructors. Contrary to function names, type constructors are
written after their arguments.

contract: Let Ident COLON LBRACE Attr Ident With
##
## Ends in an error in state: 90.
##
## field_decl -> nseq(Attr) Ident . [ SEMI RBRACE ]
## field_decl -> nseq(Attr) Ident . type_annotation(type_expr) [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Ident
##
contract: Type Ident EQ LBRACE Ident With
##
## Ends in an error in state: 28.
##
## field_decl -> Ident . [ SEMI RBRACE ]
## field_decl -> Ident . type_annotation(type_expr) [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## Ident
##

Ill-formed record type.
At this point, a type annotation for the field is expected, starting
with a colon ':'.

contract: Let Ident COLON LBRACE Attr With
##
## Ends in an error in state: 83.
##
## nseq(Attr) -> Attr . seq(Attr) [ WILD Ident ]
##
## The known suffix of the stack is as follows:
## Attr
##

Ill-formed record type.
At this point, if the attribute is complete, a field name is expected.

contract: Let Ident COLON LBRACE Ident COLON Ident SEMI With
##
## Ends in an error in state: 94.
##
## nsepseq(field_decl,SEMI) -> field_decl SEMI . nsepseq(field_decl,SEMI) [ RBRACE ]
## nseq(__anonymous_0(field_decl,SEMI)) -> field_decl SEMI . seq(__anonymous_0(field_decl,SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_decl SEMI
##
contract: Let Ident COLON LBRACE Ident COLON Ident SEMI Ident COLON Ident SEMI With
##
## Ends in an error in state: 98.
##
## nsepseq(field_decl,SEMI) -> field_decl SEMI . nsepseq(field_decl,SEMI) [ RBRACE ]
## seq(__anonymous_0(field_decl,SEMI)) -> field_decl SEMI . seq(__anonymous_0(field_decl,SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_decl SEMI
##

Ill-formed record type.
At this point one of the following is expected:
  * a field declaration, starting with a field name;
  * a closing brace '}' if the record is complete.

interactive_expr: Fun Ident COLON With
##
## Ends in an error in state: 288.
##
## type_annotation(lambda_app_type) -> COLON . lambda_app_type [ ARROW ]
##
## The known suffix of the stack is as follows:
## COLON
##

Ill-formed type annotation.
At this point, a type expression is expected.
Note: If you want a functional type, enclose it between parentheses.

interactive_expr: LPAR UIdent COLON With
##
## Ends in an error in state: 29.
##
## type_annotation(type_expr) -> COLON . type_expr [ SEMI RPAR RBRACE EQ ]
##
## The known suffix of the stack is as follows:
## COLON
##

Ill-formed typed expression.
At this point, a type expression is expected.

contract: Let Ident COLON LPAR Ident COMMA With
##
## Ends in an error in state: 102.
##
## tuple(type_expr) -> type_expr COMMA . nsepseq(type_expr,COMMA) [ RPAR ]
##
## The known suffix of the stack is as follows:
## type_expr COMMA
##
contract: Let Ident COLON LPAR Ident COMMA Ident COMMA With
##
## Ends in an error in state: 104.
##
## nsepseq(type_expr,COMMA) -> type_expr COMMA . nsepseq(type_expr,COMMA) [ RPAR ]
##
## The known suffix of the stack is as follows:
## type_expr COMMA
##

Ill-formed parametric type expression.
At this point, a type argument is expected as a type expression.

contract: Module UIdent EQ Struct With
##
## Ends in an error in state: 131.
##
## structure -> Struct . seq(declaration) End [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## Struct
##

Ill-formed module declaration.
At this point, declarations are expected.

contract: Let LPAR With
##
## Ends in an error in state: 136.
##
## par(in_core_irrefutable) -> LPAR . in_core_irrefutable RPAR [ WILD UIdent SEMI RPAR RBRACE LPAR LBRACE Ident EQ COMMA COLON Attr ARROW ]
## par(non_const_ctor_irrefutable) -> LPAR . non_const_ctor_irrefutable RPAR [ WILD UIdent SEMI RPAR RBRACE LPAR LBRACE Ident EQ COMMA COLON Attr ARROW ]
## unit -> LPAR . RPAR [ WILD UIdent SEMI RPAR RBRACE LPAR LBRACE Ident EQ COMMA COLON Attr ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR
##
interactive_expr: Match UIdent With LPAR With
##
## Ends in an error in state: 466.
##
## par(__anonymous_8) -> LPAR . pattern RPAR [ SEMI RPAR RBRACKET RBRACE CONS COMMA COLON ARROW ]
## par(__anonymous_8) -> LPAR . typed_pattern RPAR [ SEMI RPAR RBRACKET RBRACE CONS COMMA COLON ARROW ]
## unit -> LPAR . RPAR [ SEMI RPAR RBRACKET RBRACE CONS COMMA COLON ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR
##

Ill-formed pattern.
At this point, one of the following is expected:
  * a pattern followed by a closing parenthesis ')';
  * a closing parenthesis ')' if matching the unit value '()'.

contract: Let LBRACE Ident EQ With
##
## Ends in an error in state: 188.
##
## field_pattern(irrefutable) -> field_pattern_lhs EQ . tuple(core_irrefutable) [ SEMI RBRACE ]
## field_pattern(irrefutable) -> field_pattern_lhs EQ . unit [ SEMI RBRACE ]
## field_pattern(irrefutable) -> field_pattern_lhs EQ . record_pattern(irrefutable) [ SEMI RBRACE ]
## field_pattern(irrefutable) -> field_pattern_lhs EQ . par(in_core_irrefutable) [ SEMI RBRACE ]
## field_pattern(irrefutable) -> field_pattern_lhs EQ . var_pattern [ SEMI RBRACE ]
## field_pattern(irrefutable) -> field_pattern_lhs EQ . ctor_irrefutable [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## field_pattern_lhs EQ
##

Ill-formed record pattern.
At this point, an irrefutable pattern matching the field is expected,
e.g. a variable.

interactive_expr: Match UIdent With LBRACE Ident EQ With
##
## Ends in an error in state: 503.
##
## field_pattern(core_pattern) -> field_pattern_lhs EQ . core_pattern [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## field_pattern_lhs EQ
##

Ill-formed record pattern.
At this point, a pattern matching the field is expected.

contract: Let Attr With
##
## Ends in an error in state: 149.
##
## var_pattern -> Attr . var_pattern [ WILD UIdent SEMI RPAR RBRACE LPAR LBRACE Ident EQ COMMA COLON Attr ARROW ]
##
## The known suffix of the stack is as follows:
## Attr
##

Ill-formed attributed variable in a pattern.
At this point, if the attribute is complete, an identifier is
expected.

contract: Let Ident EQ With
##
## Ends in an error in state: 234.
##
## let_binding -> var_pattern EQ . expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## var_pattern EQ
##
contract: Let Ident Ident EQ With
##
## Ends in an error in state: 1027.
##
## let_binding -> var_pattern parameters EQ . expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## var_pattern parameters EQ
##
contract: Let Ident Ident COLON Ident EQ With
##
## Ends in an error in state: 1030.
##
## let_binding -> var_pattern parameters type_annotation(type_expr) EQ . expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## var_pattern parameters type_annotation(type_expr) EQ
##
contract: Let LPAR RPAR COLON Ident EQ With
##
## Ends in an error in state: 989.
##
## let_binding -> unit type_annotation(type_expr) EQ . expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## unit type_annotation(type_expr) EQ
##
contract: Let LPAR RPAR EQ With
##
## Ends in an error in state: 252.
##
## let_binding -> unit EQ . expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## unit EQ
##
contract: Let LPAR RPAR LPAR Type Ident RPAR EQ With
##
## Ends in an error in state: 992.
##
## let_binding -> unit par(__anonymous_7) EQ . expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## unit par(__anonymous_7) EQ
##
contract: Let LPAR RPAR LPAR Type Ident RPAR COLON Ident EQ With
##
## Ends in an error in state: 995.
##
## let_binding -> unit par(__anonymous_7) type_annotation(type_expr) EQ . expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## unit par(__anonymous_7) type_annotation(type_expr) EQ
##
contract: Let WILD COMMA Ident EQ With
##
## Ends in an error in state: 553.
##
## let_binding -> tuple(core_irrefutable) EQ . expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## tuple(core_irrefutable) EQ
##
contract: Let WILD COMMA Ident COLON Ident EQ With
##
## Ends in an error in state: 556.
##
## let_binding -> tuple(core_irrefutable) type_annotation(type_expr) EQ . expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## tuple(core_irrefutable) type_annotation(type_expr) EQ
##
contract: Let WILD COMMA Ident LPAR Type Ident RPAR EQ With
##
## Ends in an error in state: 559.
##
## let_binding -> tuple(core_irrefutable) par(__anonymous_7) EQ . expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## tuple(core_irrefutable) par(__anonymous_7) EQ
##
contract: Let WILD COMMA Ident LPAR Type Ident RPAR COLON Ident EQ With
##
## Ends in an error in state: 562.
##
## let_binding -> tuple(core_irrefutable) par(__anonymous_7) type_annotation(type_expr) EQ . expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## tuple(core_irrefutable) par(__anonymous_7) type_annotation(type_expr) EQ
##
contract: Let LBRACE Ident RBRACE EQ With
##
## Ends in an error in state: 565.
##
## let_binding -> record_pattern(irrefutable) EQ . expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## record_pattern(irrefutable) EQ
##
contract: Let LBRACE Ident RBRACE COLON Ident EQ With
##
## Ends in an error in state: 568.
##
## let_binding -> record_pattern(irrefutable) type_annotation(type_expr) EQ . expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## record_pattern(irrefutable) type_annotation(type_expr) EQ
##
contract: Let LBRACE Ident RBRACE LPAR Type Ident RPAR EQ With
##
## Ends in an error in state: 571.
##
## let_binding -> record_pattern(irrefutable) par(__anonymous_7) EQ . expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## record_pattern(irrefutable) par(__anonymous_7) EQ
##
contract: Let LBRACE Ident RBRACE LPAR Type Ident RPAR COLON Ident EQ With
##
## Ends in an error in state: 574.
##
## let_binding -> record_pattern(irrefutable) par(__anonymous_7) type_annotation(type_expr) EQ . expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## record_pattern(irrefutable) par(__anonymous_7) type_annotation(type_expr) EQ
##
contract: Let LPAR UIdent COLON Ident RPAR COLON Ident EQ With
##
## Ends in an error in state: 580.
##
## let_binding -> par(in_core_irrefutable) type_annotation(type_expr) EQ . expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## par(in_core_irrefutable) type_annotation(type_expr) EQ
##
contract: Let LPAR WILD RPAR EQ With
##
## Ends in an error in state: 577.
##
## let_binding -> par(in_core_irrefutable) EQ . expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## par(in_core_irrefutable) EQ
##
contract: Let LPAR WILD RPAR LPAR Type Ident RPAR EQ With
##
## Ends in an error in state: 583.
##
## let_binding -> par(in_core_irrefutable) par(__anonymous_7) EQ . expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## par(in_core_irrefutable) par(__anonymous_7) EQ
##
contract: Let LPAR WILD RPAR LPAR Type Ident RPAR COLON Ident EQ With
##
## Ends in an error in state: 586.
##
## let_binding -> par(in_core_irrefutable) par(__anonymous_7) type_annotation(type_expr) EQ . expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## par(in_core_irrefutable) par(__anonymous_7) type_annotation(type_expr) EQ
##
contract: Let UIdent EQ With
##
## Ends in an error in state: 682.
##
## let_binding -> ctor_irrefutable EQ . expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## ctor_irrefutable EQ
##
contract: Let UIdent COLON Ident EQ With
##
## Ends in an error in state: 685.
##
## let_binding -> ctor_irrefutable type_annotation(type_expr) EQ . expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## ctor_irrefutable type_annotation(type_expr) EQ
##
contract: Let UIdent LPAR Type Ident RPAR EQ With
##
## Ends in an error in state: 688.
##
## let_binding -> ctor_irrefutable par(__anonymous_7) EQ . expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## ctor_irrefutable par(__anonymous_7) EQ
##
contract: Let UIdent LPAR Type Ident RPAR COLON Ident EQ With
##
## Ends in an error in state: 691.
##
## let_binding -> ctor_irrefutable par(__anonymous_7) type_annotation(type_expr) EQ . expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## ctor_irrefutable par(__anonymous_7) type_annotation(type_expr) EQ
##
contract: Let WILD LPAR Type Ident RPAR EQ With
##
## Ends in an error in state: 1033.
##
## let_binding -> var_pattern par(__anonymous_7) EQ . expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## var_pattern par(__anonymous_7) EQ
##
contract: Let WILD LPAR Type Ident RPAR COLON Ident EQ With
##
## Ends in an error in state: 1036.
##
## let_binding -> var_pattern par(__anonymous_7) type_annotation(type_expr) EQ . expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## var_pattern par(__anonymous_7) type_annotation(type_expr) EQ
##
contract: Let Ident COLON Ident EQ ZWSP
##
## Ends in an error in state: 1024.
##
## let_binding -> var_pattern type_annotation(type_expr) EQ . expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## var_pattern type_annotation(type_expr) EQ
##

Ill-formed value declaration.
At this point, an expression is expected.

interactive_expr: Lang With
##
## Ends in an error in state: 244.
##
## code_inj -> Lang . expr RBRACKET [ With Verbatim VBAR UIdent Type Then TIMES String SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Lxor Lsr Lsl Lor Let Lang Land LT LPAR LE LBRACKET LBRACE Int In Ident GT End Else EQ EOF Directive CONS COMMA COLON CARET Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## Lang
##

Ill-formed code injection.
At this point, the code is expected as an expression whose value is a
verbatim string.

interactive_expr: LPAR With
##
## Ends in an error in state: 247.
##
## par(expr) -> LPAR . expr RPAR [ With Verbatim VBAR UIdent Type Then TIMES String SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Lxor Lsr Lsl Lor Let Lang Land LT LPAR LE LBRACKET LBRACE Int In Ident GT End Else EQ EOF Directive DOT CONS COMMA COLON CARET Bytes Begin BOOL_OR BOOL_AND Attr ]
## par(typed_expr) -> LPAR . typed_expr RPAR [ With Verbatim VBAR UIdent Type Then TIMES String SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Lxor Lsr Lsl Lor Let Lang Land LT LPAR LE LBRACKET LBRACE Int In Ident GT End Else EQ EOF Directive CONS COMMA COLON CARET Bytes Begin BOOL_OR BOOL_AND Attr ]
## unit -> LPAR . RPAR [ With Verbatim VBAR UIdent Type Then TIMES String SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Lxor Lsr Lsl Lor Let Lang Land LT LPAR LE LBRACKET LBRACE Int In Ident GT End Else EQ EOF Directive CONS COMMA COLON CARET Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## LPAR
##

Ill-formed expression.
At this point, one of the following is expected:
  * an expression, if defining a parenthesised expression;
  * a closing parenthesis ')' if defining the unit value '()'.

interactive_expr: Match UIdent With LBRACKET With
##
## Ends in an error in state: 467.
##
## brackets(option(__anonymous_1(cons_pattern_level))) -> LBRACKET . option(__anonymous_1(cons_pattern_level)) RBRACKET [ SEMI RPAR RBRACKET RBRACE CONS COMMA COLON ARROW ]
##
## The known suffix of the stack is as follows:
## LBRACKET
##

Ill-formed list of patterns.
At this point, one of the following is expected:
  * a list element as a pattern;
  * a closing bracket ']' if matching the empty list.

interactive_expr: Match UIdent With UIdent COMMA With
##
## Ends in an error in state: 534.
##
## tuple(cons_pattern_level) -> cons_pattern_level COMMA . nsepseq(cons_pattern_level,COMMA) [ RPAR COLON ARROW ]
##
## The known suffix of the stack is as follows:
## cons_pattern_level COMMA
##
interactive_expr: Match UIdent With UIdent COMMA UIdent COMMA With
##
## Ends in an error in state: 537.
##
## nsepseq(cons_pattern_level,COMMA) -> cons_pattern_level COMMA . nsepseq(cons_pattern_level,COMMA) [ RPAR COLON ARROW ]
##
## The known suffix of the stack is as follows:
## cons_pattern_level COMMA
##
contract: Let Ident COMMA With
##
## Ends in an error in state: 152.
##
## tuple(core_irrefutable) -> var_pattern COMMA . nsepseq(core_irrefutable,COMMA) [ SEMI RPAR RBRACE LPAR EQ COLON ]
##
## The known suffix of the stack is as follows:
## var_pattern COMMA
##
contract: Let WILD COMMA WILD COMMA With
##
## Ends in an error in state: 154.
##
## nsepseq(core_irrefutable,COMMA) -> var_pattern COMMA . nsepseq(core_irrefutable,COMMA) [ SEMI RPAR RBRACE LPAR EQ COLON ]
##
## The known suffix of the stack is as follows:
## var_pattern COMMA
##
contract: Let WILD COMMA LPAR RPAR COMMA With
##
## Ends in an error in state: 156.
##
## nsepseq(core_irrefutable,COMMA) -> unit COMMA . nsepseq(core_irrefutable,COMMA) [ SEMI RPAR RBRACE LPAR EQ COLON ]
##
## The known suffix of the stack is as follows:
## unit COMMA
##
contract: Let WILD COMMA LBRACE Ident RBRACE COMMA With
##
## Ends in an error in state: 158.
##
## nsepseq(core_irrefutable,COMMA) -> record_pattern(irrefutable) COMMA . nsepseq(core_irrefutable,COMMA) [ SEMI RPAR RBRACE LPAR EQ COLON ]
##
## The known suffix of the stack is as follows:
## record_pattern(irrefutable) COMMA
##
contract: Let WILD COMMA LPAR WILD RPAR COMMA With
##
## Ends in an error in state: 162.
##
## nsepseq(core_irrefutable,COMMA) -> par(in_core_irrefutable) COMMA . nsepseq(core_irrefutable,COMMA) [ SEMI RPAR RBRACE LPAR EQ COLON ]
##
## The known suffix of the stack is as follows:
## par(in_core_irrefutable) COMMA
##
contract: Let WILD COMMA UIdent COMMA With
##
## Ends in an error in state: 165.
##
## nsepseq(core_irrefutable,COMMA) -> ctor_irrefutable COMMA . nsepseq(core_irrefutable,COMMA) [ SEMI RPAR RBRACE LPAR EQ COLON ]
##
## The known suffix of the stack is as follows:
## ctor_irrefutable COMMA
##
contract: Let LPAR RPAR COMMA With
##
## Ends in an error in state: 174.
##
## tuple(core_irrefutable) -> unit COMMA . nsepseq(core_irrefutable,COMMA) [ SEMI RPAR RBRACE LPAR EQ COLON ]
##
## The known suffix of the stack is as follows:
## unit COMMA
##
contract: Let LBRACE Ident RBRACE COMMA With
##
## Ends in an error in state: 178.
##
## tuple(core_irrefutable) -> record_pattern(irrefutable) COMMA . nsepseq(core_irrefutable,COMMA) [ SEMI RPAR RBRACE LPAR EQ COLON ]
##
## The known suffix of the stack is as follows:
## record_pattern(irrefutable) COMMA
##
contract: Let LPAR WILD RPAR COMMA With
##
## Ends in an error in state: 181.
##
## tuple(core_irrefutable) -> par(in_core_irrefutable) COMMA . nsepseq(core_irrefutable,COMMA) [ SEMI RPAR RBRACE LPAR EQ COLON ]
##
## The known suffix of the stack is as follows:
## par(in_core_irrefutable) COMMA
##
contract: Let UIdent COMMA With
##
## Ends in an error in state: 184.
##
## tuple(core_irrefutable) -> ctor_irrefutable COMMA . nsepseq(core_irrefutable,COMMA) [ SEMI RPAR RBRACE LPAR EQ COLON ]
##
## The known suffix of the stack is as follows:
## ctor_irrefutable COMMA
##

Ill-formed tuple of patterns.
At this point, another component is expected as a pattern.

interactive_expr: LBRACKET With
##
## Ends in an error in state: 253.
##
## brackets(option(__anonymous_1(expr))) -> LBRACKET . option(__anonymous_1(expr)) RBRACKET [ With Verbatim VBAR UIdent Type Then TIMES String SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Lxor Lsr Lsl Lor Let Lang Land LT LPAR LE LBRACKET LBRACE Int In Ident GT End Else EQ EOF Directive CONS COMMA COLON CARET Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## LBRACKET
##

Ill-formed list of expressions.
At this point, one of the following is expected:
  * a list element as an expression;
  * a closing bracket ']' if defining the empty list.

interactive_expr: LBRACE Ident EQ With
##
## Ends in an error in state: 257.
##
## field_assignment -> Ident EQ . expr [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## Ident EQ
##

Ill-formed record expression.
At this point, an expression is expected to be assigned to the field.

interactive_expr: Begin Match UIdent With UIdent ARROW Fun LPAR Type Ident RPAR With
##
## Ends in an error in state: 771.
##
## fun_expr(base_cond) -> Fun par(__anonymous_7) . nseq(core_irrefutable) ARROW base_cond [ VBAR ]
## fun_expr(base_cond) -> Fun par(__anonymous_7) . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW base_cond [ VBAR ]
## fun_expr(last_expr) -> Fun par(__anonymous_7) . nseq(core_irrefutable) ARROW last_expr [ End ]
## fun_expr(last_expr) -> Fun par(__anonymous_7) . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW last_expr [ End ]
##
## The known suffix of the stack is as follows:
## Fun par(__anonymous_7)
##
interactive_expr: If UIdent Then Match UIdent With UIdent ARROW Attr Fun LPAR Type Ident RPAR With
##
## Ends in an error in state: 720.
##
## fun_expr(base_cond) -> Fun par(__anonymous_7) . nseq(core_irrefutable) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_cond) -> Fun par(__anonymous_7) . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_if_then_else) -> Fun par(__anonymous_7) . nseq(core_irrefutable) ARROW base_if_then_else [ Else ]
## fun_expr(base_if_then_else) -> Fun par(__anonymous_7) . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## Fun par(__anonymous_7)
##
interactive_expr: Match UIdent With UIdent ARROW If UIdent Then Attr Fun LPAR Type Ident RPAR With
##
## Ends in an error in state: 614.
##
## fun_expr(base_cond) -> Fun par(__anonymous_7) . nseq(core_irrefutable) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_cond) -> Fun par(__anonymous_7) . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(closed_expr) -> Fun par(__anonymous_7) . nseq(core_irrefutable) ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> Fun par(__anonymous_7) . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Fun par(__anonymous_7)
##
interactive_expr: Fun LPAR Type Ident RPAR With
##
## Ends in an error in state: 286.
##
## fun_expr(expr) -> Fun par(__anonymous_7) . nseq(core_irrefutable) ARROW expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(expr) -> Fun par(__anonymous_7) . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun par(__anonymous_7)
##
interactive_expr: Begin Fun LPAR Type Ident RPAR With
##
## Ends in an error in state: 823.
##
## fun_expr(last_expr) -> Fun par(__anonymous_7) . nseq(core_irrefutable) ARROW last_expr [ End ]
## fun_expr(last_expr) -> Fun par(__anonymous_7) . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW last_expr [ End ]
##
## The known suffix of the stack is as follows:
## Fun par(__anonymous_7)
##
interactive_expr: If UIdent Then Fun LPAR Type Ident RPAR With
##
## Ends in an error in state: 899.
##
## fun_expr(closed_expr) -> Fun par(__anonymous_7) . nseq(core_irrefutable) ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> Fun par(__anonymous_7) . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW closed_expr [ Else ]
## fun_expr(expr) -> Fun par(__anonymous_7) . nseq(core_irrefutable) ARROW expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(expr) -> Fun par(__anonymous_7) . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun par(__anonymous_7)
##
interactive_expr: Begin If UIdent Then Fun LPAR Type Ident RPAR With
##
## Ends in an error in state: 799.
##
## fun_expr(closed_expr) -> Fun par(__anonymous_7) . nseq(core_irrefutable) ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> Fun par(__anonymous_7) . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Fun par(__anonymous_7)
##
interactive_expr: Begin Match UIdent With UIdent ARROW Attr Fun LPAR Type Ident RPAR With
##
## Ends in an error in state: 655.
##
## fun_expr(base_cond) -> Fun par(__anonymous_7) . nseq(core_irrefutable) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_cond) -> Fun par(__anonymous_7) . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun par(__anonymous_7)
##

Ill-formed functional expression.
At this point, parameters are expected as irrefutable patterns,
e.g. variables.

interactive_expr: If UIdent Then Fun With
##
## Ends in an error in state: 898.
##
## fun_expr(closed_expr) -> Fun . nseq(core_irrefutable) ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> Fun . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> Fun . par(__anonymous_7) nseq(core_irrefutable) ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> Fun . par(__anonymous_7) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW closed_expr [ Else ]
## fun_expr(expr) -> Fun . nseq(core_irrefutable) ARROW expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(expr) -> Fun . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(expr) -> Fun . par(__anonymous_7) nseq(core_irrefutable) ARROW expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(expr) -> Fun . par(__anonymous_7) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun
##
interactive_expr: Begin Fun With
##
## Ends in an error in state: 822.
##
## fun_expr(last_expr) -> Fun . nseq(core_irrefutable) ARROW last_expr [ End ]
## fun_expr(last_expr) -> Fun . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW last_expr [ End ]
## fun_expr(last_expr) -> Fun . par(__anonymous_7) nseq(core_irrefutable) ARROW last_expr [ End ]
## fun_expr(last_expr) -> Fun . par(__anonymous_7) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW last_expr [ End ]
##
## The known suffix of the stack is as follows:
## Fun
##
interactive_expr: Begin If UIdent Then Fun With
##
## Ends in an error in state: 798.
##
## fun_expr(closed_expr) -> Fun . nseq(core_irrefutable) ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> Fun . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> Fun . par(__anonymous_7) nseq(core_irrefutable) ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> Fun . par(__anonymous_7) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Fun
##
interactive_expr: Begin Match UIdent With UIdent ARROW Fun With
##
## Ends in an error in state: 770.
##
## fun_expr(base_cond) -> Fun . nseq(core_irrefutable) ARROW base_cond [ VBAR ]
## fun_expr(base_cond) -> Fun . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW base_cond [ VBAR ]
## fun_expr(base_cond) -> Fun . par(__anonymous_7) nseq(core_irrefutable) ARROW base_cond [ VBAR ]
## fun_expr(base_cond) -> Fun . par(__anonymous_7) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW base_cond [ VBAR ]
## fun_expr(last_expr) -> Fun . nseq(core_irrefutable) ARROW last_expr [ End ]
## fun_expr(last_expr) -> Fun . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW last_expr [ End ]
## fun_expr(last_expr) -> Fun . par(__anonymous_7) nseq(core_irrefutable) ARROW last_expr [ End ]
## fun_expr(last_expr) -> Fun . par(__anonymous_7) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW last_expr [ End ]
##
## The known suffix of the stack is as follows:
## Fun
##
interactive_expr: Match UIdent With UIdent ARROW Fun With
##
## Ends in an error in state: 654.
##
## fun_expr(base_cond) -> Fun . nseq(core_irrefutable) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_cond) -> Fun . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_cond) -> Fun . par(__anonymous_7) nseq(core_irrefutable) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_cond) -> Fun . par(__anonymous_7) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun
##
interactive_expr: If UIdent Then Match UIdent With UIdent ARROW Fun With
##
## Ends in an error in state: 719.
##
## fun_expr(base_cond) -> Fun . nseq(core_irrefutable) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_cond) -> Fun . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_cond) -> Fun . par(__anonymous_7) nseq(core_irrefutable) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_cond) -> Fun . par(__anonymous_7) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_if_then_else) -> Fun . nseq(core_irrefutable) ARROW base_if_then_else [ Else ]
## fun_expr(base_if_then_else) -> Fun . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW base_if_then_else [ Else ]
## fun_expr(base_if_then_else) -> Fun . par(__anonymous_7) nseq(core_irrefutable) ARROW base_if_then_else [ Else ]
## fun_expr(base_if_then_else) -> Fun . par(__anonymous_7) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## Fun
##
interactive_expr: Fun With
##
## Ends in an error in state: 267.
##
## fun_expr(expr) -> Fun . nseq(core_irrefutable) ARROW expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(expr) -> Fun . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(expr) -> Fun . par(__anonymous_7) nseq(core_irrefutable) ARROW expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(expr) -> Fun . par(__anonymous_7) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun
##
interactive_expr: Match UIdent With UIdent ARROW If UIdent Then Attr Fun With
##
## Ends in an error in state: 613.
##
## fun_expr(base_cond) -> Fun . nseq(core_irrefutable) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_cond) -> Fun . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_cond) -> Fun . par(__anonymous_7) nseq(core_irrefutable) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_cond) -> Fun . par(__anonymous_7) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(closed_expr) -> Fun . nseq(core_irrefutable) ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> Fun . nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> Fun . par(__anonymous_7) nseq(core_irrefutable) ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> Fun . par(__anonymous_7) nseq(core_irrefutable) type_annotation(lambda_app_type) ARROW closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Fun
##

Ill-formed functional expression.
At this point, one of the following is expected:
  * parameters as irrefutable patterns, e.g. variables;
  * bound type parameters between parentheses, like '(type a b)'.

interactive_expr: If UIdent Then Match With
##
## Ends in an error in state: 886.
##
## match_expr(base_cond) -> Match . expr With option(VBAR) cases(base_cond) [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## match_expr(base_if_then_else) -> Match . expr With option(VBAR) cases(base_if_then_else) [ Else ]
##
## The known suffix of the stack is as follows:
## Match
##
interactive_expr: Begin Match With
##
## Ends in an error in state: 316.
##
## match_expr(last_expr) -> Match . expr With option(VBAR) cases(last_expr) [ End ]
##
## The known suffix of the stack is as follows:
## Match
##
interactive_expr: Match With
##
## Ends in an error in state: 245.
##
## match_expr(base_cond) -> Match . expr With option(VBAR) cases(base_cond) [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Match
##
interactive_expr: Begin If UIdent Then Match With
##
## Ends in an error in state: 593.
##
## match_expr(base_if_then_else) -> Match . expr With option(VBAR) cases(base_if_then_else) [ Else ]
##
## The known suffix of the stack is as follows:
## Match
##

Ill-formed match expression.
At this point, the expression whose value is being matched is
expected.

interactive_expr: Module UIdent EQ UIdent In With
##
## Ends in an error in state: 367.
##
## local_module_decl(expr) -> module_decl In . expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## module_decl In
##
interactive_expr: If UIdent Then Module UIdent EQ UIdent In With
##
## Ends in an error in state: 907.
##
## local_module_decl(closed_expr) -> module_decl In . closed_expr [ Else ]
## local_module_decl(expr) -> module_decl In . expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## module_decl In
##
interactive_expr: Begin If UIdent Then Module UIdent EQ UIdent In With
##
## Ends in an error in state: 807.
##
## local_module_decl(closed_expr) -> module_decl In . closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## module_decl In
##
interactive_expr: Match UIdent With UIdent ARROW If UIdent Then Module UIdent EQ UIdent In With
##
## Ends in an error in state: 627.
##
## local_module_decl(base_cond) -> module_decl In . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## local_module_decl(closed_expr) -> module_decl In . closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## module_decl In
##
interactive_expr: If UIdent Then Match UIdent With UIdent ARROW Module UIdent EQ UIdent In With
##
## Ends in an error in state: 730.
##
## local_module_decl(base_cond) -> module_decl In . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## local_module_decl(base_if_then_else) -> module_decl In . base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## module_decl In
##
interactive_expr: Match UIdent With UIdent ARROW Module UIdent EQ UIdent In With
##
## Ends in an error in state: 664.
##
## local_module_decl(base_cond) -> module_decl In . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## module_decl In
##

Ill-formed local module alias declaration.
At this point, an expression is expected.

contract: Let Ident LPAR With
##
## Ends in an error in state: 226.
##
## par(__anonymous_7) -> LPAR . Type nseq(variable) RPAR [ WILD UIdent LPAR LBRACE Ident EQ COLON Attr ]
## par(in_core_irrefutable) -> LPAR . in_core_irrefutable RPAR [ WILD UIdent LPAR LBRACE Ident EQ COLON Attr ARROW ]
## par(non_const_ctor_irrefutable) -> LPAR . non_const_ctor_irrefutable RPAR [ WILD UIdent LPAR LBRACE Ident EQ COLON Attr ARROW ]
## unit -> LPAR . RPAR [ WILD UIdent LPAR LBRACE Ident EQ COLON Attr ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR
##

Ill-formed value declaration.
At this point, one of the following is expected:
  * the keyword 'type' followed by type parameters and a closing
    parenthesis ')';
  * a closing parenthesis ')' if matching the unit pattern;
  * a parameter as an irrefutable pattern followed by a closing
    parenthesis ')'.

contract: Let Ident COLON LPAR With
##
## Ends in an error in state: 26.
##
## par(tuple(type_expr)) -> LPAR . tuple(type_expr) RPAR [ UIdent Ident ]
## par(type_expr) -> LPAR . type_expr RPAR [ VBAR UIdent Type TIMES SEMI RPAR RBRACE Module Let In Ident End EQ EOF Directive COMMA Attr ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR
##

Ill-formed parenthesised expression.
At this point, an expression is expected.
Note: Tuples of expressions do not require in general to be
parenthesised, but parentheses improve readability.

contract: Let Ident LPAR Type Ident RPAR Ident EQ With
##
## Ends in an error in state: 1039.
##
## let_binding -> var_pattern par(__anonymous_7) parameters EQ . expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## var_pattern par(__anonymous_7) parameters EQ
##
contract: Let Ident LPAR Type Ident RPAR Ident COLON Ident EQ With
##
## Ends in an error in state: 1042.
##
## let_binding -> var_pattern par(__anonymous_7) parameters type_annotation(type_expr) EQ . expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## var_pattern par(__anonymous_7) parameters type_annotation(type_expr) EQ
##

Ill-formed function declaration.
At this point, the body of the function is expected as an expression.

interactive_expr: Fun WILD LPAR RPAR With
##
## Ends in an error in state: 270.
##
## seq(core_irrefutable) -> unit . seq(core_irrefutable) [ EQ COLON ARROW ]
##
## The known suffix of the stack is as follows:
## unit
##
interactive_expr: Fun WILD LBRACE Ident RBRACE With
##
## Ends in an error in state: 272.
##
## seq(core_irrefutable) -> record_pattern(irrefutable) . seq(core_irrefutable) [ EQ COLON ARROW ]
##
## The known suffix of the stack is as follows:
## record_pattern(irrefutable)
##
interactive_expr: Fun WILD LPAR WILD RPAR With
##
## Ends in an error in state: 274.
##
## seq(core_irrefutable) -> par(in_core_irrefutable) . seq(core_irrefutable) [ EQ COLON ARROW ]
##
## The known suffix of the stack is as follows:
## par(in_core_irrefutable)
##
interactive_expr: Fun WILD UIdent With
##
## Ends in an error in state: 276.
##
## seq(core_irrefutable) -> ctor_irrefutable . seq(core_irrefutable) [ EQ COLON ARROW ]
##
## The known suffix of the stack is as follows:
## ctor_irrefutable
##
interactive_expr: Fun LPAR RPAR With
##
## Ends in an error in state: 280.
##
## nseq(core_irrefutable) -> unit . seq(core_irrefutable) [ EQ COLON ARROW ]
##
## The known suffix of the stack is as follows:
## unit
##
interactive_expr: Fun LBRACE Ident RBRACE With
##
## Ends in an error in state: 282.
##
## nseq(core_irrefutable) -> record_pattern(irrefutable) . seq(core_irrefutable) [ EQ COLON ARROW ]
##
## The known suffix of the stack is as follows:
## record_pattern(irrefutable)
##
interactive_expr: Fun LPAR WILD RPAR With
##
## Ends in an error in state: 284.
##
## nseq(core_irrefutable) -> par(in_core_irrefutable) . seq(core_irrefutable) [ EQ COLON ARROW ]
##
## The known suffix of the stack is as follows:
## par(in_core_irrefutable)
##
interactive_expr: Fun UIdent With
##
## Ends in an error in state: 672.
##
## nseq(core_irrefutable) -> ctor_irrefutable . seq(core_irrefutable) [ EQ COLON ARROW ]
##
## The known suffix of the stack is as follows:
## ctor_irrefutable
##

Ill-formed function parameters.
At this point, one of the following is expected:
  * another parameter as an irrefutable pattern, e.g a variable;
  * a type annotation starting with a colon ':' for the body;
  * the assignment symbol '=' followed by an expression.

interactive_expr: Match UIdent With VBAR With
##
## Ends in an error in state: 1009.
##
## match_expr(base_cond) -> Match expr With option(VBAR) . cases(base_cond) [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Match expr With option(VBAR)
##
interactive_expr: Match UIdent With UIdent ARROW UIdent VBAR With
##
## Ends in an error in state: 1013.
##
## cases(base_cond) -> cases(base_cond) VBAR . match_clause(base_cond) [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## cases(base_cond) VBAR
##
interactive_expr: Begin Match UIdent With UIdent ARROW UIdent VBAR With
##
## Ends in an error in state: 869.
##
## cases(base_cond) -> cases(base_cond) VBAR . match_clause(base_cond) [ VBAR ]
## cases(last_expr) -> cases(base_cond) VBAR . match_clause(last_expr) [ End ]
##
## The known suffix of the stack is as follows:
## cases(base_cond) VBAR
##
interactive_expr: If UIdent Then Match UIdent With UIdent ARROW UIdent VBAR With
##
## Ends in an error in state: 762.
##
## cases(base_cond) -> cases(base_cond) VBAR . match_clause(base_cond) [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## cases(base_if_then_else) -> cases(base_cond) VBAR . match_clause(base_if_then_else) [ Else ]
##
## The known suffix of the stack is as follows:
## cases(base_cond) VBAR
##
interactive_expr: If UIdent Then Match UIdent With VBAR With
##
## Ends in an error in state: 889.
##
## match_expr(base_cond) -> Match expr With option(VBAR) . cases(base_cond) [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## match_expr(base_if_then_else) -> Match expr With option(VBAR) . cases(base_if_then_else) [ Else ]
##
## The known suffix of the stack is as follows:
## Match expr With option(VBAR)
##
interactive_expr: Begin Match UIdent With VBAR With
##
## Ends in an error in state: 459.
##
## match_expr(last_expr) -> Match expr With option(VBAR) . cases(last_expr) [ End ]
##
## The known suffix of the stack is as follows:
## Match expr With option(VBAR)
##
interactive_expr: Begin If UIdent Then Match UIdent With VBAR With
##
## Ends in an error in state: 596.
##
## match_expr(base_if_then_else) -> Match expr With option(VBAR) . cases(base_if_then_else) [ Else ]
##
## The known suffix of the stack is as follows:
## Match expr With option(VBAR)
##

Ill-formed pattern matching.
At this point, a case is expected to start with a pattern.

interactive_expr: Match UIdent With UIdent CONS With
##
## Ends in an error in state: 518.
##
## cons_pattern_level -> core_pattern CONS . cons_pattern_level [ SEMI RPAR RBRACKET COMMA COLON ARROW ]
##
## The known suffix of the stack is as follows:
## core_pattern CONS
##

Ill-formed list pattern.
At this point, a pattern that matches as list is expected.

interactive_expr: Match UIdent With LBRACKET UIdent SEMI With
##
## Ends in an error in state: 521.
##
## nsepseq(cons_pattern_level,SEMI) -> cons_pattern_level SEMI . nsepseq(cons_pattern_level,SEMI) [ RBRACKET ]
## nseq(__anonymous_0(cons_pattern_level,SEMI)) -> cons_pattern_level SEMI . seq(__anonymous_0(cons_pattern_level,SEMI)) [ RBRACKET ]
##
## The known suffix of the stack is as follows:
## cons_pattern_level SEMI
##
interactive_expr: Match UIdent With LBRACKET UIdent SEMI UIdent SEMI With
##
## Ends in an error in state: 525.
##
## nsepseq(cons_pattern_level,SEMI) -> cons_pattern_level SEMI . nsepseq(cons_pattern_level,SEMI) [ RBRACKET ]
## seq(__anonymous_0(cons_pattern_level,SEMI)) -> cons_pattern_level SEMI . seq(__anonymous_0(cons_pattern_level,SEMI)) [ RBRACKET ]
##
## The known suffix of the stack is as follows:
## cons_pattern_level SEMI
##

Ill-formed list of patterns.
At this point, one of the following is expected:
  * a list element as a pattern;
  * a closing bracket ']' if the list is complete.

contract: Attr With
##
## Ends in an error in state: 1047.
##
## attr_decl -> Attr . declaration [ Type Module Let End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## Attr
##
interactive_expr: Attr With
##
## Ends in an error in state: 317.
##
## core_expr -> Attr . core_expr [ With Verbatim VBAR UIdent Type Then TIMES String SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Lxor Lsr Lsl Lor Let Lang Land LT LPAR LE LBRACKET LBRACE Int In Ident GT End Else EQ EOF Directive CONS COMMA COLON CARET Bytes Begin BOOL_OR BOOL_AND Attr ]
## nseq(Attr) -> Attr . seq(Attr) [ Type Module Match Let If Fun ]
##
## The known suffix of the stack is as follows:
## Attr
##

Ill-formed attributed expression.
At this point, if the attributes are complete, one of the following is
expected:
  * a functional expression starting with the keyword 'fun';
  * a local value declaration starting with the keyword 'let'.

interactive_expr: Fun Ident With
##
## Ends in an error in state: 268.
##
## nseq(core_irrefutable) -> var_pattern . seq(core_irrefutable) [ EQ COLON ARROW ]
##
## The known suffix of the stack is as follows:
## var_pattern
##
interactive_expr: Fun Ident Ident With
##
## Ends in an error in state: 269.
##
## seq(core_irrefutable) -> var_pattern . seq(core_irrefutable) [ EQ COLON ARROW ]
##
## The known suffix of the stack is as follows:
## var_pattern
##

Ill-formed functional expression.
At this point, one of the following is expected:
  * a parameter as an irrefutable pattern, e.g. a variable;
  * an arrow '->' followed by the body as an expression.

interactive_expr: Match UIdent With UIdent ARROW If UIdent Then Type Ident EQ Ident In With
##
## Ends in an error in state: 618.
##
## local_type_decl(base_cond) -> type_decl In . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## local_type_decl(closed_expr) -> type_decl In . closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## type_decl In
##
interactive_expr: If UIdent Then Type Ident EQ Ident In With
##
## Ends in an error in state: 903.
##
## local_type_decl(closed_expr) -> type_decl In . closed_expr [ Else ]
## local_type_decl(expr) -> type_decl In . expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## type_decl In
##
#
#interactive_expr: Match UIdent With UIdent ARROW If UIdent Then Type Ident EQ Ident In With
interactive_expr: If UIdent Then Match UIdent With UIdent ARROW Type Ident EQ Ident In With
##
## Ends in an error in state: 724.
##
## local_type_decl(base_cond) -> type_decl In . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## local_type_decl(base_if_then_else) -> type_decl In . base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## type_decl In
##
interactive_expr: Type Ident EQ Ident In With
##
## Ends in an error in state: 359.
##
## local_type_decl(expr) -> type_decl In . expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## type_decl In
##
interactive_expr: Match UIdent With UIdent ARROW Type Ident EQ Ident In With
##
## Ends in an error in state: 659.
##
## local_type_decl(base_cond) -> type_decl In . base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## type_decl In
##
interactive_expr: Begin If UIdent Then Type Ident EQ Ident In With
##
## Ends in an error in state: 803.
##
## local_type_decl(closed_expr) -> type_decl In . closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## type_decl In
##

Ill-formed local type declaration.
At this point, an expression is expected.

interactive_expr: LBRACE Ident With Ident EQ With
##
## Ends in an error in state: 951.
##
## field_path_assignment -> path field_lens . expr [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## path field_lens
##

Ill-formed record update.
At this point, the expression assigned to the field is expected.

interactive_expr: LBRACKET UIdent SEMI With
##
## Ends in an error in state: 981.
##
## nsepseq(expr,SEMI) -> expr SEMI . nsepseq(expr,SEMI) [ RBRACKET ]
## nseq(__anonymous_0(expr,SEMI)) -> expr SEMI . seq(__anonymous_0(expr,SEMI)) [ RBRACKET ]
##
## The known suffix of the stack is as follows:
## expr SEMI
##
interactive_expr: LBRACKET UIdent SEMI UIdent SEMI With
##
## Ends in an error in state: 985.
##
## nsepseq(expr,SEMI) -> expr SEMI . nsepseq(expr,SEMI) [ RBRACKET ]
## seq(__anonymous_0(expr,SEMI)) -> expr SEMI . seq(__anonymous_0(expr,SEMI)) [ RBRACKET ]
##
## The known suffix of the stack is as follows:
## expr SEMI
##

Ill-formed list of expressions.
At this point, one of the following is expected:
  * a list element as an expression;
  * a closing bracket ']' if the list is complete.

contract: Let Ident COLON UIdent Of Attr With
##
## Ends in an error in state: 74.
##
## core_type -> Attr . core_type [ VBAR Type TIMES SEMI RPAR RBRACE Module Let In End EQ EOF Directive COMMA Attr ARROW ]
##
## The known suffix of the stack is as follows:
## Attr
##

Ill-formed record type.
At this point, if the attribute is complete, an opening brace '{' is
expected.

contract: Type QUOTE Ident Ident With
##
## Ends in an error in state: 119.
##
## type_decl -> Type type_vars Ident . EQ type_expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## Type type_vars Ident
##
contract: Type Ident With
##
## Ends in an error in state: 15.
##
## type_decl -> Type Ident . EQ type_expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## Type Ident
##

Ill-formed type declaration.
At this point, the assignment symbol '=' is expected, followed by a
type expression.

contract: Type QUOTE Ident Ident EQ With
##
## Ends in an error in state: 120.
##
## type_decl -> Type type_vars Ident EQ . type_expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## Type type_vars Ident EQ
##
contract: Type Ident EQ With
##
## Ends in an error in state: 16.
##
## type_decl -> Type Ident EQ . type_expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## Type Ident EQ
##

Ill-formed type declaration.
At this point, a type expression is expected.

interactive_expr: Fun Ident COLON VBAR Attr With
##
## Ends in an error in state: 294.
##
## short_variant(cartesian_level) -> Attr . short_variant(cartesian_level) [ VBAR ARROW ]
##
## The known suffix of the stack is as follows:
## Attr
##

Ill-formed variant.
At this point, if the attributes of the variant are complete, a data
constructor is expected.

contract: Let Ident COLON Attr With
##
## Ends in an error in state: 32.
##
## core_type -> Attr . core_type [ Type TIMES SEMI RPAR RBRACE Module Let In End EQ EOF Directive COMMA Attr ARROW ]
## nseq(Attr) -> Attr . seq(Attr) [ VBAR ]
## short_variant(fun_type_level) -> Attr . short_variant(fun_type_level) [ VBAR Type SEMI RPAR RBRACE Module Let In End EQ EOF Directive COMMA Attr ]
##
## The known suffix of the stack is as follows:
## Attr
##
interactive_expr: Fun Ident COLON Attr With
##
## Ends in an error in state: 298.
##
## core_type -> Attr . core_type [ TIMES ARROW ]
## nseq(Attr) -> Attr . seq(Attr) [ VBAR ]
## short_variant(cartesian_level) -> Attr . short_variant(cartesian_level) [ VBAR ARROW ]
##
## The known suffix of the stack is as follows:
## Attr
##

Ill-formed attributed sum type or record type.
At this point, if the attributes are complete, one of the following is
expected:
  * an opening brace '{' followed by field declarations, if defining a
    record type;
  * a variant starting with a value constructor, if defining a sum
    type (the attributes then apply to the variant, not the type);
  * a vertical bar followed by a variant (the attributes then apply to
    the sum type, not the variant).

interactive_expr: Fun LBRACE Ident EQ UIdent With
##
## Ends in an error in state: 194.
##
## field_pattern(irrefutable) -> field_pattern_lhs EQ ctor_irrefutable . [ SEMI RBRACE ]
## tuple(core_irrefutable) -> ctor_irrefutable . COMMA nsepseq(core_irrefutable,COMMA) [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## field_pattern_lhs EQ ctor_irrefutable
##
contract: Let LBRACE Ident EQ Ident With
##
## Ends in an error in state: 189.
##
## field_pattern(irrefutable) -> field_pattern_lhs EQ var_pattern . [ SEMI RBRACE ]
## tuple(core_irrefutable) -> var_pattern . COMMA nsepseq(core_irrefutable,COMMA) [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## field_pattern_lhs EQ var_pattern
##
contract: Let LBRACE Ident EQ LPAR RPAR With
##
## Ends in an error in state: 190.
##
## field_pattern(irrefutable) -> field_pattern_lhs EQ unit . [ SEMI RBRACE ]
## tuple(core_irrefutable) -> unit . COMMA nsepseq(core_irrefutable,COMMA) [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## field_pattern_lhs EQ unit
##
contract: Let LBRACE Ident EQ LBRACE Ident RBRACE With
##
## Ends in an error in state: 192.
##
## field_pattern(irrefutable) -> field_pattern_lhs EQ record_pattern(irrefutable) . [ SEMI RBRACE ]
## tuple(core_irrefutable) -> record_pattern(irrefutable) . COMMA nsepseq(core_irrefutable,COMMA) [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## field_pattern_lhs EQ record_pattern(irrefutable)
##
contract: Let LBRACE Ident EQ LPAR WILD RPAR With
##
## Ends in an error in state: 193.
##
## field_pattern(irrefutable) -> field_pattern_lhs EQ par(in_core_irrefutable) . [ SEMI RBRACE ]
## tuple(core_irrefutable) -> par(in_core_irrefutable) . COMMA nsepseq(core_irrefutable,COMMA) [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## field_pattern_lhs EQ par(in_core_irrefutable)
##

Ill-formed record pattern.
At this point, one of the following is expected:
  * a comma ',' followed by a tuple component as a pattern, if the
    field is a tuple;
  * a semicolon ';' if the field is punned (that is, a variable with
    the same name is implicitly the pattern);
  * a closing brace '}' if the record pattern is complete.

contract: Let LPAR Ident With
##
## Ends in an error in state: 208.
##
## in_core_irrefutable -> var_pattern . [ RPAR ]
## tuple(core_irrefutable) -> var_pattern . COMMA nsepseq(core_irrefutable,COMMA) [ RPAR COLON ]
## typed_irrefutable -> var_pattern . type_annotation(type_expr) [ RPAR ]
##
## The known suffix of the stack is as follows:
## var_pattern
##
contract: Let LPAR LPAR RPAR With
##
## Ends in an error in state: 210.
##
## in_core_irrefutable -> unit . [ RPAR ]
## tuple(core_irrefutable) -> unit . COMMA nsepseq(core_irrefutable,COMMA) [ RPAR COLON ]
## typed_irrefutable -> unit . type_annotation(type_expr) [ RPAR ]
##
## The known suffix of the stack is as follows:
## unit
##
contract: Let LPAR LBRACE Ident RBRACE With
##
## Ends in an error in state: 215.
##
## in_core_irrefutable -> record_pattern(irrefutable) . [ RPAR ]
## tuple(core_irrefutable) -> record_pattern(irrefutable) . COMMA nsepseq(core_irrefutable,COMMA) [ RPAR COLON ]
## typed_irrefutable -> record_pattern(irrefutable) . type_annotation(type_expr) [ RPAR ]
##
## The known suffix of the stack is as follows:
## record_pattern(irrefutable)
##
contract: Let LPAR LPAR WILD RPAR With
##
## Ends in an error in state: 217.
##
## in_core_irrefutable -> par(in_core_irrefutable) . [ RPAR ]
## tuple(core_irrefutable) -> par(in_core_irrefutable) . COMMA nsepseq(core_irrefutable,COMMA) [ RPAR COLON ]
## typed_irrefutable -> par(in_core_irrefutable) . type_annotation(type_expr) [ RPAR ]
##
## The known suffix of the stack is as follows:
## par(in_core_irrefutable)
##
contract: Let LPAR UIdent With
##
## Ends in an error in state: 137.
##
## const_ctor_pattern -> UIdent . [ RPAR COMMA COLON ]
## non_const_ctor_irrefutable -> UIdent . unit [ RPAR ]
## non_const_ctor_irrefutable -> UIdent . record_pattern(irrefutable) [ RPAR ]
## non_const_ctor_irrefutable -> UIdent . par(in_core_irrefutable) [ RPAR ]
## non_const_ctor_irrefutable -> UIdent . var_pattern [ RPAR ]
## non_const_ctor_irrefutable -> UIdent . ctor_irrefutable [ RPAR ]
##
## The known suffix of the stack is as follows:
## UIdent
##

Ill-formed pattern.
At this point, one of the following is expected:
  * a closing parenthesis ')', if the pattern is complete;
  * a comma ',' followed by another component as a pattern, if
    defining a tuple pattern;
  * a type annotation starting with ':'.

contract: Let Ident With
##
## Ends in an error in state: 225.
##
## let_binding -> var_pattern . parameters EQ expr [ Type Module Let In End EOF Directive Attr ]
## let_binding -> var_pattern . parameters type_annotation(type_expr) EQ expr [ Type Module Let In End EOF Directive Attr ]
## let_binding -> var_pattern . par(__anonymous_7) parameters EQ expr [ Type Module Let In End EOF Directive Attr ]
## let_binding -> var_pattern . par(__anonymous_7) parameters type_annotation(type_expr) EQ expr [ Type Module Let In End EOF Directive Attr ]
## let_binding -> var_pattern . EQ expr [ Type Module Let In End EOF Directive Attr ]
## let_binding -> var_pattern . type_annotation(type_expr) EQ expr [ Type Module Let In End EOF Directive Attr ]
## let_binding -> var_pattern . par(__anonymous_7) EQ expr [ Type Module Let In End EOF Directive Attr ]
## let_binding -> var_pattern . par(__anonymous_7) type_annotation(type_expr) EQ expr [ Type Module Let In End EOF Directive Attr ]
## tuple(core_irrefutable) -> var_pattern . COMMA nsepseq(core_irrefutable,COMMA) [ LPAR EQ COLON ]
##
## The known suffix of the stack is as follows:
## var_pattern
##

Ill-formed value declaration.
At this point, one of the following is expected:
  * parameters as irrefutable patterns, e.g. variables, if defining a
    function;
  * the assignment symbol '=' followed by an expression;
  * a type annotation starting with a colon ':';
  * a comma ',' followed by another tuple component, if defining a
    tuple.

contract: Let LPAR RPAR LPAR Type Ident RPAR With
##
## Ends in an error in state: 991.
##
## let_binding -> unit par(__anonymous_7) . EQ expr [ Type Module Let In End EOF Directive Attr ]
## let_binding -> unit par(__anonymous_7) . type_annotation(type_expr) EQ expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## unit par(__anonymous_7)
##
contract: Let WILD COMMA Ident LPAR Type Ident RPAR With
##
## Ends in an error in state: 558.
##
## let_binding -> tuple(core_irrefutable) par(__anonymous_7) . EQ expr [ Type Module Let In End EOF Directive Attr ]
## let_binding -> tuple(core_irrefutable) par(__anonymous_7) . type_annotation(type_expr) EQ expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## tuple(core_irrefutable) par(__anonymous_7)
##
contract: Let LBRACE Ident RBRACE LPAR Type Ident RPAR With
##
## Ends in an error in state: 570.
##
## let_binding -> record_pattern(irrefutable) par(__anonymous_7) . EQ expr [ Type Module Let In End EOF Directive Attr ]
## let_binding -> record_pattern(irrefutable) par(__anonymous_7) . type_annotation(type_expr) EQ expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## record_pattern(irrefutable) par(__anonymous_7)
##
contract: Let LPAR WILD RPAR LPAR Type Ident RPAR With
##
## Ends in an error in state: 582.
##
## let_binding -> par(in_core_irrefutable) par(__anonymous_7) . EQ expr [ Type Module Let In End EOF Directive Attr ]
## let_binding -> par(in_core_irrefutable) par(__anonymous_7) . type_annotation(type_expr) EQ expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## par(in_core_irrefutable) par(__anonymous_7)
##
contract: Let UIdent LPAR Type Ident RPAR With
##
## Ends in an error in state: 687.
##
## let_binding -> ctor_irrefutable par(__anonymous_7) . EQ expr [ Type Module Let In End EOF Directive Attr ]
## let_binding -> ctor_irrefutable par(__anonymous_7) . type_annotation(type_expr) EQ expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## ctor_irrefutable par(__anonymous_7)
##
contract: Let WILD LPAR Type Ident RPAR With
##
## Ends in an error in state: 1032.
##
## let_binding -> var_pattern par(__anonymous_7) . parameters EQ expr [ Type Module Let In End EOF Directive Attr ]
## let_binding -> var_pattern par(__anonymous_7) . parameters type_annotation(type_expr) EQ expr [ Type Module Let In End EOF Directive Attr ]
## let_binding -> var_pattern par(__anonymous_7) . EQ expr [ Type Module Let In End EOF Directive Attr ]
## let_binding -> var_pattern par(__anonymous_7) . type_annotation(type_expr) EQ expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## var_pattern par(__anonymous_7)
##

Ill-formed value declaration.
At this point, one of the following is expected:
  * the assignment symbol '=' followed by an expression;
  * a type annotation starting with a colon ':'.

contract: Let Ident LPAR Type Ident RPAR WILD ARROW
##
## Ends in an error in state: 1038.
##
## let_binding -> var_pattern par(__anonymous_7) parameters . EQ expr [ Type Module Let In End EOF Directive Attr ]
## let_binding -> var_pattern par(__anonymous_7) parameters . type_annotation(type_expr) EQ expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## var_pattern par(__anonymous_7) parameters
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 268, spurious reduction of production seq(core_irrefutable) ->
## In state 279, spurious reduction of production nseq(core_irrefutable) -> var_pattern seq(core_irrefutable)
## In state 1044, spurious reduction of production parameters -> nseq(core_irrefutable)
##
contract: Let Ident WILD ARROW
##
## Ends in an error in state: 1026.
##
## let_binding -> var_pattern parameters . EQ expr [ Type Module Let In End EOF Directive Attr ]
## let_binding -> var_pattern parameters . type_annotation(type_expr) EQ expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## var_pattern parameters
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 268, spurious reduction of production seq(core_irrefutable) ->
## In state 279, spurious reduction of production nseq(core_irrefutable) -> var_pattern seq(core_irrefutable)
## In state 1044, spurious reduction of production parameters -> nseq(core_irrefutable)
##

Ill-formed function declaration.
At this point, if there are no more parameters, one of the following
is expected:
  * the assignment symbol '=' followed by an expression;
  * a type annotation starting with a colon ':'.

contract: Let LBRACE Ident RBRACE With
##
## Ends in an error in state: 564.
##
## let_binding -> record_pattern(irrefutable) . EQ expr [ Type Module Let In End EOF Directive Attr ]
## let_binding -> record_pattern(irrefutable) . type_annotation(type_expr) EQ expr [ Type Module Let In End EOF Directive Attr ]
## let_binding -> record_pattern(irrefutable) . par(__anonymous_7) EQ expr [ Type Module Let In End EOF Directive Attr ]
## let_binding -> record_pattern(irrefutable) . par(__anonymous_7) type_annotation(type_expr) EQ expr [ Type Module Let In End EOF Directive Attr ]
## tuple(core_irrefutable) -> record_pattern(irrefutable) . COMMA nsepseq(core_irrefutable,COMMA) [ LPAR EQ COLON ]
##
## The known suffix of the stack is as follows:
## record_pattern(irrefutable)
##
contract: Let LPAR WILD RPAR With
##
## Ends in an error in state: 576.
##
## let_binding -> par(in_core_irrefutable) . EQ expr [ Type Module Let In End EOF Directive Attr ]
## let_binding -> par(in_core_irrefutable) . type_annotation(type_expr) EQ expr [ Type Module Let In End EOF Directive Attr ]
## let_binding -> par(in_core_irrefutable) . par(__anonymous_7) EQ expr [ Type Module Let In End EOF Directive Attr ]
## let_binding -> par(in_core_irrefutable) . par(__anonymous_7) type_annotation(type_expr) EQ expr [ Type Module Let In End EOF Directive Attr ]
## tuple(core_irrefutable) -> par(in_core_irrefutable) . COMMA nsepseq(core_irrefutable,COMMA) [ LPAR EQ COLON ]
##
## The known suffix of the stack is as follows:
## par(in_core_irrefutable)
##
contract: Let UIdent With
##
## Ends in an error in state: 681.
##
## let_binding -> ctor_irrefutable . EQ expr [ Type Module Let In End EOF Directive Attr ]
## let_binding -> ctor_irrefutable . type_annotation(type_expr) EQ expr [ Type Module Let In End EOF Directive Attr ]
## let_binding -> ctor_irrefutable . par(__anonymous_7) EQ expr [ Type Module Let In End EOF Directive Attr ]
## let_binding -> ctor_irrefutable . par(__anonymous_7) type_annotation(type_expr) EQ expr [ Type Module Let In End EOF Directive Attr ]
## tuple(core_irrefutable) -> ctor_irrefutable . COMMA nsepseq(core_irrefutable,COMMA) [ LPAR EQ COLON ]
##
## The known suffix of the stack is as follows:
## ctor_irrefutable
##

Ill-formed tuple declaration.
At this point, one of the following is expected:
  * a comma ',' followed by another component as a pattern;
  * the assignment symbol '=' followed by an expression;
  * a type annotation starting with a colon ':';
  * bound type parameters between parentheses, like '(type a b)'.

interactive_expr: Begin Fun LPAR Type Ident RPAR WILD EQ
##
## Ends in an error in state: 824.
##
## fun_expr(last_expr) -> Fun par(__anonymous_7) nseq(core_irrefutable) . ARROW last_expr [ End ]
## fun_expr(last_expr) -> Fun par(__anonymous_7) nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW last_expr [ End ]
##
## The known suffix of the stack is as follows:
## Fun par(__anonymous_7) nseq(core_irrefutable)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 268, spurious reduction of production seq(core_irrefutable) ->
## In state 279, spurious reduction of production nseq(core_irrefutable) -> var_pattern seq(core_irrefutable)
##
interactive_expr: Begin Fun WILD EQ
##
## Ends in an error in state: 844.
##
## fun_expr(last_expr) -> Fun nseq(core_irrefutable) . ARROW last_expr [ End ]
## fun_expr(last_expr) -> Fun nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW last_expr [ End ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 268, spurious reduction of production seq(core_irrefutable) ->
## In state 279, spurious reduction of production nseq(core_irrefutable) -> var_pattern seq(core_irrefutable)
##
interactive_expr: Begin If Verbatim Then Fun WILD EQ
##
## Ends in an error in state: 811.
##
## fun_expr(closed_expr) -> Fun nseq(core_irrefutable) . ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> Fun nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 268, spurious reduction of production seq(core_irrefutable) ->
## In state 279, spurious reduction of production nseq(core_irrefutable) -> var_pattern seq(core_irrefutable)
##
interactive_expr: Begin Match Verbatim With WILD ARROW Fun LPAR Type Ident RPAR WILD EQ
##
## Ends in an error in state: 772.
##
## fun_expr(base_cond) -> Fun par(__anonymous_7) nseq(core_irrefutable) . ARROW base_cond [ VBAR ]
## fun_expr(base_cond) -> Fun par(__anonymous_7) nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW base_cond [ VBAR ]
## fun_expr(last_expr) -> Fun par(__anonymous_7) nseq(core_irrefutable) . ARROW last_expr [ End ]
## fun_expr(last_expr) -> Fun par(__anonymous_7) nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW last_expr [ End ]
##
## The known suffix of the stack is as follows:
## Fun par(__anonymous_7) nseq(core_irrefutable)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 268, spurious reduction of production seq(core_irrefutable) ->
## In state 279, spurious reduction of production nseq(core_irrefutable) -> var_pattern seq(core_irrefutable)
##
interactive_expr: Begin Match Verbatim With WILD ARROW Fun WILD EQ
##
## Ends in an error in state: 859.
##
## fun_expr(base_cond) -> Fun nseq(core_irrefutable) . ARROW base_cond [ VBAR ]
## fun_expr(base_cond) -> Fun nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW base_cond [ VBAR ]
## fun_expr(last_expr) -> Fun nseq(core_irrefutable) . ARROW last_expr [ End ]
## fun_expr(last_expr) -> Fun nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW last_expr [ End ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 268, spurious reduction of production seq(core_irrefutable) ->
## In state 279, spurious reduction of production nseq(core_irrefutable) -> var_pattern seq(core_irrefutable)
##
interactive_expr: Fun LPAR Type Ident RPAR WILD EQ
##
## Ends in an error in state: 287.
##
## fun_expr(expr) -> Fun par(__anonymous_7) nseq(core_irrefutable) . ARROW expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(expr) -> Fun par(__anonymous_7) nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun par(__anonymous_7) nseq(core_irrefutable)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 268, spurious reduction of production seq(core_irrefutable) ->
## In state 279, spurious reduction of production nseq(core_irrefutable) -> var_pattern seq(core_irrefutable)
##
interactive_expr: Fun WILD EQ
##
## Ends in an error in state: 878.
##
## fun_expr(expr) -> Fun nseq(core_irrefutable) . ARROW expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(expr) -> Fun nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 268, spurious reduction of production seq(core_irrefutable) ->
## In state 279, spurious reduction of production nseq(core_irrefutable) -> var_pattern seq(core_irrefutable)
##
interactive_expr: If Verbatim Then Fun LPAR Type Ident RPAR WILD EQ
##
## Ends in an error in state: 900.
##
## fun_expr(closed_expr) -> Fun par(__anonymous_7) nseq(core_irrefutable) . ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> Fun par(__anonymous_7) nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW closed_expr [ Else ]
## fun_expr(expr) -> Fun par(__anonymous_7) nseq(core_irrefutable) . ARROW expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(expr) -> Fun par(__anonymous_7) nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun par(__anonymous_7) nseq(core_irrefutable)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 268, spurious reduction of production seq(core_irrefutable) ->
## In state 279, spurious reduction of production nseq(core_irrefutable) -> var_pattern seq(core_irrefutable)
##
interactive_expr: If Verbatim Then Fun WILD EQ
##
## Ends in an error in state: 911.
##
## fun_expr(closed_expr) -> Fun nseq(core_irrefutable) . ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> Fun nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW closed_expr [ Else ]
## fun_expr(expr) -> Fun nseq(core_irrefutable) . ARROW expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(expr) -> Fun nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 268, spurious reduction of production seq(core_irrefutable) ->
## In state 279, spurious reduction of production nseq(core_irrefutable) -> var_pattern seq(core_irrefutable)
##
interactive_expr: If Verbatim Then Match Verbatim With WILD ARROW Fun LPAR Type Ident RPAR WILD EQ
##
## Ends in an error in state: 721.
##
## fun_expr(base_cond) -> Fun par(__anonymous_7) nseq(core_irrefutable) . ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_cond) -> Fun par(__anonymous_7) nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_if_then_else) -> Fun par(__anonymous_7) nseq(core_irrefutable) . ARROW base_if_then_else [ Else ]
## fun_expr(base_if_then_else) -> Fun par(__anonymous_7) nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## Fun par(__anonymous_7) nseq(core_irrefutable)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 268, spurious reduction of production seq(core_irrefutable) ->
## In state 279, spurious reduction of production nseq(core_irrefutable) -> var_pattern seq(core_irrefutable)
##
interactive_expr: If Verbatim Then Match Verbatim With WILD ARROW Fun WILD EQ
##
## Ends in an error in state: 745.
##
## fun_expr(base_cond) -> Fun nseq(core_irrefutable) . ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_cond) -> Fun nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_if_then_else) -> Fun nseq(core_irrefutable) . ARROW base_if_then_else [ Else ]
## fun_expr(base_if_then_else) -> Fun nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 268, spurious reduction of production seq(core_irrefutable) ->
## In state 279, spurious reduction of production nseq(core_irrefutable) -> var_pattern seq(core_irrefutable)
##
interactive_expr: Match Verbatim With WILD ARROW Fun LPAR Type Ident RPAR WILD EQ
##
## Ends in an error in state: 656.
##
## fun_expr(base_cond) -> Fun par(__anonymous_7) nseq(core_irrefutable) . ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_cond) -> Fun par(__anonymous_7) nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun par(__anonymous_7) nseq(core_irrefutable)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 268, spurious reduction of production seq(core_irrefutable) ->
## In state 279, spurious reduction of production nseq(core_irrefutable) -> var_pattern seq(core_irrefutable)
##
interactive_expr: Match Verbatim With WILD ARROW Fun WILD EQ
##
## Ends in an error in state: 674.
##
## fun_expr(base_cond) -> Fun nseq(core_irrefutable) . ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_cond) -> Fun nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 268, spurious reduction of production seq(core_irrefutable) ->
## In state 279, spurious reduction of production nseq(core_irrefutable) -> var_pattern seq(core_irrefutable)
##
interactive_expr: Match Verbatim With WILD ARROW If Verbatim Then Fun LPAR Type Ident RPAR WILD EQ
##
## Ends in an error in state: 615.
##
## fun_expr(base_cond) -> Fun par(__anonymous_7) nseq(core_irrefutable) . ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_cond) -> Fun par(__anonymous_7) nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(closed_expr) -> Fun par(__anonymous_7) nseq(core_irrefutable) . ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> Fun par(__anonymous_7) nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Fun par(__anonymous_7) nseq(core_irrefutable)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 268, spurious reduction of production seq(core_irrefutable) ->
## In state 279, spurious reduction of production nseq(core_irrefutable) -> var_pattern seq(core_irrefutable)
##
interactive_expr: Match Verbatim With WILD ARROW If Verbatim Then Fun WILD EQ
##
## Ends in an error in state: 704.
##
## fun_expr(base_cond) -> Fun nseq(core_irrefutable) . ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_cond) -> Fun nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(closed_expr) -> Fun nseq(core_irrefutable) . ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> Fun nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 268, spurious reduction of production seq(core_irrefutable) ->
## In state 279, spurious reduction of production nseq(core_irrefutable) -> var_pattern seq(core_irrefutable)
##

Ill-formed functional expression.
At this point, if there are no more parameters, one of the following
is expected:
  * an arrow '->', followed by the body as an expression;
  * a type annotation for the body, starting with a colon ':'.

interactive_expr: Bytes GT ZWSP ZWSP
##
## Ends in an error in state: 421.
##
## ge -> GT ZWSP . EQ [ Verbatim UIdent String Not Nat Mutez MINUS Lang LPAR LBRACKET LBRACE Int Ident Bytes Begin Attr ]
##
## The known suffix of the stack is as follows:
## GT ZWSP
##

This syntax error should not happen. Please report to the developpers.

contract: Let UIdent COLON VBAR UIdent ZWSP
##
## Ends in an error in state: 18.
##
## short_variant(fun_type_level) -> UIdent . [ VBAR Type SEMI RPAR RBRACE Module Let In End EQ EOF Directive COMMA Attr ]
## short_variant(fun_type_level) -> UIdent . of_type(fun_type_level) [ VBAR Type SEMI RPAR RBRACE Module Let In End EQ EOF Directive COMMA Attr ]
##
## The known suffix of the stack is as follows:
## UIdent
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Let UIdent COLON UIdent DOT LPAR ZWSP
##
## Ends in an error in state: 22.
##
## par(type_expr) -> LPAR . type_expr RPAR [ VBAR UIdent Type TIMES SEMI RPAR RBRACE Module Let In Ident End EQ EOF Directive COMMA Attr ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Let UIdent COLON Attr Attr ZWSP
##
## Ends in an error in state: 33.
##
## core_type -> Attr . core_type [ Type TIMES SEMI RPAR RBRACE Module Let In End EQ EOF Directive COMMA Attr ARROW ]
## seq(Attr) -> Attr . seq(Attr) [ VBAR ]
## short_variant(fun_type_level) -> Attr . short_variant(fun_type_level) [ VBAR Type SEMI RPAR RBRACE Module Let In End EQ EOF Directive COMMA Attr ]
##
## The known suffix of the stack is as follows:
## Attr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Let UIdent COLON Ident UIdent ZWSP
##
## Ends in an error in state: 37.
##
## module_path(__anonymous_4) -> UIdent . DOT module_path(__anonymous_4) [ VBAR UIdent Type TIMES SEMI RPAR RBRACE Module Let In Ident End EQ EOF Directive COMMA Attr ARROW ]
## module_path(__anonymous_4) -> UIdent . DOT Ident [ VBAR UIdent Type TIMES SEMI RPAR RBRACE Module Let In Ident End EQ EOF Directive COMMA Attr ARROW ]
##
## The known suffix of the stack is as follows:
## UIdent
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Let UIdent COLON Ident UIdent DOT ZWSP
##
## Ends in an error in state: 38.
##
## module_path(__anonymous_4) -> UIdent DOT . module_path(__anonymous_4) [ VBAR UIdent Type TIMES SEMI RPAR RBRACE Module Let In Ident End EQ EOF Directive COMMA Attr ARROW ]
## module_path(__anonymous_4) -> UIdent DOT . Ident [ VBAR UIdent Type TIMES SEMI RPAR RBRACE Module Let In Ident End EQ EOF Directive COMMA Attr ARROW ]
##
## The known suffix of the stack is as follows:
## UIdent DOT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: LBRACE Attr Attr ZWSP
##
## Ends in an error in state: 84.
##
## seq(Attr) -> Attr . seq(Attr) [ WILD Ident ]
##
## The known suffix of the stack is as follows:
## Attr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Let UIdent COLON LBRACE Attr WILD
##
## Ends in an error in state: 89.
##
## field_decl -> nseq(Attr) . Ident [ SEMI RBRACE ]
## field_decl -> nseq(Attr) . Ident type_annotation(type_expr) [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## nseq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 83, spurious reduction of production seq(Attr) ->
## In state 58, spurious reduction of production nseq(Attr) -> Attr seq(Attr)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Let UIdent COLON VBAR Attr ZWSP
##
## Ends in an error in state: 115.
##
## short_variant(fun_type_level) -> Attr . short_variant(fun_type_level) [ VBAR Type SEMI RPAR RBRACE Module Let In End EQ EOF Directive COMMA Attr ]
##
## The known suffix of the stack is as follows:
## Attr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Let UIdent COLON UIdent DOT LPAR Ident VBAR
##
## Ends in an error in state: 109.
##
## par(type_expr) -> LPAR type_expr . RPAR [ VBAR UIdent Type TIMES SEMI RPAR RBRACE Module Let In Ident End EQ EOF Directive COMMA Attr ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR type_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 53, spurious reduction of production core_type -> no_attr_type
## In state 72, spurious reduction of production cartesian_level -> core_type
## In state 79, spurious reduction of production fun_type_level -> cartesian_level
## In state 71, spurious reduction of production type_expr -> fun_type_level
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Module UIdent EQ UIdent ZWSP
##
## Ends in an error in state: 127.
##
## module_expr -> UIdent . [ Type Module Let In End EOF Directive Attr ]
## module_path(module_name) -> UIdent . DOT module_path(module_name) [ Type Module Let In End EOF Directive Attr ]
## module_path(module_name) -> UIdent . DOT UIdent [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## UIdent
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Module UIdent EQ UIdent DOT UIdent ZWSP
##
## Ends in an error in state: 129.
##
## module_path(module_name) -> UIdent . DOT module_path(module_name) [ Type Module Let In End EOF Directive Attr ]
## module_path(module_name) -> UIdent . DOT UIdent [ Type Module Let In End EOF Directive Attr ]
## module_path(module_name) -> UIdent DOT UIdent . [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## UIdent DOT UIdent
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Let LBRACE Attr Ident ZWSP
##
## Ends in an error in state: 146.
##
## field_pattern(irrefutable) -> nseq(Attr) field_pattern_lhs . [ SEMI RBRACE ]
## field_pattern(irrefutable) -> nseq(Attr) field_pattern_lhs . EQ tuple(core_irrefutable) [ SEMI RBRACE ]
## field_pattern(irrefutable) -> nseq(Attr) field_pattern_lhs . EQ unit [ SEMI RBRACE ]
## field_pattern(irrefutable) -> nseq(Attr) field_pattern_lhs . EQ record_pattern(irrefutable) [ SEMI RBRACE ]
## field_pattern(irrefutable) -> nseq(Attr) field_pattern_lhs . EQ par(in_core_irrefutable) [ SEMI RBRACE ]
## field_pattern(irrefutable) -> nseq(Attr) field_pattern_lhs . EQ var_pattern [ SEMI RBRACE ]
## field_pattern(irrefutable) -> nseq(Attr) field_pattern_lhs . EQ ctor_irrefutable [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) field_pattern_lhs
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Let LBRACE Attr Ident EQ ZWSP
##
## Ends in an error in state: 147.
##
## field_pattern(irrefutable) -> nseq(Attr) field_pattern_lhs EQ . tuple(core_irrefutable) [ SEMI RBRACE ]
## field_pattern(irrefutable) -> nseq(Attr) field_pattern_lhs EQ . unit [ SEMI RBRACE ]
## field_pattern(irrefutable) -> nseq(Attr) field_pattern_lhs EQ . record_pattern(irrefutable) [ SEMI RBRACE ]
## field_pattern(irrefutable) -> nseq(Attr) field_pattern_lhs EQ . par(in_core_irrefutable) [ SEMI RBRACE ]
## field_pattern(irrefutable) -> nseq(Attr) field_pattern_lhs EQ . var_pattern [ SEMI RBRACE ]
## field_pattern(irrefutable) -> nseq(Attr) field_pattern_lhs EQ . ctor_irrefutable [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) field_pattern_lhs EQ
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Let LBRACE Attr Ident EQ Ident ZWSP
##
## Ends in an error in state: 151.
##
## field_pattern(irrefutable) -> nseq(Attr) field_pattern_lhs EQ var_pattern . [ SEMI RBRACE ]
## tuple(core_irrefutable) -> var_pattern . COMMA nsepseq(core_irrefutable,COMMA) [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) field_pattern_lhs EQ var_pattern
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Let UIdent COMMA LPAR RPAR ZWSP
##
## Ends in an error in state: 155.
##
## nsepseq(core_irrefutable,COMMA) -> unit . [ SEMI RPAR RBRACE LPAR EQ COLON ]
## nsepseq(core_irrefutable,COMMA) -> unit . COMMA nsepseq(core_irrefutable,COMMA) [ SEMI RPAR RBRACE LPAR EQ COLON ]
##
## The known suffix of the stack is as follows:
## unit
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Let UIdent COMMA LBRACE RBRACE ZWSP
##
## Ends in an error in state: 157.
##
## nsepseq(core_irrefutable,COMMA) -> record_pattern(irrefutable) . [ SEMI RPAR RBRACE LPAR EQ COLON ]
## nsepseq(core_irrefutable,COMMA) -> record_pattern(irrefutable) . COMMA nsepseq(core_irrefutable,COMMA) [ SEMI RPAR RBRACE LPAR EQ COLON ]
##
## The known suffix of the stack is as follows:
## record_pattern(irrefutable)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Let UIdent COMMA LPAR UIdent RPAR ZWSP
##
## Ends in an error in state: 161.
##
## nsepseq(core_irrefutable,COMMA) -> par(in_core_irrefutable) . [ SEMI RPAR RBRACE LPAR EQ COLON ]
## nsepseq(core_irrefutable,COMMA) -> par(in_core_irrefutable) . COMMA nsepseq(core_irrefutable,COMMA) [ SEMI RPAR RBRACE LPAR EQ COLON ]
##
## The known suffix of the stack is as follows:
## par(in_core_irrefutable)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Let UIdent COMMA UIdent ZWSP
##
## Ends in an error in state: 164.
##
## nsepseq(core_irrefutable,COMMA) -> ctor_irrefutable . [ SEMI RPAR RBRACE LPAR EQ COLON ]
## nsepseq(core_irrefutable,COMMA) -> ctor_irrefutable . COMMA nsepseq(core_irrefutable,COMMA) [ SEMI RPAR RBRACE LPAR EQ COLON ]
##
## The known suffix of the stack is as follows:
## ctor_irrefutable
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Let LBRACE Attr Ident EQ LPAR RPAR ZWSP
##
## Ends in an error in state: 173.
##
## field_pattern(irrefutable) -> nseq(Attr) field_pattern_lhs EQ unit . [ SEMI RBRACE ]
## tuple(core_irrefutable) -> unit . COMMA nsepseq(core_irrefutable,COMMA) [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) field_pattern_lhs EQ unit
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Let LBRACE Attr Ident EQ LBRACE RBRACE ZWSP
##
## Ends in an error in state: 177.
##
## field_pattern(irrefutable) -> nseq(Attr) field_pattern_lhs EQ record_pattern(irrefutable) . [ SEMI RBRACE ]
## tuple(core_irrefutable) -> record_pattern(irrefutable) . COMMA nsepseq(core_irrefutable,COMMA) [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) field_pattern_lhs EQ record_pattern(irrefutable)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Let LBRACE Attr Ident EQ LPAR UIdent RPAR ZWSP
##
## Ends in an error in state: 180.
##
## field_pattern(irrefutable) -> nseq(Attr) field_pattern_lhs EQ par(in_core_irrefutable) . [ SEMI RBRACE ]
## tuple(core_irrefutable) -> par(in_core_irrefutable) . COMMA nsepseq(core_irrefutable,COMMA) [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) field_pattern_lhs EQ par(in_core_irrefutable)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Let LBRACE Attr Ident EQ UIdent ZWSP
##
## Ends in an error in state: 183.
##
## field_pattern(irrefutable) -> nseq(Attr) field_pattern_lhs EQ ctor_irrefutable . [ SEMI RBRACE ]
## tuple(core_irrefutable) -> ctor_irrefutable . COMMA nsepseq(core_irrefutable,COMMA) [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) field_pattern_lhs EQ ctor_irrefutable
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Let LBRACE Ident EQ UIdent COMMA UIdent LPAR
##
## Ends in an error in state: 195.
##
## nsepseq(field_pattern(irrefutable),SEMI) -> field_pattern(irrefutable) . [ RBRACE ]
## nsepseq(field_pattern(irrefutable),SEMI) -> field_pattern(irrefutable) . SEMI nsepseq(field_pattern(irrefutable),SEMI) [ RBRACE ]
## nseq(__anonymous_0(field_pattern(irrefutable),SEMI)) -> field_pattern(irrefutable) . SEMI seq(__anonymous_0(field_pattern(irrefutable),SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_pattern(irrefutable)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 164, spurious reduction of production nsepseq(core_irrefutable,COMMA) -> ctor_irrefutable
## In state 185, spurious reduction of production tuple(core_irrefutable) -> ctor_irrefutable COMMA nsepseq(core_irrefutable,COMMA)
## In state 191, spurious reduction of production field_pattern(irrefutable) -> field_pattern_lhs EQ tuple(core_irrefutable)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Let LBRACE Ident SEMI Ident EQ UIdent COMMA UIdent LPAR
##
## Ends in an error in state: 199.
##
## nsepseq(field_pattern(irrefutable),SEMI) -> field_pattern(irrefutable) . [ RBRACE ]
## nsepseq(field_pattern(irrefutable),SEMI) -> field_pattern(irrefutable) . SEMI nsepseq(field_pattern(irrefutable),SEMI) [ RBRACE ]
## seq(__anonymous_0(field_pattern(irrefutable),SEMI)) -> field_pattern(irrefutable) . SEMI seq(__anonymous_0(field_pattern(irrefutable),SEMI)) [ RBRACE ]
##
## The known suffix of the stack is as follows:
## field_pattern(irrefutable)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 164, spurious reduction of production nsepseq(core_irrefutable,COMMA) -> ctor_irrefutable
## In state 185, spurious reduction of production tuple(core_irrefutable) -> ctor_irrefutable COMMA nsepseq(core_irrefutable,COMMA)
## In state 191, spurious reduction of production field_pattern(irrefutable) -> field_pattern_lhs EQ tuple(core_irrefutable)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Let LPAR UIdent COMMA UIdent SEMI
##
## Ends in an error in state: 213.
##
## in_core_irrefutable -> tuple(core_irrefutable) . [ RPAR ]
## typed_irrefutable -> tuple(core_irrefutable) . type_annotation(type_expr) [ RPAR ]
##
## The known suffix of the stack is as follows:
## tuple(core_irrefutable)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 164, spurious reduction of production nsepseq(core_irrefutable,COMMA) -> ctor_irrefutable
## In state 185, spurious reduction of production tuple(core_irrefutable) -> ctor_irrefutable COMMA nsepseq(core_irrefutable,COMMA)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Let LPAR LPAR UIdent UIdent RPAR ZWSP
##
## Ends in an error in state: 223.
##
## in_core_irrefutable -> ctor_irrefutable . [ RPAR ]
## tuple(core_irrefutable) -> ctor_irrefutable . COMMA nsepseq(core_irrefutable,COMMA) [ RPAR COLON ]
## typed_irrefutable -> ctor_irrefutable . type_annotation(type_expr) [ RPAR ]
##
## The known suffix of the stack is as follows:
## ctor_irrefutable
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: UIdent ZWSP
##
## Ends in an error in state: 236.
##
## module_path(selected) -> UIdent . DOT module_path(selected) [ With Verbatim VBAR UIdent Type Then TIMES String SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Lxor Lsr Lsl Lor Let Lang Land LT LPAR LE LBRACKET LBRACE Int In Ident GT End Else EQ EOF Directive CONS COMMA COLON CARET Bytes Begin BOOL_OR BOOL_AND Attr ]
## module_path(selected) -> UIdent . DOT selected [ With Verbatim VBAR UIdent Type Then TIMES String SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Lxor Lsr Lsl Lor Let Lang Land LT LPAR LE LBRACKET LBRACE Int In Ident GT End Else EQ EOF Directive CONS COMMA COLON CARET Bytes Begin BOOL_OR BOOL_AND Attr ]
## no_attr_expr -> UIdent . [ With Verbatim VBAR UIdent Type Then TIMES String SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Lxor Lsr Lsl Lor Let Lang Land LT LPAR LE LBRACKET LBRACE Int In Ident GT End Else EQ EOF Directive CONS COMMA COLON CARET Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## UIdent
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: UIdent DOT UIdent ZWSP
##
## Ends in an error in state: 238.
##
## module_path(selected) -> UIdent . DOT module_path(selected) [ With Verbatim VBAR UIdent Type Then TIMES String SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Lxor Lsr Lsl Lor Let Lang Land LT LPAR LE LBRACKET LBRACE Int In Ident GT End Else EQ EOF Directive CONS COMMA COLON CARET Bytes Begin BOOL_OR BOOL_AND Attr ]
## module_path(selected) -> UIdent . DOT selected [ With Verbatim VBAR UIdent Type Then TIMES String SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Lxor Lsr Lsl Lor Let Lang Land LT LPAR LE LBRACKET LBRACE Int In Ident GT End Else EQ EOF Directive CONS COMMA COLON CARET Bytes Begin BOOL_OR BOOL_AND Attr ]
## selected -> UIdent . [ With Verbatim VBAR UIdent Type Then TIMES String SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Lxor Lsr Lsl Lor Let Lang Land LT LPAR LE LBRACKET LBRACE Int In Ident GT End Else EQ EOF Directive CONS COMMA COLON CARET Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## UIdent
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: UIdent DOT LPAR ZWSP
##
## Ends in an error in state: 239.
##
## par(expr) -> LPAR . expr RPAR [ With Verbatim VBAR UIdent Type Then TIMES String SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Lxor Lsr Lsl Lor Let Lang Land LT LPAR LE LBRACKET LBRACE Int In Ident GT End Else EQ EOF Directive CONS COMMA COLON CARET Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## LPAR
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Let UIdent LPAR ZWSP
##
## Ends in an error in state: 251.
##
## par(__anonymous_7) -> LPAR . Type nseq(variable) RPAR [ EQ COLON ]
##
## The known suffix of the stack is as follows:
## LPAR
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Ident ZWSP
##
## Ends in an error in state: 259.
##
## field_path -> Ident . DOT nsepseq(selection,DOT) [ With Verbatim VBAR UIdent Type Then TIMES String SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Lxor Lsr Lsl Lor Let Lang Land LT LPAR LE LBRACKET LBRACE Int In Ident GT End Else EQ EOF Directive CONS COMMA COLON CARET Bytes Begin BOOL_OR BOOL_AND Attr ]
## field_path -> Ident . [ With Verbatim VBAR UIdent Type Then TIMES String SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Lxor Lsr Lsl Lor Let Lang Land LT LPAR LE LBRACKET LBRACE Int In Ident GT End Else EQ EOF Directive CONS COMMA COLON CARET Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## Ident
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Ident DOT Ident ZWSP
##
## Ends in an error in state: 263.
##
## nsepseq(selection,DOT) -> selection . [ With Verbatim VBAR_EQ VBAR UIdent Type Then TIMES_EQ TIMES String SLASH_EQ SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS_EQ PLUS Or Nat NE Mutez Module Mod MINUS_EQ MINUS Lxor Lsr Lsl Lor Let Lang Land LT LPAR LE LBRACKET LBRACE Int In Ident GT End Else EQ EOF Directive CONS COMMA COLON CARET Bytes Begin BOOL_OR BOOL_AND Attr ]
## nsepseq(selection,DOT) -> selection . DOT nsepseq(selection,DOT) [ With Verbatim VBAR_EQ VBAR UIdent Type Then TIMES_EQ TIMES String SLASH_EQ SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS_EQ PLUS Or Nat NE Mutez Module Mod MINUS_EQ MINUS Lxor Lsr Lsl Lor Let Lang Land LT LPAR LE LBRACKET LBRACE Int In Ident GT End Else EQ EOF Directive CONS COMMA COLON CARET Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## selection
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Fun UIdent COLON VBAR UIdent ZWSP
##
## Ends in an error in state: 290.
##
## short_variant(cartesian_level) -> UIdent . [ VBAR ARROW ]
## short_variant(cartesian_level) -> UIdent . of_type(cartesian_level) [ VBAR ARROW ]
##
## The known suffix of the stack is as follows:
## UIdent
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Fun UIdent COLON UIdent ZWSP
##
## Ends in an error in state: 297.
##
## module_path(__anonymous_5) -> UIdent . DOT module_path(__anonymous_5) [ UIdent TIMES Ident ARROW ]
## module_path(__anonymous_5) -> UIdent . DOT Ident [ UIdent TIMES Ident ARROW ]
## module_path(__anonymous_6) -> UIdent . DOT module_path(__anonymous_6) [ UIdent TIMES Ident ARROW ]
## module_path(__anonymous_6) -> UIdent . DOT par(type_expr) [ UIdent TIMES Ident ARROW ]
## short_variant(cartesian_level) -> UIdent . [ VBAR ARROW ]
## short_variant(cartesian_level) -> UIdent . of_type(cartesian_level) [ VBAR ARROW ]
##
## The known suffix of the stack is as follows:
## UIdent
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Let LPAR UIdent COLON Ident Type
##
## Ends in an error in state: 221.
##
## par(in_core_irrefutable) -> LPAR in_core_irrefutable . RPAR [ WILD UIdent SEMI RPAR RBRACE LPAR LBRACE Ident EQ COMMA COLON Attr ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR in_core_irrefutable
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 53, spurious reduction of production core_type -> no_attr_type
## In state 72, spurious reduction of production cartesian_level -> core_type
## In state 79, spurious reduction of production fun_type_level -> cartesian_level
## In state 71, spurious reduction of production type_expr -> fun_type_level
## In state 60, spurious reduction of production type_annotation(type_expr) -> COLON type_expr
## In state 224, spurious reduction of production typed_irrefutable -> ctor_irrefutable type_annotation(type_expr)
## In state 212, spurious reduction of production in_core_irrefutable -> typed_irrefutable
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Fun UIdent COLON Attr Attr ZWSP
##
## Ends in an error in state: 299.
##
## core_type -> Attr . core_type [ TIMES ARROW ]
## seq(Attr) -> Attr . seq(Attr) [ VBAR ]
## short_variant(cartesian_level) -> Attr . short_variant(cartesian_level) [ VBAR ARROW ]
##
## The known suffix of the stack is as follows:
## Attr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Fun UIdent COLON UIdent Of Ident Type
##
## Ends in an error in state: 301.
##
## variant_type(cartesian_level) -> short_variant(cartesian_level) . [ ARROW ]
## variant_type(cartesian_level) -> short_variant(cartesian_level) . long_variants(cartesian_level) [ ARROW ]
##
## The known suffix of the stack is as follows:
## short_variant(cartesian_level)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 53, spurious reduction of production core_type -> no_attr_type
## In state 72, spurious reduction of production cartesian_level -> core_type
## In state 292, spurious reduction of production of_type(cartesian_level) -> Of cartesian_level
## In state 293, spurious reduction of production short_variant(cartesian_level) -> UIdent of_type(cartesian_level)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Fun UIdent COLON VBAR UIdent Of Ident Type
##
## Ends in an error in state: 304.
##
## nseq(long_variant(cartesian_level)) -> long_variant(cartesian_level) . seq(long_variant(cartesian_level)) [ ARROW ]
##
## The known suffix of the stack is as follows:
## long_variant(cartesian_level)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 53, spurious reduction of production core_type -> no_attr_type
## In state 72, spurious reduction of production cartesian_level -> core_type
## In state 292, spurious reduction of production of_type(cartesian_level) -> Of cartesian_level
## In state 293, spurious reduction of production short_variant(cartesian_level) -> UIdent of_type(cartesian_level)
## In state 296, spurious reduction of production long_variant(cartesian_level) -> VBAR short_variant(cartesian_level)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Fun UIdent COLON VBAR UIdent VBAR UIdent Of Ident Type
##
## Ends in an error in state: 306.
##
## seq(long_variant(cartesian_level)) -> long_variant(cartesian_level) . seq(long_variant(cartesian_level)) [ ARROW ]
##
## The known suffix of the stack is as follows:
## long_variant(cartesian_level)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 53, spurious reduction of production core_type -> no_attr_type
## In state 72, spurious reduction of production cartesian_level -> core_type
## In state 292, spurious reduction of production of_type(cartesian_level) -> Of cartesian_level
## In state 293, spurious reduction of production short_variant(cartesian_level) -> UIdent of_type(cartesian_level)
## In state 296, spurious reduction of production long_variant(cartesian_level) -> VBAR short_variant(cartesian_level)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Attr Attr ZWSP
##
## Ends in an error in state: 318.
##
## core_expr -> Attr . core_expr [ With Verbatim VBAR UIdent Type Then TIMES String SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Lxor Lsr Lsl Lor Let Lang Land LT LPAR LE LBRACKET LBRACE Int In Ident GT End Else EQ EOF Directive CONS COMMA COLON CARET Bytes Begin BOOL_OR BOOL_AND Attr ]
## seq(Attr) -> Attr . seq(Attr) [ Type Module Match Let If Fun ]
##
## The known suffix of the stack is as follows:
## Attr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: LPAR Ident RPAR ZWSP
##
## Ends in an error in state: 326.
##
## field_path -> par(expr) . [ With Verbatim VBAR UIdent Type Then TIMES String SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Lxor Lsr Lsl Lor Let Lang Land LT LPAR LE LBRACKET LBRACE Int In Ident GT End Else EQ EOF Directive CONS COMMA COLON CARET Bytes Begin BOOL_OR BOOL_AND Attr ]
## local_path -> par(expr) . DOT nsepseq(selection,DOT) [ With Verbatim VBAR UIdent Type Then TIMES String SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Lxor Lsr Lsl Lor Let Lang Land LT LPAR LE LBRACKET LBRACE Int In Ident GT End Else EQ EOF Directive CONS COMMA COLON CARET Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## par(expr)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: LPAR Ident RPAR DOT ZWSP
##
## Ends in an error in state: 327.
##
## local_path -> par(expr) DOT . nsepseq(selection,DOT) [ With Verbatim VBAR UIdent Type Then TIMES String SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Lxor Lsr Lsl Lor Let Lang Land LT LPAR LE LBRACKET LBRACE Int In Ident GT End Else EQ EOF Directive CONS COMMA COLON CARET Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## par(expr) DOT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: MINUS Attr ZWSP
##
## Ends in an error in state: 343.
##
## core_expr -> Attr . core_expr [ With Verbatim VBAR UIdent Type Then TIMES String SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Lxor Lsr Lsl Lor Let Lang Land LT LPAR LE LBRACKET LBRACE Int In Ident GT End Else EQ EOF Directive CONS COMMA COLON CARET Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## Attr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Ident Bytes ZWSP
##
## Ends in an error in state: 347.
##
## nseq(no_attr_expr) -> no_attr_expr . seq(no_attr_expr) [ With VBAR Type Then TIMES SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or NE Module Mod MINUS Lxor Lsr Lsl Lor Let Land LT LE In GT End Else EQ EOF Directive CONS COMMA COLON CARET BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## no_attr_expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Ident Ident Bytes ZWSP
##
## Ends in an error in state: 349.
##
## seq(no_attr_expr) -> no_attr_expr . seq(no_attr_expr) [ With VBAR Type Then TIMES SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or NE Module Mod MINUS Lxor Lsr Lsl Lor Let Land LT LE In GT End Else EQ EOF Directive CONS COMMA COLON CARET BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## no_attr_expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Type Ident EQ Ident Type
##
## Ends in an error in state: 358.
##
## local_type_decl(expr) -> type_decl . In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## type_decl
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 53, spurious reduction of production core_type -> no_attr_type
## In state 72, spurious reduction of production cartesian_level -> core_type
## In state 79, spurious reduction of production fun_type_level -> cartesian_level
## In state 71, spurious reduction of production type_expr -> fun_type_level
## In state 117, spurious reduction of production type_decl -> Type Ident EQ type_expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Ident VBAR
##
## Ends in an error in state: 389.
##
## base_expr(expr) -> disj_expr_level . [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## bin_op(disj_expr_level,BOOL_OR,conj_expr_level) -> disj_expr_level . BOOL_OR conj_expr_level [ With Type Then SEMI RPAR REV_APP RBRACKET RBRACE Or Module Let In End EOF Directive COMMA COLON BOOL_OR Attr ]
## bin_op(disj_expr_level,Or,conj_expr_level) -> disj_expr_level . Or conj_expr_level [ With Type Then SEMI RPAR REV_APP RBRACKET RBRACE Or Module Let In End EOF Directive COMMA COLON BOOL_OR Attr ]
## bin_op(disj_expr_level,REV_APP,conj_expr_level) -> disj_expr_level . REV_APP conj_expr_level [ With Type Then SEMI RPAR REV_APP RBRACKET RBRACE Or Module Let In End EOF Directive COMMA COLON BOOL_OR Attr ]
## tuple(disj_expr_level) -> disj_expr_level . COMMA nsepseq(disj_expr_level,COMMA) [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## disj_expr_level
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 259, spurious reduction of production field_path -> Ident
## In state 333, spurious reduction of production local_path -> field_path
## In state 331, spurious reduction of production path_expr -> local_path
## In state 324, spurious reduction of production no_attr_expr -> path_expr
## In state 329, spurious reduction of production core_expr -> no_attr_expr
## In state 345, spurious reduction of production app_expr_level -> core_expr
## In state 354, spurious reduction of production unary_expr_level -> app_expr_level
## In state 341, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 362, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 368, spurious reduction of production add_expr_level -> mult_expr_level
## In state 404, spurious reduction of production cons_expr_level -> add_expr_level
## In state 391, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 428, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 435, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 444, spurious reduction of production disj_expr_level -> conj_expr_level
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Match Ident With UIdent ZWSP
##
## Ends in an error in state: 462.
##
## ctor_app_pattern -> UIdent . core_pattern [ SEMI RPAR RBRACKET RBRACE CONS COMMA COLON ARROW ]
## ctor_app_pattern -> UIdent . [ SEMI RPAR RBRACKET RBRACE CONS COMMA COLON ARROW ]
## module_path(__anonymous_10) -> UIdent . DOT module_path(__anonymous_10) [ SEMI RPAR RBRACKET RBRACE CONS COMMA COLON ARROW ]
## module_path(__anonymous_10) -> UIdent . DOT Ident [ SEMI RPAR RBRACKET RBRACE CONS COMMA COLON ARROW ]
## module_path(__anonymous_11) -> UIdent . DOT module_path(__anonymous_11) [ SEMI RPAR RBRACKET RBRACE CONS COMMA COLON ARROW ]
## module_path(__anonymous_11) -> UIdent . DOT in_pattern [ SEMI RPAR RBRACKET RBRACE CONS COMMA COLON ARROW ]
## module_path(__anonymous_9) -> UIdent . DOT module_path(__anonymous_9) [ WILD Verbatim UIdent String Nat Mutez LPAR LBRACKET LBRACE Int Ident Bytes Attr ]
## module_path(__anonymous_9) -> UIdent . DOT UIdent [ WILD Verbatim UIdent String Nat Mutez LPAR LBRACKET LBRACE Int Ident Bytes Attr ]
##
## The known suffix of the stack is as follows:
## UIdent
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Match Ident With LBRACE Attr Ident ZWSP
##
## Ends in an error in state: 474.
##
## field_pattern(core_pattern) -> nseq(Attr) field_pattern_lhs . [ SEMI RBRACE ]
## field_pattern(core_pattern) -> nseq(Attr) field_pattern_lhs . EQ core_pattern [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) field_pattern_lhs
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Match Ident With LBRACE Attr Ident EQ ZWSP
##
## Ends in an error in state: 475.
##
## field_pattern(core_pattern) -> nseq(Attr) field_pattern_lhs EQ . core_pattern [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) field_pattern_lhs EQ
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Match Ident With Attr ZWSP
##
## Ends in an error in state: 479.
##
## attr_pattern -> Attr . core_pattern [ SEMI RPAR RBRACKET RBRACE CONS COMMA COLON ARROW ]
##
## The known suffix of the stack is as follows:
## Attr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Match Ident With LBRACKET UIdent RPAR
##
## Ends in an error in state: 520.
##
## nsepseq(cons_pattern_level,SEMI) -> cons_pattern_level . [ RBRACKET ]
## nsepseq(cons_pattern_level,SEMI) -> cons_pattern_level . SEMI nsepseq(cons_pattern_level,SEMI) [ RBRACKET ]
## nseq(__anonymous_0(cons_pattern_level,SEMI)) -> cons_pattern_level . SEMI seq(__anonymous_0(cons_pattern_level,SEMI)) [ RBRACKET ]
##
## The known suffix of the stack is as follows:
## cons_pattern_level
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 462, spurious reduction of production ctor_app_pattern -> UIdent
## In state 494, spurious reduction of production core_pattern -> ctor_app_pattern
## In state 517, spurious reduction of production cons_pattern_level -> core_pattern
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Match Ident With LBRACKET UIdent SEMI UIdent RPAR
##
## Ends in an error in state: 524.
##
## nsepseq(cons_pattern_level,SEMI) -> cons_pattern_level . [ RBRACKET ]
## nsepseq(cons_pattern_level,SEMI) -> cons_pattern_level . SEMI nsepseq(cons_pattern_level,SEMI) [ RBRACKET ]
## seq(__anonymous_0(cons_pattern_level,SEMI)) -> cons_pattern_level . SEMI seq(__anonymous_0(cons_pattern_level,SEMI)) [ RBRACKET ]
##
## The known suffix of the stack is as follows:
## cons_pattern_level
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 462, spurious reduction of production ctor_app_pattern -> UIdent
## In state 494, spurious reduction of production core_pattern -> ctor_app_pattern
## In state 517, spurious reduction of production cons_pattern_level -> core_pattern
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Match Ident With LPAR UIdent ARROW
##
## Ends in an error in state: 530.
##
## par(__anonymous_8) -> LPAR pattern . RPAR [ SEMI RPAR RBRACKET RBRACE CONS COMMA COLON ARROW ]
## typed_pattern -> pattern . type_annotation(type_expr) [ RPAR ]
##
## The known suffix of the stack is as follows:
## LPAR pattern
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 462, spurious reduction of production ctor_app_pattern -> UIdent
## In state 494, spurious reduction of production core_pattern -> ctor_app_pattern
## In state 517, spurious reduction of production cons_pattern_level -> core_pattern
## In state 533, spurious reduction of production pattern -> cons_pattern_level
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Match Ident With LPAR UIdent COLON Ident Type
##
## Ends in an error in state: 527.
##
## par(__anonymous_8) -> LPAR typed_pattern . RPAR [ SEMI RPAR RBRACKET RBRACE CONS COMMA COLON ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR typed_pattern
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 53, spurious reduction of production core_type -> no_attr_type
## In state 72, spurious reduction of production cartesian_level -> core_type
## In state 79, spurious reduction of production fun_type_level -> cartesian_level
## In state 71, spurious reduction of production type_expr -> fun_type_level
## In state 60, spurious reduction of production type_annotation(type_expr) -> COLON type_expr
## In state 532, spurious reduction of production typed_pattern -> pattern type_annotation(type_expr)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Match Ident With UIdent COMMA UIdent SEMI
##
## Ends in an error in state: 536.
##
## nsepseq(cons_pattern_level,COMMA) -> cons_pattern_level . [ RPAR COLON ARROW ]
## nsepseq(cons_pattern_level,COMMA) -> cons_pattern_level . COMMA nsepseq(cons_pattern_level,COMMA) [ RPAR COLON ARROW ]
##
## The known suffix of the stack is as follows:
## cons_pattern_level
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 462, spurious reduction of production ctor_app_pattern -> UIdent
## In state 494, spurious reduction of production core_pattern -> ctor_app_pattern
## In state 517, spurious reduction of production cons_pattern_level -> core_pattern
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Match Ident With UIdent DOT ZWSP
##
## Ends in an error in state: 539.
##
## module_path(__anonymous_10) -> UIdent DOT . module_path(__anonymous_10) [ SEMI RPAR RBRACKET RBRACE CONS COMMA COLON ARROW ]
## module_path(__anonymous_10) -> UIdent DOT . Ident [ SEMI RPAR RBRACKET RBRACE CONS COMMA COLON ARROW ]
## module_path(__anonymous_11) -> UIdent DOT . module_path(__anonymous_11) [ SEMI RPAR RBRACKET RBRACE CONS COMMA COLON ARROW ]
## module_path(__anonymous_11) -> UIdent DOT . in_pattern [ SEMI RPAR RBRACKET RBRACE CONS COMMA COLON ARROW ]
## module_path(__anonymous_9) -> UIdent DOT . module_path(__anonymous_9) [ WILD Verbatim UIdent String Nat Mutez LPAR LBRACKET LBRACE Int Ident Bytes Attr ]
## module_path(__anonymous_9) -> UIdent DOT . UIdent [ WILD Verbatim UIdent String Nat Mutez LPAR LBRACKET LBRACE Int Ident Bytes Attr ]
##
## The known suffix of the stack is as follows:
## UIdent DOT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Match Ident With UIdent DOT UIdent ZWSP
##
## Ends in an error in state: 540.
##
## module_path(__anonymous_10) -> UIdent . DOT module_path(__anonymous_10) [ SEMI RPAR RBRACKET RBRACE CONS COMMA COLON ARROW ]
## module_path(__anonymous_10) -> UIdent . DOT Ident [ SEMI RPAR RBRACKET RBRACE CONS COMMA COLON ARROW ]
## module_path(__anonymous_11) -> UIdent . DOT module_path(__anonymous_11) [ SEMI RPAR RBRACKET RBRACE CONS COMMA COLON ARROW ]
## module_path(__anonymous_11) -> UIdent . DOT in_pattern [ SEMI RPAR RBRACKET RBRACE CONS COMMA COLON ARROW ]
## module_path(__anonymous_9) -> UIdent . DOT module_path(__anonymous_9) [ WILD Verbatim UIdent String Nat Mutez LPAR LBRACKET LBRACE Int Ident Bytes Attr ]
## module_path(__anonymous_9) -> UIdent . DOT UIdent [ WILD Verbatim UIdent String Nat Mutez LPAR LBRACKET LBRACE Int Ident Bytes Attr ]
## module_path(__anonymous_9) -> UIdent DOT UIdent . [ WILD Verbatim UIdent String Nat Mutez LPAR LBRACKET LBRACE Int Ident Bytes Attr ]
##
## The known suffix of the stack is as follows:
## UIdent DOT UIdent
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Match Ident With UIdent DOT LPAR ZWSP
##
## Ends in an error in state: 541.
##
## par(__anonymous_8) -> LPAR . pattern RPAR [ SEMI RPAR RBRACKET RBRACE CONS COMMA COLON ARROW ]
## par(__anonymous_8) -> LPAR . typed_pattern RPAR [ SEMI RPAR RBRACKET RBRACE CONS COMMA COLON ARROW ]
##
## The known suffix of the stack is as follows:
## LPAR
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Let UIdent COMMA UIdent SEMI
##
## Ends in an error in state: 552.
##
## let_binding -> tuple(core_irrefutable) . EQ expr [ Type Module Let In End EOF Directive Attr ]
## let_binding -> tuple(core_irrefutable) . type_annotation(type_expr) EQ expr [ Type Module Let In End EOF Directive Attr ]
## let_binding -> tuple(core_irrefutable) . par(__anonymous_7) EQ expr [ Type Module Let In End EOF Directive Attr ]
## let_binding -> tuple(core_irrefutable) . par(__anonymous_7) type_annotation(type_expr) EQ expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## tuple(core_irrefutable)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 164, spurious reduction of production nsepseq(core_irrefutable,COMMA) -> ctor_irrefutable
## In state 185, spurious reduction of production tuple(core_irrefutable) -> ctor_irrefutable COMMA nsepseq(core_irrefutable,COMMA)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Let UIdent COMMA UIdent COLON Ident Type
##
## Ends in an error in state: 555.
##
## let_binding -> tuple(core_irrefutable) type_annotation(type_expr) . EQ expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## tuple(core_irrefutable) type_annotation(type_expr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 53, spurious reduction of production core_type -> no_attr_type
## In state 72, spurious reduction of production cartesian_level -> core_type
## In state 79, spurious reduction of production fun_type_level -> cartesian_level
## In state 71, spurious reduction of production type_expr -> fun_type_level
## In state 60, spurious reduction of production type_annotation(type_expr) -> COLON type_expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Let UIdent COMMA UIdent LPAR Type Ident RPAR COLON Ident Type
##
## Ends in an error in state: 561.
##
## let_binding -> tuple(core_irrefutable) par(__anonymous_7) type_annotation(type_expr) . EQ expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## tuple(core_irrefutable) par(__anonymous_7) type_annotation(type_expr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 53, spurious reduction of production core_type -> no_attr_type
## In state 72, spurious reduction of production cartesian_level -> core_type
## In state 79, spurious reduction of production fun_type_level -> cartesian_level
## In state 71, spurious reduction of production type_expr -> fun_type_level
## In state 60, spurious reduction of production type_annotation(type_expr) -> COLON type_expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Let LBRACE RBRACE COLON Ident Type
##
## Ends in an error in state: 567.
##
## let_binding -> record_pattern(irrefutable) type_annotation(type_expr) . EQ expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## record_pattern(irrefutable) type_annotation(type_expr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 53, spurious reduction of production core_type -> no_attr_type
## In state 72, spurious reduction of production cartesian_level -> core_type
## In state 79, spurious reduction of production fun_type_level -> cartesian_level
## In state 71, spurious reduction of production type_expr -> fun_type_level
## In state 60, spurious reduction of production type_annotation(type_expr) -> COLON type_expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Let LBRACE RBRACE LPAR Type Ident RPAR COLON Ident Type
##
## Ends in an error in state: 573.
##
## let_binding -> record_pattern(irrefutable) par(__anonymous_7) type_annotation(type_expr) . EQ expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## record_pattern(irrefutable) par(__anonymous_7) type_annotation(type_expr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 53, spurious reduction of production core_type -> no_attr_type
## In state 72, spurious reduction of production cartesian_level -> core_type
## In state 79, spurious reduction of production fun_type_level -> cartesian_level
## In state 71, spurious reduction of production type_expr -> fun_type_level
## In state 60, spurious reduction of production type_annotation(type_expr) -> COLON type_expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Let LPAR UIdent RPAR COLON Ident Type
##
## Ends in an error in state: 579.
##
## let_binding -> par(in_core_irrefutable) type_annotation(type_expr) . EQ expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## par(in_core_irrefutable) type_annotation(type_expr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 53, spurious reduction of production core_type -> no_attr_type
## In state 72, spurious reduction of production cartesian_level -> core_type
## In state 79, spurious reduction of production fun_type_level -> cartesian_level
## In state 71, spurious reduction of production type_expr -> fun_type_level
## In state 60, spurious reduction of production type_annotation(type_expr) -> COLON type_expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Let LPAR UIdent RPAR LPAR Type Ident RPAR COLON Ident Type
##
## Ends in an error in state: 585.
##
## let_binding -> par(in_core_irrefutable) par(__anonymous_7) type_annotation(type_expr) . EQ expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## par(in_core_irrefutable) par(__anonymous_7) type_annotation(type_expr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 53, spurious reduction of production core_type -> no_attr_type
## In state 72, spurious reduction of production cartesian_level -> core_type
## In state 79, spurious reduction of production fun_type_level -> cartesian_level
## In state 71, spurious reduction of production type_expr -> fun_type_level
## In state 60, spurious reduction of production type_annotation(type_expr) -> COLON type_expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Match Ident With UIdent ARROW If Ident Then Type Ident EQ Ident Type
##
## Ends in an error in state: 617.
##
## local_type_decl(base_cond) -> type_decl . In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## local_type_decl(closed_expr) -> type_decl . In closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## type_decl
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 53, spurious reduction of production core_type -> no_attr_type
## In state 72, spurious reduction of production cartesian_level -> core_type
## In state 79, spurious reduction of production fun_type_level -> cartesian_level
## In state 71, spurious reduction of production type_expr -> fun_type_level
## In state 117, spurious reduction of production type_decl -> Type Ident EQ type_expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Match Ident With UIdent ARROW If Ident Then Attr Match
##
## Ends in an error in state: 622.
##
## base_cond__open(base_cond) -> nseq(Attr) . conditional(base_cond) [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## base_expr(base_cond) -> nseq(Attr) . right_opened_expr(base_cond) [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## base_expr(closed_expr) -> nseq(Attr) . right_opened_expr(closed_expr) [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 317, spurious reduction of production seq(Attr) ->
## In state 58, spurious reduction of production nseq(Attr) -> Attr seq(Attr)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Match Ident With UIdent ARROW Type Ident EQ Ident Type
##
## Ends in an error in state: 658.
##
## local_type_decl(base_cond) -> type_decl . In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## type_decl
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 53, spurious reduction of production core_type -> no_attr_type
## In state 72, spurious reduction of production cartesian_level -> core_type
## In state 79, spurious reduction of production fun_type_level -> cartesian_level
## In state 71, spurious reduction of production type_expr -> fun_type_level
## In state 117, spurious reduction of production type_decl -> Type Ident EQ type_expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Match Ident With UIdent ARROW Attr Match
##
## Ends in an error in state: 661.
##
## base_cond__open(base_cond) -> nseq(Attr) . conditional(base_cond) [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## base_expr(base_cond) -> nseq(Attr) . right_opened_expr(base_cond) [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## nseq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 317, spurious reduction of production seq(Attr) ->
## In state 58, spurious reduction of production nseq(Attr) -> Attr seq(Attr)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Match Ident With UIdent ARROW Fun LPAR Type Ident RPAR UIdent COLON Ident VBAR
##
## Ends in an error in state: 669.
##
## fun_expr(base_cond) -> Fun par(__anonymous_7) nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun par(__anonymous_7) nseq(core_irrefutable) type_annotation(lambda_app_type)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 53, spurious reduction of production core_type -> no_attr_type
## In state 72, spurious reduction of production cartesian_level -> core_type
## In state 312, spurious reduction of production lambda_app_type -> cartesian_level
## In state 311, spurious reduction of production type_annotation(lambda_app_type) -> COLON lambda_app_type
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Match Ident With UIdent ARROW Fun UIdent COLON Ident VBAR
##
## Ends in an error in state: 677.
##
## fun_expr(base_cond) -> Fun nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable) type_annotation(lambda_app_type)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 53, spurious reduction of production core_type -> no_attr_type
## In state 72, spurious reduction of production cartesian_level -> core_type
## In state 312, spurious reduction of production lambda_app_type -> cartesian_level
## In state 311, spurious reduction of production type_annotation(lambda_app_type) -> COLON lambda_app_type
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Match Ident With UIdent ARROW Ident Else
##
## Ends in an error in state: 665.
##
## base_expr(base_cond) -> disj_expr_level . [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## bin_op(disj_expr_level,BOOL_OR,conj_expr_level) -> disj_expr_level . BOOL_OR conj_expr_level [ With VBAR Type Then SEMI RPAR REV_APP RBRACKET RBRACE Or Module Let In End EOF Directive COMMA COLON BOOL_OR Attr ]
## bin_op(disj_expr_level,Or,conj_expr_level) -> disj_expr_level . Or conj_expr_level [ With VBAR Type Then SEMI RPAR REV_APP RBRACKET RBRACE Or Module Let In End EOF Directive COMMA COLON BOOL_OR Attr ]
## bin_op(disj_expr_level,REV_APP,conj_expr_level) -> disj_expr_level . REV_APP conj_expr_level [ With VBAR Type Then SEMI RPAR REV_APP RBRACKET RBRACE Or Module Let In End EOF Directive COMMA COLON BOOL_OR Attr ]
## tuple(disj_expr_level) -> disj_expr_level . COMMA nsepseq(disj_expr_level,COMMA) [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## disj_expr_level
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 259, spurious reduction of production field_path -> Ident
## In state 333, spurious reduction of production local_path -> field_path
## In state 331, spurious reduction of production path_expr -> local_path
## In state 324, spurious reduction of production no_attr_expr -> path_expr
## In state 329, spurious reduction of production core_expr -> no_attr_expr
## In state 345, spurious reduction of production app_expr_level -> core_expr
## In state 354, spurious reduction of production unary_expr_level -> app_expr_level
## In state 341, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 362, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 368, spurious reduction of production add_expr_level -> mult_expr_level
## In state 404, spurious reduction of production cons_expr_level -> add_expr_level
## In state 391, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 428, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 435, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 444, spurious reduction of production disj_expr_level -> conj_expr_level
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Let UIdent COLON Ident Type
##
## Ends in an error in state: 684.
##
## let_binding -> ctor_irrefutable type_annotation(type_expr) . EQ expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## ctor_irrefutable type_annotation(type_expr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 53, spurious reduction of production core_type -> no_attr_type
## In state 72, spurious reduction of production cartesian_level -> core_type
## In state 79, spurious reduction of production fun_type_level -> cartesian_level
## In state 71, spurious reduction of production type_expr -> fun_type_level
## In state 60, spurious reduction of production type_annotation(type_expr) -> COLON type_expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Let UIdent LPAR Type Ident RPAR COLON Ident Type
##
## Ends in an error in state: 690.
##
## let_binding -> ctor_irrefutable par(__anonymous_7) type_annotation(type_expr) . EQ expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## ctor_irrefutable par(__anonymous_7) type_annotation(type_expr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 53, spurious reduction of production core_type -> no_attr_type
## In state 72, spurious reduction of production cartesian_level -> core_type
## In state 79, spurious reduction of production fun_type_level -> cartesian_level
## In state 71, spurious reduction of production type_expr -> fun_type_level
## In state 60, spurious reduction of production type_annotation(type_expr) -> COLON type_expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Match Ident With UIdent ARROW If Ident Then Fun LPAR Type Ident RPAR UIdent COLON Ident VBAR
##
## Ends in an error in state: 701.
##
## fun_expr(base_cond) -> Fun par(__anonymous_7) nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(closed_expr) -> Fun par(__anonymous_7) nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Fun par(__anonymous_7) nseq(core_irrefutable) type_annotation(lambda_app_type)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 53, spurious reduction of production core_type -> no_attr_type
## In state 72, spurious reduction of production cartesian_level -> core_type
## In state 312, spurious reduction of production lambda_app_type -> cartesian_level
## In state 311, spurious reduction of production type_annotation(lambda_app_type) -> COLON lambda_app_type
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Match Ident With UIdent ARROW If Ident Then Fun UIdent COLON Ident VBAR
##
## Ends in an error in state: 707.
##
## fun_expr(base_cond) -> Fun nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(closed_expr) -> Fun nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable) type_annotation(lambda_app_type)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 53, spurious reduction of production core_type -> no_attr_type
## In state 72, spurious reduction of production cartesian_level -> core_type
## In state 312, spurious reduction of production lambda_app_type -> cartesian_level
## In state 311, spurious reduction of production type_annotation(lambda_app_type) -> COLON lambda_app_type
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: If Ident Then Match Ident With UIdent ARROW Type Ident EQ Ident Type
##
## Ends in an error in state: 723.
##
## local_type_decl(base_cond) -> type_decl . In base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## local_type_decl(base_if_then_else) -> type_decl . In base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## type_decl
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 53, spurious reduction of production core_type -> no_attr_type
## In state 72, spurious reduction of production cartesian_level -> core_type
## In state 79, spurious reduction of production fun_type_level -> cartesian_level
## In state 71, spurious reduction of production type_expr -> fun_type_level
## In state 117, spurious reduction of production type_decl -> Type Ident EQ type_expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: If Ident Then Match Ident With UIdent ARROW Attr Match
##
## Ends in an error in state: 727.
##
## base_cond__open(base_cond) -> nseq(Attr) . conditional(base_cond) [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## base_expr(base_cond) -> nseq(Attr) . right_opened_expr(base_cond) [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## base_expr(base_if_then_else) -> nseq(Attr) . right_opened_expr(base_if_then_else) [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 317, spurious reduction of production seq(Attr) ->
## In state 58, spurious reduction of production nseq(Attr) -> Attr seq(Attr)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: If Ident Then Match Ident With UIdent ARROW Fun LPAR Type Ident RPAR UIdent COLON Ident VBAR
##
## Ends in an error in state: 742.
##
## fun_expr(base_cond) -> Fun par(__anonymous_7) nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_if_then_else) -> Fun par(__anonymous_7) nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## Fun par(__anonymous_7) nseq(core_irrefutable) type_annotation(lambda_app_type)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 53, spurious reduction of production core_type -> no_attr_type
## In state 72, spurious reduction of production cartesian_level -> core_type
## In state 312, spurious reduction of production lambda_app_type -> cartesian_level
## In state 311, spurious reduction of production type_annotation(lambda_app_type) -> COLON lambda_app_type
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: If Ident Then Match Ident With UIdent ARROW Fun UIdent COLON Ident VBAR
##
## Ends in an error in state: 748.
##
## fun_expr(base_cond) -> Fun nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## fun_expr(base_if_then_else) -> Fun nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW base_if_then_else [ Else ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable) type_annotation(lambda_app_type)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 53, spurious reduction of production core_type -> no_attr_type
## In state 72, spurious reduction of production cartesian_level -> core_type
## In state 312, spurious reduction of production lambda_app_type -> cartesian_level
## In state 311, spurious reduction of production type_annotation(lambda_app_type) -> COLON lambda_app_type
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Begin Match Ident With UIdent ARROW Ident COMMA Ident Type
##
## Ends in an error in state: 774.
##
## base_expr(base_cond) -> tuple_expr . [ VBAR ]
## last_expr -> tuple_expr . [ End ]
##
## The known suffix of the stack is as follows:
## tuple_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 259, spurious reduction of production field_path -> Ident
## In state 333, spurious reduction of production local_path -> field_path
## In state 331, spurious reduction of production path_expr -> local_path
## In state 324, spurious reduction of production no_attr_expr -> path_expr
## In state 329, spurious reduction of production core_expr -> no_attr_expr
## In state 345, spurious reduction of production app_expr_level -> core_expr
## In state 354, spurious reduction of production unary_expr_level -> app_expr_level
## In state 341, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 362, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 368, spurious reduction of production add_expr_level -> mult_expr_level
## In state 404, spurious reduction of production cons_expr_level -> add_expr_level
## In state 391, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 428, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 435, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 444, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 441, spurious reduction of production nsepseq(disj_expr_level,COMMA) -> disj_expr_level
## In state 440, spurious reduction of production tuple(disj_expr_level) -> disj_expr_level COMMA nsepseq(disj_expr_level,COMMA)
## In state 361, spurious reduction of production tuple_expr -> tuple(disj_expr_level)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Begin Match Ident With UIdent ARROW Attr Match
##
## Ends in an error in state: 776.
##
## base_cond__open(base_cond) -> nseq(Attr) . conditional(base_cond) [ VBAR ]
## base_expr(base_cond) -> nseq(Attr) . right_opened_expr(base_cond) [ VBAR ]
## let_in_sequence -> nseq(Attr) . Let let_binding In series [ End ]
## let_in_sequence -> nseq(Attr) . Let Rec let_binding In series [ End ]
##
## The known suffix of the stack is as follows:
## nseq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 317, spurious reduction of production seq(Attr) ->
## In state 58, spurious reduction of production nseq(Attr) -> Attr seq(Attr)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Begin If Ident Then Type Ident EQ Ident Type
##
## Ends in an error in state: 802.
##
## local_type_decl(closed_expr) -> type_decl . In closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## type_decl
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 53, spurious reduction of production core_type -> no_attr_type
## In state 72, spurious reduction of production cartesian_level -> core_type
## In state 79, spurious reduction of production fun_type_level -> cartesian_level
## In state 71, spurious reduction of production type_expr -> fun_type_level
## In state 117, spurious reduction of production type_decl -> Type Ident EQ type_expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Begin If Ident Then Attr Match
##
## Ends in an error in state: 805.
##
## base_expr(closed_expr) -> nseq(Attr) . right_opened_expr(closed_expr) [ Else ]
##
## The known suffix of the stack is as follows:
## nseq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 317, spurious reduction of production seq(Attr) ->
## In state 58, spurious reduction of production nseq(Attr) -> Attr seq(Attr)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Begin If Ident Then Fun LPAR Type Ident RPAR UIdent COLON Ident VBAR
##
## Ends in an error in state: 809.
##
## fun_expr(closed_expr) -> Fun par(__anonymous_7) nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Fun par(__anonymous_7) nseq(core_irrefutable) type_annotation(lambda_app_type)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 53, spurious reduction of production core_type -> no_attr_type
## In state 72, spurious reduction of production cartesian_level -> core_type
## In state 312, spurious reduction of production lambda_app_type -> cartesian_level
## In state 311, spurious reduction of production type_annotation(lambda_app_type) -> COLON lambda_app_type
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Begin If Ident Then Fun UIdent COLON Ident VBAR
##
## Ends in an error in state: 813.
##
## fun_expr(closed_expr) -> Fun nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable) type_annotation(lambda_app_type)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 53, spurious reduction of production core_type -> no_attr_type
## In state 72, spurious reduction of production cartesian_level -> core_type
## In state 312, spurious reduction of production lambda_app_type -> cartesian_level
## In state 311, spurious reduction of production type_annotation(lambda_app_type) -> COLON lambda_app_type
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Begin If Ident Then Ident COMMA Ident VBAR
##
## Ends in an error in state: 819.
##
## if_then_else(seq_expr) -> If expr Then closed_expr . Else seq_expr [ SEMI End ]
##
## The known suffix of the stack is as follows:
## If expr Then closed_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 259, spurious reduction of production field_path -> Ident
## In state 333, spurious reduction of production local_path -> field_path
## In state 331, spurious reduction of production path_expr -> local_path
## In state 324, spurious reduction of production no_attr_expr -> path_expr
## In state 329, spurious reduction of production core_expr -> no_attr_expr
## In state 345, spurious reduction of production app_expr_level -> core_expr
## In state 354, spurious reduction of production unary_expr_level -> app_expr_level
## In state 341, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 362, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 368, spurious reduction of production add_expr_level -> mult_expr_level
## In state 404, spurious reduction of production cons_expr_level -> add_expr_level
## In state 391, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 428, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 435, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 444, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 441, spurious reduction of production nsepseq(disj_expr_level,COMMA) -> disj_expr_level
## In state 440, spurious reduction of production tuple(disj_expr_level) -> disj_expr_level COMMA nsepseq(disj_expr_level,COMMA)
## In state 361, spurious reduction of production tuple_expr -> tuple(disj_expr_level)
## In state 804, spurious reduction of production base_expr(closed_expr) -> tuple_expr
## In state 644, spurious reduction of production base_if_then_else__open(closed_expr) -> base_expr(closed_expr)
## In state 643, spurious reduction of production closed_expr -> base_if_then_else__open(closed_expr)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Begin If Ident Then Ident Else Ident VBAR
##
## Ends in an error in state: 821.
##
## bin_op(disj_expr_level,BOOL_OR,conj_expr_level) -> disj_expr_level . BOOL_OR conj_expr_level [ SEMI REV_APP Or End BOOL_OR ]
## bin_op(disj_expr_level,Or,conj_expr_level) -> disj_expr_level . Or conj_expr_level [ SEMI REV_APP Or End BOOL_OR ]
## bin_op(disj_expr_level,REV_APP,conj_expr_level) -> disj_expr_level . REV_APP conj_expr_level [ SEMI REV_APP Or End BOOL_OR ]
## seq_expr -> disj_expr_level . [ SEMI End ]
##
## The known suffix of the stack is as follows:
## disj_expr_level
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 259, spurious reduction of production field_path -> Ident
## In state 333, spurious reduction of production local_path -> field_path
## In state 331, spurious reduction of production path_expr -> local_path
## In state 324, spurious reduction of production no_attr_expr -> path_expr
## In state 329, spurious reduction of production core_expr -> no_attr_expr
## In state 345, spurious reduction of production app_expr_level -> core_expr
## In state 354, spurious reduction of production unary_expr_level -> app_expr_level
## In state 341, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 362, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 368, spurious reduction of production add_expr_level -> mult_expr_level
## In state 404, spurious reduction of production cons_expr_level -> add_expr_level
## In state 391, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 428, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 435, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 444, spurious reduction of production disj_expr_level -> conj_expr_level
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Begin Attr Type
##
## Ends in an error in state: 827.
##
## let_in_sequence -> nseq(Attr) . Let let_binding In series [ End ]
## let_in_sequence -> nseq(Attr) . Let Rec let_binding In series [ End ]
##
## The known suffix of the stack is as follows:
## nseq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 317, spurious reduction of production seq(Attr) ->
## In state 58, spurious reduction of production nseq(Attr) -> Attr seq(Attr)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Begin Match Ident With UIdent ARROW Fun LPAR Type Ident RPAR UIdent COLON Ident VBAR
##
## Ends in an error in state: 857.
##
## fun_expr(base_cond) -> Fun par(__anonymous_7) nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW base_cond [ VBAR ]
## fun_expr(last_expr) -> Fun par(__anonymous_7) nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW last_expr [ End ]
##
## The known suffix of the stack is as follows:
## Fun par(__anonymous_7) nseq(core_irrefutable) type_annotation(lambda_app_type)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 53, spurious reduction of production core_type -> no_attr_type
## In state 72, spurious reduction of production cartesian_level -> core_type
## In state 312, spurious reduction of production lambda_app_type -> cartesian_level
## In state 311, spurious reduction of production type_annotation(lambda_app_type) -> COLON lambda_app_type
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Begin Match Ident With UIdent ARROW Fun UIdent COLON Ident VBAR
##
## Ends in an error in state: 861.
##
## fun_expr(base_cond) -> Fun nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW base_cond [ VBAR ]
## fun_expr(last_expr) -> Fun nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW last_expr [ End ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable) type_annotation(lambda_app_type)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 53, spurious reduction of production core_type -> no_attr_type
## In state 72, spurious reduction of production cartesian_level -> core_type
## In state 312, spurious reduction of production lambda_app_type -> cartesian_level
## In state 311, spurious reduction of production type_annotation(lambda_app_type) -> COLON lambda_app_type
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Begin Fun LPAR Type Ident RPAR UIdent COLON Ident VBAR
##
## Ends in an error in state: 841.
##
## fun_expr(last_expr) -> Fun par(__anonymous_7) nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW last_expr [ End ]
##
## The known suffix of the stack is as follows:
## Fun par(__anonymous_7) nseq(core_irrefutable) type_annotation(lambda_app_type)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 53, spurious reduction of production core_type -> no_attr_type
## In state 72, spurious reduction of production cartesian_level -> core_type
## In state 312, spurious reduction of production lambda_app_type -> cartesian_level
## In state 311, spurious reduction of production type_annotation(lambda_app_type) -> COLON lambda_app_type
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Begin Fun UIdent COLON Ident VBAR
##
## Ends in an error in state: 847.
##
## fun_expr(last_expr) -> Fun nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW last_expr [ End ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable) type_annotation(lambda_app_type)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 53, spurious reduction of production core_type -> no_attr_type
## In state 72, spurious reduction of production cartesian_level -> core_type
## In state 312, spurious reduction of production lambda_app_type -> cartesian_level
## In state 311, spurious reduction of production type_annotation(lambda_app_type) -> COLON lambda_app_type
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Begin Match Ident With UIdent ARROW If Ident Then Ident Type
##
## Ends in an error in state: 868.
##
## cases(base_cond) -> cases(base_cond) . VBAR match_clause(base_cond) [ VBAR ]
## cases(last_expr) -> cases(base_cond) . VBAR match_clause(last_expr) [ End ]
##
## The known suffix of the stack is as follows:
## cases(base_cond)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 259, spurious reduction of production field_path -> Ident
## In state 333, spurious reduction of production local_path -> field_path
## In state 331, spurious reduction of production path_expr -> local_path
## In state 324, spurious reduction of production no_attr_expr -> path_expr
## In state 329, spurious reduction of production core_expr -> no_attr_expr
## In state 345, spurious reduction of production app_expr_level -> core_expr
## In state 354, spurious reduction of production unary_expr_level -> app_expr_level
## In state 341, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 362, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 368, spurious reduction of production add_expr_level -> mult_expr_level
## In state 404, spurious reduction of production cons_expr_level -> add_expr_level
## In state 391, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 428, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 435, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 444, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 640, spurious reduction of production base_expr(base_cond) -> disj_expr_level
## In state 645, spurious reduction of production base_cond__open(base_cond) -> base_expr(base_cond)
## In state 646, spurious reduction of production base_cond -> base_cond__open(base_cond)
## In state 697, spurious reduction of production if_then(base_cond) -> If expr Then base_cond
## In state 637, spurious reduction of production conditional(base_cond) -> if_then(base_cond)
## In state 641, spurious reduction of production base_cond__open(base_cond) -> conditional(base_cond)
## In state 646, spurious reduction of production base_cond -> base_cond__open(base_cond)
## In state 757, spurious reduction of production match_clause(base_cond) -> pattern ARROW base_cond
## In state 759, spurious reduction of production cases(base_cond) -> match_clause(base_cond)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Fun LPAR Type Ident RPAR UIdent COLON Ident VBAR
##
## Ends in an error in state: 875.
##
## fun_expr(expr) -> Fun par(__anonymous_7) nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun par(__anonymous_7) nseq(core_irrefutable) type_annotation(lambda_app_type)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 53, spurious reduction of production core_type -> no_attr_type
## In state 72, spurious reduction of production cartesian_level -> core_type
## In state 312, spurious reduction of production lambda_app_type -> cartesian_level
## In state 311, spurious reduction of production type_annotation(lambda_app_type) -> COLON lambda_app_type
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Fun UIdent COLON Ident VBAR
##
## Ends in an error in state: 881.
##
## fun_expr(expr) -> Fun nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable) type_annotation(lambda_app_type)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 53, spurious reduction of production core_type -> no_attr_type
## In state 72, spurious reduction of production cartesian_level -> core_type
## In state 312, spurious reduction of production lambda_app_type -> cartesian_level
## In state 311, spurious reduction of production type_annotation(lambda_app_type) -> COLON lambda_app_type
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: If Ident Then Match Ident With UIdent ARROW Attr If Ident Then Ident Else Ident COMMA Ident Else
##
## Ends in an error in state: 890.
##
## cases(base_cond) -> cases(base_cond) . VBAR match_clause(base_cond) [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## cases(base_if_then_else) -> cases(base_cond) . VBAR match_clause(base_if_then_else) [ Else ]
## match_expr(base_cond) -> Match expr With option(VBAR) cases(base_cond) . [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Match expr With option(VBAR) cases(base_cond)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 259, spurious reduction of production field_path -> Ident
## In state 333, spurious reduction of production local_path -> field_path
## In state 331, spurious reduction of production path_expr -> local_path
## In state 324, spurious reduction of production no_attr_expr -> path_expr
## In state 329, spurious reduction of production core_expr -> no_attr_expr
## In state 345, spurious reduction of production app_expr_level -> core_expr
## In state 354, spurious reduction of production unary_expr_level -> app_expr_level
## In state 341, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 362, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 368, spurious reduction of production add_expr_level -> mult_expr_level
## In state 404, spurious reduction of production cons_expr_level -> add_expr_level
## In state 391, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 428, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 435, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 444, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 441, spurious reduction of production nsepseq(disj_expr_level,COMMA) -> disj_expr_level
## In state 440, spurious reduction of production tuple(disj_expr_level) -> disj_expr_level COMMA nsepseq(disj_expr_level,COMMA)
## In state 361, spurious reduction of production tuple_expr -> tuple(disj_expr_level)
## In state 660, spurious reduction of production base_expr(base_cond) -> tuple_expr
## In state 645, spurious reduction of production base_cond__open(base_cond) -> base_expr(base_cond)
## In state 646, spurious reduction of production base_cond -> base_cond__open(base_cond)
## In state 696, spurious reduction of production if_then_else(base_cond) -> If expr Then closed_expr Else base_cond
## In state 636, spurious reduction of production conditional(base_cond) -> if_then_else(base_cond)
## In state 666, spurious reduction of production base_cond__open(base_cond) -> nseq(Attr) conditional(base_cond)
## In state 646, spurious reduction of production base_cond -> base_cond__open(base_cond)
## In state 757, spurious reduction of production match_clause(base_cond) -> pattern ARROW base_cond
## In state 759, spurious reduction of production cases(base_cond) -> match_clause(base_cond)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: If Ident Then Type Ident EQ Ident Type
##
## Ends in an error in state: 902.
##
## local_type_decl(closed_expr) -> type_decl . In closed_expr [ Else ]
## local_type_decl(expr) -> type_decl . In expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## type_decl
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 53, spurious reduction of production core_type -> no_attr_type
## In state 72, spurious reduction of production cartesian_level -> core_type
## In state 79, spurious reduction of production fun_type_level -> cartesian_level
## In state 71, spurious reduction of production type_expr -> fun_type_level
## In state 117, spurious reduction of production type_decl -> Type Ident EQ type_expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: If Ident Then Ident COMMA Ident VBAR
##
## Ends in an error in state: 904.
##
## base_expr(closed_expr) -> tuple_expr . [ Else ]
## base_expr(expr) -> tuple_expr . [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## tuple_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 259, spurious reduction of production field_path -> Ident
## In state 333, spurious reduction of production local_path -> field_path
## In state 331, spurious reduction of production path_expr -> local_path
## In state 324, spurious reduction of production no_attr_expr -> path_expr
## In state 329, spurious reduction of production core_expr -> no_attr_expr
## In state 345, spurious reduction of production app_expr_level -> core_expr
## In state 354, spurious reduction of production unary_expr_level -> app_expr_level
## In state 341, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 362, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 368, spurious reduction of production add_expr_level -> mult_expr_level
## In state 404, spurious reduction of production cons_expr_level -> add_expr_level
## In state 391, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 428, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 435, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 444, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 441, spurious reduction of production nsepseq(disj_expr_level,COMMA) -> disj_expr_level
## In state 440, spurious reduction of production tuple(disj_expr_level) -> disj_expr_level COMMA nsepseq(disj_expr_level,COMMA)
## In state 361, spurious reduction of production tuple_expr -> tuple(disj_expr_level)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: If Ident Then Fun LPAR Type Ident RPAR UIdent COLON Ident VBAR
##
## Ends in an error in state: 909.
##
## fun_expr(closed_expr) -> Fun par(__anonymous_7) nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW closed_expr [ Else ]
## fun_expr(expr) -> Fun par(__anonymous_7) nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun par(__anonymous_7) nseq(core_irrefutable) type_annotation(lambda_app_type)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 53, spurious reduction of production core_type -> no_attr_type
## In state 72, spurious reduction of production cartesian_level -> core_type
## In state 312, spurious reduction of production lambda_app_type -> cartesian_level
## In state 311, spurious reduction of production type_annotation(lambda_app_type) -> COLON lambda_app_type
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: If Ident Then Fun UIdent COLON Ident VBAR
##
## Ends in an error in state: 913.
##
## fun_expr(closed_expr) -> Fun nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW closed_expr [ Else ]
## fun_expr(expr) -> Fun nseq(core_irrefutable) type_annotation(lambda_app_type) . ARROW expr [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable) type_annotation(lambda_app_type)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 53, spurious reduction of production core_type -> no_attr_type
## In state 72, spurious reduction of production cartesian_level -> core_type
## In state 312, spurious reduction of production lambda_app_type -> cartesian_level
## In state 311, spurious reduction of production type_annotation(lambda_app_type) -> COLON lambda_app_type
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: LBRACE Attr WILD
##
## Ends in an error in state: 932.
##
## field_assignment -> nseq(Attr) . Ident EQ expr [ SEMI RBRACE ]
## field_assignment -> nseq(Attr) . Ident [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## nseq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 83, spurious reduction of production seq(Attr) ->
## In state 58, spurious reduction of production nseq(Attr) -> Attr seq(Attr)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: LBRACE Attr Ident ZWSP
##
## Ends in an error in state: 933.
##
## field_assignment -> nseq(Attr) Ident . EQ expr [ SEMI RBRACE ]
## field_assignment -> nseq(Attr) Ident . [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Ident
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: LBRACE Attr Ident EQ ZWSP
##
## Ends in an error in state: 934.
##
## field_assignment -> nseq(Attr) Ident EQ . expr [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Ident EQ
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: LBRACE Ident With Ident DOT ZWSP
##
## Ends in an error in state: 940.
##
## projection -> Ident DOT . nsepseq(selection,DOT) [ VBAR_EQ TIMES_EQ SLASH_EQ PLUS_EQ MINUS_EQ EQ ]
##
## The known suffix of the stack is as follows:
## Ident DOT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: LBRACE Ident With Attr WILD
##
## Ends in an error in state: 954.
##
## field_path_assignment -> nseq(Attr) . Ident [ SEMI RBRACE ]
## field_path_assignment -> nseq(Attr) . path field_lens expr [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## nseq(Attr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 83, spurious reduction of production seq(Attr) ->
## In state 58, spurious reduction of production nseq(Attr) -> Attr seq(Attr)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: LBRACE Ident With Attr Ident ZWSP
##
## Ends in an error in state: 955.
##
## field_path_assignment -> nseq(Attr) Ident . [ SEMI RBRACE ]
## path -> Ident . [ VBAR_EQ TIMES_EQ SLASH_EQ PLUS_EQ MINUS_EQ EQ ]
## projection -> Ident . DOT nsepseq(selection,DOT) [ VBAR_EQ TIMES_EQ SLASH_EQ PLUS_EQ MINUS_EQ EQ ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) Ident
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: LBRACE Ident With Attr Ident DOT Ident With
##
## Ends in an error in state: 956.
##
## field_path_assignment -> nseq(Attr) path . field_lens expr [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) path
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 263, spurious reduction of production nsepseq(selection,DOT) -> selection
## In state 941, spurious reduction of production projection -> Ident DOT nsepseq(selection,DOT)
## In state 943, spurious reduction of production path -> projection
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: LBRACE Ident With Attr Ident EQ ZWSP
##
## Ends in an error in state: 957.
##
## field_path_assignment -> nseq(Attr) path field_lens . expr [ SEMI RBRACE ]
##
## The known suffix of the stack is as follows:
## nseq(Attr) path field_lens
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Let LPAR RPAR COLON Ident Type
##
## Ends in an error in state: 988.
##
## let_binding -> unit type_annotation(type_expr) . EQ expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## unit type_annotation(type_expr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 53, spurious reduction of production core_type -> no_attr_type
## In state 72, spurious reduction of production cartesian_level -> core_type
## In state 79, spurious reduction of production fun_type_level -> cartesian_level
## In state 71, spurious reduction of production type_expr -> fun_type_level
## In state 60, spurious reduction of production type_annotation(type_expr) -> COLON type_expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Let LPAR RPAR LPAR Type Ident RPAR COLON Ident Type
##
## Ends in an error in state: 994.
##
## let_binding -> unit par(__anonymous_7) type_annotation(type_expr) . EQ expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## unit par(__anonymous_7) type_annotation(type_expr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 53, spurious reduction of production core_type -> no_attr_type
## In state 72, spurious reduction of production cartesian_level -> core_type
## In state 79, spurious reduction of production fun_type_level -> cartesian_level
## In state 71, spurious reduction of production type_expr -> fun_type_level
## In state 60, spurious reduction of production type_annotation(type_expr) -> COLON type_expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Match Ident With UIdent RPAR
##
## Ends in an error in state: 1010.
##
## match_clause(base_cond) -> pattern . ARROW base_cond [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## pattern
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 462, spurious reduction of production ctor_app_pattern -> UIdent
## In state 494, spurious reduction of production core_pattern -> ctor_app_pattern
## In state 517, spurious reduction of production cons_pattern_level -> core_pattern
## In state 533, spurious reduction of production pattern -> cons_pattern_level
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Match Ident With UIdent ARROW Ident COMMA Ident Else
##
## Ends in an error in state: 1012.
##
## cases(base_cond) -> cases(base_cond) . VBAR match_clause(base_cond) [ With VBAR Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
## match_expr(base_cond) -> Match expr With option(VBAR) cases(base_cond) . [ With Type Then SEMI RPAR RBRACKET RBRACE Module Let In End EOF Directive COLON Attr ]
##
## The known suffix of the stack is as follows:
## Match expr With option(VBAR) cases(base_cond)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 259, spurious reduction of production field_path -> Ident
## In state 333, spurious reduction of production local_path -> field_path
## In state 331, spurious reduction of production path_expr -> local_path
## In state 324, spurious reduction of production no_attr_expr -> path_expr
## In state 329, spurious reduction of production core_expr -> no_attr_expr
## In state 345, spurious reduction of production app_expr_level -> core_expr
## In state 354, spurious reduction of production unary_expr_level -> app_expr_level
## In state 341, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 362, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 368, spurious reduction of production add_expr_level -> mult_expr_level
## In state 404, spurious reduction of production cons_expr_level -> add_expr_level
## In state 391, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 428, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 435, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 444, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 441, spurious reduction of production nsepseq(disj_expr_level,COMMA) -> disj_expr_level
## In state 440, spurious reduction of production tuple(disj_expr_level) -> disj_expr_level COMMA nsepseq(disj_expr_level,COMMA)
## In state 361, spurious reduction of production tuple_expr -> tuple(disj_expr_level)
## In state 660, spurious reduction of production base_expr(base_cond) -> tuple_expr
## In state 645, spurious reduction of production base_cond__open(base_cond) -> base_expr(base_cond)
## In state 646, spurious reduction of production base_cond -> base_cond__open(base_cond)
## In state 757, spurious reduction of production match_clause(base_cond) -> pattern ARROW base_cond
## In state 759, spurious reduction of production cases(base_cond) -> match_clause(base_cond)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: UIdent DOT LPAR Ident Type
##
## Ends in an error in state: 1017.
##
## par(expr) -> LPAR expr . RPAR [ With Verbatim VBAR UIdent Type Then TIMES String SLASH SEMI RPAR REV_APP RBRACKET RBRACE PLUS Or Nat NE Mutez Module Mod MINUS Lxor Lsr Lsl Lor Let Lang Land LT LPAR LE LBRACKET LBRACE Int In Ident GT End Else EQ EOF Directive CONS COMMA COLON CARET Bytes Begin BOOL_OR BOOL_AND Attr ]
##
## The known suffix of the stack is as follows:
## LPAR expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 259, spurious reduction of production field_path -> Ident
## In state 333, spurious reduction of production local_path -> field_path
## In state 331, spurious reduction of production path_expr -> local_path
## In state 324, spurious reduction of production no_attr_expr -> path_expr
## In state 329, spurious reduction of production core_expr -> no_attr_expr
## In state 345, spurious reduction of production app_expr_level -> core_expr
## In state 354, spurious reduction of production unary_expr_level -> app_expr_level
## In state 341, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 362, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 368, spurious reduction of production add_expr_level -> mult_expr_level
## In state 404, spurious reduction of production cons_expr_level -> add_expr_level
## In state 391, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 428, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 435, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 444, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 389, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 451, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 452, spurious reduction of production expr -> base_cond__open(expr)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Let Ident LPAR Type Ident RPAR COLON Ident Type
##
## Ends in an error in state: 1035.
##
## let_binding -> var_pattern par(__anonymous_7) type_annotation(type_expr) . EQ expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## var_pattern par(__anonymous_7) type_annotation(type_expr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 53, spurious reduction of production core_type -> no_attr_type
## In state 72, spurious reduction of production cartesian_level -> core_type
## In state 79, spurious reduction of production fun_type_level -> cartesian_level
## In state 71, spurious reduction of production type_expr -> fun_type_level
## In state 60, spurious reduction of production type_annotation(type_expr) -> COLON type_expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

contract: Let Ident LPAR Type Ident RPAR UIdent COLON Ident Type
##
## Ends in an error in state: 1041.
##
## let_binding -> var_pattern par(__anonymous_7) parameters type_annotation(type_expr) . EQ expr [ Type Module Let In End EOF Directive Attr ]
##
## The known suffix of the stack is as follows:
## var_pattern par(__anonymous_7) parameters type_annotation(type_expr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 53, spurious reduction of production core_type -> no_attr_type
## In state 72, spurious reduction of production cartesian_level -> core_type
## In state 79, spurious reduction of production fun_type_level -> cartesian_level
## In state 71, spurious reduction of production type_expr -> fun_type_level
## In state 60, spurious reduction of production type_annotation(type_expr) -> COLON type_expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Begin Match Ident With UIdent ARROW Let Rec ZWSP
##
## Ends in an error in state: 551.
##
## let_in_expr(base_cond) -> Let Rec . let_binding In base_cond [ VBAR ]
## let_in_sequence -> Let Rec . let_binding In series [ End ]
##
## The known suffix of the stack is as follows:
## Let Rec
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Begin If Ident Then Let Rec Ident EQ Ident Type
##
## Ends in an error in state: 793.
##
## let_in_expr(closed_expr) -> Let Rec let_binding . In closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Let Rec let_binding
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 259, spurious reduction of production field_path -> Ident
## In state 333, spurious reduction of production local_path -> field_path
## In state 331, spurious reduction of production path_expr -> local_path
## In state 324, spurious reduction of production no_attr_expr -> path_expr
## In state 329, spurious reduction of production core_expr -> no_attr_expr
## In state 345, spurious reduction of production app_expr_level -> core_expr
## In state 354, spurious reduction of production unary_expr_level -> app_expr_level
## In state 341, spurious reduction of production shift_expr_level -> unary_expr_level
## In state 362, spurious reduction of production mult_expr_level -> shift_expr_level
## In state 368, spurious reduction of production add_expr_level -> mult_expr_level
## In state 404, spurious reduction of production cons_expr_level -> add_expr_level
## In state 391, spurious reduction of production cat_expr_level -> cons_expr_level
## In state 428, spurious reduction of production comp_expr_level -> cat_expr_level
## In state 435, spurious reduction of production conj_expr_level -> comp_expr_level
## In state 444, spurious reduction of production disj_expr_level -> conj_expr_level
## In state 389, spurious reduction of production base_expr(expr) -> disj_expr_level
## In state 451, spurious reduction of production base_cond__open(expr) -> base_expr(expr)
## In state 452, spurious reduction of production expr -> base_cond__open(expr)
## In state 1022, spurious reduction of production let_binding -> var_pattern EQ expr
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Begin Match Ident With UIdent ARROW Fun UIdent ARROW ZWSP
##
## Ends in an error in state: 860.
##
## fun_expr(base_cond) -> Fun nseq(core_irrefutable) ARROW . base_cond [ VBAR ]
## fun_expr(last_expr) -> Fun nseq(core_irrefutable) ARROW . last_expr [ End ]
##
## The known suffix of the stack is as follows:
## Fun nseq(core_irrefutable) ARROW
##

<YOUR SYNTAX ERROR MESSAGE HERE>

interactive_expr: Begin If Ident Then Fun LPAR Type Ident RPAR UIdent EQ
##
## Ends in an error in state: 800.
##
## fun_expr(closed_expr) -> Fun par(__anonymous_7) nseq(core_irrefutable) . ARROW closed_expr [ Else ]
## fun_expr(closed_expr) -> Fun par(__anonymous_7) nseq(core_irrefutable) . type_annotation(lambda_app_type) ARROW closed_expr [ Else ]
##
## The known suffix of the stack is as follows:
## Fun par(__anonymous_7) nseq(core_irrefutable)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 672, spurious reduction of production seq(core_irrefutable) ->
## In state 673, spurious reduction of production nseq(core_irrefutable) -> ctor_irrefutable seq(core_irrefutable)
##

<YOUR SYNTAX ERROR MESSAGE HERE>
