#![no_std]

use core::panic::PanicInfo;

// #[cfg(feature = "no_std")]
#[cfg(feature = "wee_alloc")]
#[global_allocator]
static ALLOC: wee_alloc::WeeAlloc = wee_alloc::WeeAlloc::INIT;

// #[alloc_error_handler]
// pub fn alloc_error_handler(_: core::alloc::Layout) -> ! {
//     abort()
// }

// #[cfg(feature = "no_std")]
#[panic_handler]
fn panic_handler(_info: &PanicInfo) -> ! {
    loop{}
}

#[no_mangle]
pub extern "C" fn c_add_i32(a: *mut i32, b: *mut i32) -> i32 {
  let a:i32 = unsafe { *a };
  let b:i32 = unsafe { *b };
  return a + b
}

extern "C" {
  /// The entrypoint of the smart contract. This should be generated by the LIGO
  /// wasm backend.
  pub fn entrypoint(parameter: i32, storage: i32) -> i32;
}

/**  
 * The starting point of the generated wasm file.
 *
 * It loads the data from storage, calls the LIGO wasm backend generated
 * code, and stores the data once done. Currently the operations and
 * parameters are _not_ properly handled.
 *
 */
#[no_mangle]
pub extern "C" fn _start() -> i32 {
  let tuple_left = unsafe { entrypoint(2, 4)} ;
  // let tuple_left_pointer = tuple_left as *const i32;
  // let tuple_left_value = unsafe { *tuple_left_pointer }; // the pointer
  // let value_pointer = tuple_left_value as *const i32;
  // let value = unsafe { *value_pointer }; // and get the value 

  // println!("result left: {} -> {} -> {}\n", tuple_left, tuple_left_value, value);
  // let tuple_right = tuple_left + 4;
  // let tuple_right_pointer = tuple_right  as *const i32; 
  // let tuple_right_value = unsafe { *tuple_right_pointer }; // the pointer
  // let value_pointer = tuple_right_value as *const i32;
  // let value = unsafe { *value_pointer }; // the value
  // println!("result right:{} -> {} -> {} \n", tuple_right, tuple_right_value, value);
  tuple_left  
}
