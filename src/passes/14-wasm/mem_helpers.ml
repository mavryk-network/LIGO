
[@@@warning "-27"]

(* Do not change, this file is generated by the Rust `datatype_helper` macro. *)
module W = WasmObjectFile  
module A = W.Ast
module T = W.Types
module S = W.Source
module ValueVar = Stage_common.Types.ValueVar
    
let at = S.no_region

let const_0l = S.{ it = A.Const { it = I32 0l; at}; at }

type dt = <
  locals:       (string * T.value_type) list;
  malloc_name:  string;
  store:        A.instr' S.phrase list;
  reference:    A.instr' S.phrase list
>

let make_dt = fun a ->
  object
    method locals = []
    method malloc_name = ""
    method store = a
    method reference = []
  end

let var_to_string name =  
  let name, hash = ValueVar.internal_get_name_and_counter name in
  name ^ "#" ^ (string_of_int hash)


class ['T] wrapped ~(data : 'T)  = object(self)
  val size = 4l
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"wrapped_malloc" ())
  val mutable allocated = false
  val mutable stored = false
  method malloc_name = malloc_name
  method size = size
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)]
    
    @ self#data#locals 


  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )
     
    
  val data = data
  method data = data
  method get_data = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_data = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    data#store
    @
    data#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
            

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc
      @  self#store_data 

    )
    
  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]

end



type option_variant = 
  
| None
| Some

class ['T] option ~(kind: option_variant) ~(value: 'T) = object(self)
  val kind = kind
  val value = value
  
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"option_malloc" ())
  val mutable allocated = false
  val mutable stored = false

  method malloc_name = malloc_name
  method size = 12l
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method kind = kind
  method value = value
  
  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)] 
    @
    value#locals

  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )

  method store_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 4l; at  }; at };
      { it = Binary (I32 Add); at };
    ]
    @
    value#store
    @
    S.[
      { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method store_kind = 
    let kind = match self#kind with 
    
  | None -> 0l
  | Some -> 1l 
    in
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 kind; at  }; at };
      { it = Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method get_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 4l; at  }; at  };
      { it = Binary (I32 Add); at };
      { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc 
      @ self#store_kind
      @ self#store_value
   
  )

  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]
  
end
          
class  bigintwrap ~(data : dt) ~(len : dt) ~(capacity : dt)  = object(self)
  val size = 12l
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"bigintwrap_malloc" ())
  val mutable allocated = false
  val mutable stored = false
  method malloc_name = malloc_name
  method size = size
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)]
    
    @ self#data#locals 
@ self#len#locals 
@ self#capacity#locals 


  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )
     
    
  val data = data
  method data = data
  method get_data = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_data = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    data#store
    @
    data#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val len = len
  method len = len
  method get_len = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_len = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    len#store
    @
    len#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val capacity = capacity
  method capacity = capacity
  method get_capacity = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 8l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_capacity = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 8l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    capacity#store
    @
    capacity#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
            

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc
      @  self#store_data 
@  self#store_len 
@  self#store_capacity 

    )
    
  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]

end



type datatype_variant = 
  
| Int
| Nat
| Mutez
| Timestamp
| Bool
| ListItem
| Tuple
| Set
| Map
| Operations
| String

class  datatype ~(kind: datatype_variant) ~(value: dt) = object(self)
  val kind = kind
  val value = value
  
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"datatype_malloc" ())
  val mutable allocated = false
  val mutable stored = false

  method malloc_name = malloc_name
  method size = 12l
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method kind = kind
  method value = value
  
  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)] 
    @
    value#locals

  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )

  method store_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 4l; at  }; at };
      { it = Binary (I32 Add); at };
    ]
    @
    value#store
    @
    S.[
      { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method store_kind = 
    let kind = match self#kind with 
    
  | Int -> 0l
  | Nat -> 1l
  | Mutez -> 2l
  | Timestamp -> 3l
  | Bool -> 4l
  | ListItem -> 5l
  | Tuple -> 6l
  | Set -> 7l
  | Map -> 8l
  | Operations -> 9l
  | String -> 10l 
    in
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 kind; at  }; at };
      { it = Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method get_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 4l; at  }; at  };
      { it = Binary (I32 Add); at };
      { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc 
      @ self#store_kind
      @ self#store_value
   
  )

  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]
  
end
          
class  node ~(value : dt) ~(next : dt)  = object(self)
  val size = 8l
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"node_malloc" ())
  val mutable allocated = false
  val mutable stored = false
  method malloc_name = malloc_name
  method size = size
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)]
    
    @ self#value#locals 
@ self#next#locals 


  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )
     
    
  val value = value
  method value = value
  method get_value = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    value#store
    @
    value#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val next = next
  method next = next
  method get_next = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_next = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    next#store
    @
    next#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
            

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc
      @  self#store_value 
@  self#store_next 

    )
    
  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]

end



type operation_variant = 
  
| Transaction
| Delegate

class  operation ~(kind: operation_variant) ~(value: dt) = object(self)
  val kind = kind
  val value = value
  
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"operation_malloc" ())
  val mutable allocated = false
  val mutable stored = false

  method malloc_name = malloc_name
  method size = 12l
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method kind = kind
  method value = value
  
  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)] 
    @
    value#locals

  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )

  method store_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 4l; at  }; at };
      { it = Binary (I32 Add); at };
    ]
    @
    value#store
    @
    S.[
      { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method store_kind = 
    let kind = match self#kind with 
    
  | Transaction -> 0l
  | Delegate -> 1l 
    in
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 kind; at  }; at };
      { it = Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method get_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 4l; at  }; at  };
      { it = Binary (I32 Add); at };
      { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc 
      @ self#store_kind
      @ self#store_value
   
  )

  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]
  
end
          
class  operationnode ~(value : dt) ~(next : dt)  = object(self)
  val size = 8l
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"operationnode_malloc" ())
  val mutable allocated = false
  val mutable stored = false
  method malloc_name = malloc_name
  method size = size
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)]
    
    @ self#value#locals 
@ self#next#locals 


  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )
     
    
  val value = value
  method value = value
  method get_value = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    value#store
    @
    value#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val next = next
  method next = next
  method get_next = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_next = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    next#store
    @
    next#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
            

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc
      @  self#store_value 
@  self#store_next 

    )
    
  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]

end



type color_variant = 
  
| Red
| Black

class  color ~(kind: color_variant) ~(value: dt) = object(self)
  val kind = kind
  val value = value
  
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"color_malloc" ())
  val mutable allocated = false
  val mutable stored = false

  method malloc_name = malloc_name
  method size = 12l
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method kind = kind
  method value = value
  
  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)] 
    @
    value#locals

  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )

  method store_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 4l; at  }; at };
      { it = Binary (I32 Add); at };
    ]
    @
    value#store
    @
    S.[
      { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method store_kind = 
    let kind = match self#kind with 
    
  | Red -> 0l
  | Black -> 1l 
    in
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 kind; at  }; at };
      { it = Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method get_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 4l; at  }; at  };
      { it = Binary (I32 Add); at };
      { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc 
      @ self#store_kind
      @ self#store_value
   
  )

  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]
  
end
          
class  rbnode ~(parent : dt) ~(value : dt) ~(depth : dt) ~(left : dt) ~(right : dt) ~(color : dt)  = object(self)
  val size = 24l
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"rbnode_malloc" ())
  val mutable allocated = false
  val mutable stored = false
  method malloc_name = malloc_name
  method size = size
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)]
    
    @ self#parent#locals 
@ self#value#locals 
@ self#depth#locals 
@ self#left#locals 
@ self#right#locals 
@ self#color#locals 


  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )
     
    
  val parent = parent
  method parent = parent
  method get_parent = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_parent = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    parent#store
    @
    parent#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val value = value
  method value = value
  method get_value = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    value#store
    @
    value#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val depth = depth
  method depth = depth
  method get_depth = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 8l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_depth = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 8l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    depth#store
    @
    depth#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val left = left
  method left = left
  method get_left = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 12l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_left = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 12l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    left#store
    @
    left#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val right = right
  method right = right
  method get_right = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 16l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_right = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 16l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    right#store
    @
    right#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val color = color
  method color = color
  method get_color = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 20l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_color = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 20l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    color#store
    @
    color#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
            

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc
      @  self#store_parent 
@  self#store_value 
@  self#store_depth 
@  self#store_left 
@  self#store_right 
@  self#store_color 

    )
    
  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]

end


class  transaction ~(action : dt) ~(amount : dt) ~(contract : dt)  = object(self)
  val size = 12l
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"transaction_malloc" ())
  val mutable allocated = false
  val mutable stored = false
  method malloc_name = malloc_name
  method size = size
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)]
    
    @ self#action#locals 
@ self#amount#locals 
@ self#contract#locals 


  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )
     
    
  val action = action
  method action = action
  method get_action = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_action = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    action#store
    @
    action#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val amount = amount
  method amount = amount
  method get_amount = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_amount = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    amount#store
    @
    amount#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val contract = contract
  method contract = contract
  method get_contract = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 8l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_contract = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 8l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    contract#store
    @
    contract#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
            

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc
      @  self#store_action 
@  self#store_amount 
@  self#store_contract 

    )
    
  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]

end


class  delegate ~(delegate : dt)  = object(self)
  val size = 4l
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"delegate_malloc" ())
  val mutable allocated = false
  val mutable stored = false
  method malloc_name = malloc_name
  method size = size
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)]
    
    @ self#delegate#locals 


  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )
     
    
  val delegate = delegate
  method delegate = delegate
  method get_delegate = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_delegate = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    delegate#store
    @
    delegate#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
            

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc
      @  self#store_delegate 

    )
    
  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]

end


class ['T] wrapped ~(data : 'T)  = object(self)
  val size = 4l
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"wrapped_malloc" ())
  val mutable allocated = false
  val mutable stored = false
  method malloc_name = malloc_name
  method size = size
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)]
    
    @ self#data#locals 


  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )
     
    
  val data = data
  method data = data
  method get_data = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_data = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    data#store
    @
    data#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
            

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc
      @  self#store_data 

    )
    
  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]

end



type option_variant = 
  
| None
| Some

class ['T] option ~(kind: option_variant) ~(value: 'T) = object(self)
  val kind = kind
  val value = value
  
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"option_malloc" ())
  val mutable allocated = false
  val mutable stored = false

  method malloc_name = malloc_name
  method size = 12l
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method kind = kind
  method value = value
  
  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)] 
    @
    value#locals

  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )

  method store_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 4l; at  }; at };
      { it = Binary (I32 Add); at };
    ]
    @
    value#store
    @
    S.[
      { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method store_kind = 
    let kind = match self#kind with 
    
  | None -> 0l
  | Some -> 1l 
    in
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 kind; at  }; at };
      { it = Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method get_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 4l; at  }; at  };
      { it = Binary (I32 Add); at };
      { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc 
      @ self#store_kind
      @ self#store_value
   
  )

  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]
  
end
          
class  bigintwrap ~(data : dt) ~(len : dt) ~(capacity : dt)  = object(self)
  val size = 12l
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"bigintwrap_malloc" ())
  val mutable allocated = false
  val mutable stored = false
  method malloc_name = malloc_name
  method size = size
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)]
    
    @ self#data#locals 
@ self#len#locals 
@ self#capacity#locals 


  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )
     
    
  val data = data
  method data = data
  method get_data = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_data = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    data#store
    @
    data#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val len = len
  method len = len
  method get_len = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_len = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    len#store
    @
    len#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val capacity = capacity
  method capacity = capacity
  method get_capacity = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 8l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_capacity = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 8l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    capacity#store
    @
    capacity#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
            

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc
      @  self#store_data 
@  self#store_len 
@  self#store_capacity 

    )
    
  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]

end



type datatype_variant = 
  
| Int
| Nat
| Mutez
| Timestamp
| Bool
| ListItem
| Tuple
| Set
| Map
| Operations
| String

class  datatype ~(kind: datatype_variant) ~(value: dt) = object(self)
  val kind = kind
  val value = value
  
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"datatype_malloc" ())
  val mutable allocated = false
  val mutable stored = false

  method malloc_name = malloc_name
  method size = 12l
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method kind = kind
  method value = value
  
  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)] 
    @
    value#locals

  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )

  method store_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 4l; at  }; at };
      { it = Binary (I32 Add); at };
    ]
    @
    value#store
    @
    S.[
      { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method store_kind = 
    let kind = match self#kind with 
    
  | Int -> 0l
  | Nat -> 1l
  | Mutez -> 2l
  | Timestamp -> 3l
  | Bool -> 4l
  | ListItem -> 5l
  | Tuple -> 6l
  | Set -> 7l
  | Map -> 8l
  | Operations -> 9l
  | String -> 10l 
    in
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 kind; at  }; at };
      { it = Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method get_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 4l; at  }; at  };
      { it = Binary (I32 Add); at };
      { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc 
      @ self#store_kind
      @ self#store_value
   
  )

  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]
  
end
          
class  node ~(value : dt) ~(next : dt)  = object(self)
  val size = 8l
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"node_malloc" ())
  val mutable allocated = false
  val mutable stored = false
  method malloc_name = malloc_name
  method size = size
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)]
    
    @ self#value#locals 
@ self#next#locals 


  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )
     
    
  val value = value
  method value = value
  method get_value = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    value#store
    @
    value#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val next = next
  method next = next
  method get_next = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_next = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    next#store
    @
    next#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
            

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc
      @  self#store_value 
@  self#store_next 

    )
    
  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]

end



type operation_variant = 
  
| Transaction
| Delegate

class  operation ~(kind: operation_variant) ~(value: dt) = object(self)
  val kind = kind
  val value = value
  
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"operation_malloc" ())
  val mutable allocated = false
  val mutable stored = false

  method malloc_name = malloc_name
  method size = 12l
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method kind = kind
  method value = value
  
  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)] 
    @
    value#locals

  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )

  method store_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 4l; at  }; at };
      { it = Binary (I32 Add); at };
    ]
    @
    value#store
    @
    S.[
      { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method store_kind = 
    let kind = match self#kind with 
    
  | Transaction -> 0l
  | Delegate -> 1l 
    in
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 kind; at  }; at };
      { it = Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method get_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 4l; at  }; at  };
      { it = Binary (I32 Add); at };
      { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc 
      @ self#store_kind
      @ self#store_value
   
  )

  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]
  
end
          
class  operationnode ~(value : dt) ~(next : dt)  = object(self)
  val size = 8l
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"operationnode_malloc" ())
  val mutable allocated = false
  val mutable stored = false
  method malloc_name = malloc_name
  method size = size
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)]
    
    @ self#value#locals 
@ self#next#locals 


  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )
     
    
  val value = value
  method value = value
  method get_value = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    value#store
    @
    value#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val next = next
  method next = next
  method get_next = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_next = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    next#store
    @
    next#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
            

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc
      @  self#store_value 
@  self#store_next 

    )
    
  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]

end



type color_variant = 
  
| Red
| Black

class  color ~(kind: color_variant) ~(value: dt) = object(self)
  val kind = kind
  val value = value
  
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"color_malloc" ())
  val mutable allocated = false
  val mutable stored = false

  method malloc_name = malloc_name
  method size = 12l
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method kind = kind
  method value = value
  
  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)] 
    @
    value#locals

  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )

  method store_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 4l; at  }; at };
      { it = Binary (I32 Add); at };
    ]
    @
    value#store
    @
    S.[
      { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method store_kind = 
    let kind = match self#kind with 
    
  | Red -> 0l
  | Black -> 1l 
    in
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 kind; at  }; at };
      { it = Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method get_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 4l; at  }; at  };
      { it = Binary (I32 Add); at };
      { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc 
      @ self#store_kind
      @ self#store_value
   
  )

  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]
  
end
          
class  rbnode ~(parent : dt) ~(value : dt) ~(depth : dt) ~(left : dt) ~(right : dt) ~(color : dt)  = object(self)
  val size = 24l
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"rbnode_malloc" ())
  val mutable allocated = false
  val mutable stored = false
  method malloc_name = malloc_name
  method size = size
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)]
    
    @ self#parent#locals 
@ self#value#locals 
@ self#depth#locals 
@ self#left#locals 
@ self#right#locals 
@ self#color#locals 


  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )
     
    
  val parent = parent
  method parent = parent
  method get_parent = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_parent = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    parent#store
    @
    parent#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val value = value
  method value = value
  method get_value = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    value#store
    @
    value#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val depth = depth
  method depth = depth
  method get_depth = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 8l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_depth = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 8l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    depth#store
    @
    depth#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val left = left
  method left = left
  method get_left = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 12l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_left = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 12l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    left#store
    @
    left#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val right = right
  method right = right
  method get_right = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 16l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_right = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 16l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    right#store
    @
    right#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val color = color
  method color = color
  method get_color = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 20l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_color = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 20l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    color#store
    @
    color#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
            

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc
      @  self#store_parent 
@  self#store_value 
@  self#store_depth 
@  self#store_left 
@  self#store_right 
@  self#store_color 

    )
    
  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]

end


class  transaction ~(action : dt) ~(amount : dt) ~(contract : dt)  = object(self)
  val size = 12l
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"transaction_malloc" ())
  val mutable allocated = false
  val mutable stored = false
  method malloc_name = malloc_name
  method size = size
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)]
    
    @ self#action#locals 
@ self#amount#locals 
@ self#contract#locals 


  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )
     
    
  val action = action
  method action = action
  method get_action = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_action = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    action#store
    @
    action#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val amount = amount
  method amount = amount
  method get_amount = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_amount = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    amount#store
    @
    amount#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val contract = contract
  method contract = contract
  method get_contract = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 8l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_contract = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 8l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    contract#store
    @
    contract#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
            

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc
      @  self#store_action 
@  self#store_amount 
@  self#store_contract 

    )
    
  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]

end


class  delegate ~(delegate : dt)  = object(self)
  val size = 4l
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"delegate_malloc" ())
  val mutable allocated = false
  val mutable stored = false
  method malloc_name = malloc_name
  method size = size
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)]
    
    @ self#delegate#locals 


  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )
     
    
  val delegate = delegate
  method delegate = delegate
  method get_delegate = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_delegate = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    delegate#store
    @
    delegate#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
            

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc
      @  self#store_delegate 

    )
    
  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]

end


class ['T] wrapped ~(data : 'T)  = object(self)
  val size = 4l
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"wrapped_malloc" ())
  val mutable allocated = false
  val mutable stored = false
  method malloc_name = malloc_name
  method size = size
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)]
    
    @ self#data#locals 


  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )
     
    
  val data = data
  method data = data
  method get_data = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_data = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    data#store
    @
    data#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
            

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc
      @  self#store_data 

    )
    
  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]

end



type option_variant = 
  
| None
| Some

class ['T] option ~(kind: option_variant) ~(value: 'T) = object(self)
  val kind = kind
  val value = value
  
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"option_malloc" ())
  val mutable allocated = false
  val mutable stored = false

  method malloc_name = malloc_name
  method size = 12l
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method kind = kind
  method value = value
  
  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)] 
    @
    value#locals

  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )

  method store_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 4l; at  }; at };
      { it = Binary (I32 Add); at };
    ]
    @
    value#store
    @
    S.[
      { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method store_kind = 
    let kind = match self#kind with 
    
  | None -> 0l
  | Some -> 1l 
    in
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 kind; at  }; at };
      { it = Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method get_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 4l; at  }; at  };
      { it = Binary (I32 Add); at };
      { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc 
      @ self#store_kind
      @ self#store_value
   
  )

  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]
  
end
          
class  bigintwrap ~(data : dt) ~(len : dt) ~(capacity : dt)  = object(self)
  val size = 12l
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"bigintwrap_malloc" ())
  val mutable allocated = false
  val mutable stored = false
  method malloc_name = malloc_name
  method size = size
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)]
    
    @ self#data#locals 
@ self#len#locals 
@ self#capacity#locals 


  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )
     
    
  val data = data
  method data = data
  method get_data = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_data = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    data#store
    @
    data#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val len = len
  method len = len
  method get_len = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_len = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    len#store
    @
    len#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val capacity = capacity
  method capacity = capacity
  method get_capacity = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 8l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_capacity = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 8l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    capacity#store
    @
    capacity#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
            

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc
      @  self#store_data 
@  self#store_len 
@  self#store_capacity 

    )
    
  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]

end



type datatype_variant = 
  
| Int
| Nat
| Mutez
| Timestamp
| Bool
| ListItem
| Tuple
| Set
| Map
| Operations
| String

class  datatype ~(kind: datatype_variant) ~(value: dt) = object(self)
  val kind = kind
  val value = value
  
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"datatype_malloc" ())
  val mutable allocated = false
  val mutable stored = false

  method malloc_name = malloc_name
  method size = 12l
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method kind = kind
  method value = value
  
  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)] 
    @
    value#locals

  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )

  method store_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 4l; at  }; at };
      { it = Binary (I32 Add); at };
    ]
    @
    value#store
    @
    S.[
      { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method store_kind = 
    let kind = match self#kind with 
    
  | Int -> 0l
  | Nat -> 1l
  | Mutez -> 2l
  | Timestamp -> 3l
  | Bool -> 4l
  | ListItem -> 5l
  | Tuple -> 6l
  | Set -> 7l
  | Map -> 8l
  | Operations -> 9l
  | String -> 10l 
    in
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 kind; at  }; at };
      { it = Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method get_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 4l; at  }; at  };
      { it = Binary (I32 Add); at };
      { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc 
      @ self#store_kind
      @ self#store_value
   
  )

  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]
  
end
          
class  node ~(value : dt) ~(next : dt)  = object(self)
  val size = 8l
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"node_malloc" ())
  val mutable allocated = false
  val mutable stored = false
  method malloc_name = malloc_name
  method size = size
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)]
    
    @ self#value#locals 
@ self#next#locals 


  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )
     
    
  val value = value
  method value = value
  method get_value = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    value#store
    @
    value#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val next = next
  method next = next
  method get_next = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_next = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    next#store
    @
    next#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
            

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc
      @  self#store_value 
@  self#store_next 

    )
    
  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]

end



type operation_variant = 
  
| Transaction
| Delegate

class  operation ~(kind: operation_variant) ~(value: dt) = object(self)
  val kind = kind
  val value = value
  
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"operation_malloc" ())
  val mutable allocated = false
  val mutable stored = false

  method malloc_name = malloc_name
  method size = 12l
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method kind = kind
  method value = value
  
  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)] 
    @
    value#locals

  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )

  method store_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 4l; at  }; at };
      { it = Binary (I32 Add); at };
    ]
    @
    value#store
    @
    S.[
      { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method store_kind = 
    let kind = match self#kind with 
    
  | Transaction -> 0l
  | Delegate -> 1l 
    in
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 kind; at  }; at };
      { it = Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method get_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 4l; at  }; at  };
      { it = Binary (I32 Add); at };
      { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc 
      @ self#store_kind
      @ self#store_value
   
  )

  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]
  
end
          
class  operationnode ~(value : dt) ~(next : dt)  = object(self)
  val size = 8l
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"operationnode_malloc" ())
  val mutable allocated = false
  val mutable stored = false
  method malloc_name = malloc_name
  method size = size
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)]
    
    @ self#value#locals 
@ self#next#locals 


  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )
     
    
  val value = value
  method value = value
  method get_value = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    value#store
    @
    value#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val next = next
  method next = next
  method get_next = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_next = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    next#store
    @
    next#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
            

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc
      @  self#store_value 
@  self#store_next 

    )
    
  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]

end



type color_variant = 
  
| Red
| Black

class  color ~(kind: color_variant) ~(value: dt) = object(self)
  val kind = kind
  val value = value
  
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"color_malloc" ())
  val mutable allocated = false
  val mutable stored = false

  method malloc_name = malloc_name
  method size = 12l
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method kind = kind
  method value = value
  
  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)] 
    @
    value#locals

  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )

  method store_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 4l; at  }; at };
      { it = Binary (I32 Add); at };
    ]
    @
    value#store
    @
    S.[
      { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method store_kind = 
    let kind = match self#kind with 
    
  | Red -> 0l
  | Black -> 1l 
    in
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 kind; at  }; at };
      { it = Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method get_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 4l; at  }; at  };
      { it = Binary (I32 Add); at };
      { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc 
      @ self#store_kind
      @ self#store_value
   
  )

  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]
  
end
          
class  rbnode ~(parent : dt) ~(value : dt) ~(depth : dt) ~(left : dt) ~(right : dt) ~(color : dt)  = object(self)
  val size = 24l
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"rbnode_malloc" ())
  val mutable allocated = false
  val mutable stored = false
  method malloc_name = malloc_name
  method size = size
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)]
    
    @ self#parent#locals 
@ self#value#locals 
@ self#depth#locals 
@ self#left#locals 
@ self#right#locals 
@ self#color#locals 


  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )
     
    
  val parent = parent
  method parent = parent
  method get_parent = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_parent = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    parent#store
    @
    parent#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val value = value
  method value = value
  method get_value = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    value#store
    @
    value#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val depth = depth
  method depth = depth
  method get_depth = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 8l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_depth = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 8l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    depth#store
    @
    depth#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val left = left
  method left = left
  method get_left = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 12l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_left = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 12l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    left#store
    @
    left#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val right = right
  method right = right
  method get_right = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 16l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_right = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 16l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    right#store
    @
    right#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val color = color
  method color = color
  method get_color = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 20l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_color = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 20l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    color#store
    @
    color#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
            

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc
      @  self#store_parent 
@  self#store_value 
@  self#store_depth 
@  self#store_left 
@  self#store_right 
@  self#store_color 

    )
    
  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]

end


class  transaction ~(action : dt) ~(amount : dt) ~(contract : dt)  = object(self)
  val size = 12l
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"transaction_malloc" ())
  val mutable allocated = false
  val mutable stored = false
  method malloc_name = malloc_name
  method size = size
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)]
    
    @ self#action#locals 
@ self#amount#locals 
@ self#contract#locals 


  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )
     
    
  val action = action
  method action = action
  method get_action = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_action = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    action#store
    @
    action#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val amount = amount
  method amount = amount
  method get_amount = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_amount = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    amount#store
    @
    amount#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val contract = contract
  method contract = contract
  method get_contract = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 8l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_contract = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 8l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    contract#store
    @
    contract#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
            

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc
      @  self#store_action 
@  self#store_amount 
@  self#store_contract 

    )
    
  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]

end


class  delegate ~(delegate : dt)  = object(self)
  val size = 4l
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"delegate_malloc" ())
  val mutable allocated = false
  val mutable stored = false
  method malloc_name = malloc_name
  method size = size
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)]
    
    @ self#delegate#locals 


  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )
     
    
  val delegate = delegate
  method delegate = delegate
  method get_delegate = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_delegate = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    delegate#store
    @
    delegate#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
            

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc
      @  self#store_delegate 

    )
    
  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]

end


class ['T] wrapped ~(data : 'T)  = object(self)
  val size = 4l
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"wrapped_malloc" ())
  val mutable allocated = false
  val mutable stored = false
  method malloc_name = malloc_name
  method size = size
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)]
    
    @ self#data#locals 


  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )
     
    
  val data = data
  method data = data
  method get_data = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_data = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    data#store
    @
    data#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
            

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc
      @  self#store_data 

    )
    
  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]

end



type option_variant = 
  
| None
| Some

class ['T] option ~(kind: option_variant) ~(value: 'T) = object(self)
  val kind = kind
  val value = value
  
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"option_malloc" ())
  val mutable allocated = false
  val mutable stored = false

  method malloc_name = malloc_name
  method size = 12l
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method kind = kind
  method value = value
  
  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)] 
    @
    value#locals

  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )

  method store_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 4l; at  }; at };
      { it = Binary (I32 Add); at };
    ]
    @
    value#store
    @
    S.[
      { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method store_kind = 
    let kind = match self#kind with 
    
  | None -> 0l
  | Some -> 1l 
    in
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 kind; at  }; at };
      { it = Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method get_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 4l; at  }; at  };
      { it = Binary (I32 Add); at };
      { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc 
      @ self#store_kind
      @ self#store_value
   
  )

  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]
  
end
          
class  bigintwrap ~(data : dt) ~(len : dt) ~(capacity : dt)  = object(self)
  val size = 12l
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"bigintwrap_malloc" ())
  val mutable allocated = false
  val mutable stored = false
  method malloc_name = malloc_name
  method size = size
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)]
    
    @ self#data#locals 
@ self#len#locals 
@ self#capacity#locals 


  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )
     
    
  val data = data
  method data = data
  method get_data = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_data = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    data#store
    @
    data#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val len = len
  method len = len
  method get_len = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_len = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    len#store
    @
    len#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val capacity = capacity
  method capacity = capacity
  method get_capacity = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 8l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_capacity = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 8l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    capacity#store
    @
    capacity#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
            

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc
      @  self#store_data 
@  self#store_len 
@  self#store_capacity 

    )
    
  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]

end



type datatype_variant = 
  
| Int
| Nat
| Mutez
| Timestamp
| Bool
| ListItem
| Tuple
| Set
| Map
| Operations
| String

class  datatype ~(kind: datatype_variant) ~(value: dt) = object(self)
  val kind = kind
  val value = value
  
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"datatype_malloc" ())
  val mutable allocated = false
  val mutable stored = false

  method malloc_name = malloc_name
  method size = 12l
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method kind = kind
  method value = value
  
  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)] 
    @
    value#locals

  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )

  method store_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 4l; at  }; at };
      { it = Binary (I32 Add); at };
    ]
    @
    value#store
    @
    S.[
      { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method store_kind = 
    let kind = match self#kind with 
    
  | Int -> 0l
  | Nat -> 1l
  | Mutez -> 2l
  | Timestamp -> 3l
  | Bool -> 4l
  | ListItem -> 5l
  | Tuple -> 6l
  | Set -> 7l
  | Map -> 8l
  | Operations -> 9l
  | String -> 10l 
    in
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 kind; at  }; at };
      { it = Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method get_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 4l; at  }; at  };
      { it = Binary (I32 Add); at };
      { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc 
      @ self#store_kind
      @ self#store_value
   
  )

  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]
  
end
          
class  node ~(value : dt) ~(next : dt)  = object(self)
  val size = 8l
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"node_malloc" ())
  val mutable allocated = false
  val mutable stored = false
  method malloc_name = malloc_name
  method size = size
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)]
    
    @ self#value#locals 
@ self#next#locals 


  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )
     
    
  val value = value
  method value = value
  method get_value = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    value#store
    @
    value#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val next = next
  method next = next
  method get_next = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_next = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    next#store
    @
    next#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
            

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc
      @  self#store_value 
@  self#store_next 

    )
    
  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]

end



type operation_variant = 
  
| Transaction
| Delegate

class  operation ~(kind: operation_variant) ~(value: dt) = object(self)
  val kind = kind
  val value = value
  
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"operation_malloc" ())
  val mutable allocated = false
  val mutable stored = false

  method malloc_name = malloc_name
  method size = 12l
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method kind = kind
  method value = value
  
  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)] 
    @
    value#locals

  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )

  method store_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 4l; at  }; at };
      { it = Binary (I32 Add); at };
    ]
    @
    value#store
    @
    S.[
      { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method store_kind = 
    let kind = match self#kind with 
    
  | Transaction -> 0l
  | Delegate -> 1l 
    in
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 kind; at  }; at };
      { it = Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method get_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 4l; at  }; at  };
      { it = Binary (I32 Add); at };
      { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc 
      @ self#store_kind
      @ self#store_value
   
  )

  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]
  
end
          
class  operationnode ~(value : dt) ~(next : dt)  = object(self)
  val size = 8l
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"operationnode_malloc" ())
  val mutable allocated = false
  val mutable stored = false
  method malloc_name = malloc_name
  method size = size
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)]
    
    @ self#value#locals 
@ self#next#locals 


  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )
     
    
  val value = value
  method value = value
  method get_value = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    value#store
    @
    value#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val next = next
  method next = next
  method get_next = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_next = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    next#store
    @
    next#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
            

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc
      @  self#store_value 
@  self#store_next 

    )
    
  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]

end



type color_variant = 
  
| Red
| Black

class  color ~(kind: color_variant) ~(value: dt) = object(self)
  val kind = kind
  val value = value
  
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"color_malloc" ())
  val mutable allocated = false
  val mutable stored = false

  method malloc_name = malloc_name
  method size = 12l
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method kind = kind
  method value = value
  
  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)] 
    @
    value#locals

  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )

  method store_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 4l; at  }; at };
      { it = Binary (I32 Add); at };
    ]
    @
    value#store
    @
    S.[
      { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method store_kind = 
    let kind = match self#kind with 
    
  | Red -> 0l
  | Black -> 1l 
    in
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 kind; at  }; at };
      { it = Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method get_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 4l; at  }; at  };
      { it = Binary (I32 Add); at };
      { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc 
      @ self#store_kind
      @ self#store_value
   
  )

  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]
  
end
          
class  rbnode ~(parent : dt) ~(value : dt) ~(depth : dt) ~(left : dt) ~(right : dt) ~(color : dt)  = object(self)
  val size = 24l
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"rbnode_malloc" ())
  val mutable allocated = false
  val mutable stored = false
  method malloc_name = malloc_name
  method size = size
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)]
    
    @ self#parent#locals 
@ self#value#locals 
@ self#depth#locals 
@ self#left#locals 
@ self#right#locals 
@ self#color#locals 


  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )
     
    
  val parent = parent
  method parent = parent
  method get_parent = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_parent = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    parent#store
    @
    parent#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val value = value
  method value = value
  method get_value = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    value#store
    @
    value#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val depth = depth
  method depth = depth
  method get_depth = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 8l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_depth = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 8l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    depth#store
    @
    depth#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val left = left
  method left = left
  method get_left = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 12l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_left = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 12l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    left#store
    @
    left#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val right = right
  method right = right
  method get_right = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 16l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_right = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 16l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    right#store
    @
    right#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val color = color
  method color = color
  method get_color = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 20l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_color = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 20l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    color#store
    @
    color#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
            

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc
      @  self#store_parent 
@  self#store_value 
@  self#store_depth 
@  self#store_left 
@  self#store_right 
@  self#store_color 

    )
    
  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]

end


class  transaction ~(action : dt) ~(amount : dt) ~(contract : dt)  = object(self)
  val size = 12l
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"transaction_malloc" ())
  val mutable allocated = false
  val mutable stored = false
  method malloc_name = malloc_name
  method size = size
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)]
    
    @ self#action#locals 
@ self#amount#locals 
@ self#contract#locals 


  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )
     
    
  val action = action
  method action = action
  method get_action = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_action = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    action#store
    @
    action#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val amount = amount
  method amount = amount
  method get_amount = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_amount = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    amount#store
    @
    amount#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val contract = contract
  method contract = contract
  method get_contract = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 8l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_contract = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 8l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    contract#store
    @
    contract#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
            

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc
      @  self#store_action 
@  self#store_amount 
@  self#store_contract 

    )
    
  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]

end


class  delegate ~(delegate : dt)  = object(self)
  val size = 4l
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"delegate_malloc" ())
  val mutable allocated = false
  val mutable stored = false
  method malloc_name = malloc_name
  method size = size
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)]
    
    @ self#delegate#locals 


  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )
     
    
  val delegate = delegate
  method delegate = delegate
  method get_delegate = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_delegate = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    delegate#store
    @
    delegate#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
            

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc
      @  self#store_delegate 

    )
    
  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]

end


class ['T] wrapped ~(data : 'T)  = object(self)
  val size = 4l
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"wrapped_malloc" ())
  val mutable allocated = false
  val mutable stored = false
  method malloc_name = malloc_name
  method size = size
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)]
    
    @ self#data#locals 


  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )
     
    
  val data = data
  method data = data
  method get_data = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_data = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    data#store
    @
    data#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
            

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc
      @  self#store_data 

    )
    
  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]

end



type option_variant = 
  
| None
| Some

class ['T] option ~(kind: option_variant) ~(value: 'T) = object(self)
  val kind = kind
  val value = value
  
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"option_malloc" ())
  val mutable allocated = false
  val mutable stored = false

  method malloc_name = malloc_name
  method size = 12l
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method kind = kind
  method value = value
  
  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)] 
    @
    value#locals

  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )

  method store_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 4l; at  }; at };
      { it = Binary (I32 Add); at };
    ]
    @
    value#store
    @
    S.[
      { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method store_kind = 
    let kind = match self#kind with 
    
  | None -> 0l
  | Some -> 1l 
    in
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 kind; at  }; at };
      { it = Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method get_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 4l; at  }; at  };
      { it = Binary (I32 Add); at };
      { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc 
      @ self#store_kind
      @ self#store_value
   
  )

  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]
  
end
          
class  bigintwrap ~(data : dt) ~(len : dt) ~(capacity : dt)  = object(self)
  val size = 12l
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"bigintwrap_malloc" ())
  val mutable allocated = false
  val mutable stored = false
  method malloc_name = malloc_name
  method size = size
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)]
    
    @ self#data#locals 
@ self#len#locals 
@ self#capacity#locals 


  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )
     
    
  val data = data
  method data = data
  method get_data = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_data = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    data#store
    @
    data#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val len = len
  method len = len
  method get_len = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_len = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    len#store
    @
    len#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val capacity = capacity
  method capacity = capacity
  method get_capacity = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 8l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_capacity = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 8l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    capacity#store
    @
    capacity#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
            

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc
      @  self#store_data 
@  self#store_len 
@  self#store_capacity 

    )
    
  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]

end



type datatype_variant = 
  
| Int
| Nat
| Mutez
| Timestamp
| Bool
| ListItem
| Tuple
| Set
| Map
| Operations
| String

class  datatype ~(kind: datatype_variant) ~(value: dt) = object(self)
  val kind = kind
  val value = value
  
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"datatype_malloc" ())
  val mutable allocated = false
  val mutable stored = false

  method malloc_name = malloc_name
  method size = 12l
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method kind = kind
  method value = value
  
  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)] 
    @
    value#locals

  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )

  method store_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 4l; at  }; at };
      { it = Binary (I32 Add); at };
    ]
    @
    value#store
    @
    S.[
      { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method store_kind = 
    let kind = match self#kind with 
    
  | Int -> 0l
  | Nat -> 1l
  | Mutez -> 2l
  | Timestamp -> 3l
  | Bool -> 4l
  | ListItem -> 5l
  | Tuple -> 6l
  | Set -> 7l
  | Map -> 8l
  | Operations -> 9l
  | String -> 10l 
    in
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 kind; at  }; at };
      { it = Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method get_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 4l; at  }; at  };
      { it = Binary (I32 Add); at };
      { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc 
      @ self#store_kind
      @ self#store_value
   
  )

  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]
  
end
          
class  node ~(value : dt) ~(next : dt)  = object(self)
  val size = 8l
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"node_malloc" ())
  val mutable allocated = false
  val mutable stored = false
  method malloc_name = malloc_name
  method size = size
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)]
    
    @ self#value#locals 
@ self#next#locals 


  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )
     
    
  val value = value
  method value = value
  method get_value = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    value#store
    @
    value#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val next = next
  method next = next
  method get_next = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_next = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    next#store
    @
    next#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
            

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc
      @  self#store_value 
@  self#store_next 

    )
    
  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]

end



type operation_variant = 
  
| Transaction
| Delegate

class  operation ~(kind: operation_variant) ~(value: dt) = object(self)
  val kind = kind
  val value = value
  
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"operation_malloc" ())
  val mutable allocated = false
  val mutable stored = false

  method malloc_name = malloc_name
  method size = 12l
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method kind = kind
  method value = value
  
  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)] 
    @
    value#locals

  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )

  method store_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 4l; at  }; at };
      { it = Binary (I32 Add); at };
    ]
    @
    value#store
    @
    S.[
      { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method store_kind = 
    let kind = match self#kind with 
    
  | Transaction -> 0l
  | Delegate -> 1l 
    in
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 kind; at  }; at };
      { it = Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method get_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 4l; at  }; at  };
      { it = Binary (I32 Add); at };
      { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc 
      @ self#store_kind
      @ self#store_value
   
  )

  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]
  
end
          
class  operationnode ~(value : dt) ~(next : dt)  = object(self)
  val size = 8l
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"operationnode_malloc" ())
  val mutable allocated = false
  val mutable stored = false
  method malloc_name = malloc_name
  method size = size
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)]
    
    @ self#value#locals 
@ self#next#locals 


  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )
     
    
  val value = value
  method value = value
  method get_value = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    value#store
    @
    value#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val next = next
  method next = next
  method get_next = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_next = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    next#store
    @
    next#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
            

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc
      @  self#store_value 
@  self#store_next 

    )
    
  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]

end



type color_variant = 
  
| Red
| Black

class  color ~(kind: color_variant) ~(value: dt) = object(self)
  val kind = kind
  val value = value
  
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"color_malloc" ())
  val mutable allocated = false
  val mutable stored = false

  method malloc_name = malloc_name
  method size = 12l
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method kind = kind
  method value = value
  
  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)] 
    @
    value#locals

  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )

  method store_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 4l; at  }; at };
      { it = Binary (I32 Add); at };
    ]
    @
    value#store
    @
    S.[
      { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method store_kind = 
    let kind = match self#kind with 
    
  | Red -> 0l
  | Black -> 1l 
    in
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 kind; at  }; at };
      { it = Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method get_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 4l; at  }; at  };
      { it = Binary (I32 Add); at };
      { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc 
      @ self#store_kind
      @ self#store_value
   
  )

  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]
  
end
          
class  rbnode ~(parent : dt) ~(value : dt) ~(depth : dt) ~(left : dt) ~(right : dt) ~(color : dt)  = object(self)
  val size = 24l
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"rbnode_malloc" ())
  val mutable allocated = false
  val mutable stored = false
  method malloc_name = malloc_name
  method size = size
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)]
    
    @ self#parent#locals 
@ self#value#locals 
@ self#depth#locals 
@ self#left#locals 
@ self#right#locals 
@ self#color#locals 


  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )
     
    
  val parent = parent
  method parent = parent
  method get_parent = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_parent = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    parent#store
    @
    parent#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val value = value
  method value = value
  method get_value = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    value#store
    @
    value#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val depth = depth
  method depth = depth
  method get_depth = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 8l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_depth = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 8l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    depth#store
    @
    depth#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val left = left
  method left = left
  method get_left = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 12l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_left = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 12l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    left#store
    @
    left#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val right = right
  method right = right
  method get_right = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 16l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_right = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 16l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    right#store
    @
    right#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val color = color
  method color = color
  method get_color = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 20l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_color = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 20l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    color#store
    @
    color#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
            

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc
      @  self#store_parent 
@  self#store_value 
@  self#store_depth 
@  self#store_left 
@  self#store_right 
@  self#store_color 

    )
    
  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]

end


class  transaction ~(action : dt) ~(amount : dt) ~(contract : dt)  = object(self)
  val size = 12l
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"transaction_malloc" ())
  val mutable allocated = false
  val mutable stored = false
  method malloc_name = malloc_name
  method size = size
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)]
    
    @ self#action#locals 
@ self#amount#locals 
@ self#contract#locals 


  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )
     
    
  val action = action
  method action = action
  method get_action = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_action = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    action#store
    @
    action#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val amount = amount
  method amount = amount
  method get_amount = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_amount = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    amount#store
    @
    amount#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val contract = contract
  method contract = contract
  method get_contract = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 8l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_contract = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 8l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    contract#store
    @
    contract#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
            

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc
      @  self#store_action 
@  self#store_amount 
@  self#store_contract 

    )
    
  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]

end


class  delegate ~(delegate : dt)  = object(self)
  val size = 4l
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"delegate_malloc" ())
  val mutable allocated = false
  val mutable stored = false
  method malloc_name = malloc_name
  method size = size
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)]
    
    @ self#delegate#locals 


  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )
     
    
  val delegate = delegate
  method delegate = delegate
  method get_delegate = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_delegate = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    delegate#store
    @
    delegate#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
            

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc
      @  self#store_delegate 

    )
    
  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]

end


class ['T] wrapped ~(data : 'T)  = object(self)
  val size = 4l
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"wrapped_malloc" ())
  val mutable allocated = false
  val mutable stored = false
  method malloc_name = malloc_name
  method size = size
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)]
    
    @ self#data#locals 


  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )
     
    
  val data = data
  method data = data
  method get_data = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_data = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    data#store
    @
    data#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
            

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc
      @  self#store_data 

    )
    
  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]

end



type option_variant = 
  
| None
| Some

class ['T] option ~(kind: option_variant) ~(value: 'T) = object(self)
  val kind = kind
  val value = value
  
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"option_malloc" ())
  val mutable allocated = false
  val mutable stored = false

  method malloc_name = malloc_name
  method size = 12l
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method kind = kind
  method value = value
  
  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)] 
    @
    value#locals

  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )

  method store_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 4l; at  }; at };
      { it = Binary (I32 Add); at };
    ]
    @
    value#store
    @
    S.[
      { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method store_kind = 
    let kind = match self#kind with 
    
  | None -> 0l
  | Some -> 1l 
    in
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 kind; at  }; at };
      { it = Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method get_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 4l; at  }; at  };
      { it = Binary (I32 Add); at };
      { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc 
      @ self#store_kind
      @ self#store_value
   
  )

  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]
  
end
          
class  bigintwrap ~(data : dt) ~(len : dt) ~(capacity : dt)  = object(self)
  val size = 12l
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"bigintwrap_malloc" ())
  val mutable allocated = false
  val mutable stored = false
  method malloc_name = malloc_name
  method size = size
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)]
    
    @ self#data#locals 
@ self#len#locals 
@ self#capacity#locals 


  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )
     
    
  val data = data
  method data = data
  method get_data = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_data = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    data#store
    @
    data#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val len = len
  method len = len
  method get_len = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_len = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    len#store
    @
    len#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val capacity = capacity
  method capacity = capacity
  method get_capacity = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 8l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_capacity = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 8l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    capacity#store
    @
    capacity#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
            

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc
      @  self#store_data 
@  self#store_len 
@  self#store_capacity 

    )
    
  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]

end



type datatype_variant = 
  
| Int
| Nat
| Mutez
| Timestamp
| Bool
| ListItem
| Tuple
| Set
| Map
| Operations
| String

class  datatype ~(kind: datatype_variant) ~(value: dt) = object(self)
  val kind = kind
  val value = value
  
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"datatype_malloc" ())
  val mutable allocated = false
  val mutable stored = false

  method malloc_name = malloc_name
  method size = 12l
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method kind = kind
  method value = value
  
  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)] 
    @
    value#locals

  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )

  method store_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 4l; at  }; at };
      { it = Binary (I32 Add); at };
    ]
    @
    value#store
    @
    S.[
      { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method store_kind = 
    let kind = match self#kind with 
    
  | Int -> 0l
  | Nat -> 1l
  | Mutez -> 2l
  | Timestamp -> 3l
  | Bool -> 4l
  | ListItem -> 5l
  | Tuple -> 6l
  | Set -> 7l
  | Map -> 8l
  | Operations -> 9l
  | String -> 10l 
    in
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 kind; at  }; at };
      { it = Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method get_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 4l; at  }; at  };
      { it = Binary (I32 Add); at };
      { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc 
      @ self#store_kind
      @ self#store_value
   
  )

  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]
  
end
          
class  node ~(value : dt) ~(next : dt)  = object(self)
  val size = 8l
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"node_malloc" ())
  val mutable allocated = false
  val mutable stored = false
  method malloc_name = malloc_name
  method size = size
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)]
    
    @ self#value#locals 
@ self#next#locals 


  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )
     
    
  val value = value
  method value = value
  method get_value = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    value#store
    @
    value#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val next = next
  method next = next
  method get_next = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_next = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    next#store
    @
    next#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
            

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc
      @  self#store_value 
@  self#store_next 

    )
    
  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]

end



type operation_variant = 
  
| Transaction
| Delegate

class  operation ~(kind: operation_variant) ~(value: dt) = object(self)
  val kind = kind
  val value = value
  
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"operation_malloc" ())
  val mutable allocated = false
  val mutable stored = false

  method malloc_name = malloc_name
  method size = 12l
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method kind = kind
  method value = value
  
  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)] 
    @
    value#locals

  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )

  method store_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 4l; at  }; at };
      { it = Binary (I32 Add); at };
    ]
    @
    value#store
    @
    S.[
      { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method store_kind = 
    let kind = match self#kind with 
    
  | Transaction -> 0l
  | Delegate -> 1l 
    in
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 kind; at  }; at };
      { it = Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method get_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 4l; at  }; at  };
      { it = Binary (I32 Add); at };
      { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc 
      @ self#store_kind
      @ self#store_value
   
  )

  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]
  
end
          
class  operationnode ~(value : dt) ~(next : dt)  = object(self)
  val size = 8l
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"operationnode_malloc" ())
  val mutable allocated = false
  val mutable stored = false
  method malloc_name = malloc_name
  method size = size
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)]
    
    @ self#value#locals 
@ self#next#locals 


  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )
     
    
  val value = value
  method value = value
  method get_value = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    value#store
    @
    value#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val next = next
  method next = next
  method get_next = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_next = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    next#store
    @
    next#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
            

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc
      @  self#store_value 
@  self#store_next 

    )
    
  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]

end



type color_variant = 
  
| Red
| Black

class  color ~(kind: color_variant) ~(value: dt) = object(self)
  val kind = kind
  val value = value
  
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"color_malloc" ())
  val mutable allocated = false
  val mutable stored = false

  method malloc_name = malloc_name
  method size = 12l
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method kind = kind
  method value = value
  
  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)] 
    @
    value#locals

  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )

  method store_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 4l; at  }; at };
      { it = Binary (I32 Add); at };
    ]
    @
    value#store
    @
    S.[
      { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method store_kind = 
    let kind = match self#kind with 
    
  | Red -> 0l
  | Black -> 1l 
    in
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 kind; at  }; at };
      { it = Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method get_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 4l; at  }; at  };
      { it = Binary (I32 Add); at };
      { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc 
      @ self#store_kind
      @ self#store_value
   
  )

  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]
  
end
          
class  rbnode ~(parent : dt) ~(value : dt) ~(depth : dt) ~(left : dt) ~(right : dt) ~(color : dt)  = object(self)
  val size = 24l
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"rbnode_malloc" ())
  val mutable allocated = false
  val mutable stored = false
  method malloc_name = malloc_name
  method size = size
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)]
    
    @ self#parent#locals 
@ self#value#locals 
@ self#depth#locals 
@ self#left#locals 
@ self#right#locals 
@ self#color#locals 


  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )
     
    
  val parent = parent
  method parent = parent
  method get_parent = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_parent = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    parent#store
    @
    parent#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val value = value
  method value = value
  method get_value = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    value#store
    @
    value#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val depth = depth
  method depth = depth
  method get_depth = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 8l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_depth = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 8l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    depth#store
    @
    depth#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val left = left
  method left = left
  method get_left = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 12l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_left = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 12l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    left#store
    @
    left#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val right = right
  method right = right
  method get_right = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 16l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_right = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 16l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    right#store
    @
    right#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val color = color
  method color = color
  method get_color = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 20l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_color = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 20l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    color#store
    @
    color#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
            

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc
      @  self#store_parent 
@  self#store_value 
@  self#store_depth 
@  self#store_left 
@  self#store_right 
@  self#store_color 

    )
    
  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]

end


class  transaction ~(action : dt) ~(amount : dt) ~(contract : dt)  = object(self)
  val size = 12l
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"transaction_malloc" ())
  val mutable allocated = false
  val mutable stored = false
  method malloc_name = malloc_name
  method size = size
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)]
    
    @ self#action#locals 
@ self#amount#locals 
@ self#contract#locals 


  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )
     
    
  val action = action
  method action = action
  method get_action = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_action = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    action#store
    @
    action#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val amount = amount
  method amount = amount
  method get_amount = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_amount = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    amount#store
    @
    amount#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val contract = contract
  method contract = contract
  method get_contract = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 8l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_contract = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 8l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    contract#store
    @
    contract#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
            

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc
      @  self#store_action 
@  self#store_amount 
@  self#store_contract 

    )
    
  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]

end


class  delegate ~(delegate : dt)  = object(self)
  val size = 4l
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"delegate_malloc" ())
  val mutable allocated = false
  val mutable stored = false
  method malloc_name = malloc_name
  method size = size
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)]
    
    @ self#delegate#locals 


  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )
     
    
  val delegate = delegate
  method delegate = delegate
  method get_delegate = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_delegate = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    delegate#store
    @
    delegate#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
            

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc
      @  self#store_delegate 

    )
    
  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]

end


class ['T] wrapped ~(data : 'T)  = object(self)
  val size = 4l
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"wrapped_malloc" ())
  val mutable allocated = false
  val mutable stored = false
  method malloc_name = malloc_name
  method size = size
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)]
    
    @ self#data#locals 


  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )
     
    
  val data = data
  method data = data
  method get_data = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_data = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    data#store
    @
    data#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
            

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc
      @  self#store_data 

    )
    
  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]

end



type option_variant = 
  
| None
| Some

class ['T] option ~(kind: option_variant) ~(value: 'T) = object(self)
  val kind = kind
  val value = value
  
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"option_malloc" ())
  val mutable allocated = false
  val mutable stored = false

  method malloc_name = malloc_name
  method size = 12l
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method kind = kind
  method value = value
  
  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)] 
    @
    value#locals

  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )

  method store_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 4l; at  }; at };
      { it = Binary (I32 Add); at };
    ]
    @
    value#store
    @
    S.[
      { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method store_kind = 
    let kind = match self#kind with 
    
  | None -> 0l
  | Some -> 1l 
    in
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 kind; at  }; at };
      { it = Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method get_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 4l; at  }; at  };
      { it = Binary (I32 Add); at };
      { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc 
      @ self#store_kind
      @ self#store_value
   
  )

  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]
  
end
          
class  bigintwrap ~(data : dt) ~(len : dt) ~(capacity : dt)  = object(self)
  val size = 12l
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"bigintwrap_malloc" ())
  val mutable allocated = false
  val mutable stored = false
  method malloc_name = malloc_name
  method size = size
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)]
    
    @ self#data#locals 
@ self#len#locals 
@ self#capacity#locals 


  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )
     
    
  val data = data
  method data = data
  method get_data = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_data = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    data#store
    @
    data#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val len = len
  method len = len
  method get_len = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_len = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    len#store
    @
    len#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val capacity = capacity
  method capacity = capacity
  method get_capacity = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 8l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_capacity = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 8l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    capacity#store
    @
    capacity#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
            

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc
      @  self#store_data 
@  self#store_len 
@  self#store_capacity 

    )
    
  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]

end



type datatype_variant = 
  
| Int
| Nat
| Mutez
| Timestamp
| Bool
| ListItem
| Tuple
| Set
| Map
| Operations
| String

class  datatype ~(kind: datatype_variant) ~(value: dt) = object(self)
  val kind = kind
  val value = value
  
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"datatype_malloc" ())
  val mutable allocated = false
  val mutable stored = false

  method malloc_name = malloc_name
  method size = 12l
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method kind = kind
  method value = value
  
  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)] 
    @
    value#locals

  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )

  method store_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 4l; at  }; at };
      { it = Binary (I32 Add); at };
    ]
    @
    value#store
    @
    S.[
      { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method store_kind = 
    let kind = match self#kind with 
    
  | Int -> 0l
  | Nat -> 1l
  | Mutez -> 2l
  | Timestamp -> 3l
  | Bool -> 4l
  | ListItem -> 5l
  | Tuple -> 6l
  | Set -> 7l
  | Map -> 8l
  | Operations -> 9l
  | String -> 10l 
    in
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 kind; at  }; at };
      { it = Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method get_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 4l; at  }; at  };
      { it = Binary (I32 Add); at };
      { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc 
      @ self#store_kind
      @ self#store_value
   
  )

  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]
  
end
          
class  node ~(value : dt) ~(next : dt)  = object(self)
  val size = 8l
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"node_malloc" ())
  val mutable allocated = false
  val mutable stored = false
  method malloc_name = malloc_name
  method size = size
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)]
    
    @ self#value#locals 
@ self#next#locals 


  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )
     
    
  val value = value
  method value = value
  method get_value = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    value#store
    @
    value#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val next = next
  method next = next
  method get_next = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_next = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    next#store
    @
    next#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
            

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc
      @  self#store_value 
@  self#store_next 

    )
    
  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]

end



type operation_variant = 
  
| Transaction
| Delegate

class  operation ~(kind: operation_variant) ~(value: dt) = object(self)
  val kind = kind
  val value = value
  
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"operation_malloc" ())
  val mutable allocated = false
  val mutable stored = false

  method malloc_name = malloc_name
  method size = 12l
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method kind = kind
  method value = value
  
  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)] 
    @
    value#locals

  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )

  method store_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 4l; at  }; at };
      { it = Binary (I32 Add); at };
    ]
    @
    value#store
    @
    S.[
      { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method store_kind = 
    let kind = match self#kind with 
    
  | Transaction -> 0l
  | Delegate -> 1l 
    in
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 kind; at  }; at };
      { it = Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method get_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 4l; at  }; at  };
      { it = Binary (I32 Add); at };
      { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc 
      @ self#store_kind
      @ self#store_value
   
  )

  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]
  
end
          
class  operationnode ~(value : dt) ~(next : dt)  = object(self)
  val size = 8l
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"operationnode_malloc" ())
  val mutable allocated = false
  val mutable stored = false
  method malloc_name = malloc_name
  method size = size
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)]
    
    @ self#value#locals 
@ self#next#locals 


  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )
     
    
  val value = value
  method value = value
  method get_value = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    value#store
    @
    value#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val next = next
  method next = next
  method get_next = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_next = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    next#store
    @
    next#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
            

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc
      @  self#store_value 
@  self#store_next 

    )
    
  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]

end



type color_variant = 
  
| Red
| Black

class  color ~(kind: color_variant) ~(value: dt) = object(self)
  val kind = kind
  val value = value
  
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"color_malloc" ())
  val mutable allocated = false
  val mutable stored = false

  method malloc_name = malloc_name
  method size = 12l
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method kind = kind
  method value = value
  
  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)] 
    @
    value#locals

  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )

  method store_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 4l; at  }; at };
      { it = Binary (I32 Add); at };
    ]
    @
    value#store
    @
    S.[
      { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method store_kind = 
    let kind = match self#kind with 
    
  | Red -> 0l
  | Black -> 1l 
    in
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 kind; at  }; at };
      { it = Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method get_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 4l; at  }; at  };
      { it = Binary (I32 Add); at };
      { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc 
      @ self#store_kind
      @ self#store_value
   
  )

  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]
  
end
          
class  rbnode ~(parent : dt) ~(value : dt) ~(depth : dt) ~(left : dt) ~(right : dt) ~(color : dt)  = object(self)
  val size = 24l
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"rbnode_malloc" ())
  val mutable allocated = false
  val mutable stored = false
  method malloc_name = malloc_name
  method size = size
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)]
    
    @ self#parent#locals 
@ self#value#locals 
@ self#depth#locals 
@ self#left#locals 
@ self#right#locals 
@ self#color#locals 


  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )
     
    
  val parent = parent
  method parent = parent
  method get_parent = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_parent = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    parent#store
    @
    parent#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val value = value
  method value = value
  method get_value = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    value#store
    @
    value#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val depth = depth
  method depth = depth
  method get_depth = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 8l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_depth = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 8l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    depth#store
    @
    depth#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val left = left
  method left = left
  method get_left = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 12l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_left = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 12l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    left#store
    @
    left#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val right = right
  method right = right
  method get_right = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 16l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_right = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 16l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    right#store
    @
    right#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val color = color
  method color = color
  method get_color = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 20l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_color = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 20l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    color#store
    @
    color#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
            

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc
      @  self#store_parent 
@  self#store_value 
@  self#store_depth 
@  self#store_left 
@  self#store_right 
@  self#store_color 

    )
    
  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]

end


class  transaction ~(action : dt) ~(amount : dt) ~(contract : dt)  = object(self)
  val size = 12l
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"transaction_malloc" ())
  val mutable allocated = false
  val mutable stored = false
  method malloc_name = malloc_name
  method size = size
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)]
    
    @ self#action#locals 
@ self#amount#locals 
@ self#contract#locals 


  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )
     
    
  val action = action
  method action = action
  method get_action = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_action = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    action#store
    @
    action#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val amount = amount
  method amount = amount
  method get_amount = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_amount = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    amount#store
    @
    amount#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val contract = contract
  method contract = contract
  method get_contract = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 8l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_contract = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 8l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    contract#store
    @
    contract#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
            

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc
      @  self#store_action 
@  self#store_amount 
@  self#store_contract 

    )
    
  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]

end


class  delegate ~(delegate : dt)  = object(self)
  val size = 4l
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"delegate_malloc" ())
  val mutable allocated = false
  val mutable stored = false
  method malloc_name = malloc_name
  method size = size
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)]
    
    @ self#delegate#locals 


  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )
     
    
  val delegate = delegate
  method delegate = delegate
  method get_delegate = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_delegate = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    delegate#store
    @
    delegate#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
            

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc
      @  self#store_delegate 

    )
    
  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]

end


class ['T] wrapped ~(data : 'T)  = object(self)
  val size = 4l
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"wrapped_malloc" ())
  val mutable allocated = false
  val mutable stored = false
  method malloc_name = malloc_name
  method size = size
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)]
    
    @ self#data#locals 


  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )
     
    
  val data = data
  method data = data
  method get_data = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_data = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    data#store
    @
    data#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
            

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc
      @  self#store_data 

    )
    
  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]

end



type option_variant = 
  
| None
| Some

class ['T] option ~(kind: option_variant) ~(value: 'T) = object(self)
  val kind = kind
  val value = value
  
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"option_malloc" ())
  val mutable allocated = false
  val mutable stored = false

  method malloc_name = malloc_name
  method size = 12l
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method kind = kind
  method value = value
  
  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)] 
    @
    value#locals

  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )

  method store_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 4l; at  }; at };
      { it = Binary (I32 Add); at };
    ]
    @
    value#store
    @
    S.[
      { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method store_kind = 
    let kind = match self#kind with 
    
  | None -> 0l
  | Some -> 1l 
    in
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 kind; at  }; at };
      { it = Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method get_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 4l; at  }; at  };
      { it = Binary (I32 Add); at };
      { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc 
      @ self#store_kind
      @ self#store_value
   
  )

  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]
  
end
          
class  bigintwrap ~(data : dt) ~(len : dt) ~(capacity : dt)  = object(self)
  val size = 12l
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"bigintwrap_malloc" ())
  val mutable allocated = false
  val mutable stored = false
  method malloc_name = malloc_name
  method size = size
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)]
    
    @ self#data#locals 
@ self#len#locals 
@ self#capacity#locals 


  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )
     
    
  val data = data
  method data = data
  method get_data = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_data = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    data#store
    @
    data#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val len = len
  method len = len
  method get_len = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_len = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    len#store
    @
    len#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val capacity = capacity
  method capacity = capacity
  method get_capacity = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 8l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_capacity = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 8l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    capacity#store
    @
    capacity#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
            

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc
      @  self#store_data 
@  self#store_len 
@  self#store_capacity 

    )
    
  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]

end



type datatype_variant = 
  
| Int
| Nat
| Mutez
| Timestamp
| Bool
| ListItem
| Tuple
| Set
| Map
| Operations
| String

class  datatype ~(kind: datatype_variant) ~(value: dt) = object(self)
  val kind = kind
  val value = value
  
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"datatype_malloc" ())
  val mutable allocated = false
  val mutable stored = false

  method malloc_name = malloc_name
  method size = 12l
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method kind = kind
  method value = value
  
  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)] 
    @
    value#locals

  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )

  method store_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 4l; at  }; at };
      { it = Binary (I32 Add); at };
    ]
    @
    value#store
    @
    S.[
      { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method store_kind = 
    let kind = match self#kind with 
    
  | Int -> 0l
  | Nat -> 1l
  | Mutez -> 2l
  | Timestamp -> 3l
  | Bool -> 4l
  | ListItem -> 5l
  | Tuple -> 6l
  | Set -> 7l
  | Map -> 8l
  | Operations -> 9l
  | String -> 10l 
    in
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 kind; at  }; at };
      { it = Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method get_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 4l; at  }; at  };
      { it = Binary (I32 Add); at };
      { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc 
      @ self#store_kind
      @ self#store_value
   
  )

  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]
  
end
          
class  node ~(value : dt) ~(next : dt)  = object(self)
  val size = 8l
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"node_malloc" ())
  val mutable allocated = false
  val mutable stored = false
  method malloc_name = malloc_name
  method size = size
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)]
    
    @ self#value#locals 
@ self#next#locals 


  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )
     
    
  val value = value
  method value = value
  method get_value = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    value#store
    @
    value#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val next = next
  method next = next
  method get_next = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_next = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    next#store
    @
    next#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
            

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc
      @  self#store_value 
@  self#store_next 

    )
    
  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]

end



type operation_variant = 
  
| Transaction
| Delegate

class  operation ~(kind: operation_variant) ~(value: dt) = object(self)
  val kind = kind
  val value = value
  
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"operation_malloc" ())
  val mutable allocated = false
  val mutable stored = false

  method malloc_name = malloc_name
  method size = 12l
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method kind = kind
  method value = value
  
  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)] 
    @
    value#locals

  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )

  method store_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 4l; at  }; at };
      { it = Binary (I32 Add); at };
    ]
    @
    value#store
    @
    S.[
      { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method store_kind = 
    let kind = match self#kind with 
    
  | Transaction -> 0l
  | Delegate -> 1l 
    in
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 kind; at  }; at };
      { it = Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method get_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 4l; at  }; at  };
      { it = Binary (I32 Add); at };
      { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc 
      @ self#store_kind
      @ self#store_value
   
  )

  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]
  
end
          
class  operationnode ~(value : dt) ~(next : dt)  = object(self)
  val size = 8l
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"operationnode_malloc" ())
  val mutable allocated = false
  val mutable stored = false
  method malloc_name = malloc_name
  method size = size
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)]
    
    @ self#value#locals 
@ self#next#locals 


  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )
     
    
  val value = value
  method value = value
  method get_value = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    value#store
    @
    value#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val next = next
  method next = next
  method get_next = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_next = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    next#store
    @
    next#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
            

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc
      @  self#store_value 
@  self#store_next 

    )
    
  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]

end



type color_variant = 
  
| Red
| Black

class  color ~(kind: color_variant) ~(value: dt) = object(self)
  val kind = kind
  val value = value
  
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"color_malloc" ())
  val mutable allocated = false
  val mutable stored = false

  method malloc_name = malloc_name
  method size = 12l
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method kind = kind
  method value = value
  
  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)] 
    @
    value#locals

  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )

  method store_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 4l; at  }; at };
      { it = Binary (I32 Add); at };
    ]
    @
    value#store
    @
    S.[
      { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method store_kind = 
    let kind = match self#kind with 
    
  | Red -> 0l
  | Black -> 1l 
    in
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 kind; at  }; at };
      { it = Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method get_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 4l; at  }; at  };
      { it = Binary (I32 Add); at };
      { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc 
      @ self#store_kind
      @ self#store_value
   
  )

  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]
  
end
          
class  rbnode ~(parent : dt) ~(value : dt) ~(depth : dt) ~(left : dt) ~(right : dt) ~(color : dt)  = object(self)
  val size = 24l
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"rbnode_malloc" ())
  val mutable allocated = false
  val mutable stored = false
  method malloc_name = malloc_name
  method size = size
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)]
    
    @ self#parent#locals 
@ self#value#locals 
@ self#depth#locals 
@ self#left#locals 
@ self#right#locals 
@ self#color#locals 


  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )
     
    
  val parent = parent
  method parent = parent
  method get_parent = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_parent = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    parent#store
    @
    parent#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val value = value
  method value = value
  method get_value = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    value#store
    @
    value#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val depth = depth
  method depth = depth
  method get_depth = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 8l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_depth = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 8l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    depth#store
    @
    depth#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val left = left
  method left = left
  method get_left = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 12l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_left = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 12l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    left#store
    @
    left#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val right = right
  method right = right
  method get_right = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 16l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_right = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 16l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    right#store
    @
    right#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val color = color
  method color = color
  method get_color = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 20l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_color = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 20l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    color#store
    @
    color#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
            

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc
      @  self#store_parent 
@  self#store_value 
@  self#store_depth 
@  self#store_left 
@  self#store_right 
@  self#store_color 

    )
    
  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]

end


class  transaction ~(action : dt) ~(amount : dt) ~(contract : dt)  = object(self)
  val size = 12l
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"transaction_malloc" ())
  val mutable allocated = false
  val mutable stored = false
  method malloc_name = malloc_name
  method size = size
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)]
    
    @ self#action#locals 
@ self#amount#locals 
@ self#contract#locals 


  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )
     
    
  val action = action
  method action = action
  method get_action = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_action = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    action#store
    @
    action#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val amount = amount
  method amount = amount
  method get_amount = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_amount = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    amount#store
    @
    amount#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val contract = contract
  method contract = contract
  method get_contract = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 8l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_contract = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 8l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    contract#store
    @
    contract#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
            

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc
      @  self#store_action 
@  self#store_amount 
@  self#store_contract 

    )
    
  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]

end


class  delegate ~(delegate : dt)  = object(self)
  val size = 4l
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"delegate_malloc" ())
  val mutable allocated = false
  val mutable stored = false
  method malloc_name = malloc_name
  method size = size
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)]
    
    @ self#delegate#locals 


  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )
     
    
  val delegate = delegate
  method delegate = delegate
  method get_delegate = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_delegate = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    delegate#store
    @
    delegate#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
            

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc
      @  self#store_delegate 

    )
    
  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]

end


class ['T] wrapped ~(data : 'T)  = object(self)
  val size = 4l
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"wrapped_malloc" ())
  val mutable allocated = false
  val mutable stored = false
  method malloc_name = malloc_name
  method size = size
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)]
    
    @ self#data#locals 


  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )
     
    
  val data = data
  method data = data
  method get_data = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_data = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    data#store
    @
    data#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
            

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc
      @  self#store_data 

    )
    
  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]

end



type option_variant = 
  
| None
| Some

class ['T] option ~(kind: option_variant) ~(value: 'T) = object(self)
  val kind = kind
  val value = value
  
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"option_malloc" ())
  val mutable allocated = false
  val mutable stored = false

  method malloc_name = malloc_name
  method size = 12l
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method kind = kind
  method value = value
  
  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)] 
    @
    value#locals

  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )

  method store_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 4l; at  }; at };
      { it = Binary (I32 Add); at };
    ]
    @
    value#store
    @
    S.[
      { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method store_kind = 
    let kind = match self#kind with 
    
  | None -> 0l
  | Some -> 1l 
    in
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 kind; at  }; at };
      { it = Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method get_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 4l; at  }; at  };
      { it = Binary (I32 Add); at };
      { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc 
      @ self#store_kind
      @ self#store_value
   
  )

  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]
  
end
          
class  bigintwrap ~(data : dt) ~(len : dt) ~(capacity : dt)  = object(self)
  val size = 12l
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"bigintwrap_malloc" ())
  val mutable allocated = false
  val mutable stored = false
  method malloc_name = malloc_name
  method size = size
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)]
    
    @ self#data#locals 
@ self#len#locals 
@ self#capacity#locals 


  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )
     
    
  val data = data
  method data = data
  method get_data = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_data = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    data#store
    @
    data#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val len = len
  method len = len
  method get_len = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_len = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    len#store
    @
    len#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val capacity = capacity
  method capacity = capacity
  method get_capacity = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 8l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_capacity = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 8l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    capacity#store
    @
    capacity#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
            

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc
      @  self#store_data 
@  self#store_len 
@  self#store_capacity 

    )
    
  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]

end



type datatype_variant = 
  
| Int
| Nat
| Mutez
| Timestamp
| Bool
| ListItem
| Tuple
| Set
| Map
| Operations
| String

class  datatype ~(kind: datatype_variant) ~(value: dt) = object(self)
  val kind = kind
  val value = value
  
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"datatype_malloc" ())
  val mutable allocated = false
  val mutable stored = false

  method malloc_name = malloc_name
  method size = 12l
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method kind = kind
  method value = value
  
  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)] 
    @
    value#locals

  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )

  method store_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 4l; at  }; at };
      { it = Binary (I32 Add); at };
    ]
    @
    value#store
    @
    S.[
      { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method store_kind = 
    let kind = match self#kind with 
    
  | Int -> 0l
  | Nat -> 1l
  | Mutez -> 2l
  | Timestamp -> 3l
  | Bool -> 4l
  | ListItem -> 5l
  | Tuple -> 6l
  | Set -> 7l
  | Map -> 8l
  | Operations -> 9l
  | String -> 10l 
    in
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 kind; at  }; at };
      { it = Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method get_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 4l; at  }; at  };
      { it = Binary (I32 Add); at };
      { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc 
      @ self#store_kind
      @ self#store_value
   
  )

  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]
  
end
          
class  node ~(value : dt) ~(next : dt)  = object(self)
  val size = 8l
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"node_malloc" ())
  val mutable allocated = false
  val mutable stored = false
  method malloc_name = malloc_name
  method size = size
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)]
    
    @ self#value#locals 
@ self#next#locals 


  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )
     
    
  val value = value
  method value = value
  method get_value = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    value#store
    @
    value#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val next = next
  method next = next
  method get_next = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_next = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    next#store
    @
    next#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
            

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc
      @  self#store_value 
@  self#store_next 

    )
    
  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]

end



type operation_variant = 
  
| Transaction
| Delegate

class  operation ~(kind: operation_variant) ~(value: dt) = object(self)
  val kind = kind
  val value = value
  
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"operation_malloc" ())
  val mutable allocated = false
  val mutable stored = false

  method malloc_name = malloc_name
  method size = 12l
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method kind = kind
  method value = value
  
  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)] 
    @
    value#locals

  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )

  method store_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 4l; at  }; at };
      { it = Binary (I32 Add); at };
    ]
    @
    value#store
    @
    S.[
      { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method store_kind = 
    let kind = match self#kind with 
    
  | Transaction -> 0l
  | Delegate -> 1l 
    in
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 kind; at  }; at };
      { it = Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method get_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 4l; at  }; at  };
      { it = Binary (I32 Add); at };
      { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc 
      @ self#store_kind
      @ self#store_value
   
  )

  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]
  
end
          
class  operationnode ~(value : dt) ~(next : dt)  = object(self)
  val size = 8l
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"operationnode_malloc" ())
  val mutable allocated = false
  val mutable stored = false
  method malloc_name = malloc_name
  method size = size
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)]
    
    @ self#value#locals 
@ self#next#locals 


  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )
     
    
  val value = value
  method value = value
  method get_value = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    value#store
    @
    value#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val next = next
  method next = next
  method get_next = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_next = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    next#store
    @
    next#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
            

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc
      @  self#store_value 
@  self#store_next 

    )
    
  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]

end



type color_variant = 
  
| Red
| Black

class  color ~(kind: color_variant) ~(value: dt) = object(self)
  val kind = kind
  val value = value
  
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"color_malloc" ())
  val mutable allocated = false
  val mutable stored = false

  method malloc_name = malloc_name
  method size = 12l
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method kind = kind
  method value = value
  
  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)] 
    @
    value#locals

  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )

  method store_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 4l; at  }; at };
      { it = Binary (I32 Add); at };
    ]
    @
    value#store
    @
    S.[
      { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method store_kind = 
    let kind = match self#kind with 
    
  | Red -> 0l
  | Black -> 1l 
    in
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 kind; at  }; at };
      { it = Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method get_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 4l; at  }; at  };
      { it = Binary (I32 Add); at };
      { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc 
      @ self#store_kind
      @ self#store_value
   
  )

  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]
  
end
          
class  rbnode ~(parent : dt) ~(value : dt) ~(depth : dt) ~(left : dt) ~(right : dt) ~(color : dt)  = object(self)
  val size = 24l
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"rbnode_malloc" ())
  val mutable allocated = false
  val mutable stored = false
  method malloc_name = malloc_name
  method size = size
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)]
    
    @ self#parent#locals 
@ self#value#locals 
@ self#depth#locals 
@ self#left#locals 
@ self#right#locals 
@ self#color#locals 


  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )
     
    
  val parent = parent
  method parent = parent
  method get_parent = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_parent = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    parent#store
    @
    parent#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val value = value
  method value = value
  method get_value = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    value#store
    @
    value#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val depth = depth
  method depth = depth
  method get_depth = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 8l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_depth = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 8l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    depth#store
    @
    depth#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val left = left
  method left = left
  method get_left = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 12l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_left = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 12l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    left#store
    @
    left#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val right = right
  method right = right
  method get_right = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 16l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_right = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 16l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    right#store
    @
    right#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val color = color
  method color = color
  method get_color = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 20l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_color = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 20l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    color#store
    @
    color#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
            

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc
      @  self#store_parent 
@  self#store_value 
@  self#store_depth 
@  self#store_left 
@  self#store_right 
@  self#store_color 

    )
    
  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]

end


class  transaction ~(action : dt) ~(amount : dt) ~(contract : dt)  = object(self)
  val size = 12l
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"transaction_malloc" ())
  val mutable allocated = false
  val mutable stored = false
  method malloc_name = malloc_name
  method size = size
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)]
    
    @ self#action#locals 
@ self#amount#locals 
@ self#contract#locals 


  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )
     
    
  val action = action
  method action = action
  method get_action = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_action = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    action#store
    @
    action#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val amount = amount
  method amount = amount
  method get_amount = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_amount = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    amount#store
    @
    amount#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val contract = contract
  method contract = contract
  method get_contract = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 8l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_contract = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 8l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    contract#store
    @
    contract#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
            

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc
      @  self#store_action 
@  self#store_amount 
@  self#store_contract 

    )
    
  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]

end


class  delegate ~(delegate : dt)  = object(self)
  val size = 4l
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"delegate_malloc" ())
  val mutable allocated = false
  val mutable stored = false
  method malloc_name = malloc_name
  method size = size
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)]
    
    @ self#delegate#locals 


  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )
     
    
  val delegate = delegate
  method delegate = delegate
  method get_delegate = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_delegate = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    delegate#store
    @
    delegate#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
            

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc
      @  self#store_delegate 

    )
    
  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]

end


class ['T] wrapped ~(data : 'T)  = object(self)
  val size = 4l
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"wrapped_malloc" ())
  val mutable allocated = false
  val mutable stored = false
  method malloc_name = malloc_name
  method size = size
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)]
    
    @ self#data#locals 


  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )
     
    
  val data = data
  method data = data
  method get_data = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_data = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    data#store
    @
    data#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
            

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc
      @  self#store_data 

    )
    
  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]

end



type option_variant = 
  
| None
| Some

class ['T] option ~(kind: option_variant) ~(value: 'T) = object(self)
  val kind = kind
  val value = value
  
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"option_malloc" ())
  val mutable allocated = false
  val mutable stored = false

  method malloc_name = malloc_name
  method size = 12l
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method kind = kind
  method value = value
  
  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)] 
    @
    value#locals

  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )

  method store_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 4l; at  }; at };
      { it = Binary (I32 Add); at };
    ]
    @
    value#store
    @
    S.[
      { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method store_kind = 
    let kind = match self#kind with 
    
  | None -> 0l
  | Some -> 1l 
    in
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 kind; at  }; at };
      { it = Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method get_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 4l; at  }; at  };
      { it = Binary (I32 Add); at };
      { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc 
      @ self#store_kind
      @ self#store_value
   
  )

  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]
  
end
          
class  bigintwrap ~(data : dt) ~(len : dt) ~(capacity : dt)  = object(self)
  val size = 12l
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"bigintwrap_malloc" ())
  val mutable allocated = false
  val mutable stored = false
  method malloc_name = malloc_name
  method size = size
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)]
    
    @ self#data#locals 
@ self#len#locals 
@ self#capacity#locals 


  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )
     
    
  val data = data
  method data = data
  method get_data = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_data = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    data#store
    @
    data#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val len = len
  method len = len
  method get_len = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_len = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    len#store
    @
    len#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val capacity = capacity
  method capacity = capacity
  method get_capacity = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 8l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_capacity = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 8l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    capacity#store
    @
    capacity#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
            

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc
      @  self#store_data 
@  self#store_len 
@  self#store_capacity 

    )
    
  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]

end



type datatype_variant = 
  
| Int
| Nat
| Mutez
| Timestamp
| Bool
| ListItem
| Tuple
| Set
| Map
| Operations
| String

class  datatype ~(kind: datatype_variant) ~(value: dt) = object(self)
  val kind = kind
  val value = value
  
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"datatype_malloc" ())
  val mutable allocated = false
  val mutable stored = false

  method malloc_name = malloc_name
  method size = 12l
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method kind = kind
  method value = value
  
  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)] 
    @
    value#locals

  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )

  method store_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 4l; at  }; at };
      { it = Binary (I32 Add); at };
    ]
    @
    value#store
    @
    S.[
      { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method store_kind = 
    let kind = match self#kind with 
    
  | Int -> 0l
  | Nat -> 1l
  | Mutez -> 2l
  | Timestamp -> 3l
  | Bool -> 4l
  | ListItem -> 5l
  | Tuple -> 6l
  | Set -> 7l
  | Map -> 8l
  | Operations -> 9l
  | String -> 10l 
    in
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 kind; at  }; at };
      { it = Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method get_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 4l; at  }; at  };
      { it = Binary (I32 Add); at };
      { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc 
      @ self#store_kind
      @ self#store_value
   
  )

  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]
  
end
          
class  node ~(value : dt) ~(next : dt)  = object(self)
  val size = 8l
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"node_malloc" ())
  val mutable allocated = false
  val mutable stored = false
  method malloc_name = malloc_name
  method size = size
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)]
    
    @ self#value#locals 
@ self#next#locals 


  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )
     
    
  val value = value
  method value = value
  method get_value = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    value#store
    @
    value#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val next = next
  method next = next
  method get_next = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_next = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    next#store
    @
    next#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
            

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc
      @  self#store_value 
@  self#store_next 

    )
    
  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]

end



type operation_variant = 
  
| Transaction
| Delegate

class  operation ~(kind: operation_variant) ~(value: dt) = object(self)
  val kind = kind
  val value = value
  
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"operation_malloc" ())
  val mutable allocated = false
  val mutable stored = false

  method malloc_name = malloc_name
  method size = 12l
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method kind = kind
  method value = value
  
  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)] 
    @
    value#locals

  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )

  method store_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 4l; at  }; at };
      { it = Binary (I32 Add); at };
    ]
    @
    value#store
    @
    S.[
      { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method store_kind = 
    let kind = match self#kind with 
    
  | Transaction -> 0l
  | Delegate -> 1l 
    in
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 kind; at  }; at };
      { it = Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method get_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 4l; at  }; at  };
      { it = Binary (I32 Add); at };
      { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc 
      @ self#store_kind
      @ self#store_value
   
  )

  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]
  
end
          
class  operationnode ~(value : dt) ~(next : dt)  = object(self)
  val size = 8l
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"operationnode_malloc" ())
  val mutable allocated = false
  val mutable stored = false
  method malloc_name = malloc_name
  method size = size
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)]
    
    @ self#value#locals 
@ self#next#locals 


  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )
     
    
  val value = value
  method value = value
  method get_value = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    value#store
    @
    value#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val next = next
  method next = next
  method get_next = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_next = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    next#store
    @
    next#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
            

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc
      @  self#store_value 
@  self#store_next 

    )
    
  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]

end



type color_variant = 
  
| Red
| Black

class  color ~(kind: color_variant) ~(value: dt) = object(self)
  val kind = kind
  val value = value
  
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"color_malloc" ())
  val mutable allocated = false
  val mutable stored = false

  method malloc_name = malloc_name
  method size = 12l
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method kind = kind
  method value = value
  
  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)] 
    @
    value#locals

  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )

  method store_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 4l; at  }; at };
      { it = Binary (I32 Add); at };
    ]
    @
    value#store
    @
    S.[
      { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method store_kind = 
    let kind = match self#kind with 
    
  | Red -> 0l
  | Black -> 1l 
    in
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 kind; at  }; at };
      { it = Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method get_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 4l; at  }; at  };
      { it = Binary (I32 Add); at };
      { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc 
      @ self#store_kind
      @ self#store_value
   
  )

  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]
  
end
          
class  rbnode ~(parent : dt) ~(value : dt) ~(depth : dt) ~(left : dt) ~(right : dt) ~(color : dt)  = object(self)
  val size = 24l
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"rbnode_malloc" ())
  val mutable allocated = false
  val mutable stored = false
  method malloc_name = malloc_name
  method size = size
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)]
    
    @ self#parent#locals 
@ self#value#locals 
@ self#depth#locals 
@ self#left#locals 
@ self#right#locals 
@ self#color#locals 


  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )
     
    
  val parent = parent
  method parent = parent
  method get_parent = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_parent = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    parent#store
    @
    parent#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val value = value
  method value = value
  method get_value = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    value#store
    @
    value#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val depth = depth
  method depth = depth
  method get_depth = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 8l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_depth = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 8l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    depth#store
    @
    depth#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val left = left
  method left = left
  method get_left = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 12l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_left = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 12l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    left#store
    @
    left#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val right = right
  method right = right
  method get_right = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 16l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_right = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 16l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    right#store
    @
    right#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val color = color
  method color = color
  method get_color = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 20l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_color = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 20l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    color#store
    @
    color#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
            

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc
      @  self#store_parent 
@  self#store_value 
@  self#store_depth 
@  self#store_left 
@  self#store_right 
@  self#store_color 

    )
    
  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]

end


class  transaction ~(action : dt) ~(amount : dt) ~(contract : dt)  = object(self)
  val size = 12l
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"transaction_malloc" ())
  val mutable allocated = false
  val mutable stored = false
  method malloc_name = malloc_name
  method size = size
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)]
    
    @ self#action#locals 
@ self#amount#locals 
@ self#contract#locals 


  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )
     
    
  val action = action
  method action = action
  method get_action = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_action = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    action#store
    @
    action#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val amount = amount
  method amount = amount
  method get_amount = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_amount = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    amount#store
    @
    amount#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val contract = contract
  method contract = contract
  method get_contract = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 8l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_contract = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 8l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    contract#store
    @
    contract#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
            

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc
      @  self#store_action 
@  self#store_amount 
@  self#store_contract 

    )
    
  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]

end


class  delegate ~(delegate : dt)  = object(self)
  val size = 4l
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"delegate_malloc" ())
  val mutable allocated = false
  val mutable stored = false
  method malloc_name = malloc_name
  method size = size
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)]
    
    @ self#delegate#locals 


  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )
     
    
  val delegate = delegate
  method delegate = delegate
  method get_delegate = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_delegate = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    delegate#store
    @
    delegate#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
            

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc
      @  self#store_delegate 

    )
    
  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]

end


class ['T] wrapped ~(data : 'T)  = object(self)
  val size = 4l
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"wrapped_malloc" ())
  val mutable allocated = false
  val mutable stored = false
  method malloc_name = malloc_name
  method size = size
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)]
    
    @ self#data#locals 


  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )
     
    
  val data = data
  method data = data
  method get_data = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_data = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    data#store
    @
    data#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
            

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc
      @  self#store_data 

    )
    
  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]

end



type option_variant = 
  
| None
| Some

class ['T] option ~(kind: option_variant) ~(value: 'T) = object(self)
  val kind = kind
  val value = value
  
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"option_malloc" ())
  val mutable allocated = false
  val mutable stored = false

  method malloc_name = malloc_name
  method size = 12l
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method kind = kind
  method value = value
  
  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)] 
    @
    value#locals

  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )

  method store_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 4l; at  }; at };
      { it = Binary (I32 Add); at };
    ]
    @
    value#store
    @
    S.[
      { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method store_kind = 
    let kind = match self#kind with 
    
  | None -> 0l
  | Some -> 1l 
    in
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 kind; at  }; at };
      { it = Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method get_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 4l; at  }; at  };
      { it = Binary (I32 Add); at };
      { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc 
      @ self#store_kind
      @ self#store_value
   
  )

  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]
  
end
          
class  bigintwrap ~(data : dt) ~(len : dt) ~(capacity : dt)  = object(self)
  val size = 12l
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"bigintwrap_malloc" ())
  val mutable allocated = false
  val mutable stored = false
  method malloc_name = malloc_name
  method size = size
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)]
    
    @ self#data#locals 
@ self#len#locals 
@ self#capacity#locals 


  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )
     
    
  val data = data
  method data = data
  method get_data = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_data = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    data#store
    @
    data#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val len = len
  method len = len
  method get_len = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_len = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    len#store
    @
    len#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val capacity = capacity
  method capacity = capacity
  method get_capacity = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 8l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_capacity = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 8l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    capacity#store
    @
    capacity#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
            

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc
      @  self#store_data 
@  self#store_len 
@  self#store_capacity 

    )
    
  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]

end



type datatype_variant = 
  
| Int
| Nat
| Mutez
| Timestamp
| Bool
| ListItem
| Tuple
| Set
| Map
| Operations
| String

class  datatype ~(kind: datatype_variant) ~(value: dt) = object(self)
  val kind = kind
  val value = value
  
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"datatype_malloc" ())
  val mutable allocated = false
  val mutable stored = false

  method malloc_name = malloc_name
  method size = 12l
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method kind = kind
  method value = value
  
  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)] 
    @
    value#locals

  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )

  method store_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 4l; at  }; at };
      { it = Binary (I32 Add); at };
    ]
    @
    value#store
    @
    S.[
      { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method store_kind = 
    let kind = match self#kind with 
    
  | Int -> 0l
  | Nat -> 1l
  | Mutez -> 2l
  | Timestamp -> 3l
  | Bool -> 4l
  | ListItem -> 5l
  | Tuple -> 6l
  | Set -> 7l
  | Map -> 8l
  | Operations -> 9l
  | String -> 10l 
    in
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 kind; at  }; at };
      { it = Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method get_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 4l; at  }; at  };
      { it = Binary (I32 Add); at };
      { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc 
      @ self#store_kind
      @ self#store_value
   
  )

  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]
  
end
          
class  node ~(value : dt) ~(next : dt)  = object(self)
  val size = 8l
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"node_malloc" ())
  val mutable allocated = false
  val mutable stored = false
  method malloc_name = malloc_name
  method size = size
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)]
    
    @ self#value#locals 
@ self#next#locals 


  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )
     
    
  val value = value
  method value = value
  method get_value = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    value#store
    @
    value#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val next = next
  method next = next
  method get_next = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_next = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    next#store
    @
    next#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
            

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc
      @  self#store_value 
@  self#store_next 

    )
    
  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]

end



type operation_variant = 
  
| Transaction
| Delegate

class  operation ~(kind: operation_variant) ~(value: dt) = object(self)
  val kind = kind
  val value = value
  
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"operation_malloc" ())
  val mutable allocated = false
  val mutable stored = false

  method malloc_name = malloc_name
  method size = 12l
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method kind = kind
  method value = value
  
  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)] 
    @
    value#locals

  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )

  method store_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 4l; at  }; at };
      { it = Binary (I32 Add); at };
    ]
    @
    value#store
    @
    S.[
      { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method store_kind = 
    let kind = match self#kind with 
    
  | Transaction -> 0l
  | Delegate -> 1l 
    in
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 kind; at  }; at };
      { it = Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method get_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 4l; at  }; at  };
      { it = Binary (I32 Add); at };
      { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc 
      @ self#store_kind
      @ self#store_value
   
  )

  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]
  
end
          
class  operationnode ~(value : dt) ~(next : dt)  = object(self)
  val size = 8l
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"operationnode_malloc" ())
  val mutable allocated = false
  val mutable stored = false
  method malloc_name = malloc_name
  method size = size
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)]
    
    @ self#value#locals 
@ self#next#locals 


  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )
     
    
  val value = value
  method value = value
  method get_value = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    value#store
    @
    value#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val next = next
  method next = next
  method get_next = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_next = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    next#store
    @
    next#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
            

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc
      @  self#store_value 
@  self#store_next 

    )
    
  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]

end



type color_variant = 
  
| Red
| Black

class  color ~(kind: color_variant) ~(value: dt) = object(self)
  val kind = kind
  val value = value
  
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"color_malloc" ())
  val mutable allocated = false
  val mutable stored = false

  method malloc_name = malloc_name
  method size = 12l
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method kind = kind
  method value = value
  
  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)] 
    @
    value#locals

  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )

  method store_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 4l; at  }; at };
      { it = Binary (I32 Add); at };
    ]
    @
    value#store
    @
    S.[
      { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method store_kind = 
    let kind = match self#kind with 
    
  | Red -> 0l
  | Black -> 1l 
    in
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 kind; at  }; at };
      { it = Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method get_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 4l; at  }; at  };
      { it = Binary (I32 Add); at };
      { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc 
      @ self#store_kind
      @ self#store_value
   
  )

  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]
  
end
          
class  rbnode ~(parent : dt) ~(value : dt) ~(depth : dt) ~(left : dt) ~(right : dt) ~(color : dt)  = object(self)
  val size = 24l
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"rbnode_malloc" ())
  val mutable allocated = false
  val mutable stored = false
  method malloc_name = malloc_name
  method size = size
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)]
    
    @ self#parent#locals 
@ self#value#locals 
@ self#depth#locals 
@ self#left#locals 
@ self#right#locals 
@ self#color#locals 


  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )
     
    
  val parent = parent
  method parent = parent
  method get_parent = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_parent = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    parent#store
    @
    parent#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val value = value
  method value = value
  method get_value = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    value#store
    @
    value#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val depth = depth
  method depth = depth
  method get_depth = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 8l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_depth = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 8l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    depth#store
    @
    depth#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val left = left
  method left = left
  method get_left = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 12l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_left = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 12l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    left#store
    @
    left#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val right = right
  method right = right
  method get_right = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 16l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_right = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 16l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    right#store
    @
    right#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val color = color
  method color = color
  method get_color = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 20l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_color = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 20l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    color#store
    @
    color#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
            

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc
      @  self#store_parent 
@  self#store_value 
@  self#store_depth 
@  self#store_left 
@  self#store_right 
@  self#store_color 

    )
    
  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]

end


class  transaction ~(action : dt) ~(amount : dt) ~(contract : dt)  = object(self)
  val size = 12l
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"transaction_malloc" ())
  val mutable allocated = false
  val mutable stored = false
  method malloc_name = malloc_name
  method size = size
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)]
    
    @ self#action#locals 
@ self#amount#locals 
@ self#contract#locals 


  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )
     
    
  val action = action
  method action = action
  method get_action = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_action = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    action#store
    @
    action#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val amount = amount
  method amount = amount
  method get_amount = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_amount = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    amount#store
    @
    amount#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val contract = contract
  method contract = contract
  method get_contract = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 8l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_contract = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 8l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    contract#store
    @
    contract#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
            

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc
      @  self#store_action 
@  self#store_amount 
@  self#store_contract 

    )
    
  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]

end


class  delegate ~(delegate : dt)  = object(self)
  val size = 4l
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"delegate_malloc" ())
  val mutable allocated = false
  val mutable stored = false
  method malloc_name = malloc_name
  method size = size
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)]
    
    @ self#delegate#locals 


  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )
     
    
  val delegate = delegate
  method delegate = delegate
  method get_delegate = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_delegate = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    delegate#store
    @
    delegate#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
            

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc
      @  self#store_delegate 

    )
    
  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]

end


class ['T] wrapped ~(data : 'T)  = object(self)
  val size = 4l
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"wrapped_malloc" ())
  val mutable allocated = false
  val mutable stored = false
  method malloc_name = malloc_name
  method size = size
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)]
    
    @ self#data#locals 


  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )
     
    
  val data = data
  method data = data
  method get_data = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_data = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    data#store
    @
    data#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
            

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc
      @  self#store_data 

    )
    
  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]

end



type option_variant = 
  
| None
| Some

class ['T] option ~(kind: option_variant) ~(value: 'T) = object(self)
  val kind = kind
  val value = value
  
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"option_malloc" ())
  val mutable allocated = false
  val mutable stored = false

  method malloc_name = malloc_name
  method size = 12l
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method kind = kind
  method value = value
  
  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)] 
    @
    value#locals

  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )

  method store_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 4l; at  }; at };
      { it = Binary (I32 Add); at };
    ]
    @
    value#store
    @
    S.[
      { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method store_kind = 
    let kind = match self#kind with 
    
  | None -> 0l
  | Some -> 1l 
    in
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 kind; at  }; at };
      { it = Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method get_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 4l; at  }; at  };
      { it = Binary (I32 Add); at };
      { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc 
      @ self#store_kind
      @ self#store_value
   
  )

  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]
  
end
          
class  bigintwrap ~(data : dt) ~(len : dt) ~(capacity : dt)  = object(self)
  val size = 12l
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"bigintwrap_malloc" ())
  val mutable allocated = false
  val mutable stored = false
  method malloc_name = malloc_name
  method size = size
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)]
    
    @ self#data#locals 
@ self#len#locals 
@ self#capacity#locals 


  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )
     
    
  val data = data
  method data = data
  method get_data = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_data = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    data#store
    @
    data#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val len = len
  method len = len
  method get_len = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_len = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    len#store
    @
    len#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val capacity = capacity
  method capacity = capacity
  method get_capacity = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 8l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_capacity = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 8l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    capacity#store
    @
    capacity#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
            

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc
      @  self#store_data 
@  self#store_len 
@  self#store_capacity 

    )
    
  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]

end



type datatype_variant = 
  
| Int
| Nat
| Mutez
| Timestamp
| Bool
| ListItem
| Tuple
| Set
| Map
| Operations
| String

class  datatype ~(kind: datatype_variant) ~(value: dt) = object(self)
  val kind = kind
  val value = value
  
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"datatype_malloc" ())
  val mutable allocated = false
  val mutable stored = false

  method malloc_name = malloc_name
  method size = 12l
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method kind = kind
  method value = value
  
  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)] 
    @
    value#locals

  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )

  method store_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 4l; at  }; at };
      { it = Binary (I32 Add); at };
    ]
    @
    value#store
    @
    S.[
      { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method store_kind = 
    let kind = match self#kind with 
    
  | Int -> 0l
  | Nat -> 1l
  | Mutez -> 2l
  | Timestamp -> 3l
  | Bool -> 4l
  | ListItem -> 5l
  | Tuple -> 6l
  | Set -> 7l
  | Map -> 8l
  | Operations -> 9l
  | String -> 10l 
    in
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 kind; at  }; at };
      { it = Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method get_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 4l; at  }; at  };
      { it = Binary (I32 Add); at };
      { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc 
      @ self#store_kind
      @ self#store_value
   
  )

  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]
  
end
          
class  node ~(value : dt) ~(next : dt)  = object(self)
  val size = 8l
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"node_malloc" ())
  val mutable allocated = false
  val mutable stored = false
  method malloc_name = malloc_name
  method size = size
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)]
    
    @ self#value#locals 
@ self#next#locals 


  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )
     
    
  val value = value
  method value = value
  method get_value = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    value#store
    @
    value#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val next = next
  method next = next
  method get_next = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_next = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    next#store
    @
    next#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
            

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc
      @  self#store_value 
@  self#store_next 

    )
    
  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]

end



type operation_variant = 
  
| Transaction
| Delegate

class  operation ~(kind: operation_variant) ~(value: dt) = object(self)
  val kind = kind
  val value = value
  
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"operation_malloc" ())
  val mutable allocated = false
  val mutable stored = false

  method malloc_name = malloc_name
  method size = 12l
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method kind = kind
  method value = value
  
  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)] 
    @
    value#locals

  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )

  method store_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 4l; at  }; at };
      { it = Binary (I32 Add); at };
    ]
    @
    value#store
    @
    S.[
      { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method store_kind = 
    let kind = match self#kind with 
    
  | Transaction -> 0l
  | Delegate -> 1l 
    in
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 kind; at  }; at };
      { it = Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method get_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 4l; at  }; at  };
      { it = Binary (I32 Add); at };
      { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc 
      @ self#store_kind
      @ self#store_value
   
  )

  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]
  
end
          
class  operationnode ~(value : dt) ~(next : dt)  = object(self)
  val size = 8l
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"operationnode_malloc" ())
  val mutable allocated = false
  val mutable stored = false
  method malloc_name = malloc_name
  method size = size
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)]
    
    @ self#value#locals 
@ self#next#locals 


  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )
     
    
  val value = value
  method value = value
  method get_value = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    value#store
    @
    value#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val next = next
  method next = next
  method get_next = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_next = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    next#store
    @
    next#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
            

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc
      @  self#store_value 
@  self#store_next 

    )
    
  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]

end



type color_variant = 
  
| Red
| Black

class  color ~(kind: color_variant) ~(value: dt) = object(self)
  val kind = kind
  val value = value
  
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"color_malloc" ())
  val mutable allocated = false
  val mutable stored = false

  method malloc_name = malloc_name
  method size = 12l
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method kind = kind
  method value = value
  
  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)] 
    @
    value#locals

  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )

  method store_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 4l; at  }; at };
      { it = Binary (I32 Add); at };
    ]
    @
    value#store
    @
    S.[
      { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method store_kind = 
    let kind = match self#kind with 
    
  | Red -> 0l
  | Black -> 1l 
    in
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 kind; at  }; at };
      { it = Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method get_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 4l; at  }; at  };
      { it = Binary (I32 Add); at };
      { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc 
      @ self#store_kind
      @ self#store_value
   
  )

  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]
  
end
          
class  rbnode ~(parent : dt) ~(value : dt) ~(depth : dt) ~(left : dt) ~(right : dt) ~(color : dt)  = object(self)
  val size = 24l
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"rbnode_malloc" ())
  val mutable allocated = false
  val mutable stored = false
  method malloc_name = malloc_name
  method size = size
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)]
    
    @ self#parent#locals 
@ self#value#locals 
@ self#depth#locals 
@ self#left#locals 
@ self#right#locals 
@ self#color#locals 


  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )
     
    
  val parent = parent
  method parent = parent
  method get_parent = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_parent = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    parent#store
    @
    parent#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val value = value
  method value = value
  method get_value = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    value#store
    @
    value#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val depth = depth
  method depth = depth
  method get_depth = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 8l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_depth = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 8l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    depth#store
    @
    depth#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val left = left
  method left = left
  method get_left = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 12l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_left = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 12l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    left#store
    @
    left#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val right = right
  method right = right
  method get_right = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 16l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_right = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 16l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    right#store
    @
    right#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val color = color
  method color = color
  method get_color = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 20l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_color = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 20l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    color#store
    @
    color#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
            

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc
      @  self#store_parent 
@  self#store_value 
@  self#store_depth 
@  self#store_left 
@  self#store_right 
@  self#store_color 

    )
    
  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]

end


class  transaction ~(action : dt) ~(amount : dt) ~(contract : dt)  = object(self)
  val size = 12l
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"transaction_malloc" ())
  val mutable allocated = false
  val mutable stored = false
  method malloc_name = malloc_name
  method size = size
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)]
    
    @ self#action#locals 
@ self#amount#locals 
@ self#contract#locals 


  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )
     
    
  val action = action
  method action = action
  method get_action = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_action = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    action#store
    @
    action#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val amount = amount
  method amount = amount
  method get_amount = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_amount = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    amount#store
    @
    amount#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val contract = contract
  method contract = contract
  method get_contract = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 8l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_contract = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 8l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    contract#store
    @
    contract#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
            

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc
      @  self#store_action 
@  self#store_amount 
@  self#store_contract 

    )
    
  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]

end


class  delegate ~(delegate : dt)  = object(self)
  val size = 4l
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"delegate_malloc" ())
  val mutable allocated = false
  val mutable stored = false
  method malloc_name = malloc_name
  method size = size
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)]
    
    @ self#delegate#locals 


  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )
     
    
  val delegate = delegate
  method delegate = delegate
  method get_delegate = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_delegate = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    delegate#store
    @
    delegate#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
            

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc
      @  self#store_delegate 

    )
    
  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]

end


class ['T] wrapped ~(data : 'T)  = object(self)
  val size = 4l
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"wrapped_malloc" ())
  val mutable allocated = false
  val mutable stored = false
  method malloc_name = malloc_name
  method size = size
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)]
    
    @ self#data#locals 


  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )
     
    
  val data = data
  method data = data
  method get_data = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_data = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    data#store
    @
    data#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
            

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc
      @  self#store_data 

    )
    
  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]

end



type option_variant = 
  
| None
| Some

class ['T] option ~(kind: option_variant) ~(value: 'T) = object(self)
  val kind = kind
  val value = value
  
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"option_malloc" ())
  val mutable allocated = false
  val mutable stored = false

  method malloc_name = malloc_name
  method size = 12l
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method kind = kind
  method value = value
  
  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)] 
    @
    value#locals

  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )

  method store_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 4l; at  }; at };
      { it = Binary (I32 Add); at };
    ]
    @
    value#store
    @
    S.[
      { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method store_kind = 
    let kind = match self#kind with 
    
  | None -> 0l
  | Some -> 1l 
    in
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 kind; at  }; at };
      { it = Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method get_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 4l; at  }; at  };
      { it = Binary (I32 Add); at };
      { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc 
      @ self#store_kind
      @ self#store_value
   
  )

  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]
  
end
          
class  bigintwrap ~(data : dt) ~(len : dt) ~(capacity : dt)  = object(self)
  val size = 12l
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"bigintwrap_malloc" ())
  val mutable allocated = false
  val mutable stored = false
  method malloc_name = malloc_name
  method size = size
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)]
    
    @ self#data#locals 
@ self#len#locals 
@ self#capacity#locals 


  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )
     
    
  val data = data
  method data = data
  method get_data = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_data = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    data#store
    @
    data#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val len = len
  method len = len
  method get_len = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_len = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    len#store
    @
    len#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val capacity = capacity
  method capacity = capacity
  method get_capacity = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 8l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_capacity = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 8l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    capacity#store
    @
    capacity#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
            

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc
      @  self#store_data 
@  self#store_len 
@  self#store_capacity 

    )
    
  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]

end



type datatype_variant = 
  
| Int
| Nat
| Mutez
| Timestamp
| Bool
| ListItem
| Tuple
| Set
| Map
| Operations
| String

class  datatype ~(kind: datatype_variant) ~(value: dt) = object(self)
  val kind = kind
  val value = value
  
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"datatype_malloc" ())
  val mutable allocated = false
  val mutable stored = false

  method malloc_name = malloc_name
  method size = 12l
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method kind = kind
  method value = value
  
  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)] 
    @
    value#locals

  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )

  method store_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 4l; at  }; at };
      { it = Binary (I32 Add); at };
    ]
    @
    value#store
    @
    S.[
      { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method store_kind = 
    let kind = match self#kind with 
    
  | Int -> 0l
  | Nat -> 1l
  | Mutez -> 2l
  | Timestamp -> 3l
  | Bool -> 4l
  | ListItem -> 5l
  | Tuple -> 6l
  | Set -> 7l
  | Map -> 8l
  | Operations -> 9l
  | String -> 10l 
    in
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 kind; at  }; at };
      { it = Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method get_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 4l; at  }; at  };
      { it = Binary (I32 Add); at };
      { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc 
      @ self#store_kind
      @ self#store_value
   
  )

  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]
  
end
          
class  node ~(value : dt) ~(next : dt)  = object(self)
  val size = 8l
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"node_malloc" ())
  val mutable allocated = false
  val mutable stored = false
  method malloc_name = malloc_name
  method size = size
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)]
    
    @ self#value#locals 
@ self#next#locals 


  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )
     
    
  val value = value
  method value = value
  method get_value = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    value#store
    @
    value#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val next = next
  method next = next
  method get_next = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_next = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    next#store
    @
    next#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
            

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc
      @  self#store_value 
@  self#store_next 

    )
    
  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]

end



type operation_variant = 
  
| Transaction
| Delegate

class  operation ~(kind: operation_variant) ~(value: dt) = object(self)
  val kind = kind
  val value = value
  
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"operation_malloc" ())
  val mutable allocated = false
  val mutable stored = false

  method malloc_name = malloc_name
  method size = 12l
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method kind = kind
  method value = value
  
  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)] 
    @
    value#locals

  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )

  method store_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 4l; at  }; at };
      { it = Binary (I32 Add); at };
    ]
    @
    value#store
    @
    S.[
      { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method store_kind = 
    let kind = match self#kind with 
    
  | Transaction -> 0l
  | Delegate -> 1l 
    in
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 kind; at  }; at };
      { it = Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method get_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 4l; at  }; at  };
      { it = Binary (I32 Add); at };
      { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc 
      @ self#store_kind
      @ self#store_value
   
  )

  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]
  
end
          
class  operationnode ~(value : dt) ~(next : dt)  = object(self)
  val size = 8l
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"operationnode_malloc" ())
  val mutable allocated = false
  val mutable stored = false
  method malloc_name = malloc_name
  method size = size
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)]
    
    @ self#value#locals 
@ self#next#locals 


  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )
     
    
  val value = value
  method value = value
  method get_value = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    value#store
    @
    value#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val next = next
  method next = next
  method get_next = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_next = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    next#store
    @
    next#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
            

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc
      @  self#store_value 
@  self#store_next 

    )
    
  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]

end



type color_variant = 
  
| Red
| Black

class  color ~(kind: color_variant) ~(value: dt) = object(self)
  val kind = kind
  val value = value
  
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"color_malloc" ())
  val mutable allocated = false
  val mutable stored = false

  method malloc_name = malloc_name
  method size = 12l
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method kind = kind
  method value = value
  
  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)] 
    @
    value#locals

  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )

  method store_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 4l; at  }; at };
      { it = Binary (I32 Add); at };
    ]
    @
    value#store
    @
    S.[
      { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method store_kind = 
    let kind = match self#kind with 
    
  | Red -> 0l
  | Black -> 1l 
    in
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 kind; at  }; at };
      { it = Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method get_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
      { it = Const { it = I32 4l; at  }; at  };
      { it = Binary (I32 Add); at };
      { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc 
      @ self#store_kind
      @ self#store_value
   
  )

  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]
  
end
          
class  rbnode ~(parent : dt) ~(value : dt) ~(depth : dt) ~(left : dt) ~(right : dt) ~(color : dt)  = object(self)
  val size = 24l
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"rbnode_malloc" ())
  val mutable allocated = false
  val mutable stored = false
  method malloc_name = malloc_name
  method size = size
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)]
    
    @ self#parent#locals 
@ self#value#locals 
@ self#depth#locals 
@ self#left#locals 
@ self#right#locals 
@ self#color#locals 


  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )
     
    
  val parent = parent
  method parent = parent
  method get_parent = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_parent = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    parent#store
    @
    parent#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val value = value
  method value = value
  method get_value = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_value = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    value#store
    @
    value#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val depth = depth
  method depth = depth
  method get_depth = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 8l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_depth = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 8l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    depth#store
    @
    depth#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val left = left
  method left = left
  method get_left = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 12l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_left = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 12l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    left#store
    @
    left#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val right = right
  method right = right
  method get_right = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 16l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_right = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 16l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    right#store
    @
    right#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val color = color
  method color = color
  method get_color = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 20l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_color = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 20l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    color#store
    @
    color#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
            

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc
      @  self#store_parent 
@  self#store_value 
@  self#store_depth 
@  self#store_left 
@  self#store_right 
@  self#store_color 

    )
    
  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]

end


class  transaction ~(action : dt) ~(amount : dt) ~(contract : dt)  = object(self)
  val size = 12l
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"transaction_malloc" ())
  val mutable allocated = false
  val mutable stored = false
  method malloc_name = malloc_name
  method size = size
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)]
    
    @ self#action#locals 
@ self#amount#locals 
@ self#contract#locals 


  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )
     
    
  val action = action
  method action = action
  method get_action = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_action = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    action#store
    @
    action#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val amount = amount
  method amount = amount
  method get_amount = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_amount = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 4l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    amount#store
    @
    amount#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
              
  val contract = contract
  method contract = contract
  method get_contract = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 8l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_contract = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 8l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    contract#store
    @
    contract#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
            

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc
      @  self#store_action 
@  self#store_amount 
@  self#store_contract 

    )
    
  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]

end


class  delegate ~(delegate : dt)  = object(self)
  val size = 4l
  val malloc_name =  var_to_string (ValueVar.fresh ~name:"delegate_malloc" ())
  val mutable allocated = false
  val mutable stored = false
  method malloc_name = malloc_name
  method size = size
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)]
    
    @ self#delegate#locals 


  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{ it = A.Const { it = I32 self#size; at}; at };
        { it = Call "malloc"; at };
        { it = LocalSet self#malloc_name; at };]
    )
     
    
  val delegate = delegate
  method delegate = delegate
  method get_delegate = 
     S.[
       { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
       { it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at }
     ]
    
  method store_delegate = 
    S.[
      { it = A.LocalGet self#malloc_name; at };
       { it = Const { it = I32 0l; at  }; at };
       { it = Binary (I32 Add); at };
    ]
    @
    delegate#store
    @
    delegate#reference
    @
    S.[
       { it = A.Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at };
    ]
            

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc
      @  self#store_delegate 

    )
    
  method reference =
    S.[{ it = A.LocalGet self#malloc_name; at };]

end

