[@@@warning "-27-26"]

(* Do not change, this file is generated by the Rust `expose_datatype` macro. *)
module W = WasmObjectFile
module A = W.Ast
module T = W.Types
module S = W.Source
module ValueVar = Stage_common.Types.ValueVar

let at = S.no_region

let const n = S.{it = A.Const {it = I32 n; at}; at}

let var_to_string name =
  let name, hash = ValueVar.internal_get_name_and_counter name in
  name ^ "#" ^ string_of_int hash

type locals = (string * T.value_type) list

and 't wrapped = {data: 't}

and 't option = None | Some of 't

and bigintwrap = {data: int32; len: int32; capacity: int32}

and datatype =
  | Int of bigintwrap wrapped
  | Nat of bigintwrap wrapped
  | Mutez of bigintwrap wrapped
  | Timestamp of int32
  | Bool of bool
  | ListItem of node wrapped
  | Tuple of node wrapped
  | Set of rbnode wrapped
  | Map of rbnode wrapped
  | Operations of operationnode wrapped option
  | String of string wrapped
  | Instructions of A.instr list

and node = {value: datatype wrapped; next: node wrapped option}

and operation = Transaction of transaction | Delegate of delegate

and operationnode = {
  value: operation wrapped;
  next: operationnode wrapped option;
}

and color = Red | Black

and rbnode = {
  parent: rbnode wrapped option;
  value: datatype wrapped;
  depth: int32;
  left: rbnode wrapped option;
  right: rbnode wrapped option;
  color: color;
}

and transaction = {action: datatype; amount: bigintwrap; contract: bigintwrap}

and delegate = {delegate: datatype option}

let rec int32_size () = 4l

and bool_size () = 4l

and t_size () = int32_size ()

and usize_size () = int32_size ()

and wrapped_size () = Int32.(0l + 4l)

and option_size () = Int32.(4l + List.fold_left ~f:max ~init:0l [t_size ()])

and bigintwrap_size () = Int32.(0l + 4l + usize_size () + usize_size ())

and datatype_size () =
  Int32.(
    4l
    + List.fold_left ~f:max ~init:0l
        [
          wrapped_size ();
          wrapped_size ();
          wrapped_size ();
          int32_size ();
          bool_size ();
          wrapped_size ();
          wrapped_size ();
          wrapped_size ();
          wrapped_size ();
          option_size ();
          wrapped_size ();
        ])

and node_size () = Int32.(0l + wrapped_size () + option_size ())

and operation_size () =
  Int32.(
    4l + List.fold_left ~f:max ~init:0l [transaction_size (); delegate_size ()])

and operationnode_size () = Int32.(0l + wrapped_size () + option_size ())

and color_size () = Int32.(4l + List.fold_left ~f:max ~init:0l [])

and rbnode_size () =
  Int32.(
    0l + option_size () + wrapped_size () + usize_size () + option_size ()
    + option_size () + color_size ())

and transaction_size () =
  Int32.(0l + datatype_size () + bigintwrap_size () + bigintwrap_size ())

and delegate_size () = Int32.(0l + option_size ())

let rec malloc : name:string -> size:int32 -> string * A.instr list =
 fun ~name ~size ->
  let malloc_local = var_to_string (ValueVar.fresh ~name ()) in
  ( malloc_local,
    S.
      [
        {it = A.Const {it = I32 size; at}; at};
        {it = Call "malloc"; at};
        {it = LocalSet malloc_local; at};
      ] )

and alloc_value : alloc:string -> A.instr list =
 fun ~alloc -> S.[{it = A.LocalGet alloc; at}]

and load : alloc:string -> offset:int32 -> string -> locals * A.instr list =
 fun ~alloc ~offset name ->
  let name_l = var_to_string (ValueVar.fresh ~name ()) in
  ( [(name_l, T.I32Type)],
    alloc_value ~alloc
    @ (if Int32.(offset = 0l) then []
      else
        S.
          [
            {it = A.Const {it = I32 offset; at}; at}; {it = Binary (I32 Add); at};
          ])
    @ S.
        [
          {it = Load {ty = I32Type; align = 0; offset = 0l; sz = None}; at};
          {it = LocalSet name_l; at};
        ] )

and store :
    alloc:string ->
    offset:int32 ->
    locals * A.instr list ->
    locals * A.instr list =
 fun ~alloc ~offset value ->
  let locals, value = value in
  ( locals,
    alloc_value ~alloc
    @ (if Int32.(offset = 0l) then []
      else
        S.
          [
            {it = A.Const {it = I32 offset; at}; at}; {it = Binary (I32 Add); at};
          ])
    @ value
    @ S.[{it = Store {ty = I32Type; align = 0; offset = 0l; sz = None}; at}] )

and store_int32 :
    ?alloc:string -> ?offset:int32 -> int32 -> locals * A.instr list =
 fun ?alloc ?offset n ->
  match (alloc, offset) with
  | Some alloc, Some offset ->
    store ~alloc ~offset ([], S.[{it = A.Const {it = I32 n; at}; at}])
  | _ -> ([], S.[{it = A.Const {it = I32 n; at}; at}])

and store_u8 : ?alloc:string -> ?offset:int32 -> int32 -> locals * A.instr list
    =
 fun ?alloc ?offset n -> store_int32 ?alloc ?offset n

and store_usize :
    ?alloc:string -> ?offset:int32 -> int32 -> locals * A.instr list =
 fun ?alloc ?offset n -> store_int32 ?alloc ?offset n

and store_bool : ?alloc:string -> ?offset:int32 -> bool -> locals * A.instr list
    =
 fun ?alloc ?offset b ->
  if b then store_int32 ?alloc ?offset 1l else store_int32 ?alloc ?offset 0l

and store_string :
    ?alloc:string -> ?offset:int32 -> string -> locals * A.instr list =
 fun ?alloc ?offset s -> failwith "todo"

and load_wrapped : alloc:string -> locals * A.instr list =
 fun ~alloc ->
  let locals_data, data_instructions = load ~alloc ~offset:0l "data" in
  let locals = locals_data @ [] in
  let instructions = data_instructions @ [] in
  (locals, instructions)

and store_wrapped :
      't.
      ?alloc:string ->
      ?offset:int32 ->
      't wrapped ->
      (?alloc:string -> ?offset:int32 -> 't -> locals * A.instr list) ->
      locals * A.instr list =
 fun ?alloc ?offset value store_t ->
  let offset =
    match offset with
    | Some offset -> offset
    | None -> 0l
  in
  let alloc, alloc_instructions, return_ =
    match alloc with
    | Some alloc -> (alloc, [], [])
    | None ->
      let alloc, i = malloc ~name:"malloc_wrapped" ~size:(wrapped_size ()) in
      (alloc, i, alloc_value ~alloc)
  in
  let locals_data, data_instructions =
    store ~alloc ~offset:Int32.(offset + 0l) (store_t value.data)
  in

  ( ((alloc, T.I32Type) :: locals_data) @ [],
    alloc_instructions @ data_instructions @ return_ )

and load_option_none : symbol:string -> locals * A.instr list =
 fun ~symbol -> ([], [])

and load_option_some : symbol:string -> locals * A.instr list =
 fun ~symbol -> ([], [])

and store_option :
      't.
      ?alloc:string ->
      ?offset:int32 ->
      't option ->
      (?alloc:string -> ?offset:int32 -> 't -> locals * A.instr list) ->
      locals * A.instr list =
 fun ?alloc ?offset value store_t ->
  let offset =
    match offset with
    | Some offset -> offset
    | None -> 0l
  in
  match value with
  | None ->
    let alloc, alloc_l, alloc_instructions, return_l =
      match alloc with
      | Some alloc -> (alloc, [], [], [])
      | None ->
        let a, i = malloc ~name:"Option_None_malloc" ~size:Int32.(4l + 0l) in
        (a, [(a, T.I32Type)], i, alloc_value ~alloc:a)
    in
    let header_locals, header_instructions = store_int32 ~alloc ~offset 0l in
    let value_locals, value_instructions = ([], []) in
    ( alloc_l @ header_locals @ value_locals,
      alloc_instructions @ header_instructions @ value_instructions @ return_l
    )
  | Some t ->
    let alloc, alloc_l, alloc_instructions, return_l =
      match alloc with
      | Some alloc -> (alloc, [], [], [])
      | None ->
        let a, i =
          malloc ~name:"Option_Some_malloc" ~size:Int32.(4l + t_size ())
        in
        (a, [(a, T.I32Type)], i, alloc_value ~alloc:a)
    in
    let header_locals, header_instructions = store_int32 ~alloc ~offset 1l in
    let value_locals, value_instructions =
      store_t ~alloc ~offset:Int32.(offset + 4l) t
    in
    ( alloc_l @ header_locals @ value_locals,
      alloc_instructions @ header_instructions @ value_instructions @ return_l
    )

and load_bigintwrap : alloc:string -> locals * A.instr list =
 fun ~alloc ->
  let locals_data, data_instructions = load ~alloc ~offset:0l "data" in
  let locals_len, len_instructions = load ~alloc ~offset:4l "len" in
  let locals_capacity, capacity_instructions =
    load ~alloc ~offset:8l "capacity"
  in
  let locals = locals_data @ locals_len @ locals_capacity @ [] in
  let instructions =
    data_instructions @ len_instructions @ capacity_instructions @ []
  in
  (locals, instructions)

and store_bigintwrap :
    ?alloc:string -> ?offset:int32 -> bigintwrap -> locals * A.instr list =
 fun ?alloc ?offset value ->
  let offset =
    match offset with
    | Some offset -> offset
    | None -> 0l
  in
  let alloc, alloc_instructions, return_ =
    match alloc with
    | Some alloc -> (alloc, [], [])
    | None ->
      let alloc, i =
        malloc ~name:"malloc_bigintwrap" ~size:(bigintwrap_size ())
      in
      (alloc, i, alloc_value ~alloc)
  in
  let locals_data, data_instructions =
    store ~alloc ~offset:Int32.(offset + 0l) (store_u8 value.data)
  in
  let locals_len, len_instructions =
    store_usize ~alloc ~offset:Int32.(offset + 4l) value.len
  in
  let locals_capacity, capacity_instructions =
    store_usize ~alloc ~offset:Int32.(offset + 8l) value.capacity
  in

  ( ((alloc, T.I32Type) :: locals_data) @ locals_len @ locals_capacity @ [],
    alloc_instructions @ data_instructions @ len_instructions
    @ capacity_instructions @ return_ )

and load_datatype_int : symbol:string -> locals * A.instr list =
 fun ~symbol -> ([], [])

and load_datatype_nat : symbol:string -> locals * A.instr list =
 fun ~symbol -> ([], [])

and load_datatype_mutez : symbol:string -> locals * A.instr list =
 fun ~symbol -> ([], [])

and load_datatype_timestamp : symbol:string -> locals * A.instr list =
 fun ~symbol -> ([], [])

and load_datatype_bool : symbol:string -> locals * A.instr list =
 fun ~symbol -> ([], [])

and load_datatype_listitem : symbol:string -> locals * A.instr list =
 fun ~symbol -> ([], [])

and load_datatype_tuple : symbol:string -> locals * A.instr list =
 fun ~symbol -> ([], [])

and load_datatype_set : symbol:string -> locals * A.instr list =
 fun ~symbol -> ([], [])

and load_datatype_map : symbol:string -> locals * A.instr list =
 fun ~symbol -> ([], [])

and load_datatype_operations : symbol:string -> locals * A.instr list =
 fun ~symbol -> ([], [])

and load_datatype_string : symbol:string -> locals * A.instr list =
 fun ~symbol -> ([], [])

and store_datatype :
    ?alloc:string -> ?offset:int32 -> datatype -> locals * A.instr list =
 fun ?alloc ?offset value ->
  let offset =
    match offset with
    | Some offset -> offset
    | None -> 0l
  in
  match value with
  | Int b ->
    let alloc, alloc_l, alloc_instructions, return_l =
      match alloc with
      | Some alloc -> (alloc, [], [], [])
      | None ->
        let a, i =
          malloc ~name:"DataType_Int_malloc" ~size:Int32.(4l + wrapped_size ())
        in
        (a, [(a, T.I32Type)], i, alloc_value ~alloc:a)
    in
    let header_locals, header_instructions = store_int32 ~alloc ~offset 0l in
    let value_locals, value_instructions =
      store_wrapped ~alloc
        ~offset:Int32.(offset + 4l)
        b
        (fun ?alloc ?offset a ->
          let l, i = store_bigintwrap ?alloc ?offset a in
          (l, i))
    in
    ( alloc_l @ header_locals @ value_locals,
      alloc_instructions @ header_instructions @ value_instructions @ return_l
    )
  | Nat b ->
    let alloc, alloc_l, alloc_instructions, return_l =
      match alloc with
      | Some alloc -> (alloc, [], [], [])
      | None ->
        let a, i =
          malloc ~name:"DataType_Nat_malloc" ~size:Int32.(4l + wrapped_size ())
        in
        (a, [(a, T.I32Type)], i, alloc_value ~alloc:a)
    in
    let header_locals, header_instructions = store_int32 ~alloc ~offset 1l in
    let value_locals, value_instructions =
      store_wrapped ~alloc
        ~offset:Int32.(offset + 4l)
        b
        (fun ?alloc ?offset a ->
          let l, i = store_bigintwrap ?alloc ?offset a in
          (l, i))
    in
    ( alloc_l @ header_locals @ value_locals,
      alloc_instructions @ header_instructions @ value_instructions @ return_l
    )
  | Mutez b ->
    let alloc, alloc_l, alloc_instructions, return_l =
      match alloc with
      | Some alloc -> (alloc, [], [], [])
      | None ->
        let a, i =
          malloc ~name:"DataType_Mutez_malloc"
            ~size:Int32.(4l + wrapped_size ())
        in
        (a, [(a, T.I32Type)], i, alloc_value ~alloc:a)
    in
    let header_locals, header_instructions = store_int32 ~alloc ~offset 2l in
    let value_locals, value_instructions =
      store_wrapped ~alloc
        ~offset:Int32.(offset + 4l)
        b
        (fun ?alloc ?offset a ->
          let l, i = store_bigintwrap ?alloc ?offset a in
          (l, i))
    in
    ( alloc_l @ header_locals @ value_locals,
      alloc_instructions @ header_instructions @ value_instructions @ return_l
    )
  | Timestamp i ->
    let alloc, alloc_l, alloc_instructions, return_l =
      match alloc with
      | Some alloc -> (alloc, [], [], [])
      | None ->
        let a, i =
          malloc ~name:"DataType_Timestamp_malloc"
            ~size:Int32.(4l + int32_size ())
        in
        (a, [(a, T.I32Type)], i, alloc_value ~alloc:a)
    in
    let header_locals, header_instructions = store_int32 ~alloc ~offset 3l in
    let value_locals, value_instructions =
      store_int32 ~alloc ~offset:Int32.(offset + 4l) i
    in
    ( alloc_l @ header_locals @ value_locals,
      alloc_instructions @ header_instructions @ value_instructions @ return_l
    )
  | Bool b ->
    let alloc, alloc_l, alloc_instructions, return_l =
      match alloc with
      | Some alloc -> (alloc, [], [], [])
      | None ->
        let a, i =
          malloc ~name:"DataType_Bool_malloc" ~size:Int32.(4l + bool_size ())
        in
        (a, [(a, T.I32Type)], i, alloc_value ~alloc:a)
    in
    let header_locals, header_instructions = store_int32 ~alloc ~offset 4l in
    let value_locals, value_instructions =
      store_bool ~alloc ~offset:Int32.(offset + 4l) b
    in
    ( alloc_l @ header_locals @ value_locals,
      alloc_instructions @ header_instructions @ value_instructions @ return_l
    )
  | ListItem n ->
    let alloc, alloc_l, alloc_instructions, return_l =
      match alloc with
      | Some alloc -> (alloc, [], [], [])
      | None ->
        let a, i =
          malloc ~name:"DataType_ListItem_malloc"
            ~size:Int32.(4l + wrapped_size ())
        in
        (a, [(a, T.I32Type)], i, alloc_value ~alloc:a)
    in
    let header_locals, header_instructions = store_int32 ~alloc ~offset 5l in
    let value_locals, value_instructions =
      store_wrapped ~alloc
        ~offset:Int32.(offset + 4l)
        n
        (fun ?alloc ?offset a ->
          let l, i = store_node ?alloc ?offset a in
          (l, i))
    in
    ( alloc_l @ header_locals @ value_locals,
      alloc_instructions @ header_instructions @ value_instructions @ return_l
    )
  | Tuple n ->
    let alloc, alloc_l, alloc_instructions, return_l =
      match alloc with
      | Some alloc -> (alloc, [], [], [])
      | None ->
        let a, i =
          malloc ~name:"DataType_Tuple_malloc"
            ~size:Int32.(4l + wrapped_size ())
        in
        (a, [(a, T.I32Type)], i, alloc_value ~alloc:a)
    in
    let header_locals, header_instructions = store_int32 ~alloc ~offset 6l in
    let value_locals, value_instructions =
      store_wrapped ~alloc
        ~offset:Int32.(offset + 4l)
        n
        (fun ?alloc ?offset a ->
          let l, i = store_node ?alloc ?offset a in
          (l, i))
    in
    ( alloc_l @ header_locals @ value_locals,
      alloc_instructions @ header_instructions @ value_instructions @ return_l
    )
  | Set r ->
    let alloc, alloc_l, alloc_instructions, return_l =
      match alloc with
      | Some alloc -> (alloc, [], [], [])
      | None ->
        let a, i =
          malloc ~name:"DataType_Set_malloc" ~size:Int32.(4l + wrapped_size ())
        in
        (a, [(a, T.I32Type)], i, alloc_value ~alloc:a)
    in
    let header_locals, header_instructions = store_int32 ~alloc ~offset 7l in
    let value_locals, value_instructions =
      store_wrapped ~alloc
        ~offset:Int32.(offset + 4l)
        r
        (fun ?alloc ?offset a ->
          let l, i = store_rbnode ?alloc ?offset a in
          (l, i))
    in
    ( alloc_l @ header_locals @ value_locals,
      alloc_instructions @ header_instructions @ value_instructions @ return_l
    )
  | Map r ->
    let alloc, alloc_l, alloc_instructions, return_l =
      match alloc with
      | Some alloc -> (alloc, [], [], [])
      | None ->
        let a, i =
          malloc ~name:"DataType_Map_malloc" ~size:Int32.(4l + wrapped_size ())
        in
        (a, [(a, T.I32Type)], i, alloc_value ~alloc:a)
    in
    let header_locals, header_instructions = store_int32 ~alloc ~offset 8l in
    let value_locals, value_instructions =
      store_wrapped ~alloc
        ~offset:Int32.(offset + 4l)
        r
        (fun ?alloc ?offset a ->
          let l, i = store_rbnode ?alloc ?offset a in
          (l, i))
    in
    ( alloc_l @ header_locals @ value_locals,
      alloc_instructions @ header_instructions @ value_instructions @ return_l
    )
  | Operations o ->
    let alloc, alloc_l, alloc_instructions, return_l =
      match alloc with
      | Some alloc -> (alloc, [], [], [])
      | None ->
        let a, i =
          malloc ~name:"DataType_Operations_malloc"
            ~size:Int32.(4l + option_size ())
        in
        (a, [(a, T.I32Type)], i, alloc_value ~alloc:a)
    in
    let header_locals, header_instructions = store_int32 ~alloc ~offset 9l in
    let value_locals, value_instructions =
      store_option ~alloc
        ~offset:Int32.(offset + 4l)
        o
        (fun ?alloc ?offset a ->
          let l, i =
            store_wrapped ?alloc ?offset a (fun ?alloc ?offset a ->
                let l, i = store_operationnode ?alloc ?offset a in
                (l, i))
          in
          (l, i))
    in
    ( alloc_l @ header_locals @ value_locals,
      alloc_instructions @ header_instructions @ value_instructions @ return_l
    )
  | String s ->
    let alloc, alloc_l, alloc_instructions, return_l =
      match alloc with
      | Some alloc -> (alloc, [], [], [])
      | None ->
        let a, i =
          malloc ~name:"DataType_String_malloc"
            ~size:Int32.(4l + wrapped_size ())
        in
        (a, [(a, T.I32Type)], i, alloc_value ~alloc:a)
    in
    let header_locals, header_instructions = store_int32 ~alloc ~offset 10l in
    let value_locals, value_instructions =
      store_wrapped ~alloc
        ~offset:Int32.(offset + 4l)
        s
        (fun ?alloc ?offset a ->
          let l, i = store_string ?alloc ?offset a in
          (l, i))
    in
    ( alloc_l @ header_locals @ value_locals,
      alloc_instructions @ header_instructions @ value_instructions @ return_l
    )
  | Instructions e -> ([], e)

and load_node : alloc:string -> locals * A.instr list =
 fun ~alloc ->
  let locals_value, value_instructions = load ~alloc ~offset:0l "value" in
  let locals_next, next_instructions = load ~alloc ~offset:4l "next" in
  let locals = locals_value @ locals_next @ [] in
  let instructions = value_instructions @ next_instructions @ [] in
  (locals, instructions)

and store_node : ?alloc:string -> ?offset:int32 -> node -> locals * A.instr list
    =
 fun ?alloc ?offset value ->
  let offset =
    match offset with
    | Some offset -> offset
    | None -> 0l
  in
  let alloc, alloc_instructions, return_ =
    match alloc with
    | Some alloc -> (alloc, [], [])
    | None ->
      let alloc, i = malloc ~name:"malloc_node" ~size:(node_size ()) in
      (alloc, i, alloc_value ~alloc)
  in
  let locals_value, value_instructions =
    store_wrapped ~alloc
      ~offset:Int32.(offset + 0l)
      value.value
      (fun ?alloc ?offset a ->
        let l, i = store_datatype ?alloc ?offset a in
        (l, i))
  in
  let locals_next, next_instructions =
    store_option ~alloc
      ~offset:Int32.(offset + 4l)
      value.next
      (fun ?alloc ?offset a ->
        let l, i =
          store_wrapped ?alloc ?offset a (fun ?alloc ?offset a ->
              let l, i = store_node ?alloc ?offset a in
              (l, i))
        in
        (l, i))
  in

  ( ((alloc, T.I32Type) :: locals_value) @ locals_next @ [],
    alloc_instructions @ value_instructions @ next_instructions @ return_ )

and load_operation_transaction : symbol:string -> locals * A.instr list =
 fun ~symbol -> ([], [])

and load_operation_delegate : symbol:string -> locals * A.instr list =
 fun ~symbol -> ([], [])

and store_operation :
    ?alloc:string -> ?offset:int32 -> operation -> locals * A.instr list =
 fun ?alloc ?offset value ->
  let offset =
    match offset with
    | Some offset -> offset
    | None -> 0l
  in
  match value with
  | Transaction t ->
    let alloc, alloc_l, alloc_instructions, return_l =
      match alloc with
      | Some alloc -> (alloc, [], [], [])
      | None ->
        let a, i =
          malloc ~name:"Operation_Transaction_malloc"
            ~size:Int32.(4l + transaction_size ())
        in
        (a, [(a, T.I32Type)], i, alloc_value ~alloc:a)
    in
    let header_locals, header_instructions = store_int32 ~alloc ~offset 0l in
    let value_locals, value_instructions =
      store_transaction ~alloc ~offset:Int32.(offset + 4l) t
    in
    ( alloc_l @ header_locals @ value_locals,
      alloc_instructions @ header_instructions @ value_instructions @ return_l
    )
  | Delegate d ->
    let alloc, alloc_l, alloc_instructions, return_l =
      match alloc with
      | Some alloc -> (alloc, [], [], [])
      | None ->
        let a, i =
          malloc ~name:"Operation_Delegate_malloc"
            ~size:Int32.(4l + delegate_size ())
        in
        (a, [(a, T.I32Type)], i, alloc_value ~alloc:a)
    in
    let header_locals, header_instructions = store_int32 ~alloc ~offset 1l in
    let value_locals, value_instructions =
      store_delegate ~alloc ~offset:Int32.(offset + 4l) d
    in
    ( alloc_l @ header_locals @ value_locals,
      alloc_instructions @ header_instructions @ value_instructions @ return_l
    )

and load_operationnode : alloc:string -> locals * A.instr list =
 fun ~alloc ->
  let locals_value, value_instructions = load ~alloc ~offset:0l "value" in
  let locals_next, next_instructions = load ~alloc ~offset:4l "next" in
  let locals = locals_value @ locals_next @ [] in
  let instructions = value_instructions @ next_instructions @ [] in
  (locals, instructions)

and store_operationnode :
    ?alloc:string -> ?offset:int32 -> operationnode -> locals * A.instr list =
 fun ?alloc ?offset value ->
  let offset =
    match offset with
    | Some offset -> offset
    | None -> 0l
  in
  let alloc, alloc_instructions, return_ =
    match alloc with
    | Some alloc -> (alloc, [], [])
    | None ->
      let alloc, i =
        malloc ~name:"malloc_operationnode" ~size:(operationnode_size ())
      in
      (alloc, i, alloc_value ~alloc)
  in
  let locals_value, value_instructions =
    store_wrapped ~alloc
      ~offset:Int32.(offset + 0l)
      value.value
      (fun ?alloc ?offset a ->
        let l, i = store_operation ?alloc ?offset a in
        (l, i))
  in
  let locals_next, next_instructions =
    store_option ~alloc
      ~offset:Int32.(offset + 4l)
      value.next
      (fun ?alloc ?offset a ->
        let l, i =
          store_wrapped ?alloc ?offset a (fun ?alloc ?offset a ->
              let l, i = store_operationnode ?alloc ?offset a in
              (l, i))
        in
        (l, i))
  in

  ( ((alloc, T.I32Type) :: locals_value) @ locals_next @ [],
    alloc_instructions @ value_instructions @ next_instructions @ return_ )

and load_color_red : symbol:string -> locals * A.instr list =
 fun ~symbol -> ([], [])

and load_color_black : symbol:string -> locals * A.instr list =
 fun ~symbol -> ([], [])

and store_color :
    ?alloc:string -> ?offset:int32 -> color -> locals * A.instr list =
 fun ?alloc ?offset value ->
  let offset =
    match offset with
    | Some offset -> offset
    | None -> 0l
  in
  match value with
  | Red ->
    let alloc, alloc_l, alloc_instructions, return_l =
      match alloc with
      | Some alloc -> (alloc, [], [], [])
      | None ->
        let a, i = malloc ~name:"Color_Red_malloc" ~size:Int32.(4l + 0l) in
        (a, [(a, T.I32Type)], i, alloc_value ~alloc:a)
    in
    let header_locals, header_instructions = store_int32 ~alloc ~offset 0l in
    let value_locals, value_instructions = ([], []) in
    ( alloc_l @ header_locals @ value_locals,
      alloc_instructions @ header_instructions @ value_instructions @ return_l
    )
  | Black ->
    let alloc, alloc_l, alloc_instructions, return_l =
      match alloc with
      | Some alloc -> (alloc, [], [], [])
      | None ->
        let a, i = malloc ~name:"Color_Black_malloc" ~size:Int32.(4l + 0l) in
        (a, [(a, T.I32Type)], i, alloc_value ~alloc:a)
    in
    let header_locals, header_instructions = store_int32 ~alloc ~offset 1l in
    let value_locals, value_instructions = ([], []) in
    ( alloc_l @ header_locals @ value_locals,
      alloc_instructions @ header_instructions @ value_instructions @ return_l
    )

and load_rbnode : alloc:string -> locals * A.instr list =
 fun ~alloc ->
  let locals_parent, parent_instructions = load ~alloc ~offset:0l "parent" in
  let locals_value, value_instructions = load ~alloc ~offset:4l "value" in
  let locals_depth, depth_instructions = load ~alloc ~offset:8l "depth" in
  let locals_left, left_instructions = load ~alloc ~offset:12l "left" in
  let locals_right, right_instructions = load ~alloc ~offset:16l "right" in
  let locals_color, color_instructions = load ~alloc ~offset:20l "color" in
  let locals =
    locals_parent @ locals_value @ locals_depth @ locals_left @ locals_right
    @ locals_color @ []
  in
  let instructions =
    parent_instructions @ value_instructions @ depth_instructions
    @ left_instructions @ right_instructions @ color_instructions @ []
  in
  (locals, instructions)

and store_rbnode :
    ?alloc:string -> ?offset:int32 -> rbnode -> locals * A.instr list =
 fun ?alloc ?offset value ->
  let offset =
    match offset with
    | Some offset -> offset
    | None -> 0l
  in
  let alloc, alloc_instructions, return_ =
    match alloc with
    | Some alloc -> (alloc, [], [])
    | None ->
      let alloc, i = malloc ~name:"malloc_rbnode" ~size:(rbnode_size ()) in
      (alloc, i, alloc_value ~alloc)
  in
  let locals_parent, parent_instructions =
    store_option ~alloc
      ~offset:Int32.(offset + 0l)
      value.parent
      (fun ?alloc ?offset a ->
        let l, i =
          store_wrapped ?alloc ?offset a (fun ?alloc ?offset a ->
              let l, i = store_rbnode ?alloc ?offset a in
              (l, i))
        in
        (l, i))
  in
  let locals_value, value_instructions =
    store_wrapped ~alloc
      ~offset:Int32.(offset + 4l)
      value.value
      (fun ?alloc ?offset a ->
        let l, i = store_datatype ?alloc ?offset a in
        (l, i))
  in
  let locals_depth, depth_instructions =
    store_usize ~alloc ~offset:Int32.(offset + 8l) value.depth
  in
  let locals_left, left_instructions =
    store_option ~alloc
      ~offset:Int32.(offset + 12l)
      value.left
      (fun ?alloc ?offset a ->
        let l, i =
          store_wrapped ?alloc ?offset a (fun ?alloc ?offset a ->
              let l, i = store_rbnode ?alloc ?offset a in
              (l, i))
        in
        (l, i))
  in
  let locals_right, right_instructions =
    store_option ~alloc
      ~offset:Int32.(offset + 16l)
      value.right
      (fun ?alloc ?offset a ->
        let l, i =
          store_wrapped ?alloc ?offset a (fun ?alloc ?offset a ->
              let l, i = store_rbnode ?alloc ?offset a in
              (l, i))
        in
        (l, i))
  in
  let locals_color, color_instructions =
    store_color ~alloc ~offset:Int32.(offset + 20l) value.color
  in

  ( ((alloc, T.I32Type) :: locals_parent)
    @ locals_value @ locals_depth @ locals_left @ locals_right @ locals_color
    @ [],
    alloc_instructions @ parent_instructions @ value_instructions
    @ depth_instructions @ left_instructions @ right_instructions
    @ color_instructions @ return_ )

and load_transaction : alloc:string -> locals * A.instr list =
 fun ~alloc ->
  let locals_action, action_instructions = load ~alloc ~offset:0l "action" in
  let locals_amount, amount_instructions = load ~alloc ~offset:4l "amount" in
  let locals_contract, contract_instructions =
    load ~alloc ~offset:8l "contract"
  in
  let locals = locals_action @ locals_amount @ locals_contract @ [] in
  let instructions =
    action_instructions @ amount_instructions @ contract_instructions @ []
  in
  (locals, instructions)

and store_transaction :
    ?alloc:string -> ?offset:int32 -> transaction -> locals * A.instr list =
 fun ?alloc ?offset value ->
  let offset =
    match offset with
    | Some offset -> offset
    | None -> 0l
  in
  let alloc, alloc_instructions, return_ =
    match alloc with
    | Some alloc -> (alloc, [], [])
    | None ->
      let alloc, i =
        malloc ~name:"malloc_transaction" ~size:(transaction_size ())
      in
      (alloc, i, alloc_value ~alloc)
  in
  let locals_action, action_instructions =
    store_datatype ~alloc ~offset:Int32.(offset + 0l) value.action
  in
  let locals_amount, amount_instructions =
    store_bigintwrap ~alloc ~offset:Int32.(offset + 4l) value.amount
  in
  let locals_contract, contract_instructions =
    store_bigintwrap ~alloc ~offset:Int32.(offset + 8l) value.contract
  in

  ( ((alloc, T.I32Type) :: locals_action) @ locals_amount @ locals_contract @ [],
    alloc_instructions @ action_instructions @ amount_instructions
    @ contract_instructions @ return_ )

and load_delegate : alloc:string -> locals * A.instr list =
 fun ~alloc ->
  let locals_delegate, delegate_instructions =
    load ~alloc ~offset:0l "delegate"
  in
  let locals = locals_delegate @ [] in
  let instructions = delegate_instructions @ [] in
  (locals, instructions)

and store_delegate :
    ?alloc:string -> ?offset:int32 -> delegate -> locals * A.instr list =
 fun ?alloc ?offset value ->
  let offset =
    match offset with
    | Some offset -> offset
    | None -> 0l
  in
  let alloc, alloc_instructions, return_ =
    match alloc with
    | Some alloc -> (alloc, [], [])
    | None ->
      let alloc, i = malloc ~name:"malloc_delegate" ~size:(delegate_size ()) in
      (alloc, i, alloc_value ~alloc)
  in
  let locals_delegate, delegate_instructions =
    store_option ~alloc
      ~offset:Int32.(offset + 0l)
      value.delegate
      (fun ?alloc ?offset a ->
        let l, i = store_datatype ?alloc ?offset a in
        (l, i))
  in

  ( ((alloc, T.I32Type) :: locals_delegate) @ [],
    alloc_instructions @ delegate_instructions @ return_ )
