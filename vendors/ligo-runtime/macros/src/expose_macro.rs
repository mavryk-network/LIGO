use std::fmt::Write;
use std::fs::OpenOptions;

use proc_macro::TokenStream;
use syn::{ItemFn, ReturnType};

struct WasmFn {
  fn_name:         String,
  no_of_arguments: usize,
  no_of_return:    usize,
}

static mut EXPOSED: Vec<WasmFn> = Vec::new();

pub fn expose(input: TokenStream) -> TokenStream {
  let token_copy = input.clone();
  let input: ItemFn = syn::parse_macro_input!(input as ItemFn);
  let signature = input.sig;
  let fn_name = signature.ident.to_string();
  let no_of_arguments = signature.inputs.len();
  let no_of_return = match signature.output {
    ReturnType::Default => 0,
    ReturnType::Type(..) => 1,
  };
  unsafe {
    EXPOSED.push(WasmFn {
      fn_name,
      no_of_arguments,
      no_of_return,
    });
  }
  return token_copy;
}

pub fn produce_file(input: TokenStream) -> TokenStream {
  let wasm_fns: &Vec<WasmFn> = unsafe { &EXPOSED };
  let mut types = String::new();
  let mut imports = String::new();
  let mut symbols = String::new();
  for f in wasm_fns.iter() {
    let mut args = String::new();
    for _ in 0..(f.no_of_arguments + f.no_of_return) {
      write!(args, "I32Type; ").unwrap()
    }
    let result = String::new();
    // for _ in 0..f.no_of_return {
    //   write!(&mut result, "I32Type; ");
    // };
    write!(
      &mut types,
      " {{
            it = {{
            tname = \"{}\";
            tdetails = FuncType([{}], [{}]);
            }};
            at
        }};",
      f.fn_name, args, result
    )
    .unwrap();
    write!(
      &mut imports,
      " {{
        it = {{
            module_name = name \"env\";
            item_name   = name \"{}\";
            idesc = {{
            it = FuncImport \"{}\";
            at
            }};
        }};
        at
    }};
    ",
      f.fn_name, f.fn_name
    )
    .unwrap();
    let mut args = String::new();
    for _ in 0..(f.no_of_arguments + f.no_of_return) {
      write!(&mut args, "I32Type; ").unwrap();
    }
    write!(
      &mut symbols,
      " {{
        it = {{
        name = \"{}\";
        details = Import([{}], [{}]);
        }};
        at
    }};",
      f.fn_name,
      args,
      String::new()
    )
    .unwrap();
  }

  let mut file_contents = String::new();
  write!(
    &mut file_contents,
    "(* Do not change, this file is generated by the Rust `expose` macro. *)
module W = WasmObjectFile
open W.Source
open W.Ast

let at = no_region

let name s =
try W.Utf8.decode s with W.Utf8.Utf8 ->
    failwith \"invalid UTF-8 encoding\"

let env: module_ = {{
it = {{
    empty_module with 
    types = [
        {}
    ];
    imports = [
        {}
    ];
    symbols = [
        {}
    ]
}};
at
}}",
    types, imports, symbols
  )
  .unwrap();

  let output = OpenOptions::new()
    .create(true)
    .write(true)
    .truncate(true)
    .open("../../src/passes/14-wasm/interop.ml");
  match output {
    Ok(mut f) => {
      use std::io::Write;
      write!(f, "{}", file_contents).unwrap();
    }
    Err(..) => panic!("Could not create the `interop.ml` file"),
  };

  input
}
