use proc_macro::TokenStream;
use proc_macro::TokenTree;
use proc_macro::*;
use syn::{parse_macro_input, Result, Item, ItemFn, ItemEnum, ItemStruct, FnArg, ReturnType};
use syn::parse::{Parse, ParseStream};
use std::fs::File;
use std::fmt::Write;
use core::iter::Map;

struct WasmFn {
  fn_name: String, 
  no_of_arguments: usize,
  no_of_return: usize
}

static mut exposed: Vec<WasmFn> = Vec::new();

#[proc_macro_attribute]
pub fn expose(_attr: TokenStream, input: TokenStream) -> TokenStream {
    let token_copy = input.clone();
    let input: ItemFn = syn::parse_macro_input!(input as ItemFn);
    let signature = input.sig;
    let fn_name = signature.ident.to_string();
    let no_of_arguments = signature.inputs.len();
    let no_of_return = match signature.output {
        ReturnType::Default => 0,
        ReturnType::Type(..) => 1
    };

    unsafe {
        exposed.push(WasmFn {
            fn_name, 
            no_of_arguments,
            no_of_return
        });
    }
    return token_copy
}

#[proc_macro_attribute]
pub fn produce_file (_attr: TokenStream, input: TokenStream) -> TokenStream {
    let wasm_fns: &Vec<WasmFn> = unsafe { &exposed };
    let mut types = String::new();

    for f in wasm_fns.iter() {
        let mut args = String::new();
        for _ in 0..(f.no_of_arguments + f.no_of_return) {
          write!(&mut args, "I32Type; ");
        };
        let mut result = String::new();
        // for _ in 0..f.no_of_return {
        //   write!(&mut result, "I32Type; ");
        // };
        write!(&mut types, " {{
            it = {{
              tname = \"{}\";
              tdetails = FuncType([{}], [{}]);
            }};
            at
        }};", f.fn_name, args, result);
    }
    
    let mut imports = String::new();
    for f in wasm_fns.iter() {
      write!(&mut imports, " {{
        it = {{
            module_name = name \"env\";
            item_name   = name \"{}\";
            idesc = {{
              it = FuncImport \"{}\";
              at
            }};
        }};
        at
      }};
      ", f.fn_name, f.fn_name);
    }

    let mut symbols = String::new();
    for f in wasm_fns.iter() {
      let mut args = String::new();
      for _ in 0..(f.no_of_arguments + f.no_of_return) {
        write!(&mut args, "I32Type; ");
      };
      let mut result = String::new();
    //   for _ in 0..f.no_of_return {
    //     write!(&mut result, "I32Type; ");
    //   };
      write!(&mut symbols, " {{
        it = {{
          name = \"{}\";
          details = Import([{}], [{}]);
        }};
        at
      }};", f.fn_name, args, result);
    }

    let mut file_contents = String::new();
    write!(&mut file_contents, 
"(* Do not change, this file is generated by the Rust `expose` macro. *)
module W = WasmObjectFile
open W.Source
open W.Ast

let at = no_region

let name s =
  try W.Utf8.decode s with W.Utf8.Utf8 ->
    failwith \"invalid UTF-8 encoding\"

let env: module_ = {{
  it = {{
    empty_module with 
      types = [
        {}
      ];
      imports = [
        {}
      ];
      symbols = [
        {}
      ]
  }};
  at
}}", types, imports, symbols);



    let output = File::create("../../src/passes/14-wasm/interop.ml");
    match output {
        Ok(mut f) => {
            use std::io::Write;
            write!(f, "{}", file_contents)
        }
        Err(..) => panic!()
    };

    input
}

static mut datatypes: Vec<Item> = Vec::new();

#[proc_macro_attribute]
pub fn datatype_helper(_attr: TokenStream, input: TokenStream) -> TokenStream {
    let token_copy = input.clone();
    let input: Item = syn::parse_macro_input!(input as Item);
    match input {
        Item::Enum(ItemEnum { .. }) |
        Item::Struct(ItemStruct { .. }) => {
            unsafe {
                datatypes.push(input)
            }
        },
        _ => {
            panic!("Not supported yet...")
        }
    };
  /* 
    

    Object Tuple {
        method value (memory) {

        };
        method next (memory) {

        }
    }

    module Tuple {
        let value () = {
            return the symbol
        }

        let next () = {
            return the value
        }

    }
    
    Objects ?!

        object Tuple {
            method value;
            method next;
        }       
  */


  return token_copy
}

#[proc_macro_attribute]
pub fn produce_datatype_file (_attr: TokenStream, input: TokenStream) -> TokenStream {
    println!("yas");
    return input
}