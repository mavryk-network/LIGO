#![warn(missing_docs)]
#![warn(rustdoc::missing_doc_code_examples)]

//! Macros to help with the interop between wasm code generated by Rust and
//! wasm code generated by the LIGO compiler.

use proc_macro::TokenStream;

mod expose_macro;

mod datatype_helper;

/**
 * Expose a function to wasm (via OCaml) by creating the necessary types,
 * imports, and symbols so linking can work.
 *
 * For `expose` in this example:
 *
 * ```rust
 * #[expose_fn]
 * #[no_mangle]
 * pub extern "C" fn int_neg(i: DataType) -> DataType {
 *   i
 * }
 * ```
 *
 * will create types, imports and symbols.
 *
 * Note that currently this macro only collects the data, while the
 * `produce_file` macro actually creates the OCaml output.
 *
 */
#[proc_macro_attribute]
pub fn expose_fn(_attr: TokenStream, input: TokenStream) -> TokenStream {
  expose_macro::expose(input)
}

/**
 * Turns the collected data of functions which have the `expose` macro into
 * a file: src/passes/14-wasm/interop.ml
 */
#[proc_macro_attribute]
pub fn produce_file(_attr: TokenStream, input: TokenStream) -> TokenStream {
  expose_macro::produce_file(input)
}

/**
 * Turn `struct` and `enum` datatypes into OCaml objects that hide the wasm
 * instructions.
 *
 * Note: not all forms of struct and enum are supported.
 */
#[proc_macro_attribute]
pub fn expose_datatype(_attr: TokenStream, input: TokenStream) -> TokenStream {
  datatype_helper::datatype_helper(input)
}

/**  
 * Turns the collected data of datatypes which have the `datatype_helper`
 * macro into a file: src/passes/14-wasm/mem_helpers.ml
 */
#[proc_macro_attribute]
pub fn produce_datatype_file(_attr: TokenStream, input: TokenStream) -> TokenStream {
  datatype_helper::produce_datatype_file(input)
}
