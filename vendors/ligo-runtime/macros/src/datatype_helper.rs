use std::fmt::Write;
use std::fs::OpenOptions;

use proc_macro::TokenStream;
use syn::Fields::*;
use syn::{FieldsNamed, FieldsUnnamed, GenericParam, Item, ItemEnum, ItemStruct, TypeParam};

struct StructData {
  name:        String,
  type_params: Vec<String>,
  fields:      Vec<(String, String)>,
}

struct EnumData {
  name:        String,
  type_params: Vec<String>,
  variants:    Vec<(String, Vec<String>)>,
}

enum ItemData {
  Struct(StructData),
  Enum(EnumData),
}

static mut DATATYPES: Vec<ItemData> = Vec::new();

fn ty_to_string(t: &syn::Type) -> String {
  match t {
    syn::Type::Path(syn::TypePath {
      path: syn::Path { segments, .. },
      ..
    }) => {
      let v: Vec<String> = segments
        .iter()
        .map(|s| -> String { s.ident.to_string() })
        .collect();
      let result = v.join(".");
      return result;
    }
    syn::Type::Ptr(syn::TypePtr { elem, .. }) => ty_to_string(elem),
    _ => panic!("Type not supported yet"),
  }
}

pub fn datatype_helper(input: TokenStream) -> TokenStream {
  let token_copy = input.clone();
  let input = syn::parse_macro_input!(input as Item);
  match input {
    Item::Struct(ItemStruct {
      ident,
      fields,
      generics,
      ..
    }) => {
      let type_params: Vec<String> = generics.params.iter().fold(vec![], |mut acc, param| -> _ {
        match param {
          GenericParam::Type(TypeParam { ident, .. }) => {
            acc.push(ident.to_string());
            acc
          }
          _ => acc,
        }
      });
      let name = ident.to_string();
      match fields {
        Named(FieldsNamed { named, .. }) => {
          let fields = named
            .iter()
            .map(|field| -> (String, String) {
              (
                field.ident.as_ref().unwrap().to_string(),
                ty_to_string(&field.ty),
              )
            })
            .collect();
          unsafe {
            DATATYPES.push(ItemData::Struct(StructData {
              name,
              type_params,
              fields,
            }))
          }
        }
        _ => panic!("Not supported fields kind"),
      }
    }
    Item::Enum(ItemEnum {
      ident,
      variants,
      generics,
      ..
    }) => {
      let type_params: Vec<String> = generics.params.iter().fold(vec![], |mut acc, param| -> _ {
        match param {
          GenericParam::Type(TypeParam { ident, .. }) => {
            acc.push(ident.to_string());
            acc
          }
          _ => acc,
        }
      });
      let ident = &ident;
      let name = ident.to_string();
      let variants: Vec<(String, Vec<String>)> = variants
        .iter()
        .map(|f| -> (String, Vec<String>) {
          match &f.fields {
            Unnamed(FieldsUnnamed { unnamed, .. }) => {
              //  println!("Test 123: {}", unnamed.iter().len());
              let args: Vec<String> = unnamed
                .iter()
                .map(|f| -> String { ty_to_string(&f.ty) })
                .collect();
              return (f.ident.to_string(), args);
            }
            Named(FieldsNamed { named, .. }) => {
              let args: Vec<String> = named
                .iter()
                .map(|f| -> String { ty_to_string(&f.ty) })
                .collect();
              return (f.ident.to_string(), args);
            }
            Unit => return (f.ident.to_string(), vec![]),
          }
        })
        .collect();
      unsafe {
        DATATYPES.push(ItemData::Enum(EnumData {
          name,
          type_params,
          variants,
        }))
      }
    }
    _ => {
      panic!("Not supported yet...")
    }
  };
  return token_copy;
}

pub fn produce_datatype_file(input: TokenStream) -> TokenStream {
  let d: &Vec<ItemData> = unsafe { &DATATYPES };
  let mut datatype_file = String::new();
  write!(
    &mut datatype_file,
    "
[@@@warning \"-27\"]

(* Do not change, this file is generated by the Rust `datatype_helper` macro. *)
module W = WasmObjectFile  
module A = W.Ast
module T = W.Types
module S = W.Source
module ValueVar = Stage_common.Types.ValueVar
    
let at = S.no_region

let const_0l = S.{{ it = A.Const {{ it = I32 0l; at}}; at }}

type dt = <
  locals:       (string * T.value_type) list;
  malloc_name:  string;
  store:        A.instr' S.phrase list;
  reference:    A.instr' S.phrase list
>

let make_dt = fun a ->
  object
    method locals = []
    method malloc_name = \"\"
    method store = a
    method reference = []
  end

let var_to_string name =  
  let name, hash = ValueVar.internal_get_name_and_counter name in
  name ^ \"#\" ^ (string_of_int hash)

"
  )
  .unwrap();

  for item in d.iter() {
    let mut index = 0;
    match item {
      ItemData::Struct(StructData {
        name,
        type_params,
        fields,
      }) => {
        let (field_accessors, parameters, store_fields, child_locals): (
          String,
          String,
          String,
          String,
        ) = fields.iter().fold(
          (String::new(), String::new(), String::new(), String::new()),
          |acc: (String, String, String, String),
           param: &(String, String)|
           -> (String, String, String, String) {
            let (mut field_accessors, mut parameters, mut store_fields, mut child_locals) = acc;
            field_accessors.push_str(
              format!(
                "  
  val {0} = {0}
  method {0} = {0}
  method get_{0} = 
     S.[
       {{ it = A.LocalGet self#malloc_name; at }};
       {{ it = Const {{ it = I32 {1}l; at  }}; at }};
       {{ it = Binary (I32 Add); at }};
       {{ it = Load {{ty = I32Type; align = 0; offset = 0l; sz = None}}; at }}
     ]
    
  method store_{0} = 
    S.[
      {{ it = A.LocalGet self#malloc_name; at }};
       {{ it = Const {{ it = I32 {1}l; at  }}; at }};
       {{ it = Binary (I32 Add); at }};
    ]
    @
    {0}#store
    @
    {0}#reference
    @
    S.[
       {{ it = A.Store {{ty = I32Type; align = 0; offset = 0l; sz = None}}; at }};
    ]
            ",
                param.0.as_str(),
                index * 4
              )
              .as_str(),
            );

            let type_ = param.1.as_str().to_string();
            let type_exists = type_params.iter().any(|x| *x == type_);
            let parameter;
            // let first_char: char = type_.chars().nth(0).unwrap();
            // println!("Checking: {}", type_.chars().nth(0).unwrap());
            if type_exists {
              parameter = format!("~({} : '{}) ", param.0.as_str(), type_);
            // } else if first_char.is_uppercase() {
            //   parameter = format!("~({} : {}) ", param.0.as_str(),
            // type_.to_lowercase());
            } else {
              parameter = format!("~({} : dt) ", param.0.as_str());
            }
            parameters.push_str(parameter.as_str());
            store_fields.push_str(format!("@  self#store_{0} \n", param.0.as_str()).as_str());
            child_locals.push_str(format!("@ self#{0}#locals \n", param.0.as_str()).as_str());
            index = index + 1;
            return (field_accessors, parameters, store_fields, child_locals);
          },
        );

        let mut class_params = "".to_string();
        if type_params.len() > 0 {
          let class_params2: Vec<String> =
            type_params.iter().map(|x| "'".to_string() + x).collect();
          let class_params2: String = class_params2.join(";");
          class_params = "[".to_string() + class_params2.as_str() + "]";
        };

        write!(
          &mut datatype_file,
          "
class {6} {0} {3} = object(self)
  val size = {2}l
  val malloc_name =  var_to_string (ValueVar.fresh ~name:\"{0}_malloc\" ())
  val mutable allocated = false
  val mutable stored = false
  method malloc_name = malloc_name
  method size = size
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)]
    
    {5}

  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{{ it = A.Const {{ it = I32 self#size; at}}; at }};
        {{ it = Call \"malloc\"; at }};
        {{ it = LocalSet self#malloc_name; at }};]
    )
     
  {1}

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc
      {4}
    )
    
  method reference =
    S.[{{ it = A.LocalGet self#malloc_name; at }};]

end

",
          name.to_lowercase(),
          field_accessors,
          fields.iter().len() * 4,
          parameters,
          store_fields,
          child_locals,
          class_params
        )
        .unwrap();
      }
      ItemData::Enum(EnumData {
        name,
        variants,
        type_params,
      }) => {
        let mut counter = 0;
        let (variants_, kinds) =
          variants
            .iter()
            .fold((String::new(), String::new()), |acc, param| -> _ {
              let (mut variants_, mut kinds) = acc;
              variants_.push_str(format!("\n| {}", param.0).as_str());
              kinds.push_str(format!("\n  | {} -> {}l", param.0, counter).as_str());
              counter = counter + 1;
              return (variants_, kinds);
            });

        let mut class_params = "".to_string();
        let type_params_exists = type_params.is_empty() == false;
        if type_params_exists {
          let class_params2: Vec<String> =
            type_params.iter().map(|x| "'".to_string() + x).collect();
          let class_params2: String = class_params2.join(";");
          class_params = "[".to_string() + class_params2.as_str() + "]";
        };
        let a = type_params.first();
        let value_type;
        match a {
          Some(s) => value_type = "'".to_string() + s,
          _ => value_type = "dt".to_string(),
        }
        write!(
          &mut datatype_file,
          "

type {0}_variant = 
  {1}

class {3} {0} ~(kind: {0}_variant) ~(value: {4}) = object(self)
  val kind = kind
  val value = value
  
  val malloc_name =  var_to_string (ValueVar.fresh ~name:\"{0}_malloc\" ())
  val mutable allocated = false
  val mutable stored = false

  method malloc_name = malloc_name
  method size = 12l
  method set_allocated a = allocated <- a
  method set_stored a = stored <- a

  method kind = kind
  method value = value
  
  method locals: (string * T.value_type) list = 
    [(self#malloc_name, T.I32Type)] 
    @
    value#locals

  method alloc = 
    if allocated then 
      []
    else (
      self#set_allocated true;
      S.[{{ it = A.Const {{ it = I32 self#size; at}}; at }};
        {{ it = Call \"malloc\"; at }};
        {{ it = LocalSet self#malloc_name; at }};]
    )

  method store_value = 
    S.[
      {{ it = A.LocalGet self#malloc_name; at }};
      {{ it = Const {{ it = I32 4l; at  }}; at }};
      {{ it = Binary (I32 Add); at }};
    ]
    @
    value#store
    @
    S.[
      {{ it = A.Store {{ty = I32Type; align = 0; offset = 0l; sz = None}}; at }};
    ]

  method store_kind = 
    let kind = match self#kind with 
    {2} 
    in
    S.[
      {{ it = A.LocalGet self#malloc_name; at }};
      {{ it = Const {{ it = I32 kind; at  }}; at }};
      {{ it = Store {{ty = I32Type; align = 0; offset = 0l; sz = None}}; at }};
    ]

  method get_value = 
    S.[
      {{ it = A.LocalGet self#malloc_name; at }};
      {{ it = Const {{ it = I32 4l; at  }}; at  }};
      {{ it = Binary (I32 Add); at }};
      {{ it = Load {{ty = I32Type; align = 0; offset = 0l; sz = None}}; at }};
    ]

  method store = 
    if stored then 
      []
    else (
      self#set_stored true;
      self#alloc 
      @ self#store_kind
      @ self#store_value
   
  )

  method reference =
    S.[{{ it = A.LocalGet self#malloc_name; at }};]
  
end
          ",
          name.to_lowercase(),
          variants_,
          kinds,
          class_params,
          value_type
        )
        .unwrap();
      }
    }
  }

  let output = OpenOptions::new()
    .create(true)
    .write(true)
    .truncate(true)
    .open("../../src/passes/14-wasm/mem_helpers.ml");

  match output {
    Ok(mut f) => {
      use std::io::Write;
      write!(f, "{}", datatype_file).unwrap();
    }
    Err(..) => panic!(),
  };

  return input;
}
