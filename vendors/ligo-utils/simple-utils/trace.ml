(** {1 Constructors} *)

(* Warnings *)
let warning_with f =
  let warnings = ref [] in
  let add_warning x = warnings := x :: !warnings in
  let get_warnings () = !warnings in
  f add_warning get_warnings

(* Errors *)
type 't raise = { raise : 'a . 't -> 'a }

let try_with (type t) f catch =
  let exception Local of t in
  let raise : t raise = {raise = fun x -> Stdlib.raise (Local x)} in
  try (f ~raise)
  with Local x -> catch x

let to_stdlib_result : (raise:'error raise -> 'value) -> ('value, 'error) Stdlib.result =
  fun f ->
  try_with
    (fun ~raise -> Ok (f ~raise))
    (fun e -> Error (e))


let trace ~raise tracer f =
    try_with f @@ fun a -> raise.raise @@ tracer a

let trace_option ~raise error = function
  None -> raise.raise error
| Some s -> s

(* Erase the current error stack, and replace it by the given
   error. It's useful when using [Assert] and you want to discard its
   autogenerated message. *)

let trace_strong ~raise err =
  trace ~raise (fun _ -> err)

let from_result ~raise = function
    Ok    o -> o
  | Error e -> raise.raise e

(* Check if there is no error. Useful for tests. *)
let to_bool f =
  try_with (fun ~raise ->let _ = f ~raise in true) (fun _ -> false)

let to_option f =
  try_with (fun ~raise -> Some (f ~raise)) (fun _ -> None)


(* Convert an option to a result, with a given error if the parameter
   is None. *)

let trace_assert_fail_option ~raise error = function
   None -> ()
 | Some _s -> raise.raise error


let bind_map_or handler fa fb c =
  try_with
    (fa c)
    (fun _ ->
      try_with (fb c) handler)

let bind_or ~raise a b =
  bind_map_or raise.raise
    (fun () -> a)
    (fun () -> b)
    ()

let rec bind_exists ~raise = function | (x, []) -> x ~raise
                                      | (x, y :: ys) -> bind_or ~raise x (bind_exists (y, ys))

(* Assertion module.
   TODO: Would make sense to move it outside Trace. *)
module Assert = struct
  let assert_fail ~raise:r err f =
    try_with
      (fun ~raise -> let _ = f ~raise in r.raise err)
      (fun _ -> ())

  let assert_true ~raise err = function
    | true -> ()
    | false -> raise.raise err

  let assert_list_size ~raise err lst n =
    assert_true ~raise err List.(length lst = n)

  let assert_list_empty ~raise err lst =
    assert_true ~raise err List.(length lst = 0)

  let assert_list_same_size ~raise err lsta lstb =
    assert_true ~raise err List.(length lsta = length lstb)
end
